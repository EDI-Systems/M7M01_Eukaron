/* Now we need to parse the XML. We do not need a full parser, no we don't. We just need a very simple one to work on. */
/* First thing we do is to read the user supplied XML and find the chip that we are using.
 * Then, we attempt to open the
 * chip configuration file. Should we encounter any failures we will exit. 

we design our parser to get the first encounter of something. 

Give an start, give an end, extract something in the middle, with the first encounter, allow using suffix *./
Probably the correct way is just to read in all the stuff as a whole string.

/* We have successfully parsed the XML. Now we need to generate the project specific files. */

/* The first thing is to figure out the basic configurations of RME, which is the kernel configurations. This is very important */

/* The next thing is to figure out the port specific configurations, also very important. */

/* Regarding memory map, well. Generate the kernel configurations first and we'll talk about this */

/* Now everything else is resolved, we need to figure out the memory map. 
 * make alignments at least at 1kB, this is important. We're not lacking this memory.
 */

/* Quickly we will resolve the exact locations of the memory segments. After that, the
 * only remaining task is to figure out the construction of page tables. 
 * we're only supporting cortex-m, so this is relatively simple:
 * 59kB/8 -> 7.375kB, we assume 8kB -> 56kB + 3kB. This is very easy to implement. 
 * Also make sure that no memory is placed across the designated shared areas. These holes will be
 * evicted from the available space first before we make any allocations, and will always be mapped
 * in with additional solutions. 

algorithm of placing the memory :
place large ones first.
Then smaller ones.
Then smaller ones.
Then smaller ones.
When all is placed, produce the page table setup for that component.
If they want full manual placement to fully use the space, be it, let the human brains do it, we don't do it here

MAX_CHIP_PROCS*(MAX_PROC_SEGS+MAX_PROC_VECTS)... what do we do here?? */
struct Project
{
    s8 Name[MAX_NAME_LEN];
    /* We know that there is only one chip */
    struct Chip_Info Chip;
    /* Information for RME */
    struct RME_Info RME;
    /* Information for RVM */
    struct RVM_Info RVM;
    /* The number of processes can be known just by scanning the XML file */
    cnt_t Num_Procs;
    struct Proc_Info* Proc;
    /* The kernel objects are allocated in a holistic view */
    struct Kobj_Info Kobj;
}

struct Chip_Info
{
    /* ROM, RAM and device */
    struct Mem_Info* ROM;
    struct Mem_Info* RAM;
    struct Mem_Info* Device;
    .... options, vectors, etc. after this, this file will just get closed. Chip info read is now complete.
}

struct Proc_Info
{
    struct Mem Segs[];
    /* Fixed segments will be mapped anyway, regardless of if there is memory or not */
    struct Mem* Fixed_Segs[];
    .... read from the project file, after reading this, the process is just complete. 
}

// at this point, we would have resolved all the memory relationships.

/* These does NOT include the RVM's kernel objects */
struct Kobj_Info
{
    /* How many capability tables are there? */
    struct Captbl_Obj* Captbl;
    /* How many page tables are there, and how should we construct them and map in pages? */
    struct Pgtbl_Obj* Pgtbl;
    /* How many processes are there and what capability table/page table is used for them? */
    struct Proc_Obj* Proc;
    /* How many threads are there and what process/entry,etc are they in? */
    struct Thd_Obj* Thd;
    /* How many invocation ports are there, and where should they be delegated to? */
    struct Inv_Obj* Inv;
    /* How many signal endpoints are there, and where should they be delegated to? */
    struct Sig_Obj* Sig;
}

/* How to place our generated code stub from what? and why? */
/* Note that we have dropped STKERR, thus now we can put the stub in the code section.
 * any such errors, just gets ignored and does not need special treatment. */

/* Now we can generate the kernel object allocation code for RVM. After this is done, we should have created all files and directories. */

/* At last, generate the  


/* Should generate the whole keil project to ease the user off.... need to know keil project format.
   This generator should be implemented for both keil and eclipse.
   I suggest that we use one for each. That means, developing separate stuff.
   This is gonna make the system useful after such tweaks to a basic possibility.
   Due to the fact that this only generate skeletons, it should be easy.

   The compilation flow is: compartment 1... 2... 3... 4..., each with a scatter file added to the project alongside the stuff. Also, create a main file and add to the project.
   
   After we've created the projects, we create the MPW.
   After all these are done, release the project IMMEDIATELY. we cannot wait anymore; this is dangerous. Very dangerous.

   We, in the same sense, uses xml for such needs.
   For mpw, we choose a wholly different build system. This is perfectly fine.
 */

... header ...
How many xmls are there and why?
There will be two xmls:
the first one is the user supplied project description.
the second one is the chip database.
the third one is the generated very detailed view.
Then, we supply the third one to our config generator.

The user compartments will be initialized by the manager, including all the data.

/* Given the name, we can derive from it these stuff. Because we provided a header 
 * library and just need to adapt that, this is super simple.
 * This is an example that demonstrates that */

rme_platform_STM32F767IG.xml

/* Generated header to feed to the config generator */
<Project> 
    <Name> M7M1 </Name>                                                         <!-- The name of the whole project, no special characters -->
    <Chip> STM32F767IG </Chip>                                                  <!-- The full name of the chip -->
    </Chip>
    <RME>                                                                       <!-- OS configuration description -->
        <General>                                                               <!-- The settings that will apply to all ports -->
            <KMEM_SIZE> 0x10000 <KMEM_SIZE>                                                        <!-- How much kernel memory does the user want? -->
            <RME_KMEM_VA_START> 0x20003000 </RME_KMEM_VA_START>                 <!-- The start address for kernel virtual memory -->
            <RME_KMEM_SIZE> 0x20003000 </RME_KMEM_SIZE>                         <!-- The size for kernel virtual memory -->
            <RME_HYP_VA_START> 0x20020000 </RME_HYP_VA_START>                   <!-- The start address for hypervisor reserved virtual memory -->
            <RME_HYP_SIZE> 0x60000 </RME_HYP_SIZE>                              <!-- The size of the hypervisor reserved virtual memory -->
            <RME_KMEM_SLOT_ORDER> 4 </RME_KMEM_SLOT_ORDER>                      <!-- The order of allocation for the kernel memory -->
            <RME_KMEM_STACK_ADDR> 0x20000FF0 </RME_KMEM_STACK_ADDR>             <!-- The kernel stack address -->
            <RME_MAX_PREEMPT_PRIO> 32 </RME_MAX_PREEMPT_PRIO>                   <!-- The maximum number of priorities in the system -->
        </General>
        <CMX>                                                                   <!-- The settings that applies specifically to this port -->
        </CMX>
        <STM32F767IGT6>                                                         <!-- The settings for this chip - we know we gonna use this template anyway, so useless -->
            <>
        </STM32F767IGT6>
    </RME>
</Project>

where did our compiler options go??? 


Command line (very simple)
pcc -i project.xml -o ../Output

