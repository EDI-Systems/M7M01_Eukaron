
RME.elf:     file format elf32-littlearm


Disassembly of section .text:

80100000 <_start>:
    .global             __bss_end__
    .global             __va_offset__
    .global             main
_start:
    .global             _start
    LDR                 R0,=__bss_start__
80100000:	e59f01ac 	ldr	r0, [pc, #428]	@ 801001b4 <finish+0x8>
    LDR                 R1,=__bss_end__
80100004:	e59f11ac 	ldr	r1, [pc, #428]	@ 801001b8 <finish+0xc>
    LDR                 R2,=__va_offset__
80100008:	e59f21ac 	ldr	r2, [pc, #428]	@ 801001bc <finish+0x10>
    SUB                 R0,R0,R2
8010000c:	e0400002 	sub	r0, r0, r2
    SUB                 R1,R1,R2
80100010:	e0411002 	sub	r1, r1, r2
    LDR                 R2,=0x00        
80100014:	e3a02000 	mov	r2, #0

80100018 <clear_bss>:
clear_bss:
    CMP                 R0,R1
80100018:	e1500001 	cmp	r0, r1
    BEQ                 clear_done
8010001c:	0a000002 	beq	8010002c <clear_done>
    STR                 R2,[R0]
80100020:	e5802000 	str	r2, [r0]
    ADD                 R0,#0x04
80100024:	e2800004 	add	r0, r0, #4
    B                   clear_bss
80100028:	eafffffa 	b	80100018 <clear_bss>

8010002c <clear_done>:
clear_done:
    /* Set stacks for all modes */
    LDR                 R4,=__RME_A7A_Stack_Start
8010002c:	e59f418c 	ldr	r4, [pc, #396]	@ 801001c0 <finish+0x14>
    ADD                 R4,#0x10000
80100030:	e2844801 	add	r4, r4, #65536	@ 0x10000
    /* IRQ mode */
    LDR                 R0,=0x600F00D2
80100034:	e59f0188 	ldr	r0, [pc, #392]	@ 801001c4 <finish+0x18>
    MSR                 CPSR,R0
80100038:	e129f000 	msr	CPSR_fc, r0
    MOV                 SP,R4
8010003c:	e1a0d004 	mov	sp, r4
    /* ABT mode */
    LDR                 R0,=0x600F00D7
80100040:	e59f0180 	ldr	r0, [pc, #384]	@ 801001c8 <finish+0x1c>
    MSR                 CPSR,R0
80100044:	e129f000 	msr	CPSR_fc, r0
    MOV                 SP,R4
80100048:	e1a0d004 	mov	sp, r4
    /* FIQ mode */
    LDR                 R0,=0x600F00D1
8010004c:	e59f0178 	ldr	r0, [pc, #376]	@ 801001cc <finish+0x20>
    MSR                 CPSR,R0
80100050:	e129f000 	msr	CPSR_fc, r0
    MOV                 SP,R4
80100054:	e1a0d004 	mov	sp, r4
    /* UND mode */
    LDR                 R0,=0x600F00DB
80100058:	e59f0170 	ldr	r0, [pc, #368]	@ 801001d0 <finish+0x24>
    MSR                 CPSR,R0
8010005c:	e129f000 	msr	CPSR_fc, r0
    MOV                 SP,R4
80100060:	e1a0d004 	mov	sp, r4
    /* SYS mode */
    LDR                 R0,=0x600F00DB
80100064:	e59f0164 	ldr	r0, [pc, #356]	@ 801001d0 <finish+0x24>
    MSR                 CPSR,R0
80100068:	e129f000 	msr	CPSR_fc, r0
    MOV                 SP,R4
8010006c:	e1a0d004 	mov	sp, r4
    /* SVC mode */
    LDR                 R0,=0x600F00D3
80100070:	e59f015c 	ldr	r0, [pc, #348]	@ 801001d4 <finish+0x28>
    MSR                 CPSR,R0
80100074:	e129f000 	msr	CPSR_fc, r0
    MOV                 SP,R4
80100078:	e1a0d004 	mov	sp, r4

    /* Turn off the MMU and all cache if it is already enabled. There's no need
     * to turn cache off because we are not modifying the instruction stream at
     * all; the TLB walker will start walking from L1D if it is enabled */
    CP15_GET_INIT       CRN=C1 OP1=0 CRM=C0 OP2=0   //08C5187A off, 08C5187F on
8010007c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    LDR                 R1,=~((1<<2)|(1<<0))
80100080:	e3e01005 	mvn	r1, #5
    AND                 R0,R0,R1
80100084:	e0000001 	and	r0, r0, r1
    CP15_SET_INIT       CRN=C1 OP1=0 CRM=C0 OP2=0 /* SCTLR.AFE,TRE,I,C,M */
80100088:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    ISB
8010008c:	f57ff06f 	isb	sy
    /* Flush TLB */
    LDR                 R0,=0x00
80100090:	e3a00000 	mov	r0, #0
    CP15_SET_INIT       CRN=C8 OP1=0 CRM=C7 OP2=0 /* TLBIALL */
80100094:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
    ISB
80100098:	f57ff06f 	isb	sy
     * R5: Number of pages
     * R6: Property mask
     * R7: Page counter
     * R8: Write index register
     * R9: Write content register */
    LDR                 R0,=RME_A7A_Mem_Info   //165F18
8010009c:	e59f0134 	ldr	r0, [pc, #308]	@ 801001d8 <finish+0x2c>
    LDR                 R1,=__RME_A7A_Kern_Pgt //150000
801000a0:	e59f1134 	ldr	r1, [pc, #308]	@ 801001dc <finish+0x30>
    LDR                 R2,=__va_offset__
801000a4:	e59f2110 	ldr	r2, [pc, #272]	@ 801001bc <finish+0x10>
    /* Calculate the actual address */
    SUB                 R0,R0,R2
801000a8:	e0400002 	sub	r0, r0, r2
    SUB                 R1,R1,R2
801000ac:	e0411002 	sub	r1, r1, r2
    /* Calculate the configuration end address */
    LDR                 R3,[R0]
801000b0:	e5903000 	ldr	r3, [r0]
    LSL					R3,R3,#2
801000b4:	e1a03103 	lsl	r3, r3, #2
    ADD                 R2,R0,R3
801000b8:	e0802003 	add	r2, r0, r3
    ADD                 R0,R0,#0x04
801000bc:	e2800004 	add	r0, r0, #4

801000c0 <load_config>:
    /* Load configurations and generate page table layout one by one */
load_config:
    LDMIA               R0!,{R3-R6}
801000c0:	e8b00078 	ldm	r0!, {r3, r4, r5, r6}
    MOV                 R7,#0x00
801000c4:	e3a07000 	mov	r7, #0
    LSR                 R8,R4,#18
801000c8:	e1a08924 	lsr	r8, r4, #18
    ADD                 R8,R1,R8
801000cc:	e0818008 	add	r8, r1, r8
    ORR                 R9,R3,R6
801000d0:	e1839006 	orr	r9, r3, r6

801000d4 <fill_pgtbl>:

fill_pgtbl:
    STR                 R9,[R8]
801000d4:	e5889000 	str	r9, [r8]
    ADD                 R8,R8,#4
801000d8:	e2888004 	add	r8, r8, #4
    ADD                 R7,R7,#1
801000dc:	e2877001 	add	r7, r7, #1
    ADD                 R9,R9,#0x100000
801000e0:	e2899601 	add	r9, r9, #1048576	@ 0x100000

    CMP                 R7,R5
801000e4:	e1570005 	cmp	r7, r5
    BNE                 fill_pgtbl
801000e8:	1afffff9 	bne	801000d4 <fill_pgtbl>

    CMP                 R0,R2
801000ec:	e1500002 	cmp	r0, r2
    BNE                 load_config
801000f0:	1afffff2 	bne	801000c0 <load_config>

    ISB
801000f4:	f57ff06f 	isb	sy

    /* Set the registers */
    LDR                 R0,=0x02
801000f8:	e3a00002 	mov	r0, #2
    CP15_SET_INIT       CRN=C2 OP1=0 CRM=C0 OP2=2 /* TTBCR, TTBR1 in use when accessing > 1GB */
801000fc:	ee020f50 	mcr	15, 0, r0, cr2, cr0, {2}
    ISB
80100100:	f57ff06f 	isb	sy

    LDR                 R0,=0xFFFFFFFFF//0x55555555
80100104:	e3e00000 	mvn	r0, #0
    CP15_SET_INIT       CRN=C3 OP1=0 CRM=C0 OP2=0 /* DACR */
80100108:	ee030f10 	mcr	15, 0, r0, cr3, cr0, {0}
    ISB
8010010c:	f57ff06f 	isb	sy

    LDR                 R0,=0x000A00A4
80100110:	e59f00c8 	ldr	r0, [pc, #200]	@ 801001e0 <finish+0x34>
    CP15_SET_INIT       CRN=C10 OP1=0 CRM=C2 OP2=0 /* PRRR */
80100114:	ee0a0f12 	mcr	15, 0, r0, cr10, cr2, {0}
    ISB
80100118:	f57ff06f 	isb	sy

    LDR                 R0,=0x006C006C
8010011c:	e59f00c0 	ldr	r0, [pc, #192]	@ 801001e4 <finish+0x38>
    CP15_SET_INIT       CRN=C10 OP1=0 CRM=C2 OP2=1 /* NMRR */
80100120:	ee0a0f32 	mcr	15, 0, r0, cr10, cr2, {1}
    ISB
80100124:	f57ff06f 	isb	sy

    /* Set base address */
    LDR                 R0,=__RME_A7A_Kern_Pgt
80100128:	e59f00ac 	ldr	r0, [pc, #172]	@ 801001dc <finish+0x30>
    LDR                 R1,=__va_offset__
8010012c:	e59f1088 	ldr	r1, [pc, #136]	@ 801001bc <finish+0x10>
    SUB                 R0,R0,R1 //R0=00150000
80100130:	e0400001 	sub	r0, r0, r1
    ORR					R0,R0,#0x09 /* Stuff to write into TTBR */
80100134:	e3800009 	orr	r0, r0, #9
    CP15_SET_INIT       CRN=C2 OP1=0 CRM=C0 OP2=0 /* TTBR0 */
80100138:	ee020f10 	mcr	15, 0, r0, cr2, cr0, {0}
    CP15_SET_INIT       CRN=C2 OP1=0 CRM=C0 OP2=1 /* TTBR1 */
8010013c:	ee020f30 	mcr	15, 0, r0, cr2, cr0, {1}
    /* Load the main function address to R3 first to prepare for a long jump */
    LDR                 R3,=main  //R3=80165848
80100140:	e59f30a0 	ldr	r3, [pc, #160]	@ 801001e8 <finish+0x3c>
    ISB
80100144:	f57ff06f 	isb	sy

    /* Turn on paging and cache */
    CP15_GET_INIT       CRN=C1 OP1=0 CRM=C0 OP2=0
80100148:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    LDR                 R1,=(1<<29)|(1<<28)|(1<<12)|(1<<2)|(1<<0) //R1=30001005 |(1<<12)|(1<<2)|(1<<0)
8010014c:	e59f1098 	ldr	r1, [pc, #152]	@ 801001ec <finish+0x40>
    ORR                 R0,R0,R1  //R0=38C5187F
80100150:	e1800001 	orr	r0, r0, r1
    CP15_SET_INIT       CRN=C1 OP1=0 CRM=C0 OP2=0 /* SCTLR.AFE,TRE,I,C,M */
80100154:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    ISB
80100158:	f57ff06f 	isb	sy

    /* Flush TLB again */
    LDR                 R0,=0x00
8010015c:	e3a00000 	mov	r0, #0
    CP15_SET_INIT       CRN=C8 OP1=0 CRM=C7 OP2=0 /* TLBIALL */
80100160:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
    ISB
80100164:	f57ff06f 	isb	sy

    /* Branch to main function */
    BX                  R3
80100168:	e12fff13 	bx	r3

	/* Print a hex number in LR, R12 used as counter ********************************************/
    MOV 				LR,R0
8010016c:	e1a0e000 	mov	lr, r0
    MOV					R12,#32     /* 32-bits */
80100170:	e3a0c020 	mov	ip, #32

80100174 <nextdigit>:
nextdigit:
    SUB					R12,R12,#0x04
80100174:	e24cc004 	sub	ip, ip, #4
    LSR					R11,LR,R12
80100178:	e1a0bc3e 	lsr	fp, lr, ip
	AND					R11,R11,#0x0F
8010017c:	e20bb00f 	and	fp, fp, #15
	CMP					R11,#0x09
80100180:	e35b0009 	cmp	fp, #9
	BGE					bigger
80100184:	aa000001 	bge	80100190 <bigger>
	ADD					R11,R11,#0x30 /* add '0' */
80100188:	e28bb030 	add	fp, fp, #48	@ 0x30
	B					printwait
8010018c:	ea000000 	b	80100194 <printwait>

80100190 <bigger>:
bigger:
	ADD					R11,R11,#(0x41-10) /* add 'A' */
80100190:	e28bb037 	add	fp, fp, #55	@ 0x37

80100194 <printwait>:
printwait:
    LDR                 R10,=0xE000102C
80100194:	e59fa054 	ldr	sl, [pc, #84]	@ 801001f0 <finish+0x44>
    LDR					R10,[R10]
80100198:	e59aa000 	ldr	sl, [sl]
    TST					R10,#0x08
8010019c:	e31a0008 	tst	sl, #8
    BEQ					printwait
801001a0:	0afffffb 	beq	80100194 <printwait>
    LDR                 R10,=0xE0001030
801001a4:	e59fa048 	ldr	sl, [pc, #72]	@ 801001f4 <finish+0x48>
    STR                 R11,[R10]
801001a8:	e58ab000 	str	fp, [sl]

801001ac <finish>:
finish:
	CMP					R12,#0x00
801001ac:	e35c0000 	cmp	ip, #0
	BNE					nextdigit
801001b0:	1affffef 	bne	80100174 <nextdigit>
    LDR                 R0,=__bss_start__
801001b4:	8016d000 	.word	0x8016d000
    LDR                 R1,=__bss_end__
801001b8:	8096d118 	.word	0x8096d118
    LDR                 R2,=__va_offset__
801001bc:	80000000 	.word	0x80000000
    LDR                 R4,=__RME_A7A_Stack_Start
801001c0:	80100200 	.word	0x80100200
    LDR                 R0,=0x600F00D2
801001c4:	600f00d2 	.word	0x600f00d2
    LDR                 R0,=0x600F00D7
801001c8:	600f00d7 	.word	0x600f00d7
    LDR                 R0,=0x600F00D1
801001cc:	600f00d1 	.word	0x600f00d1
    LDR                 R0,=0x600F00DB
801001d0:	600f00db 	.word	0x600f00db
    LDR                 R0,=0x600F00D3
801001d4:	600f00d3 	.word	0x600f00d3
    LDR                 R0,=RME_A7A_Mem_Info   //165F18
801001d8:	8016c374 	.word	0x8016c374
    LDR                 R1,=__RME_A7A_Kern_Pgt //150000
801001dc:	80150000 	.word	0x80150000
    LDR                 R0,=0x000A00A4
801001e0:	000a00a4 	.word	0x000a00a4
    LDR                 R0,=0x006C006C
801001e4:	006c006c 	.word	0x006c006c
    LDR                 R3,=main  //R3=80165848
801001e8:	8016b488 	.word	0x8016b488
    LDR                 R1,=(1<<29)|(1<<28)|(1<<12)|(1<<2)|(1<<0) //R1=30001005 |(1<<12)|(1<<2)|(1<<0)
801001ec:	30001005 	.word	0x30001005
    LDR                 R10,=0xE000102C
801001f0:	e000102c 	.word	0xe000102c
    LDR                 R10,=0xE0001030
801001f4:	e0001030 	.word	0xe0001030
801001f8:	e320f000 	nop	{0}
801001fc:	e320f000 	nop	{0}

80100200 <__RME_A7A_Stack_Start>:
	...

80140200 <__RME_A7A_Stack_End>:
	...

80150000 <__RME_A7A_Kern_Pgt>:
	...

80160000 <__RME_A7A_Vector_Table>:
__RME_A7A_Kern_Pgt:
    .space              65536
/* Vectors *******************************************************************/
    .align              8
__RME_A7A_Vector_Table:
    B                   Reset_Handler
80160000:	ea0001d8 	b	80160768 <Reset_Handler>
    B                   Undefined_Handler
80160004:	ea0001d8 	b	8016076c <Undefined_Handler>
    B                   SVC_Handler
80160008:	ea000201 	b	80160814 <SVC_Handler>
    B                   Prefetch_Abort_Handler
8016000c:	ea0001e4 	b	801607a4 <Prefetch_Abort_Handler>
    B                   Data_Abort_Handler
80160010:	ea0001f1 	b	801607dc <Data_Abort_Handler>
    B                   Unused_Handler
80160014:	ea0001d3 	b	80160768 <Reset_Handler>
    B                   IRQ_Handler
80160018:	ea00020b 	b	8016084c <IRQ_Handler>
    B                   FIQ_Handler
8016001c:	ea000218 	b	80160884 <FIQ_Handler>

80160020 <__RME_A7A_CPSR_Get>:
Output      : None.
Return      : R0 - The XXXX register contents.
******************************************************************************/
/* CPSR & SPSR */
__RME_A7A_CPSR_Get:
    MRS                 R0,CPSR
80160020:	e10f0000 	mrs	r0, CPSR
    BX                  LR
80160024:	e12fff1e 	bx	lr

80160028 <__RME_A7A_SPSR_Get>:
__RME_A7A_SPSR_Get:
    MRS                 R0,SPSR
80160028:	e14f0000 	mrs	r0, SPSR
    BX                  LR
8016002c:	e12fff1e 	bx	lr

80160030 <__RME_A7A_MIDR_Get>:

/* Main ID register */
__RME_A7A_MIDR_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C0 OP2=0
80160030:	ee100f10 	mrc	15, 0, r0, cr0, cr0, {0}
80160034:	e12fff1e 	bx	lr

80160038 <__RME_A7A_CTR_Get>:
/* Cache type register */
__RME_A7A_CTR_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C0 OP2=1
80160038:	ee100f30 	mrc	15, 0, r0, cr0, cr0, {1}
8016003c:	e12fff1e 	bx	lr

80160040 <__RME_A7A_TCMTR_Get>:
/* TCM type register */
__RME_A7A_TCMTR_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C0 OP2=2
80160040:	ee100f50 	mrc	15, 0, r0, cr0, cr0, {2}
80160044:	e12fff1e 	bx	lr

80160048 <__RME_A7A_TLBTR_Get>:
/* TLB type register */
__RME_A7A_TLBTR_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C0 OP2=3
80160048:	ee100f70 	mrc	15, 0, r0, cr0, cr0, {3}
8016004c:	e12fff1e 	bx	lr

80160050 <__RME_A7A_MPIDR_Get>:
/* Multiprocessor affinity register */
__RME_A7A_MPIDR_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C0 OP2=5
80160050:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
80160054:	e12fff1e 	bx	lr

80160058 <__RME_A7A_REVIDR_Get>:
/* Revision ID register */
__RME_A7A_REVIDR_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C0 OP2=6
80160058:	ee100fd0 	mrc	15, 0, r0, cr0, cr0, {6}
8016005c:	e12fff1e 	bx	lr

80160060 <__RME_A7A_ID_PFR0_Get>:
/* Processor feature register 0 */
__RME_A7A_ID_PFR0_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=0
80160060:	ee100f11 	mrc	15, 0, r0, cr0, cr1, {0}
80160064:	e12fff1e 	bx	lr

80160068 <__RME_A7A_ID_PFR1_Get>:
/* Processor feature register 1 */
__RME_A7A_ID_PFR1_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=1
80160068:	ee100f31 	mrc	15, 0, r0, cr0, cr1, {1}
8016006c:	e12fff1e 	bx	lr

80160070 <__RME_A7A_ID_DFR0_Get>:
/* Debug feature register 0 */
__RME_A7A_ID_DFR0_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=2
80160070:	ee100f51 	mrc	15, 0, r0, cr0, cr1, {2}
80160074:	e12fff1e 	bx	lr

80160078 <__RME_A7A_ID_AFR0_Get>:
/* Auxiliary feature register 0 */
__RME_A7A_ID_AFR0_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=3
80160078:	ee100f71 	mrc	15, 0, r0, cr0, cr1, {3}
8016007c:	e12fff1e 	bx	lr

80160080 <__RME_A7A_ID_MMFR0_Get>:
/* Memory model feature register 0 */
__RME_A7A_ID_MMFR0_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=4
80160080:	ee100f91 	mrc	15, 0, r0, cr0, cr1, {4}
80160084:	e12fff1e 	bx	lr

80160088 <__RME_A7A_ID_MMFR1_Get>:
/* Memory model feature register 1 */
__RME_A7A_ID_MMFR1_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=5
80160088:	ee100fb1 	mrc	15, 0, r0, cr0, cr1, {5}
8016008c:	e12fff1e 	bx	lr

80160090 <__RME_A7A_ID_MMFR2_Get>:
/* Memory model feature register 2 */
__RME_A7A_ID_MMFR2_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=6
80160090:	ee100fd1 	mrc	15, 0, r0, cr0, cr1, {6}
80160094:	e12fff1e 	bx	lr

80160098 <__RME_A7A_ID_MMFR3_Get>:
/* Memory model feature register 3 */
__RME_A7A_ID_MMFR3_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=7
80160098:	ee100ff1 	mrc	15, 0, r0, cr0, cr1, {7}
8016009c:	e12fff1e 	bx	lr

801600a0 <__RME_A7A_ID_ISAR0_Get>:
/* ISA feature register 0 */
__RME_A7A_ID_ISAR0_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C2 OP2=0
801600a0:	ee100f12 	mrc	15, 0, r0, cr0, cr2, {0}
801600a4:	e12fff1e 	bx	lr

801600a8 <__RME_A7A_ID_ISAR1_Get>:
/* ISA feature register 1 */
__RME_A7A_ID_ISAR1_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C2 OP2=1
801600a8:	ee100f32 	mrc	15, 0, r0, cr0, cr2, {1}
801600ac:	e12fff1e 	bx	lr

801600b0 <__RME_A7A_ID_ISAR2_Get>:
/* ISA feature register 2 */
__RME_A7A_ID_ISAR2_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C2 OP2=2
801600b0:	ee100f52 	mrc	15, 0, r0, cr0, cr2, {2}
801600b4:	e12fff1e 	bx	lr

801600b8 <__RME_A7A_ID_ISAR3_Get>:
/* ISA feature register 3 */
__RME_A7A_ID_ISAR3_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C2 OP2=3
801600b8:	ee100f72 	mrc	15, 0, r0, cr0, cr2, {3}
801600bc:	e12fff1e 	bx	lr

801600c0 <__RME_A7A_ID_ISAR4_Get>:
/* ISA feature register 4 */
__RME_A7A_ID_ISAR4_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C2 OP2=4
801600c0:	ee100f92 	mrc	15, 0, r0, cr0, cr2, {4}
801600c4:	e12fff1e 	bx	lr

801600c8 <__RME_A7A_ID_ISAR5_Get>:
/* ISA feature register 5 */
__RME_A7A_ID_ISAR5_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C2 OP2=5
801600c8:	ee100fb2 	mrc	15, 0, r0, cr0, cr2, {5}
801600cc:	e12fff1e 	bx	lr

801600d0 <__RME_A7A_ID_CCSIDR_Get>:
/* Cache size ID registers */
__RME_A7A_ID_CCSIDR_Get:
    CP15_GET            CRN=C0 OP1=1 CRM=C0 OP2=0
801600d0:	ee300f10 	mrc	15, 1, r0, cr0, cr0, {0}
801600d4:	e12fff1e 	bx	lr

801600d8 <__RME_A7A_ID_CLIDR_Get>:
/* Cache level ID register */
__RME_A7A_ID_CLIDR_Get:
    CP15_GET            CRN=C0 OP1=1 CRM=C0 OP2=1
801600d8:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
801600dc:	e12fff1e 	bx	lr

801600e0 <__RME_A7A_ID_AIDR_Get>:
/* Auxiliary ID register */
__RME_A7A_ID_AIDR_Get:
    CP15_GET            CRN=C0 OP1=1 CRM=C0 OP2=7
801600e0:	ee300ff0 	mrc	15, 1, r0, cr0, cr0, {7}
801600e4:	e12fff1e 	bx	lr

801600e8 <__RME_A7A_ID_CSSELR_Get>:
/* Cache size selection register */
__RME_A7A_ID_CSSELR_Get:
    CP15_GET            CRN=C0 OP1=2 CRM=C0 OP2=0
801600e8:	ee500f10 	mrc	15, 2, r0, cr0, cr0, {0}
801600ec:	e12fff1e 	bx	lr

801600f0 <__RME_A7A_ID_VPIDR_Get>:
/* Virtualization processor ID register  */
__RME_A7A_ID_VPIDR_Get:
    CP15_GET            CRN=C0 OP1=4 CRM=C0 OP2=0
801600f0:	ee900f10 	mrc	15, 4, r0, cr0, cr0, {0}
801600f4:	e12fff1e 	bx	lr

801600f8 <__RME_A7A_ID_VMPIDR_Get>:
/* Virtualization multiprocessor ID register */
__RME_A7A_ID_VMPIDR_Get:
    CP15_GET            CRN=C0 OP1=4 CRM=C0 OP2=5
801600f8:	ee900fb0 	mrc	15, 4, r0, cr0, cr0, {5}
801600fc:	e12fff1e 	bx	lr

80160100 <__RME_A7A_SCTLR_Get>:

/* System control register */
__RME_A7A_SCTLR_Get:
    CP15_GET            CRN=C1 OP1=0 CRM=C0 OP2=0
80160100:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
80160104:	e12fff1e 	bx	lr

80160108 <__RME_A7A_ACTLR_Get>:
/* Auxiliary control register */
__RME_A7A_ACTLR_Get:
    CP15_GET            CRN=C1 OP1=0 CRM=C0 OP2=1
80160108:	ee110f30 	mrc	15, 0, r0, cr1, cr0, {1}
8016010c:	e12fff1e 	bx	lr

80160110 <__RME_A7A_CPACR_Get>:
/* Coprocessor auxiliary control register */
__RME_A7A_CPACR_Get:
    CP15_GET            CRN=C1 OP1=0 CRM=C0 OP2=2
80160110:	ee110f50 	mrc	15, 0, r0, cr1, cr0, {2}
80160114:	e12fff1e 	bx	lr

80160118 <__RME_A7A_SCR_Get>:
/* Secure configuration register */
__RME_A7A_SCR_Get:
    CP15_GET            CRN=C1 OP1=0 CRM=C1 OP2=0
80160118:	ee110f11 	mrc	15, 0, r0, cr1, cr1, {0}
8016011c:	e12fff1e 	bx	lr

80160120 <__RME_A7A_SDER_Get>:
/* Secure debug enable register */
__RME_A7A_SDER_Get:
    CP15_GET            CRN=C1 OP1=0 CRM=C1 OP2=1
80160120:	ee110f31 	mrc	15, 0, r0, cr1, cr1, {1}
80160124:	e12fff1e 	bx	lr

80160128 <__RME_A7A_NSACR_Get>:
/* Non-secure access control register */
__RME_A7A_NSACR_Get:
    CP15_GET            CRN=C1 OP1=0 CRM=C1 OP2=2
80160128:	ee110f51 	mrc	15, 0, r0, cr1, cr1, {2}
8016012c:	e12fff1e 	bx	lr

80160130 <__RME_A7A_HSCTLR_Get>:
/* Hyp system control register */
__RME_A7A_HSCTLR_Get:
    CP15_GET            CRN=C1 OP1=4 CRM=C0 OP2=0
80160130:	ee910f10 	mrc	15, 4, r0, cr1, cr0, {0}
80160134:	e12fff1e 	bx	lr

80160138 <__RME_A7A_HACTLR_Get>:
/* Hyp auxiliary control register */
__RME_A7A_HACTLR_Get:
    CP15_GET            CRN=C1 OP1=4 CRM=C0 OP2=1
80160138:	ee910f30 	mrc	15, 4, r0, cr1, cr0, {1}
8016013c:	e12fff1e 	bx	lr

80160140 <__RME_A7A_HCR_Get>:
/* Hyp configuration register */
__RME_A7A_HCR_Get:
    CP15_GET            CRN=C1 OP1=4 CRM=C1 OP2=0
80160140:	ee910f11 	mrc	15, 4, r0, cr1, cr1, {0}
80160144:	e12fff1e 	bx	lr

80160148 <__RME_A7A_HDCR_Get>:
/* Hyp debug configuration register */
__RME_A7A_HDCR_Get:
    CP15_GET            CRN=C1 OP1=4 CRM=C1 OP2=1
80160148:	ee910f31 	mrc	15, 4, r0, cr1, cr1, {1}
8016014c:	e12fff1e 	bx	lr

80160150 <__RME_A7A_HCPTR_Get>:
/* Hyp coprocessor trap register */
__RME_A7A_HCPTR_Get:
    CP15_GET            CRN=C1 OP1=4 CRM=C1 OP2=2
80160150:	ee910f51 	mrc	15, 4, r0, cr1, cr1, {2}
80160154:	e12fff1e 	bx	lr

80160158 <__RME_A7A_HSTR_Get>:
/* Hyp system trap register */
__RME_A7A_HSTR_Get:
    CP15_GET            CRN=C1 OP1=4 CRM=C1 OP2=3
80160158:	ee910f71 	mrc	15, 4, r0, cr1, cr1, {3}
8016015c:	e12fff1e 	bx	lr

80160160 <__RME_A7A_HACR_Get>:
/* Hyp auxiliary configuration register */
__RME_A7A_HACR_Get:
    CP15_GET            CRN=C1 OP1=4 CRM=C1 OP2=7
80160160:	ee910ff1 	mrc	15, 4, r0, cr1, cr1, {7}
80160164:	e12fff1e 	bx	lr

80160168 <__RME_A7A_TTBR0_Get>:

/* Translation table base register 0 - 32bit. We do not support PAE of any kind */
__RME_A7A_TTBR0_Get:
    CP15_GET            CRN=C2 OP1=0 CRM=C0 OP2=0
80160168:	ee120f10 	mrc	15, 0, r0, cr2, cr0, {0}
8016016c:	e12fff1e 	bx	lr

80160170 <__RME_A7A_TTBR1_Get>:
/* Translation table base register 1 - 32bit. We do not support PAE of any kind */
__RME_A7A_TTBR1_Get:
    CP15_GET            CRN=C2 OP1=0 CRM=C0 OP2=1
80160170:	ee120f30 	mrc	15, 0, r0, cr2, cr0, {1}
80160174:	e12fff1e 	bx	lr

80160178 <__RME_A7A_TTBCR_Get>:
/* Translation table base controle register */
__RME_A7A_TTBCR_Get:
    CP15_GET            CRN=C2 OP1=0 CRM=C0 OP2=2
80160178:	ee120f50 	mrc	15, 0, r0, cr2, cr0, {2}
8016017c:	e12fff1e 	bx	lr

80160180 <__RME_A7A_HTCR_Get>:
/* Hyp translation control register */
__RME_A7A_HTCR_Get:
    CP15_GET            CRN=C2 OP1=4 CRM=C0 OP2=2
80160180:	ee920f50 	mrc	15, 4, r0, cr2, cr0, {2}
80160184:	e12fff1e 	bx	lr

80160188 <__RME_A7A_VTCR_Get>:
/* Virtualization translation control register */
__RME_A7A_VTCR_Get:
    CP15_GET            CRN=C2 OP1=4 CRM=C1 OP2=2
80160188:	ee920f51 	mrc	15, 4, r0, cr2, cr1, {2}
8016018c:	e12fff1e 	bx	lr

80160190 <__RME_A7A_DACR_Get>:
/* Domain access control register */
__RME_A7A_DACR_Get:
    CP15_GET            CRN=C3 OP1=0 CRM=C0 OP2=0
80160190:	ee130f10 	mrc	15, 0, r0, cr3, cr0, {0}
80160194:	e12fff1e 	bx	lr

80160198 <__RME_A7A_DFSR_Get>:

/* Data fault status register */
__RME_A7A_DFSR_Get:
    CP15_GET            CRN=C5 OP1=0 CRM=C0 OP2=0
80160198:	ee150f10 	mrc	15, 0, r0, cr5, cr0, {0}
8016019c:	e12fff1e 	bx	lr

801601a0 <__RME_A7A_IFSR_Get>:
/* Instruction fault status register */
__RME_A7A_IFSR_Get:
    CP15_GET            CRN=C5 OP1=0 CRM=C0 OP2=1
801601a0:	ee150f30 	mrc	15, 0, r0, cr5, cr0, {1}
801601a4:	e12fff1e 	bx	lr

801601a8 <__RME_A7A_ADFSR_Get>:
/* Auxiliary data fault status register */
__RME_A7A_ADFSR_Get:
    CP15_GET            CRN=C5 OP1=0 CRM=C1 OP2=0
801601a8:	ee150f11 	mrc	15, 0, r0, cr5, cr1, {0}
801601ac:	e12fff1e 	bx	lr

801601b0 <__RME_A7A_AIFSR_Get>:
/* Auxiliary instruction fault status register */
__RME_A7A_AIFSR_Get:
    CP15_GET            CRN=C5 OP1=0 CRM=C1 OP2=1
801601b0:	ee150f31 	mrc	15, 0, r0, cr5, cr1, {1}
801601b4:	e12fff1e 	bx	lr

801601b8 <__RME_A7A_HADFSR_Get>:
/* Hyp auxiliary data fault status register */
__RME_A7A_HADFSR_Get:
    CP15_GET            CRN=C5 OP1=4 CRM=C1 OP2=0
801601b8:	ee950f11 	mrc	15, 4, r0, cr5, cr1, {0}
801601bc:	e12fff1e 	bx	lr

801601c0 <__RME_A7A_HAIFSR_Get>:
/* Hyp auxiliary instruction fault status register */
__RME_A7A_HAIFSR_Get:
    CP15_GET            CRN=C5 OP1=4 CRM=C1 OP2=1
801601c0:	ee950f31 	mrc	15, 4, r0, cr5, cr1, {1}
801601c4:	e12fff1e 	bx	lr

801601c8 <__RME_A7A_HSR_Get>:
/* Hyp syndrome register */
__RME_A7A_HSR_Get:
    CP15_GET            CRN=C5 OP1=4 CRM=C2 OP2=0
801601c8:	ee950f12 	mrc	15, 4, r0, cr5, cr2, {0}
801601cc:	e12fff1e 	bx	lr

801601d0 <__RME_A7A_DFAR_Get>:
/* Data fault address register */
__RME_A7A_DFAR_Get:
    CP15_GET            CRN=C6 OP1=0 CRM=C0 OP2=0
801601d0:	ee160f10 	mrc	15, 0, r0, cr6, cr0, {0}
801601d4:	e12fff1e 	bx	lr

801601d8 <__RME_A7A_IFAR_Get>:
/* Instruction fault address register */
__RME_A7A_IFAR_Get:
    CP15_GET            CRN=C6 OP1=0 CRM=C0 OP2=2
801601d8:	ee160f50 	mrc	15, 0, r0, cr6, cr0, {2}
801601dc:	e12fff1e 	bx	lr

801601e0 <__RME_A7A_HDFAR_Get>:
/* Hyp data fault address register */
__RME_A7A_HDFAR_Get:
    CP15_GET            CRN=C6 OP1=4 CRM=C0 OP2=0
801601e0:	ee960f10 	mrc	15, 4, r0, cr6, cr0, {0}
801601e4:	e12fff1e 	bx	lr

801601e8 <__RME_A7A_HIFAR_Get>:
/* Hyp instruction fault address register */
__RME_A7A_HIFAR_Get:
    CP15_GET            CRN=C6 OP1=4 CRM=C0 OP2=2
801601e8:	ee960f50 	mrc	15, 4, r0, cr6, cr0, {2}
801601ec:	e12fff1e 	bx	lr

801601f0 <__RME_A7A_HPFAR_Get>:
/* Hyp IPA fault address register */
__RME_A7A_HPFAR_Get:
    CP15_GET            CRN=C6 OP1=4 CRM=C0 OP2=4
801601f0:	ee960f90 	mrc	15, 4, r0, cr6, cr0, {4}
801601f4:	e12fff1e 	bx	lr

801601f8 <__RME_A7A_PAR_Get>:

/* Physical address register */
__RME_A7A_PAR_Get:
    CP15_GET            CRN=C7 OP1=0 CRM=C4 OP2=0
801601f8:	ee170f14 	mrc	15, 0, r0, cr7, cr4, {0}
801601fc:	e12fff1e 	bx	lr

80160200 <__RME_A7A_TLBLR_Get>:

/* C9 registers currently unsupported */

/* TLB lockdown register - Cortex-A9 */
__RME_A7A_TLBLR_Get:
    CP15_GET            CRN=C10 OP1=0 CRM=C0 OP2=0
80160200:	ee1a0f10 	mrc	15, 0, r0, cr10, cr0, {0}
80160204:	e12fff1e 	bx	lr

80160208 <__RME_A7A_PRRR_Get>:
/* Primary region remap register */
__RME_A7A_PRRR_Get:
    CP15_GET            CRN=C10 OP1=0 CRM=C2 OP2=0
80160208:	ee1a0f12 	mrc	15, 0, r0, cr10, cr2, {0}
8016020c:	e12fff1e 	bx	lr

80160210 <__RME_A7A_NMRR_Get>:
/* Normal memory remap register */
__RME_A7A_NMRR_Get:
    CP15_GET            CRN=C10 OP1=0 CRM=C2 OP2=1
80160210:	ee1a0f32 	mrc	15, 0, r0, cr10, cr2, {1}
80160214:	e12fff1e 	bx	lr

80160218 <__RME_A7A_AMAIR0_Get>:
/* Auxiliary memory attribute indirection register 0 */
__RME_A7A_AMAIR0_Get:
    CP15_GET            CRN=C10 OP1=0 CRM=C3 OP2=0
80160218:	ee1a0f13 	mrc	15, 0, r0, cr10, cr3, {0}
8016021c:	e12fff1e 	bx	lr

80160220 <__RME_A7A_AMAIR1_Get>:
/* Auxiliary memory attribute indirection register 1 */
__RME_A7A_AMAIR1_Get:
    CP15_GET            CRN=C10 OP1=0 CRM=C3 OP2=1
80160220:	ee1a0f33 	mrc	15, 0, r0, cr10, cr3, {1}
80160224:	e12fff1e 	bx	lr

80160228 <__RME_A7A_HMAIR0_Get>:
/* Hyp memory attribute indirection register 0 */
__RME_A7A_HMAIR0_Get:
    CP15_GET            CRN=C10 OP1=4 CRM=C2 OP2=0
80160228:	ee9a0f12 	mrc	15, 4, r0, cr10, cr2, {0}
8016022c:	e12fff1e 	bx	lr

80160230 <__RME_A7A_HMAIR1_Get>:
/* Hyp memory attribute indirection register 1 */
__RME_A7A_HMAIR1_Get:
    CP15_GET            CRN=C10 OP1=4 CRM=C2 OP2=1
80160230:	ee9a0f32 	mrc	15, 4, r0, cr10, cr2, {1}
80160234:	e12fff1e 	bx	lr

80160238 <__RME_A7A_HAMAIR0_Get>:
/* Hyp auxiliary memory attribute indirection register 0 */
__RME_A7A_HAMAIR0_Get:
    CP15_GET            CRN=C10 OP1=4 CRM=C3 OP2=0
80160238:	ee9a0f13 	mrc	15, 4, r0, cr10, cr3, {0}
8016023c:	e12fff1e 	bx	lr

80160240 <__RME_A7A_HAMAIR1_Get>:
/* Hyp auxiliary memory attribute indirection register 1 */
__RME_A7A_HAMAIR1_Get:
    CP15_GET            CRN=C10 OP1=4 CRM=C3 OP2=1
80160240:	ee9a0f33 	mrc	15, 4, r0, cr10, cr3, {1}
80160244:	e12fff1e 	bx	lr

80160248 <__RME_A7A_VBAR_Get>:

/* Vector base address register */
__RME_A7A_VBAR_Get:
    CP15_GET            CRN=C12 OP1=0 CRM=C0 OP2=0
80160248:	ee1c0f10 	mrc	15, 0, r0, cr12, cr0, {0}
8016024c:	e12fff1e 	bx	lr

80160250 <__RME_A7A_MVBAR_Get>:
/* Vector base address register */
__RME_A7A_MVBAR_Get:
    CP15_GET            CRN=C12 OP1=0 CRM=C0 OP2=1
80160250:	ee1c0f30 	mrc	15, 0, r0, cr12, cr0, {1}
80160254:	e12fff1e 	bx	lr

80160258 <__RME_A7A_ISR_Get>:
/* Interrupt status register */
__RME_A7A_ISR_Get:
    CP15_GET            CRN=C12 OP1=0 CRM=C1 OP2=0
80160258:	ee1c0f11 	mrc	15, 0, r0, cr12, cr1, {0}
8016025c:	e12fff1e 	bx	lr

80160260 <__RME_A7A_HVBAR_Get>:
/* Hyp vector base address register */
__RME_A7A_HVBAR_Get:
    CP15_GET            CRN=C12 OP1=4 CRM=C0 OP2=0
80160260:	ee9c0f10 	mrc	15, 4, r0, cr12, cr0, {0}
80160264:	e12fff1e 	bx	lr

80160268 <__RME_A7A_FCSEIDR_Get>:

/* FCSE PID register */
__RME_A7A_FCSEIDR_Get:
    CP15_GET            CRN=C13 OP1=0 CRM=C0 OP2=0
80160268:	ee1d0f10 	mrc	15, 0, r0, cr13, cr0, {0}
8016026c:	e12fff1e 	bx	lr

80160270 <__RME_A7A_CONTEXTIDR_Get>:
/* Context ID register */
__RME_A7A_CONTEXTIDR_Get:
    CP15_GET            CRN=C13 OP1=0 CRM=C0 OP2=1
80160270:	ee1d0f30 	mrc	15, 0, r0, cr13, cr0, {1}
80160274:	e12fff1e 	bx	lr

80160278 <__RME_A7A_TPIDRURW_Get>:
/* User read/write software thread register */
__RME_A7A_TPIDRURW_Get:
    CP15_GET            CRN=C13 OP1=0 CRM=C0 OP2=2
80160278:	ee1d0f50 	mrc	15, 0, r0, cr13, cr0, {2}
8016027c:	e12fff1e 	bx	lr

80160280 <__RME_A7A_TPIDRURO_Get>:
/* User read-only software thread register */
__RME_A7A_TPIDRURO_Get:
    CP15_GET            CRN=C13 OP1=0 CRM=C0 OP2=3
80160280:	ee1d0f70 	mrc	15, 0, r0, cr13, cr0, {3}
80160284:	e12fff1e 	bx	lr

80160288 <__RME_A7A_TPIDRPRW_Get>:
/* PL1-only software thread register */
__RME_A7A_TPIDRPRW_Get:
    CP15_GET            CRN=C13 OP1=0 CRM=C0 OP2=4
80160288:	ee1d0f90 	mrc	15, 0, r0, cr13, cr0, {4}
8016028c:	e12fff1e 	bx	lr

80160290 <__RME_A7A_HTPIDR_Get>:
/* Hyp read/write software thread register */
__RME_A7A_HTPIDR_Get:
    CP15_GET            CRN=C13 OP1=4 CRM=C0 OP2=2
80160290:	ee9d0f50 	mrc	15, 4, r0, cr13, cr0, {2}
80160294:	e12fff1e 	bx	lr

80160298 <__RME_A7A_CNTFRQ_Get>:

/* Counter frequency register */
__RME_A7A_CNTFRQ_Get:
    CP15_GET            CRN=C14 OP1=0 CRM=C0 OP2=0
80160298:	ee1e0f10 	mrc	15, 0, r0, cr14, cr0, {0}
8016029c:	e12fff1e 	bx	lr

801602a0 <__RME_A7A_CNTKCTL_Get>:
/* Timer PL1 control register */
__RME_A7A_CNTKCTL_Get:
    CP15_GET            CRN=C14 OP1=0 CRM=C1 OP2=0
801602a0:	ee1e0f11 	mrc	15, 0, r0, cr14, cr1, {0}
801602a4:	e12fff1e 	bx	lr

801602a8 <__RME_A7A_CNTP_TVAL_Get>:
/* PL1 physical timer value register */
__RME_A7A_CNTP_TVAL_Get:
    CP15_GET            CRN=C14 OP1=0 CRM=C2 OP2=0
801602a8:	ee1e0f12 	mrc	15, 0, r0, cr14, cr2, {0}
801602ac:	e12fff1e 	bx	lr

801602b0 <__RME_A7A_CNTP_CTL_Get>:
/* PL1 physical timer control register */
__RME_A7A_CNTP_CTL_Get:
    CP15_GET            CRN=C14 OP1=0 CRM=C2 OP2=1
801602b0:	ee1e0f32 	mrc	15, 0, r0, cr14, cr2, {1}
801602b4:	e12fff1e 	bx	lr

801602b8 <__RME_A7A_CNTV_TVAL_Get>:
/* Virtual timer value register */
__RME_A7A_CNTV_TVAL_Get:
    CP15_GET            CRN=C14 OP1=0 CRM=C3 OP2=0
801602b8:	ee1e0f13 	mrc	15, 0, r0, cr14, cr3, {0}
801602bc:	e12fff1e 	bx	lr

801602c0 <__RME_A7A_CNTV_CTL_Get>:
/* Virtual timer control register */
__RME_A7A_CNTV_CTL_Get:
    CP15_GET            CRN=C14 OP1=0 CRM=C3 OP2=1
801602c0:	ee1e0f33 	mrc	15, 0, r0, cr14, cr3, {1}
801602c4:	e12fff1e 	bx	lr

801602c8 <__RME_A7A_CNTHCTL_Get>:
/* Timer PL2 control register */
__RME_A7A_CNTHCTL_Get:
    CP15_GET            CRN=C14 OP1=4 CRM=C1 OP2=0
801602c8:	ee9e0f11 	mrc	15, 4, r0, cr14, cr1, {0}
801602cc:	e12fff1e 	bx	lr

801602d0 <__RME_A7A_CNTHP_TVAL_Get>:
/* PL2 physical timer value register */
__RME_A7A_CNTHP_TVAL_Get:
    CP15_GET            CRN=C14 OP1=4 CRM=C2 OP2=0
801602d0:	ee9e0f12 	mrc	15, 4, r0, cr14, cr2, {0}
801602d4:	e12fff1e 	bx	lr

801602d8 <__RME_A7A_CNTHP_CTL_Get>:
/* PL2 physical timer control register */
__RME_A7A_CNTHP_CTL_Get:
    CP15_GET            CRN=C14 OP1=4 CRM=C2 OP2=1
801602d8:	ee9e0f32 	mrc	15, 4, r0, cr14, cr2, {1}
801602dc:	e12fff1e 	bx	lr

801602e0 <__RME_A7A_CNTPCT_DW_Get>:
              rme_ptr_t* R1 - The pointer to the higher bits.
Return      : None.
******************************************************************************/
/* Physical count register */
__RME_A7A_CNTPCT_DW_Get:
    CP15_GET_DOUBLE     CRM=C14 OP=0
801602e0:	ec532f0e 	mrrc	15, 0, r2, r3, cr14
801602e4:	e5802000 	str	r2, [r0]
801602e8:	e5813000 	str	r3, [r1]
801602ec:	e12fff1e 	bx	lr

801602f0 <__RME_A7A_CNTVCT_DW_Get>:
/* Virtual count register */
__RME_A7A_CNTVCT_DW_Get:
    CP15_GET_DOUBLE     CRM=C14 OP=1
801602f0:	ec532f1e 	mrrc	15, 1, r2, r3, cr14
801602f4:	e5802000 	str	r2, [r0]
801602f8:	e5813000 	str	r3, [r1]
801602fc:	e12fff1e 	bx	lr

80160300 <__RME_A7A_CNTP_CVAL_DW_Get>:
/* PL1 physical timer compare value register */
__RME_A7A_CNTP_CVAL_DW_Get:
    CP15_GET_DOUBLE     CRM=C14 OP=2
80160300:	ec532f2e 	mrrc	15, 2, r2, r3, cr14
80160304:	e5802000 	str	r2, [r0]
80160308:	e5813000 	str	r3, [r1]
8016030c:	e12fff1e 	bx	lr

80160310 <__RME_A7A_CNTV_CVAL_DW_Get>:
/* Virtual timer compare value register */
__RME_A7A_CNTV_CVAL_DW_Get:
    CP15_GET_DOUBLE     CRM=C14 OP=3
80160310:	ec532f3e 	mrrc	15, 3, r2, r3, cr14
80160314:	e5802000 	str	r2, [r0]
80160318:	e5813000 	str	r3, [r1]
8016031c:	e12fff1e 	bx	lr

80160320 <__RME_A7A_CNTVOFF_DW_Get>:
/* Virtual offset register */
__RME_A7A_CNTVOFF_DW_Get:
    CP15_GET_DOUBLE     CRM=C14 OP=4
80160320:	ec532f4e 	mrrc	15, 4, r2, r3, cr14
80160324:	e5802000 	str	r2, [r0]
80160328:	e5813000 	str	r3, [r1]
8016032c:	e12fff1e 	bx	lr

80160330 <__RME_A7A_CNTHP_CVAL_DW_Get>:
/* L2 physical timer compare value register */
__RME_A7A_CNTHP_CVAL_DW_Get:
    CP15_GET_DOUBLE     CRM=C14 OP=6
80160330:	ec532f6e 	mrrc	15, 6, r2, r3, cr14
80160334:	e5802000 	str	r2, [r0]
80160338:	e5813000 	str	r3, [r1]
8016033c:	e12fff1e 	bx	lr

80160340 <__RME_A7A_CPSR_Set>:
Output      : None.
Return      : None.
******************************************************************************/
/* CPSR & SPSR */
__RME_A7A_CPSR_Set:
    MSR                 CPSR,R0
80160340:	e129f000 	msr	CPSR_fc, r0
    BX                  LR
80160344:	e12fff1e 	bx	lr

80160348 <__RME_A7A_SPSR_Set>:
__RME_A7A_SPSR_Set:
    MSR                 SPSR,R0
80160348:	e169f000 	msr	SPSR_fc, r0
    BX                  LR
8016034c:	e12fff1e 	bx	lr

80160350 <__RME_A7A_ID_CSSELR_Set>:

/* Cache size selection register */
__RME_A7A_ID_CSSELR_Set:
    CP15_SET            CRN=C0 OP1=2 CRM=C0 OP2=0
80160350:	ee400f10 	mcr	15, 2, r0, cr0, cr0, {0}
80160354:	e12fff1e 	bx	lr

80160358 <__RME_A7A_ID_VPIDR_Set>:
/* Virtualization processor ID register  */
__RME_A7A_ID_VPIDR_Set:
    CP15_SET            CRN=C0 OP1=4 CRM=C0 OP2=0
80160358:	ee800f10 	mcr	15, 4, r0, cr0, cr0, {0}
8016035c:	e12fff1e 	bx	lr

80160360 <__RME_A7A_ID_VMPIDR_Set>:
/* Virtualization multiprocessor ID register */
__RME_A7A_ID_VMPIDR_Set:
    CP15_SET            CRN=C0 OP1=4 CRM=C0 OP2=5
80160360:	ee800fb0 	mcr	15, 4, r0, cr0, cr0, {5}
80160364:	e12fff1e 	bx	lr

80160368 <__RME_A7A_SCTLR_Set>:

/* System control register */
__RME_A7A_SCTLR_Set:
    CP15_SET            CRN=C1 OP1=0 CRM=C0 OP2=0
80160368:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
8016036c:	e12fff1e 	bx	lr

80160370 <__RME_A7A_ACTLR_Set>:
/* Auxiliary control register */
__RME_A7A_ACTLR_Set:
    CP15_SET            CRN=C1 OP1=0 CRM=C0 OP2=1
80160370:	ee010f30 	mcr	15, 0, r0, cr1, cr0, {1}
80160374:	e12fff1e 	bx	lr

80160378 <__RME_A7A_CPACR_Set>:
/* Coprocessor auxiliary control register */
__RME_A7A_CPACR_Set:
    CP15_SET            CRN=C1 OP1=0 CRM=C0 OP2=2
80160378:	ee010f50 	mcr	15, 0, r0, cr1, cr0, {2}
8016037c:	e12fff1e 	bx	lr

80160380 <__RME_A7A_SCR_Set>:
/* Secure configuration register */
__RME_A7A_SCR_Set:
    CP15_SET            CRN=C1 OP1=0 CRM=C1 OP2=0
80160380:	ee010f11 	mcr	15, 0, r0, cr1, cr1, {0}
80160384:	e12fff1e 	bx	lr

80160388 <__RME_A7A_SDER_Set>:
/* Secure debug enable register */
__RME_A7A_SDER_Set:
    CP15_SET            CRN=C1 OP1=0 CRM=C1 OP2=1
80160388:	ee010f31 	mcr	15, 0, r0, cr1, cr1, {1}
8016038c:	e12fff1e 	bx	lr

80160390 <__RME_A7A_NSACR_Set>:
/* Non-secure access control register */
__RME_A7A_NSACR_Set:
    CP15_SET            CRN=C1 OP1=0 CRM=C1 OP2=2
80160390:	ee010f51 	mcr	15, 0, r0, cr1, cr1, {2}
80160394:	e12fff1e 	bx	lr

80160398 <__RME_A7A_HSCTLR_Set>:
/* Hyp system control register */
__RME_A7A_HSCTLR_Set:
    CP15_SET            CRN=C1 OP1=4 CRM=C0 OP2=0
80160398:	ee810f10 	mcr	15, 4, r0, cr1, cr0, {0}
8016039c:	e12fff1e 	bx	lr

801603a0 <__RME_A7A_HACTLR_Set>:
/* Hyp auxiliary control register */
__RME_A7A_HACTLR_Set:
    CP15_SET            CRN=C1 OP1=4 CRM=C0 OP2=1
801603a0:	ee810f30 	mcr	15, 4, r0, cr1, cr0, {1}
801603a4:	e12fff1e 	bx	lr

801603a8 <__RME_A7A_HCR_Set>:
/* Hyp configuration register */
__RME_A7A_HCR_Set:
    CP15_SET            CRN=C1 OP1=4 CRM=C1 OP2=0
801603a8:	ee810f11 	mcr	15, 4, r0, cr1, cr1, {0}
801603ac:	e12fff1e 	bx	lr

801603b0 <__RME_A7A_HDCR_Set>:
/* Hyp debug configuration register */
__RME_A7A_HDCR_Set:
    CP15_SET            CRN=C1 OP1=4 CRM=C1 OP2=1
801603b0:	ee810f31 	mcr	15, 4, r0, cr1, cr1, {1}
801603b4:	e12fff1e 	bx	lr

801603b8 <__RME_A7A_HCPTR_Set>:
/* Hyp coprocessor trap register */
__RME_A7A_HCPTR_Set:
    CP15_SET            CRN=C1 OP1=4 CRM=C1 OP2=2
801603b8:	ee810f51 	mcr	15, 4, r0, cr1, cr1, {2}
801603bc:	e12fff1e 	bx	lr

801603c0 <__RME_A7A_HSTR_Set>:
/* Hyp system trap register */
__RME_A7A_HSTR_Set:
    CP15_SET            CRN=C1 OP1=4 CRM=C1 OP2=3
801603c0:	ee810f71 	mcr	15, 4, r0, cr1, cr1, {3}
801603c4:	e12fff1e 	bx	lr

801603c8 <__RME_A7A_HACR_Set>:
/* Hyp auxiliary configuration register */
__RME_A7A_HACR_Set:
    CP15_SET            CRN=C1 OP1=4 CRM=C1 OP2=7
801603c8:	ee810ff1 	mcr	15, 4, r0, cr1, cr1, {7}
801603cc:	e12fff1e 	bx	lr

801603d0 <__RME_A7A_Pgt_Set>:

/* Translation table base register 0 - 32bit. We do not support PAE of any kind.
 * This operation also sets the page table of this architecture */
__RME_A7A_TTBR0_Set:
__RME_A7A_Pgt_Set:
    CP15_SET            CRN=C2 OP1=0 CRM=C0 OP2=0
801603d0:	ee020f10 	mcr	15, 0, r0, cr2, cr0, {0}
801603d4:	e12fff1e 	bx	lr

801603d8 <__RME_A7A_TTBR1_Set>:
/* Translation table base register 1 - 32bit. We do not support PAE of any kind */
__RME_A7A_TTBR1_Set:
    CP15_SET            CRN=C2 OP1=0 CRM=C0 OP2=1
801603d8:	ee020f30 	mcr	15, 0, r0, cr2, cr0, {1}
801603dc:	e12fff1e 	bx	lr

801603e0 <__RME_A7A_TTBCR_Set>:
/* Translation table base controle register */
__RME_A7A_TTBCR_Set:
    CP15_SET            CRN=C2 OP1=0 CRM=C0 OP2=2
801603e0:	ee020f50 	mcr	15, 0, r0, cr2, cr0, {2}
801603e4:	e12fff1e 	bx	lr

801603e8 <__RME_A7A_HTCR_Set>:
/* Hyp translation control register */
__RME_A7A_HTCR_Set:
    CP15_SET            CRN=C2 OP1=4 CRM=C0 OP2=2
801603e8:	ee820f50 	mcr	15, 4, r0, cr2, cr0, {2}
801603ec:	e12fff1e 	bx	lr

801603f0 <__RME_A7A_VTCR_Set>:
/* Virtualization translation control register */
__RME_A7A_VTCR_Set:
    CP15_SET            CRN=C2 OP1=4 CRM=C1 OP2=2
801603f0:	ee820f51 	mcr	15, 4, r0, cr2, cr1, {2}
801603f4:	e12fff1e 	bx	lr

801603f8 <__RME_A7A_DACR_Set>:
/* Domain access control register */
__RME_A7A_DACR_Set:
    CP15_SET            CRN=C3 OP1=0 CRM=C0 OP2=0
801603f8:	ee030f10 	mcr	15, 0, r0, cr3, cr0, {0}
801603fc:	e12fff1e 	bx	lr

80160400 <__RME_A7A_DFSR_Set>:

/* Data fault status register */
__RME_A7A_DFSR_Set:
    CP15_SET            CRN=C5 OP1=0 CRM=C0 OP2=0
80160400:	ee050f10 	mcr	15, 0, r0, cr5, cr0, {0}
80160404:	e12fff1e 	bx	lr

80160408 <__RME_A7A_IFSR_Set>:
/* Instruction fault status register */
__RME_A7A_IFSR_Set:
    CP15_SET            CRN=C5 OP1=0 CRM=C0 OP2=1
80160408:	ee050f30 	mcr	15, 0, r0, cr5, cr0, {1}
8016040c:	e12fff1e 	bx	lr

80160410 <__RME_A7A_ADFSR_Set>:
/* Auxiliary data fault status register */
__RME_A7A_ADFSR_Set:
    CP15_SET            CRN=C5 OP1=0 CRM=C1 OP2=0
80160410:	ee050f11 	mcr	15, 0, r0, cr5, cr1, {0}
80160414:	e12fff1e 	bx	lr

80160418 <__RME_A7A_AIFSR_Set>:
/* Auxiliary instruction fault status register */
__RME_A7A_AIFSR_Set:
    CP15_SET            CRN=C5 OP1=0 CRM=C1 OP2=1
80160418:	ee050f31 	mcr	15, 0, r0, cr5, cr1, {1}
8016041c:	e12fff1e 	bx	lr

80160420 <__RME_A7A_HADFSR_Set>:
/* Hyp auxiliary data fault status register */
__RME_A7A_HADFSR_Set:
    CP15_SET            CRN=C5 OP1=4 CRM=C1 OP2=0
80160420:	ee850f11 	mcr	15, 4, r0, cr5, cr1, {0}
80160424:	e12fff1e 	bx	lr

80160428 <__RME_A7A_HAIFSR_Set>:
/* Hyp auxiliary instruction fault status register */
__RME_A7A_HAIFSR_Set:
    CP15_SET            CRN=C5 OP1=4 CRM=C1 OP2=1
80160428:	ee850f31 	mcr	15, 4, r0, cr5, cr1, {1}
8016042c:	e12fff1e 	bx	lr

80160430 <__RME_A7A_HSR_Set>:
/* Hyp syndrome register */
__RME_A7A_HSR_Set:
    CP15_SET            CRN=C5 OP1=4 CRM=C2 OP2=0
80160430:	ee850f12 	mcr	15, 4, r0, cr5, cr2, {0}
80160434:	e12fff1e 	bx	lr

80160438 <__RME_A7A_DFAR_Set>:
/* Data fault address register */
__RME_A7A_DFAR_Set:
    CP15_SET            CRN=C6 OP1=0 CRM=C0 OP2=0
80160438:	ee060f10 	mcr	15, 0, r0, cr6, cr0, {0}
8016043c:	e12fff1e 	bx	lr

80160440 <__RME_A7A_IFAR_Set>:
/* Instruction fault address register */
__RME_A7A_IFAR_Set:
    CP15_SET            CRN=C6 OP1=0 CRM=C0 OP2=2
80160440:	ee060f50 	mcr	15, 0, r0, cr6, cr0, {2}
80160444:	e12fff1e 	bx	lr

80160448 <__RME_A7A_HDFAR_Set>:
/* Hyp data fault address register */
__RME_A7A_HDFAR_Set:
    CP15_SET            CRN=C6 OP1=4 CRM=C0 OP2=0
80160448:	ee860f10 	mcr	15, 4, r0, cr6, cr0, {0}
8016044c:	e12fff1e 	bx	lr

80160450 <__RME_A7A_HIFAR_Set>:
/* Hyp instruction fault address register */
__RME_A7A_HIFAR_Set:
    CP15_SET            CRN=C6 OP1=4 CRM=C0 OP2=2
80160450:	ee860f50 	mcr	15, 4, r0, cr6, cr0, {2}
80160454:	e12fff1e 	bx	lr

80160458 <__RME_A7A_HPFAR_Set>:
/* Hyp IPA fault address register */
__RME_A7A_HPFAR_Set:
    CP15_SET            CRN=C6 OP1=4 CRM=C0 OP2=4
80160458:	ee860f90 	mcr	15, 4, r0, cr6, cr0, {4}
8016045c:	e12fff1e 	bx	lr

80160460 <__RME_A7A_ICIALLUIS_Set>:

/* Instruction cache invalidate all to PoU inner shareable */
__RME_A7A_ICIALLUIS_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C1 OP2=0
80160460:	ee070f11 	mcr	15, 0, r0, cr7, cr1, {0}
80160464:	e12fff1e 	bx	lr

80160468 <__RME_A7A_BPIALLIS_Set>:
/* Branch predictor invalidate all inner shareable */
__RME_A7A_BPIALLIS_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C1 OP2=6
80160468:	ee070fd1 	mcr	15, 0, r0, cr7, cr1, {6}
8016046c:	e12fff1e 	bx	lr

80160470 <__RME_A7A_PAR_Set>:
/* Physical address register */
__RME_A7A_PAR_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C4 OP2=6
80160470:	ee070fd4 	mcr	15, 0, r0, cr7, cr4, {6}
80160474:	e12fff1e 	bx	lr

80160478 <__RME_A7A_ICIALLU_Set>:
/* Instruction cache invalidate all to PoU */
__RME_A7A_ICIALLU_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C5 OP2=0
80160478:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
8016047c:	e12fff1e 	bx	lr

80160480 <__RME_A7A_ICIMVAU_Set>:
/* Invalidate instruction cache by MVA to PoU */
__RME_A7A_ICIMVAU_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C5 OP2=1
80160480:	ee070f35 	mcr	15, 0, r0, cr7, cr5, {1}
80160484:	e12fff1e 	bx	lr

80160488 <__RME_A7A_CP15ISB_Set>:
/* ISB register - deprecated */
__RME_A7A_CP15ISB_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C5 OP2=4
80160488:	ee070f95 	mcr	15, 0, r0, cr7, cr5, {4}
8016048c:	e12fff1e 	bx	lr

80160490 <__RME_A7A_BPIALL_Set>:
/* Invalidate entire branch predictor array */
__RME_A7A_BPIALL_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C5 OP2=6
80160490:	ee070fd5 	mcr	15, 0, r0, cr7, cr5, {6}
80160494:	e12fff1e 	bx	lr

80160498 <__RME_A7A_BPIMVA_Set>:
/* Invalidate MVA from branch predictors */
__RME_A7A_BPIMVA_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C5 OP2=7
80160498:	ee070ff5 	mcr	15, 0, r0, cr7, cr5, {7}
8016049c:	e12fff1e 	bx	lr

801604a0 <__RME_A7A_DCIMVAC_Set>:
/* Invalidate data cache by MVA to PoC */
__RME_A7A_DCIMVAC_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C6 OP2=1
801604a0:	ee070f36 	mcr	15, 0, r0, cr7, cr6, {1}
801604a4:	e12fff1e 	bx	lr

801604a8 <__RME_A7A_DCISW_Set>:
/* Invalidate data cache line by set/way */
__RME_A7A_DCISW_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C6 OP2=2
801604a8:	ee070f56 	mcr	15, 0, r0, cr7, cr6, {2}
801604ac:	e12fff1e 	bx	lr

801604b0 <__RME_A7A_ATS1CPR_Set>:
/* Priviledged read VA to PA translation */
__RME_A7A_ATS1CPR_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=0
801604b0:	ee070f18 	mcr	15, 0, r0, cr7, cr8, {0}
801604b4:	e12fff1e 	bx	lr

801604b8 <__RME_A7A_ATS1CPW_Set>:
/* Priviledged write VA to PA translation */
__RME_A7A_ATS1CPW_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=1
801604b8:	ee070f38 	mcr	15, 0, r0, cr7, cr8, {1}
801604bc:	e12fff1e 	bx	lr

801604c0 <__RME_A7A_ATS1CUR_Set>:
/* User read VA to PA translation */
__RME_A7A_ATS1CUR_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=2
801604c0:	ee070f58 	mcr	15, 0, r0, cr7, cr8, {2}
801604c4:	e12fff1e 	bx	lr

801604c8 <__RME_A7A_ATS1CUW_Set>:
/* User write VA to PA translation */
__RME_A7A_ATS1CUW_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=3
801604c8:	ee070f78 	mcr	15, 0, r0, cr7, cr8, {3}
801604cc:	e12fff1e 	bx	lr

801604d0 <__RME_A7A_ATS12NSOPR_Set>:
/* Priviledged read VA to PA translation, other security state */
__RME_A7A_ATS12NSOPR_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=4
801604d0:	ee070f98 	mcr	15, 0, r0, cr7, cr8, {4}
801604d4:	e12fff1e 	bx	lr

801604d8 <__RME_A7A_ATS12NSOPW_Set>:
/* Priviledged write VA to PA translation, other security state */
__RME_A7A_ATS12NSOPW_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=5
801604d8:	ee070fb8 	mcr	15, 0, r0, cr7, cr8, {5}
801604dc:	e12fff1e 	bx	lr

801604e0 <__RME_A7A_ATS12NSOUR_Set>:
/* User read VA to PA translation, other security state */
__RME_A7A_ATS12NSOUR_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=6
801604e0:	ee070fd8 	mcr	15, 0, r0, cr7, cr8, {6}
801604e4:	e12fff1e 	bx	lr

801604e8 <__RME_A7A_ATS12NSOUW_Set>:
/* User write VA to PA translation, other security state */
__RME_A7A_ATS12NSOUW_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=7
801604e8:	ee070ff8 	mcr	15, 0, r0, cr7, cr8, {7}
801604ec:	e12fff1e 	bx	lr

801604f0 <__RME_A7A_DCCMVAC_Set>:
/* Clean data cache line by MVA to PoC */
__RME_A7A_DCCMVAC_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C10 OP2=1
801604f0:	ee070f3a 	mcr	15, 0, r0, cr7, cr10, {1}
801604f4:	e12fff1e 	bx	lr

801604f8 <__RME_A7A_DCCSW_Set>:
/* Clean data cache line by set/way */
__RME_A7A_DCCSW_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C10 OP2=2
801604f8:	ee070f5a 	mcr	15, 0, r0, cr7, cr10, {2}
801604fc:	e12fff1e 	bx	lr

80160500 <__RME_A7A_CP15DSB_Set>:
/* DSB register - deprecated */
__RME_A7A_CP15DSB_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C10 OP2=4
80160500:	ee070f9a 	mcr	15, 0, r0, cr7, cr10, {4}
80160504:	e12fff1e 	bx	lr

80160508 <__RME_A7A_CP15DMB_Set>:
/* DMB register - deprecated */
__RME_A7A_CP15DMB_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C10 OP2=5
80160508:	ee070fba 	mcr	15, 0, r0, cr7, cr10, {5}
8016050c:	e12fff1e 	bx	lr

80160510 <__RME_A7A_DCCMVAU_Set>:
/* Clean data cache line by MVA to PoU */
__RME_A7A_DCCMVAU_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C11 OP2=1
80160510:	ee070f3b 	mcr	15, 0, r0, cr7, cr11, {1}
80160514:	e12fff1e 	bx	lr

80160518 <__RME_A7A_DCCIMVAC_Set>:
/* Clean and invalidate data cache line by MVA to PoC */
__RME_A7A_DCCIMVAC_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C14 OP2=1
80160518:	ee070f3e 	mcr	15, 0, r0, cr7, cr14, {1}
8016051c:	e12fff1e 	bx	lr

80160520 <__RME_A7A_DCCISW_Set>:
/* Clean and invalidate data cache line by set/way */
__RME_A7A_DCCISW_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C14 OP2=2
80160520:	ee070f5e 	mcr	15, 0, r0, cr7, cr14, {2}
80160524:	e12fff1e 	bx	lr

80160528 <__RME_A7A_ATS1HR_Set>:
/* Hyp mode read translation */
__RME_A7A_ATS1HR_Set:
    CP15_SET            CRN=C7 OP1=4 CRM=C8 OP2=0
80160528:	ee870f18 	mcr	15, 4, r0, cr7, cr8, {0}
8016052c:	e12fff1e 	bx	lr

80160530 <__RME_A7A_ATS1HW_Set>:
/* Hyp mode write translation */
__RME_A7A_ATS1HW_Set:
    CP15_SET            CRN=C7 OP1=4 CRM=C8 OP2=1
80160530:	ee870f38 	mcr	15, 4, r0, cr7, cr8, {1}
80160534:	e12fff1e 	bx	lr

80160538 <__RME_A7A_TLBIALLIS_Set>:

/* Invalidate entire TLB IS */
__RME_A7A_TLBIALLIS_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C3 OP2=0
80160538:	ee080f13 	mcr	15, 0, r0, cr8, cr3, {0}
8016053c:	e12fff1e 	bx	lr

80160540 <__RME_A7A_TLBIMVAIS_Set>:
/* Invalidate unified TLB entry by MVA and ASID IS */
__RME_A7A_TLBIMVAIS_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C3 OP2=1
80160540:	ee080f33 	mcr	15, 0, r0, cr8, cr3, {1}
80160544:	e12fff1e 	bx	lr

80160548 <__RME_A7A_TLBIASIDIS_Set>:
/* Invalidate unified TLB by ASID match IS */
__RME_A7A_TLBIASIDIS_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C3 OP2=2
80160548:	ee080f53 	mcr	15, 0, r0, cr8, cr3, {2}
8016054c:	e12fff1e 	bx	lr

80160550 <__RME_A7A_TLBIMVAAIS_Set>:
/* Invalidate unified TLB entry by MVA all ASID IS */
__RME_A7A_TLBIMVAAIS_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C3 OP2=3
80160550:	ee080f73 	mcr	15, 0, r0, cr8, cr3, {3}
80160554:	e12fff1e 	bx	lr

80160558 <__RME_A7A_ITLBIALL_Set>:
/* Invalidate instruction TLB */
__RME_A7A_ITLBIALL_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C5 OP2=0
80160558:	ee080f15 	mcr	15, 0, r0, cr8, cr5, {0}
8016055c:	e12fff1e 	bx	lr

80160560 <__RME_A7A_ITLBIMVA_Set>:
/* Invalidate instruction TLB entry by MVA and ASID */
__RME_A7A_ITLBIMVA_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C5 OP2=1
80160560:	ee080f35 	mcr	15, 0, r0, cr8, cr5, {1}
80160564:	e12fff1e 	bx	lr

80160568 <__RME_A7A_ITLBIASID_Set>:
/* Invalidate instruction TLB by ASID match */
__RME_A7A_ITLBIASID_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C5 OP2=2
80160568:	ee080f55 	mcr	15, 0, r0, cr8, cr5, {2}
8016056c:	e12fff1e 	bx	lr

80160570 <__RME_A7A_DTLBIALL_Set>:
/* Invalidate data TLB */
__RME_A7A_DTLBIALL_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C6 OP2=0
80160570:	ee080f16 	mcr	15, 0, r0, cr8, cr6, {0}
80160574:	e12fff1e 	bx	lr

80160578 <__RME_A7A_DTLBIMVA_Set>:
/* Invalidate data TLB entry by MVA and ASID */
__RME_A7A_DTLBIMVA_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C6 OP2=1
80160578:	ee080f36 	mcr	15, 0, r0, cr8, cr6, {1}
8016057c:	e12fff1e 	bx	lr

80160580 <__RME_A7A_DTLBIASID_Set>:
/* Invalidate data TLB by ASID match */
__RME_A7A_DTLBIASID_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C6 OP2=2
80160580:	ee080f56 	mcr	15, 0, r0, cr8, cr6, {2}
80160584:	e12fff1e 	bx	lr

80160588 <__RME_A7A_TLBIALL_Set>:
/* Invalidate unified TLB */
__RME_A7A_TLBIALL_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C7 OP2=0
80160588:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
8016058c:	e12fff1e 	bx	lr

80160590 <__RME_A7A_TLBIMVA_Set>:
/* Invalidate unified TLB entry by MVA and ASID */
__RME_A7A_TLBIMVA_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C7 OP2=1
80160590:	ee080f37 	mcr	15, 0, r0, cr8, cr7, {1}
80160594:	e12fff1e 	bx	lr

80160598 <__RME_A7A_TLBIASID_Set>:
/* Invalidate unified TLB by ASID match */
__RME_A7A_TLBIASID_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C7 OP2=2
80160598:	ee080f57 	mcr	15, 0, r0, cr8, cr7, {2}
8016059c:	e12fff1e 	bx	lr

801605a0 <__RME_A7A_TLBIMVAA_Set>:
/* Invalidate unified TLB entries by MVA all ASID */
__RME_A7A_TLBIMVAA_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C7 OP2=3
801605a0:	ee080f77 	mcr	15, 0, r0, cr8, cr7, {3}
801605a4:	e12fff1e 	bx	lr

801605a8 <__RME_A7A_TLBIALLHIS_Set>:
/* Invalidate entire Hyp unified TLB IS */
__RME_A7A_TLBIALLHIS_Set:
    CP15_SET            CRN=C8 OP1=4 CRM=C3 OP2=0
801605a8:	ee880f13 	mcr	15, 4, r0, cr8, cr3, {0}
801605ac:	e12fff1e 	bx	lr

801605b0 <__RME_A7A_TLBIMVAHIS_Set>:
/* Invalidate Hyp unified TLB entry by MVA IS */
__RME_A7A_TLBIMVAHIS_Set:
    CP15_SET            CRN=C8 OP1=4 CRM=C3 OP2=1
801605b0:	ee880f33 	mcr	15, 4, r0, cr8, cr3, {1}
801605b4:	e12fff1e 	bx	lr

801605b8 <__RME_A7A_TLBIALLNSNHIS_Set>:
/* Invalidate entire Non-secure non-Hyp unified TLB IS */
__RME_A7A_TLBIALLNSNHIS_Set:
    CP15_SET            CRN=C8 OP1=4 CRM=C3 OP2=4
801605b8:	ee880f93 	mcr	15, 4, r0, cr8, cr3, {4}
801605bc:	e12fff1e 	bx	lr

801605c0 <__RME_A7A_TLBIALLH_Set>:
/* Invalidate entire Hyp unified TLB */
__RME_A7A_TLBIALLH_Set:
    CP15_SET            CRN=C8 OP1=4 CRM=C7 OP2=0
801605c0:	ee880f17 	mcr	15, 4, r0, cr8, cr7, {0}
801605c4:	e12fff1e 	bx	lr

801605c8 <__RME_A7A_TLBIMVAH_Set>:
/* Invalidate Hyp unified TLB entry by MVA */
__RME_A7A_TLBIMVAH_Set:
    CP15_SET            CRN=C8 OP1=4 CRM=C7 OP2=1
801605c8:	ee880f37 	mcr	15, 4, r0, cr8, cr7, {1}
801605cc:	e12fff1e 	bx	lr

801605d0 <__RME_A7A_TLBIALLNSNH_Set>:
/* Invalidate entire Non-secure non-Hyp unified TLB */
__RME_A7A_TLBIALLNSNH_Set:
    CP15_SET            CRN=C8 OP1=4 CRM=C7 OP2=4
801605d0:	ee880f97 	mcr	15, 4, r0, cr8, cr7, {4}
801605d4:	e12fff1e 	bx	lr

801605d8 <__RME_A7A_TLBLR_Set>:

/* C9 registers currently unsupported */

/* TLB lockdown register - Cortex-A9 */
__RME_A7A_TLBLR_Set:
    CP15_SET            CRN=C10 OP1=0 CRM=C0 OP2=0
801605d8:	ee0a0f10 	mcr	15, 0, r0, cr10, cr0, {0}
801605dc:	e12fff1e 	bx	lr

801605e0 <__RME_A7A_PRRR_Set>:
/* Primary region remap register */
__RME_A7A_PRRR_Set:
    CP15_SET            CRN=C10 OP1=0 CRM=C2 OP2=0
801605e0:	ee0a0f12 	mcr	15, 0, r0, cr10, cr2, {0}
801605e4:	e12fff1e 	bx	lr

801605e8 <__RME_A7A_NMRR_Set>:
/* Normal memory remap register */
__RME_A7A_NMRR_Set:
    CP15_SET            CRN=C10 OP1=0 CRM=C2 OP2=1
801605e8:	ee0a0f32 	mcr	15, 0, r0, cr10, cr2, {1}
801605ec:	e12fff1e 	bx	lr

801605f0 <__RME_A7A_AMAIR0_Set>:
/* Auxiliary memory attribute indirection register 0 */
__RME_A7A_AMAIR0_Set:
    CP15_SET            CRN=C10 OP1=0 CRM=C3 OP2=0
801605f0:	ee0a0f13 	mcr	15, 0, r0, cr10, cr3, {0}
801605f4:	e12fff1e 	bx	lr

801605f8 <__RME_A7A_AMAIR1_Set>:
/* Auxiliary memory attribute indirection register 1 */
__RME_A7A_AMAIR1_Set:
    CP15_SET            CRN=C10 OP1=0 CRM=C3 OP2=1
801605f8:	ee0a0f33 	mcr	15, 0, r0, cr10, cr3, {1}
801605fc:	e12fff1e 	bx	lr

80160600 <__RME_A7A_HMAIR0_Set>:
/* Hyp memory attribute indirection register 0 */
__RME_A7A_HMAIR0_Set:
    CP15_SET            CRN=C10 OP1=4 CRM=C2 OP2=0
80160600:	ee8a0f12 	mcr	15, 4, r0, cr10, cr2, {0}
80160604:	e12fff1e 	bx	lr

80160608 <__RME_A7A_HMAIR1_Set>:
/* Hyp memory attribute indirection register 1 */
__RME_A7A_HMAIR1_Set:
    CP15_SET            CRN=C10 OP1=4 CRM=C2 OP2=1
80160608:	ee8a0f32 	mcr	15, 4, r0, cr10, cr2, {1}
8016060c:	e12fff1e 	bx	lr

80160610 <__RME_A7A_HAMAIR0_Set>:
/* Hyp auxiliary memory attribute indirection register 0 */
__RME_A7A_HAMAIR0_Set:
    CP15_SET            CRN=C10 OP1=4 CRM=C3 OP2=0
80160610:	ee8a0f13 	mcr	15, 4, r0, cr10, cr3, {0}
80160614:	e12fff1e 	bx	lr

80160618 <__RME_A7A_HAMAIR1_Set>:
/* Hyp auxiliary memory attribute indirection register 1 */
__RME_A7A_HAMAIR1_Set:
    CP15_SET            CRN=C10 OP1=4 CRM=C3 OP2=1
80160618:	ee8a0f33 	mcr	15, 4, r0, cr10, cr3, {1}
8016061c:	e12fff1e 	bx	lr

80160620 <__RME_A7A_VBAR_Set>:

/* Vector base address register */
__RME_A7A_VBAR_Set:
    CP15_SET            CRN=C12 OP1=0 CRM=C0 OP2=0
80160620:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
80160624:	e12fff1e 	bx	lr

80160628 <__RME_A7A_MVBAR_Set>:
/* Vector base address register */
__RME_A7A_MVBAR_Set:
    CP15_SET            CRN=C12 OP1=0 CRM=C0 OP2=1
80160628:	ee0c0f30 	mcr	15, 0, r0, cr12, cr0, {1}
8016062c:	e12fff1e 	bx	lr

80160630 <__RME_A7A_HVBAR_Set>:
/* Hyp vector base address register */
__RME_A7A_HVBAR_Set:
    CP15_SET            CRN=C12 OP1=4 CRM=C0 OP2=0
80160630:	ee8c0f10 	mcr	15, 4, r0, cr12, cr0, {0}
80160634:	e12fff1e 	bx	lr

80160638 <__RME_A7A_CONTEXTIDR_Set>:

/* Context ID register */
__RME_A7A_CONTEXTIDR_Set:
    CP15_SET            CRN=C13 OP1=0 CRM=C0 OP2=1
80160638:	ee0d0f30 	mcr	15, 0, r0, cr13, cr0, {1}
8016063c:	e12fff1e 	bx	lr

80160640 <__RME_A7A_TPIDRURW_Set>:
/* User read/write software thread register */
__RME_A7A_TPIDRURW_Set:
    CP15_SET            CRN=C13 OP1=0 CRM=C0 OP2=2
80160640:	ee0d0f50 	mcr	15, 0, r0, cr13, cr0, {2}
80160644:	e12fff1e 	bx	lr

80160648 <__RME_A7A_TPIDRURO_Set>:
/* User read-only software thread register */
__RME_A7A_TPIDRURO_Set:
    CP15_SET            CRN=C13 OP1=0 CRM=C0 OP2=3
80160648:	ee0d0f70 	mcr	15, 0, r0, cr13, cr0, {3}
8016064c:	e12fff1e 	bx	lr

80160650 <__RME_A7A_TPIDRPRW_Set>:
/* PL1-only software thread register */
__RME_A7A_TPIDRPRW_Set:
    CP15_SET            CRN=C13 OP1=0 CRM=C0 OP2=4
80160650:	ee0d0f90 	mcr	15, 0, r0, cr13, cr0, {4}
80160654:	e12fff1e 	bx	lr

80160658 <__RME_A7A_HTPIDR_Set>:
/* Hyp read/write software thread register */
__RME_A7A_HTPIDR_Set:
    CP15_SET            CRN=C13 OP1=4 CRM=C0 OP2=2
80160658:	ee8d0f50 	mcr	15, 4, r0, cr13, cr0, {2}
8016065c:	e12fff1e 	bx	lr

80160660 <__RME_A7A_CNTFRQ_Set>:

/* Counter frequency register */
__RME_A7A_CNTFRQ_Set:
    CP15_SET            CRN=C14 OP1=0 CRM=C0 OP2=0
80160660:	ee0e0f10 	mcr	15, 0, r0, cr14, cr0, {0}
80160664:	e12fff1e 	bx	lr

80160668 <__RME_A7A_CNTKCTL_Set>:
/* Timer PL1 control register */
__RME_A7A_CNTKCTL_Set:
    CP15_SET            CRN=C14 OP1=0 CRM=C1 OP2=0
80160668:	ee0e0f11 	mcr	15, 0, r0, cr14, cr1, {0}
8016066c:	e12fff1e 	bx	lr

80160670 <__RME_A7A_CNTP_TVAL_Set>:
/* PL1 physical timer value register */
__RME_A7A_CNTP_TVAL_Set:
    CP15_SET            CRN=C14 OP1=0 CRM=C2 OP2=0
80160670:	ee0e0f12 	mcr	15, 0, r0, cr14, cr2, {0}
80160674:	e12fff1e 	bx	lr

80160678 <__RME_A7A_CNTP_CTL_Set>:
/* PL1 physical timer control register */
__RME_A7A_CNTP_CTL_Set:
    CP15_SET            CRN=C14 OP1=0 CRM=C2 OP2=1
80160678:	ee0e0f32 	mcr	15, 0, r0, cr14, cr2, {1}
8016067c:	e12fff1e 	bx	lr

80160680 <__RME_A7A_CNTV_TVAL_Set>:
/* Virtual timer value register */
__RME_A7A_CNTV_TVAL_Set:
    CP15_SET            CRN=C14 OP1=0 CRM=C3 OP2=0
80160680:	ee0e0f13 	mcr	15, 0, r0, cr14, cr3, {0}
80160684:	e12fff1e 	bx	lr

80160688 <__RME_A7A_CNTV_CTL_Set>:
/* Virtual timer control register */
__RME_A7A_CNTV_CTL_Set:
    CP15_SET            CRN=C14 OP1=0 CRM=C3 OP2=1
80160688:	ee0e0f33 	mcr	15, 0, r0, cr14, cr3, {1}
8016068c:	e12fff1e 	bx	lr

80160690 <__RME_A7A_CNTHCTL_Set>:
/* Timer PL2 control register */
__RME_A7A_CNTHCTL_Set:
    CP15_SET            CRN=C14 OP1=4 CRM=C1 OP2=0
80160690:	ee8e0f11 	mcr	15, 4, r0, cr14, cr1, {0}
80160694:	e12fff1e 	bx	lr

80160698 <__RME_A7A_CNTHP_TVAL_Set>:
/* PL2 physical timer value register */
__RME_A7A_CNTHP_TVAL_Set:
    CP15_SET            CRN=C14 OP1=4 CRM=C2 OP2=0
80160698:	ee8e0f12 	mcr	15, 4, r0, cr14, cr2, {0}
8016069c:	e12fff1e 	bx	lr

801606a0 <__RME_A7A_CNTHP_CTL_Set>:
/* PL2 physical timer control register */
__RME_A7A_CNTHP_CTL_Set:
    CP15_SET            CRN=C14 OP1=4 CRM=C2 OP2=1
801606a0:	ee8e0f32 	mcr	15, 4, r0, cr14, cr2, {1}
801606a4:	e12fff1e 	bx	lr

801606a8 <__RME_A7A_CNTP_CVAL_DW_Set>:
Output      : None.
Return      : None.
******************************************************************************/
/* PL1 physical timer compare value register */
__RME_A7A_CNTP_CVAL_DW_Set:
    CP15_SET_DOUBLE     CRM=C14 OP=2
801606a8:	ec400f2e 	mcrr	15, 2, r0, r0, cr14
801606ac:	e12fff1e 	bx	lr

801606b0 <__RME_A7A_CNTV_CVAL_DW_Set>:
/* Virtual timer compare value register */
__RME_A7A_CNTV_CVAL_DW_Set:
    CP15_SET_DOUBLE     CRM=C14 OP=3
801606b0:	ec400f3e 	mcrr	15, 3, r0, r0, cr14
801606b4:	e12fff1e 	bx	lr

801606b8 <__RME_A7A_CNTVOFF_DW_Set>:
/* Virtual offset register */
__RME_A7A_CNTVOFF_DW_Set:
    CP15_SET_DOUBLE     CRM=C14 OP=4
801606b8:	ec400f4e 	mcrr	15, 4, r0, r0, cr14
801606bc:	e12fff1e 	bx	lr

801606c0 <__RME_A7A_CNTHP_CVAL_DW_Set>:
/* L2 physical timer compare value register */
__RME_A7A_CNTHP_CVAL_DW_Set:
    CP15_SET_DOUBLE     CRM=C14 OP=6
801606c0:	ec400f6e 	mcrr	15, 6, r0, r0, cr14
801606c4:	e12fff1e 	bx	lr

801606c8 <__RME_A7A_Fetch_Add>:
              cnt_t Addend - The number to add.
Output      : ptr_t* Ptr - The pointer to the data.
Return      : ptr_t - The value before the addition.
******************************************************************************/
__RME_A7A_Fetch_Add:
    LDREX               R2,[R0]
801606c8:	e1902f9f 	ldrex	r2, [r0]
    ADD                 R3,R2,R1
801606cc:	e0823001 	add	r3, r2, r1
    STREX               R12,R3,[R0]
801606d0:	e180cf93 	strex	ip, r3, [r0]
    CMP                 R12,#0x00
801606d4:	e35c0000 	cmp	ip, #0
    BNE                 __RME_A7A_Fetch_Add
801606d8:	1afffffa 	bne	801606c8 <__RME_A7A_Fetch_Add>
    MOV                 R0,R2
801606dc:	e1a00002 	mov	r0, r2
    BX                  LR
801606e0:	e12fff1e 	bx	lr

801606e4 <__RME_A7A_Fetch_And>:
              cnt_t Operand - The number to logic AND with the destination.
Output      : ptr_t* Ptr - The pointer to the data.
Return      : ptr_t - The value before the AND operation.
******************************************************************************/
__RME_A7A_Fetch_And:
    LDREX               R2,[R0]
801606e4:	e1902f9f 	ldrex	r2, [r0]
    AND                 R3,R2,R1
801606e8:	e0023001 	and	r3, r2, r1
    STREX               R12,R3,[R0]
801606ec:	e180cf93 	strex	ip, r3, [r0]
    CMP                 R12,#0x00
801606f0:	e35c0000 	cmp	ip, #0
    BNE                 __RME_A7A_Fetch_Add
801606f4:	1afffff3 	bne	801606c8 <__RME_A7A_Fetch_Add>
    MOV                 R0,R2
801606f8:	e1a00002 	mov	r0, r2
    BX                  LR
801606fc:	e12fff1e 	bx	lr

80160700 <__RME_A7A_Read_Acquire>:
Input       : rme_ptr_t* R0 - Address to read from.
Output      : None.
Return      : None.
******************************************************************************/
__RME_A7A_Read_Acquire:
    LDR                 R0,[R0]
80160700:	e5900000 	ldr	r0, [r0]
    DMB
80160704:	f57ff05f 	dmb	sy
    BX                  LR
80160708:	e12fff1e 	bx	lr

8016070c <__RME_A7A_Write_Release>:
              rme_ptr_t R1 - Content to write to the address.
Output      : None.
Return      : None.
******************************************************************************/
__RME_A7A_Write_Release:
    DMB
8016070c:	f57ff05f 	dmb	sy
    STR                 R1,[R0]
80160710:	e5801000 	str	r1, [r0]
    BX                  LR
80160714:	e12fff1e 	bx	lr

80160718 <__RME_Int_Disable>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
__RME_Int_Disable:
    CPSID               I
80160718:	f10c0080 	cpsid	i
    BX                  LR
8016071c:	e12fff1e 	bx	lr

80160720 <__RME_Int_Enable>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
__RME_Int_Enable:
    CPSIE               I
80160720:	f1080080 	cpsie	i
    BX                  LR
80160724:	e12fff1e 	bx	lr

80160728 <__RME_A7A_Halt>:
Output      : None.
Return      : None.
******************************************************************************/
__RME_A7A_Halt:
    /* Wait for interrupt */
    WFI
80160728:	e320f003 	wfi
    BX                  LR
8016072c:	e12fff1e 	bx	lr

80160730 <_RME_Kmain>:
Input       : ptr_t Stack - The stack address to set SP to.
Output      : None.
Return      : None.
******************************************************************************/
_RME_Kmain:
    MOV                 R0,SP
80160730:	e1a0000d 	mov	r0, sp
    BL                  RME_Kmain
80160734:	eb0001a0 	bl	80160dbc <RME_Kmain>

80160738 <__RME_A7A_MSB_Get>:
Input       : ptr_t Val - The value.
Output      : None.
Return      : ptr_t - The MSB position.
******************************************************************************/
__RME_A7A_MSB_Get:
    CLZ                 R1,R0
80160738:	e16f1f10 	clz	r1, r0
    MOV                 R0,#31
8016073c:	e3a0001f 	mov	r0, #31
    SUB                 R0,R1
80160740:	e0400001 	sub	r0, r0, r1
    BX                  LR
80160744:	e12fff1e 	bx	lr

80160748 <__RME_User_Enter>:
              ptr_t CPUID - The CPUID.
Output      : None.
Return      : None.
******************************************************************************/
__RME_User_Enter:
    PUSH                {R0,R1}
80160748:	e92d0003 	push	{r0, r1}
    MOV                 R0,R2
8016074c:	e1a00002 	mov	r0, r2
    /* Prepare the SPSR for user-level */
    LDR                 R2,=0x600F0010
80160750:	e59f2130 	ldr	r2, [pc, #304]	@ 80160888 <FIQ_Handler+0x4>
    MSR                 SPSR_cxsf,R2
80160754:	e16ff002 	msr	SPSR_fsxc, r2
    /* Exception return as well as restoring user-level SP and PC */
    MOV					R2,SP
80160758:	e1a0200d 	mov	r2, sp
    LDMIA               R2,{SP}^
8016075c:	e8d22000 	ldm	r2, {sp}^
    ADD					SP,R2,#0x04
80160760:	e282d004 	add	sp, r2, #4
    LDMIA               SP!,{PC}^
80160764:	e8fd8000 	ldm	sp!, {pc}^

80160768 <Reset_Handler>:
Output      : None.
Return      : None.
******************************************************************************/
Reset_Handler:
Unused_Handler:
    B                   .
80160768:	eafffffe 	b	80160768 <Reset_Handler>

8016076c <Undefined_Handler>:
    /* Restore user-mode PC */
    LDMIA               SP!,{PC}^
.endm

Undefined_Handler:
    SAVE_GP_REGS
8016076c:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
80160770:	e94d6000 	stmdb	sp, {sp, lr}^
80160774:	e24dd008 	sub	sp, sp, #8
80160778:	e92d1fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
8016077c:	e14f0000 	mrs	r0, SPSR
80160780:	e52d0004 	push	{r0}		@ (str r0, [sp, #-4]!)
80160784:	e1a0000d 	mov	r0, sp
    BL                  __RME_A7A_Undefined_Handler
80160788:	eb002d24 	bl	8016bc20 <__RME_A7A_Undefined_Handler>
    RESTORE_GP_REGS
8016078c:	e49d0004 	pop	{r0}		@ (ldr r0, [sp], #4)
80160790:	e16ff000 	msr	SPSR_fsxc, r0
80160794:	e8bd1fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
80160798:	e8dd6000 	ldm	sp, {sp, lr}^
8016079c:	e28dd008 	add	sp, sp, #8
801607a0:	e8fd8000 	ldm	sp!, {pc}^

801607a4 <Prefetch_Abort_Handler>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
Prefetch_Abort_Handler:
    SAVE_GP_REGS
801607a4:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
801607a8:	e94d6000 	stmdb	sp, {sp, lr}^
801607ac:	e24dd008 	sub	sp, sp, #8
801607b0:	e92d1fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
801607b4:	e14f0000 	mrs	r0, SPSR
801607b8:	e52d0004 	push	{r0}		@ (str r0, [sp, #-4]!)
801607bc:	e1a0000d 	mov	r0, sp
    BL                  __RME_A7A_Prefetch_Abort_Handler
801607c0:	eb002d1b 	bl	8016bc34 <__RME_A7A_Prefetch_Abort_Handler>
    RESTORE_GP_REGS
801607c4:	e49d0004 	pop	{r0}		@ (ldr r0, [sp], #4)
801607c8:	e16ff000 	msr	SPSR_fsxc, r0
801607cc:	e8bd1fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
801607d0:	e8dd6000 	ldm	sp, {sp, lr}^
801607d4:	e28dd008 	add	sp, sp, #8
801607d8:	e8fd8000 	ldm	sp!, {pc}^

801607dc <Data_Abort_Handler>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
Data_Abort_Handler:
    SAVE_GP_REGS
801607dc:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
801607e0:	e94d6000 	stmdb	sp, {sp, lr}^
801607e4:	e24dd008 	sub	sp, sp, #8
801607e8:	e92d1fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
801607ec:	e14f0000 	mrs	r0, SPSR
801607f0:	e52d0004 	push	{r0}		@ (str r0, [sp, #-4]!)
801607f4:	e1a0000d 	mov	r0, sp
    BL                  __RME_A7A_Data_Abort_Handler
801607f8:	eb002d12 	bl	8016bc48 <__RME_A7A_Data_Abort_Handler>
    RESTORE_GP_REGS
801607fc:	e49d0004 	pop	{r0}		@ (ldr r0, [sp], #4)
80160800:	e16ff000 	msr	SPSR_fsxc, r0
80160804:	e8bd1fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
80160808:	e8dd6000 	ldm	sp, {sp, lr}^
8016080c:	e28dd008 	add	sp, sp, #8
80160810:	e8fd8000 	ldm	sp!, {pc}^

80160814 <SVC_Handler>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
SVC_Handler:
    SAVE_GP_REGS
80160814:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
80160818:	e94d6000 	stmdb	sp, {sp, lr}^
8016081c:	e24dd008 	sub	sp, sp, #8
80160820:	e92d1fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
80160824:	e14f0000 	mrs	r0, SPSR
80160828:	e52d0004 	push	{r0}		@ (str r0, [sp, #-4]!)
8016082c:	e1a0000d 	mov	r0, sp
    BL                  _RME_Svc_Handler
80160830:	eb000174 	bl	80160e08 <_RME_Svc_Handler>
    RESTORE_GP_REGS
80160834:	e49d0004 	pop	{r0}		@ (ldr r0, [sp], #4)
80160838:	e16ff000 	msr	SPSR_fsxc, r0
8016083c:	e8bd1fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
80160840:	e8dd6000 	ldm	sp, {sp, lr}^
80160844:	e28dd008 	add	sp, sp, #8
80160848:	e8fd8000 	ldm	sp!, {pc}^

8016084c <IRQ_Handler>:
IRQ_Handler:
    //LDR                 R0,=0x41210000
    //LDR                 R1,=0x55555555
   // STR                 R1,[R0]
   // B .
    SAVE_GP_REGS
8016084c:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
80160850:	e94d6000 	stmdb	sp, {sp, lr}^
80160854:	e24dd008 	sub	sp, sp, #8
80160858:	e92d1fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
8016085c:	e14f0000 	mrs	r0, SPSR
80160860:	e52d0004 	push	{r0}		@ (str r0, [sp, #-4]!)
80160864:	e1a0000d 	mov	r0, sp
    BL                  __RME_A7A_IRQ_Handler
80160868:	eb002cfb 	bl	8016bc5c <__RME_A7A_IRQ_Handler>
    RESTORE_GP_REGS
8016086c:	e49d0004 	pop	{r0}		@ (ldr r0, [sp], #4)
80160870:	e16ff000 	msr	SPSR_fsxc, r0
80160874:	e8bd1fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
80160878:	e8dd6000 	ldm	sp, {sp, lr}^
8016087c:	e28dd008 	add	sp, sp, #8
80160880:	e8fd8000 	ldm	sp!, {pc}^

80160884 <FIQ_Handler>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
FIQ_Handler:
    B                   .
80160884:	eafffffe 	b	80160884 <FIQ_Handler>
    LDR                 R2,=0x600F0010
80160888:	600f0010 	.word	0x600f0010

8016088c <RME_Int_Print>:
Output      : None.
Return      : rme_cnt_t - The length of the string printed.
******************************************************************************/
#if(RME_DBGLOG_ENABLE!=0U)
rme_cnt_t RME_Int_Print(rme_cnt_t Int)
{
8016088c:	e92d4800 	push	{fp, lr}
80160890:	e28db004 	add	fp, sp, #4
80160894:	e24dd020 	sub	sp, sp, #32
80160898:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
    rme_cnt_t Iter;
    rme_cnt_t Count;
    rme_cnt_t Div;
    
    /* Exit on zero */
    if(Int==0)
8016089c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801608a0:	e3530000 	cmp	r3, #0
801608a4:	1a000001 	bne	801608b0 <RME_Int_Print+0x24>
    {
        RME_COV_MARKER();

        return 1;
801608a8:	e3a03001 	mov	r3, #1
801608ac:	ea000050 	b	801609f4 <RME_Int_Print+0x168>
        /* No action required */
    }


    /* Correct all negatives into positives */
    if(Int<0)
801608b0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801608b4:	e3530000 	cmp	r3, #0
801608b8:	aa000007 	bge	801608dc <RME_Int_Print+0x50>
    {
        RME_COV_MARKER();

        __RME_Putchar('-');
801608bc:	e3a0002d 	mov	r0, #45	@ 0x2d
801608c0:	eb002af6 	bl	8016b4a0 <__RME_Putchar>
        Abs=-Int;
801608c4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801608c8:	e2633000 	rsb	r3, r3, #0
801608cc:	e50b300c 	str	r3, [fp, #-12]
        Num=1;
801608d0:	e3a03001 	mov	r3, #1
801608d4:	e50b3008 	str	r3, [fp, #-8]
801608d8:	ea000003 	b	801608ec <RME_Int_Print+0x60>
    }
    else
    {
        RME_COV_MARKER();

        Abs=Int;
801608dc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801608e0:	e50b300c 	str	r3, [fp, #-12]
        Num=0;
801608e4:	e3a03000 	mov	r3, #0
801608e8:	e50b3008 	str	r3, [fp, #-8]
    }

    /* How many digits are there? */
    Count=0;
801608ec:	e3a03000 	mov	r3, #0
801608f0:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Div=1;
801608f4:	e3a03001 	mov	r3, #1
801608f8:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Iter=Abs;
801608fc:	e51b300c 	ldr	r3, [fp, #-12]
80160900:	e50b3010 	str	r3, [fp, #-16]
    while(1U)
    {
        Iter/=10;
80160904:	e51b2010 	ldr	r2, [fp, #-16]
80160908:	e3063667 	movw	r3, #26215	@ 0x6667
8016090c:	e3463666 	movt	r3, #26214	@ 0x6666
80160910:	e0c31293 	smull	r1, r3, r3, r2
80160914:	e1a01143 	asr	r1, r3, #2
80160918:	e1a03fc2 	asr	r3, r2, #31
8016091c:	e0413003 	sub	r3, r1, r3
80160920:	e50b3010 	str	r3, [fp, #-16]
        Count++;
80160924:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80160928:	e2833001 	add	r3, r3, #1
8016092c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
        if(Iter!=0)
80160930:	e51b3010 	ldr	r3, [fp, #-16]
80160934:	e3530000 	cmp	r3, #0
80160938:	0a000006 	beq	80160958 <RME_Int_Print+0xcc>
        {
            RME_COV_MARKER();

            Div*=10;
8016093c:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80160940:	e1a03002 	mov	r3, r2
80160944:	e1a03103 	lsl	r3, r3, #2
80160948:	e0833002 	add	r3, r3, r2
8016094c:	e1a03083 	lsl	r3, r3, #1
80160950:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
        Iter/=10;
80160954:	eaffffea 	b	80160904 <RME_Int_Print+0x78>
        }
        else
        {
            RME_COV_MARKER();

            break;
80160958:	e320f000 	nop	{0}
        }
    }
    Num+=Count;
8016095c:	e51b2008 	ldr	r2, [fp, #-8]
80160960:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80160964:	e0823003 	add	r3, r2, r3
80160968:	e50b3008 	str	r3, [fp, #-8]

    /* Print the integer */
    Iter=Abs;
8016096c:	e51b300c 	ldr	r3, [fp, #-12]
80160970:	e50b3010 	str	r3, [fp, #-16]

    while(Count>0)
80160974:	ea00001a 	b	801609e4 <RME_Int_Print+0x158>
    {
        Count--;
80160978:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016097c:	e2433001 	sub	r3, r3, #1
80160980:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
        __RME_Putchar((rme_s8_t)(Iter/Div)+'0');
80160984:	e51b1018 	ldr	r1, [fp, #-24]	@ 0xffffffe8
80160988:	e51b0010 	ldr	r0, [fp, #-16]
8016098c:	fa002da5 	blx	8016c028 <__divsi3>
80160990:	e1a03000 	mov	r3, r0
80160994:	e6ef3073 	uxtb	r3, r3
80160998:	e2833030 	add	r3, r3, #48	@ 0x30
8016099c:	e6ef3073 	uxtb	r3, r3
801609a0:	e6af3073 	sxtb	r3, r3
801609a4:	e1a00003 	mov	r0, r3
801609a8:	eb002abc 	bl	8016b4a0 <__RME_Putchar>
        Iter=Iter%Div;
801609ac:	e51b3010 	ldr	r3, [fp, #-16]
801609b0:	e51b1018 	ldr	r1, [fp, #-24]	@ 0xffffffe8
801609b4:	e1a00003 	mov	r0, r3
801609b8:	fa002e3f 	blx	8016c2bc <__aeabi_idivmod>
801609bc:	e1a03001 	mov	r3, r1
801609c0:	e50b3010 	str	r3, [fp, #-16]
        Div/=10;
801609c4:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
801609c8:	e3063667 	movw	r3, #26215	@ 0x6667
801609cc:	e3463666 	movt	r3, #26214	@ 0x6666
801609d0:	e0c31293 	smull	r1, r3, r3, r2
801609d4:	e1a01143 	asr	r1, r3, #2
801609d8:	e1a03fc2 	asr	r3, r2, #31
801609dc:	e0413003 	sub	r3, r1, r3
801609e0:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    while(Count>0)
801609e4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801609e8:	e3530000 	cmp	r3, #0
801609ec:	caffffe1 	bgt	80160978 <RME_Int_Print+0xec>
    }
    
    return Num;
801609f0:	e51b3008 	ldr	r3, [fp, #-8]
}
801609f4:	e1a00003 	mov	r0, r3
801609f8:	e24bd004 	sub	sp, fp, #4
801609fc:	e8bd8800 	pop	{fp, pc}

80160a00 <RME_Hex_Print>:
Output      : None.
Return      : rme_cnt_t - The length of the string printed.
******************************************************************************/
#if(RME_DBGLOG_ENABLE!=0U)
rme_cnt_t RME_Hex_Print(rme_ptr_t Uint)
{
80160a00:	e92d4800 	push	{fp, lr}
80160a04:	e28db004 	add	fp, sp, #4
80160a08:	e24dd018 	sub	sp, sp, #24
80160a0c:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
    rme_ptr_t Iter;
    rme_ptr_t Count;
    rme_ptr_t Num;
    
    /* Exit on zero */
    if(Uint==0U)
80160a10:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80160a14:	e3530000 	cmp	r3, #0
80160a18:	1a000003 	bne	80160a2c <RME_Hex_Print+0x2c>
    {
        RME_COV_MARKER();
        
        __RME_Putchar('0');
80160a1c:	e3a00030 	mov	r0, #48	@ 0x30
80160a20:	eb002a9e 	bl	8016b4a0 <__RME_Putchar>
        return 1;
80160a24:	e3a03001 	mov	r3, #1
80160a28:	ea000033 	b	80160afc <RME_Hex_Print+0xfc>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Filter out all the zeroes */
    Count=0U;
80160a2c:	e3a03000 	mov	r3, #0
80160a30:	e50b300c 	str	r3, [fp, #-12]
    Iter=Uint;
80160a34:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80160a38:	e50b3008 	str	r3, [fp, #-8]
    while((Iter>>(RME_WORD_BIT-4U))==0U)
80160a3c:	ea000005 	b	80160a58 <RME_Hex_Print+0x58>
    {
        Iter<<=4;
80160a40:	e51b3008 	ldr	r3, [fp, #-8]
80160a44:	e1a03203 	lsl	r3, r3, #4
80160a48:	e50b3008 	str	r3, [fp, #-8]
        Count++;
80160a4c:	e51b300c 	ldr	r3, [fp, #-12]
80160a50:	e2833001 	add	r3, r3, #1
80160a54:	e50b300c 	str	r3, [fp, #-12]
    while((Iter>>(RME_WORD_BIT-4U))==0U)
80160a58:	e51b3008 	ldr	r3, [fp, #-8]
80160a5c:	e1a03e23 	lsr	r3, r3, #28
80160a60:	e3530000 	cmp	r3, #0
80160a64:	0afffff5 	beq	80160a40 <RME_Hex_Print+0x40>
    }
    
    /* Count is the number of pts to print */
    Count=RME_POW2(RME_WORD_ORDER-2U)-Count;
80160a68:	e51b300c 	ldr	r3, [fp, #-12]
80160a6c:	e2633008 	rsb	r3, r3, #8
80160a70:	e50b300c 	str	r3, [fp, #-12]
    Num=Count;
80160a74:	e51b300c 	ldr	r3, [fp, #-12]
80160a78:	e50b3010 	str	r3, [fp, #-16]
    while(Count>0U)
80160a7c:	ea00001a 	b	80160aec <RME_Hex_Print+0xec>
    {
        Count--;
80160a80:	e51b300c 	ldr	r3, [fp, #-12]
80160a84:	e2433001 	sub	r3, r3, #1
80160a88:	e50b300c 	str	r3, [fp, #-12]
        Iter=(Uint>>(Count<<2U))&0x0FU;
80160a8c:	e51b300c 	ldr	r3, [fp, #-12]
80160a90:	e1a03103 	lsl	r3, r3, #2
80160a94:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80160a98:	e1a03332 	lsr	r3, r2, r3
80160a9c:	e203300f 	and	r3, r3, #15
80160aa0:	e50b3008 	str	r3, [fp, #-8]
        if(Iter<10U)
80160aa4:	e51b3008 	ldr	r3, [fp, #-8]
80160aa8:	e3530009 	cmp	r3, #9
80160aac:	8a000007 	bhi	80160ad0 <RME_Hex_Print+0xd0>
        {
            RME_COV_MARKER();
            
            __RME_Putchar((rme_s8_t)Iter+'0');
80160ab0:	e51b3008 	ldr	r3, [fp, #-8]
80160ab4:	e6ef3073 	uxtb	r3, r3
80160ab8:	e2833030 	add	r3, r3, #48	@ 0x30
80160abc:	e6ef3073 	uxtb	r3, r3
80160ac0:	e6af3073 	sxtb	r3, r3
80160ac4:	e1a00003 	mov	r0, r3
80160ac8:	eb002a74 	bl	8016b4a0 <__RME_Putchar>
80160acc:	ea000006 	b	80160aec <RME_Hex_Print+0xec>
        }
        else
        {
            RME_COV_MARKER();
            
            __RME_Putchar((rme_s8_t)Iter+'A'-10);
80160ad0:	e51b3008 	ldr	r3, [fp, #-8]
80160ad4:	e6ef3073 	uxtb	r3, r3
80160ad8:	e2833037 	add	r3, r3, #55	@ 0x37
80160adc:	e6ef3073 	uxtb	r3, r3
80160ae0:	e6af3073 	sxtb	r3, r3
80160ae4:	e1a00003 	mov	r0, r3
80160ae8:	eb002a6c 	bl	8016b4a0 <__RME_Putchar>
    while(Count>0U)
80160aec:	e51b300c 	ldr	r3, [fp, #-12]
80160af0:	e3530000 	cmp	r3, #0
80160af4:	1affffe1 	bne	80160a80 <RME_Hex_Print+0x80>
        }
    }
    
    return (rme_cnt_t)Num;
80160af8:	e51b3010 	ldr	r3, [fp, #-16]
}
80160afc:	e1a00003 	mov	r0, r3
80160b00:	e24bd004 	sub	sp, fp, #4
80160b04:	e8bd8800 	pop	{fp, pc}

80160b08 <RME_Str_Print>:
Output      : None.
Return      : rme_cnt_t - The length of the string printed, the '\0' is not included.
******************************************************************************/
#if(RME_DBGLOG_ENABLE!=0U)
rme_cnt_t RME_Str_Print(const rme_s8_t* String)
{
80160b08:	e92d4800 	push	{fp, lr}
80160b0c:	e28db004 	add	fp, sp, #4
80160b10:	e24dd010 	sub	sp, sp, #16
80160b14:	e50b0010 	str	r0, [fp, #-16]
    rme_ptr_t Count;
    
    for(Count=0U;Count<RME_DBGLOG_MAX;Count++)
80160b18:	e3a03000 	mov	r3, #0
80160b1c:	e50b3008 	str	r3, [fp, #-8]
80160b20:	ea00000e 	b	80160b60 <RME_Str_Print+0x58>
    {
        if(String[Count]==(rme_s8_t)'\0')
80160b24:	e51b2010 	ldr	r2, [fp, #-16]
80160b28:	e51b3008 	ldr	r3, [fp, #-8]
80160b2c:	e0823003 	add	r3, r2, r3
80160b30:	e1d330d0 	ldrsb	r3, [r3]
80160b34:	e3530000 	cmp	r3, #0
80160b38:	0a00000c 	beq	80160b70 <RME_Str_Print+0x68>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        __RME_Putchar(String[Count]);
80160b3c:	e51b2010 	ldr	r2, [fp, #-16]
80160b40:	e51b3008 	ldr	r3, [fp, #-8]
80160b44:	e0823003 	add	r3, r2, r3
80160b48:	e1d330d0 	ldrsb	r3, [r3]
80160b4c:	e1a00003 	mov	r0, r3
80160b50:	eb002a52 	bl	8016b4a0 <__RME_Putchar>
    for(Count=0U;Count<RME_DBGLOG_MAX;Count++)
80160b54:	e51b3008 	ldr	r3, [fp, #-8]
80160b58:	e2833001 	add	r3, r3, #1
80160b5c:	e50b3008 	str	r3, [fp, #-8]
80160b60:	e51b3008 	ldr	r3, [fp, #-8]
80160b64:	e35300fe 	cmp	r3, #254	@ 0xfe
80160b68:	9affffed 	bls	80160b24 <RME_Str_Print+0x1c>
80160b6c:	ea000000 	b	80160b74 <RME_Str_Print+0x6c>
            break;
80160b70:	e320f000 	nop	{0}
    }
    
    return (rme_cnt_t)Count;
80160b74:	e51b3008 	ldr	r3, [fp, #-8]
}
80160b78:	e1a00003 	mov	r0, r3
80160b7c:	e24bd004 	sub	sp, fp, #4
80160b80:	e8bd8800 	pop	{fp, pc}

80160b84 <RME_Log>:
#ifndef RME_LOG
void RME_Log(const char* File,
             long Line,
             const char* Date,
             const char* Time)
{
80160b84:	e92d4800 	push	{fp, lr}
80160b88:	e28db004 	add	fp, sp, #4
80160b8c:	e24dd010 	sub	sp, sp, #16
80160b90:	e50b0008 	str	r0, [fp, #-8]
80160b94:	e50b100c 	str	r1, [fp, #-12]
80160b98:	e50b2010 	str	r2, [fp, #-16]
80160b9c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    RME_DBG_S("\r\n***\r\nKernel panic - not syncing :\r\n"); \
80160ba0:	e30c02dc 	movw	r0, #49884	@ 0xc2dc
80160ba4:	e3480016 	movt	r0, #32790	@ 0x8016
80160ba8:	ebffffd6 	bl	80160b08 <RME_Str_Print>
    RME_DBG_S(File); \
80160bac:	e51b0008 	ldr	r0, [fp, #-8]
80160bb0:	ebffffd4 	bl	80160b08 <RME_Str_Print>
    RME_DBG_S(" , Line "); \
80160bb4:	e30c0304 	movw	r0, #49924	@ 0xc304
80160bb8:	e3480016 	movt	r0, #32790	@ 0x8016
80160bbc:	ebffffd1 	bl	80160b08 <RME_Str_Print>
    RME_DBG_I(Line); \
80160bc0:	e51b000c 	ldr	r0, [fp, #-12]
80160bc4:	ebffff30 	bl	8016088c <RME_Int_Print>
    RME_DBG_S("\r\n"); \
80160bc8:	e30c0310 	movw	r0, #49936	@ 0xc310
80160bcc:	e3480016 	movt	r0, #32790	@ 0x8016
80160bd0:	ebffffcc 	bl	80160b08 <RME_Str_Print>
    RME_DBG_S(Date); \
80160bd4:	e51b0010 	ldr	r0, [fp, #-16]
80160bd8:	ebffffca 	bl	80160b08 <RME_Str_Print>
    RME_DBG_S(" , "); \
80160bdc:	e30c0314 	movw	r0, #49940	@ 0xc314
80160be0:	e3480016 	movt	r0, #32790	@ 0x8016
80160be4:	ebffffc7 	bl	80160b08 <RME_Str_Print>
    RME_DBG_S(Time); \
80160be8:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80160bec:	ebffffc5 	bl	80160b08 <RME_Str_Print>
    RME_DBG_S("\r\n"); \
80160bf0:	e30c0310 	movw	r0, #49936	@ 0xc310
80160bf4:	e3480016 	movt	r0, #32790	@ 0x8016
80160bf8:	ebffffc2 	bl	80160b08 <RME_Str_Print>
}
80160bfc:	e320f000 	nop	{0}
80160c00:	e24bd004 	sub	sp, fp, #4
80160c04:	e8bd8800 	pop	{fp, pc}

80160c08 <_RME_Comp_Swap_Single>:
Return      : rme_ptr_t - If successful, 1; else 0.
******************************************************************************/
rme_ptr_t _RME_Comp_Swap_Single(volatile rme_ptr_t* Ptr,
                                rme_ptr_t Old,
                                rme_ptr_t New)
{
80160c08:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160c0c:	e28db000 	add	fp, sp, #0
80160c10:	e24dd014 	sub	sp, sp, #20
80160c14:	e50b0008 	str	r0, [fp, #-8]
80160c18:	e50b100c 	str	r1, [fp, #-12]
80160c1c:	e50b2010 	str	r2, [fp, #-16]
    if(*Ptr==Old)
80160c20:	e51b3008 	ldr	r3, [fp, #-8]
80160c24:	e5933000 	ldr	r3, [r3]
80160c28:	e51b200c 	ldr	r2, [fp, #-12]
80160c2c:	e1520003 	cmp	r2, r3
80160c30:	1a000004 	bne	80160c48 <_RME_Comp_Swap_Single+0x40>
    {
        RME_COV_MARKER();
        
        *Ptr=New;
80160c34:	e51b3008 	ldr	r3, [fp, #-8]
80160c38:	e51b2010 	ldr	r2, [fp, #-16]
80160c3c:	e5832000 	str	r2, [r3]
        return 1U;
80160c40:	e3a03001 	mov	r3, #1
80160c44:	ea000000 	b	80160c4c <_RME_Comp_Swap_Single+0x44>
    {
        RME_COV_MARKER();
        /* No action required */
    }

    return 0U;
80160c48:	e3a03000 	mov	r3, #0
}
80160c4c:	e1a00003 	mov	r0, r3
80160c50:	e28bd000 	add	sp, fp, #0
80160c54:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160c58:	e12fff1e 	bx	lr

80160c5c <_RME_Fetch_Add_Single>:
Output      : volatile rme_ptr_t* Ptr - The pointer to the data.
Return      : rme_ptr_t - The value before the addition.
*******************************************************************************/
rme_ptr_t _RME_Fetch_Add_Single(volatile rme_ptr_t* Ptr,
                                rme_cnt_t Addend)
{
80160c5c:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160c60:	e28db000 	add	fp, sp, #0
80160c64:	e24dd014 	sub	sp, sp, #20
80160c68:	e50b0010 	str	r0, [fp, #-16]
80160c6c:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
    rme_cnt_t Old;

    Old=(rme_cnt_t)(*Ptr);
80160c70:	e51b3010 	ldr	r3, [fp, #-16]
80160c74:	e5933000 	ldr	r3, [r3]
80160c78:	e50b3008 	str	r3, [fp, #-8]
    *Ptr=(rme_ptr_t)(Old+Addend);
80160c7c:	e51b2008 	ldr	r2, [fp, #-8]
80160c80:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80160c84:	e0823003 	add	r3, r2, r3
80160c88:	e1a02003 	mov	r2, r3
80160c8c:	e51b3010 	ldr	r3, [fp, #-16]
80160c90:	e5832000 	str	r2, [r3]

    return (rme_ptr_t)Old;
80160c94:	e51b3008 	ldr	r3, [fp, #-8]
}
80160c98:	e1a00003 	mov	r0, r3
80160c9c:	e28bd000 	add	sp, fp, #0
80160ca0:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160ca4:	e12fff1e 	bx	lr

80160ca8 <_RME_Fetch_And_Single>:
Output      : volatile rme_ptr_t* Ptr - The pointer to the data.
Return      : rme_ptr_t - The value before the AND operation.
******************************************************************************/
rme_ptr_t _RME_Fetch_And_Single(volatile rme_ptr_t* Ptr,
                                rme_ptr_t Operand)
{
80160ca8:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160cac:	e28db000 	add	fp, sp, #0
80160cb0:	e24dd014 	sub	sp, sp, #20
80160cb4:	e50b0010 	str	r0, [fp, #-16]
80160cb8:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
    rme_ptr_t Old;

    Old=*Ptr;
80160cbc:	e51b3010 	ldr	r3, [fp, #-16]
80160cc0:	e5933000 	ldr	r3, [r3]
80160cc4:	e50b3008 	str	r3, [fp, #-8]
    *Ptr=Old&Operand;
80160cc8:	e51b2008 	ldr	r2, [fp, #-8]
80160ccc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80160cd0:	e0022003 	and	r2, r2, r3
80160cd4:	e51b3010 	ldr	r3, [fp, #-16]
80160cd8:	e5832000 	str	r2, [r3]

    return Old;
80160cdc:	e51b3008 	ldr	r3, [fp, #-8]
}
80160ce0:	e1a00003 	mov	r0, r3
80160ce4:	e28bd000 	add	sp, fp, #0
80160ce8:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160cec:	e12fff1e 	bx	lr

80160cf0 <_RME_List_Crt>:
Input       : struct RME_List* Head - The pointer to the list head.
Output      : None.
Return      : None.
******************************************************************************/
void _RME_List_Crt(struct RME_List* Head)
{
80160cf0:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160cf4:	e28db000 	add	fp, sp, #0
80160cf8:	e24dd00c 	sub	sp, sp, #12
80160cfc:	e50b0008 	str	r0, [fp, #-8]
    Head->Prev=Head;
80160d00:	e51b3008 	ldr	r3, [fp, #-8]
80160d04:	e51b2008 	ldr	r2, [fp, #-8]
80160d08:	e5832004 	str	r2, [r3, #4]
    Head->Next=Head;
80160d0c:	e51b3008 	ldr	r3, [fp, #-8]
80160d10:	e51b2008 	ldr	r2, [fp, #-8]
80160d14:	e5832000 	str	r2, [r3]
}
80160d18:	e320f000 	nop	{0}
80160d1c:	e28bd000 	add	sp, fp, #0
80160d20:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160d24:	e12fff1e 	bx	lr

80160d28 <_RME_List_Del>:
Output      : None.
Return      : None.
******************************************************************************/
void _RME_List_Del(struct RME_List* Prev,
                   struct RME_List* Next)
{
80160d28:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160d2c:	e28db000 	add	fp, sp, #0
80160d30:	e24dd00c 	sub	sp, sp, #12
80160d34:	e50b0008 	str	r0, [fp, #-8]
80160d38:	e50b100c 	str	r1, [fp, #-12]
    Next->Prev=Prev;
80160d3c:	e51b300c 	ldr	r3, [fp, #-12]
80160d40:	e51b2008 	ldr	r2, [fp, #-8]
80160d44:	e5832004 	str	r2, [r3, #4]
    Prev->Next=Next;
80160d48:	e51b3008 	ldr	r3, [fp, #-8]
80160d4c:	e51b200c 	ldr	r2, [fp, #-12]
80160d50:	e5832000 	str	r2, [r3]
}
80160d54:	e320f000 	nop	{0}
80160d58:	e28bd000 	add	sp, fp, #0
80160d5c:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160d60:	e12fff1e 	bx	lr

80160d64 <_RME_List_Ins>:
Return      : None.
******************************************************************************/
void _RME_List_Ins(struct RME_List* New,
                   struct RME_List* Prev,
                   struct RME_List* Next)
{
80160d64:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160d68:	e28db000 	add	fp, sp, #0
80160d6c:	e24dd014 	sub	sp, sp, #20
80160d70:	e50b0008 	str	r0, [fp, #-8]
80160d74:	e50b100c 	str	r1, [fp, #-12]
80160d78:	e50b2010 	str	r2, [fp, #-16]
    Next->Prev=New;
80160d7c:	e51b3010 	ldr	r3, [fp, #-16]
80160d80:	e51b2008 	ldr	r2, [fp, #-8]
80160d84:	e5832004 	str	r2, [r3, #4]
    New->Next=Next;
80160d88:	e51b3008 	ldr	r3, [fp, #-8]
80160d8c:	e51b2010 	ldr	r2, [fp, #-16]
80160d90:	e5832000 	str	r2, [r3]
    New->Prev=Prev;
80160d94:	e51b3008 	ldr	r3, [fp, #-8]
80160d98:	e51b200c 	ldr	r2, [fp, #-12]
80160d9c:	e5832004 	str	r2, [r3, #4]
    Prev->Next=New;
80160da0:	e51b300c 	ldr	r3, [fp, #-12]
80160da4:	e51b2008 	ldr	r2, [fp, #-8]
80160da8:	e5832000 	str	r2, [r3]
}
80160dac:	e320f000 	nop	{0}
80160db0:	e28bd000 	add	sp, fp, #0
80160db4:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160db8:	e12fff1e 	bx	lr

80160dbc <RME_Kmain>:
Input       : None.
Output      : None.
Return      : rme_ret_t - This function never returns.
******************************************************************************/
rme_ret_t RME_Kmain(void)
{
80160dbc:	e92d4800 	push	{fp, lr}
80160dc0:	e28db004 	add	fp, sp, #4
    /* Disable all interrupts first */
    __RME_Int_Disable();
80160dc4:	ebfffe53 	bl	80160718 <__RME_Int_Disable>
    /* Some low-level kernel assertions */
    _RME_Lowlvl_Check();
80160dc8:	eb000007 	bl	80160dec <_RME_Lowlvl_Check>
    /* Hardware low-level init */
    __RME_Lowlvl_Init();
80160dcc:	eb002aa5 	bl	8016b868 <__RME_Lowlvl_Init>
    /* Initialize the kernel page tables or memory mappings */
    __RME_Pgt_Kom_Init();
80160dd0:	eb002ac0 	bl	8016b8d8 <__RME_Pgt_Kom_Init>
    
    /* Initialize the kernel object allocation table - default init */
    _RME_Kot_Init(RME_KOT_WORD_NUM);
80160dd4:	e3a00602 	mov	r0, #2097152	@ 0x200000
80160dd8:	eb000ebc 	bl	801648d0 <_RME_Kot_Init>
    
    /* Boot into the first process */
    __RME_Boot();
80160ddc:	eb002ac4 	bl	8016b8f4 <__RME_Boot>
    
    /* Should never reach here */
    return 0;
80160de0:	e3a03000 	mov	r3, #0
}
80160de4:	e1a00003 	mov	r0, r3
80160de8:	e8bd8800 	pop	{fp, pc}

80160dec <_RME_Lowlvl_Check>:
Input       : None.
Output      : None.
Return      : rme_ret_t - Always 0.
******************************************************************************/
static rme_ret_t _RME_Lowlvl_Check(void)
{
80160dec:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160df0:	e28db000 	add	fp, sp, #0
    /* Kernel memory allocation minimal size aligned to word boundary */
    RME_ASSERT(RME_KOM_SLOT_ORDER>=RME_WORD_ORDER-3U);
    /* Make sure the number of priorities do not exceed half-word boundary */
    RME_ASSERT(RME_PREEMPT_PRIO_NUM<=RME_POW2(RME_WORD_BIT>>1));
    
    return 0;
80160df4:	e3a03000 	mov	r3, #0
}
80160df8:	e1a00003 	mov	r0, r3
80160dfc:	e28bd000 	add	sp, fp, #0
80160e00:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160e04:	e12fff1e 	bx	lr

80160e08 <_RME_Svc_Handler>:
Input       : struct RME_Reg_Struct* Reg - The register set.
Output      : struct RME_Reg_Struct* Reg - The updated register set.
Return      : None.
******************************************************************************/
void _RME_Svc_Handler(struct RME_Reg_Struct* Reg)
{
80160e08:	e92d4830 	push	{r4, r5, fp, lr}
80160e0c:	e28db00c 	add	fp, sp, #12
80160e10:	e24dd048 	sub	sp, sp, #72	@ 0x48
80160e14:	e50b0038 	str	r0, [fp, #-56]	@ 0xffffffc8
    struct RME_Thd_Struct* Thd_Cur;
    struct RME_Inv_Struct* Inv_Top;
    struct RME_Cap_Cpt* Cpt;

    /* Get the system call parameters from the system call */
    __RME_Svc_Param_Get(Reg, &Svc, &Cid, Param);
80160e18:	e24b3034 	sub	r3, fp, #52	@ 0x34
80160e1c:	e24b2028 	sub	r2, fp, #40	@ 0x28
80160e20:	e24b1024 	sub	r1, fp, #36	@ 0x24
80160e24:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80160e28:	eb002ab6 	bl	8016b908 <__RME_Svc_Param_Get>
    /* System call number takes [5:0] bits */
    Svc_Num=Svc&RME_MASK_END(5U);
80160e2c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80160e30:	e203303f 	and	r3, r3, #63	@ 0x3f
80160e34:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    
    /* Ultra-fast path - synchronous invocation returning */
    if(Svc_Num==RME_SVC_INV_RET)
80160e38:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80160e3c:	e3530000 	cmp	r3, #0
80160e40:	1a00000c 	bne	80160e78 <_RME_Svc_Handler+0x70>
    {
        RME_COV_MARKER();
        
        Retval=_RME_Inv_Ret(Reg,                                            /* volatile struct RME_Reg_Struct* Reg */
80160e44:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80160e48:	e3a02000 	mov	r2, #0
80160e4c:	e1a01003 	mov	r1, r3
80160e50:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80160e54:	eb002880 	bl	8016b05c <_RME_Inv_Ret>
80160e58:	e50b0010 	str	r0, [fp, #-16]
                            Param[0],                                       /* rme_ptr_t Retval */
                            0U);                                            /* rme_ptr_t Is_Exc */
        RME_SWITCH_RETURN(Reg, Retval);
80160e5c:	e51b3010 	ldr	r3, [fp, #-16]
80160e60:	e3530000 	cmp	r3, #0
80160e64:	aa00022e 	bge	80161724 <_RME_Svc_Handler+0x91c>
80160e68:	e51b1010 	ldr	r1, [fp, #-16]
80160e6c:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80160e70:	eb002ac7 	bl	8016b994 <__RME_Svc_Retval_Set>
80160e74:	ea00022a 	b	80161724 <_RME_Svc_Handler+0x91c>
        /* No action required */
    }
    
    /* Get our current capability table. No need to check whether it is frozen
     * because it can't be deleted anyway */
    Thd_Cur=RME_CPU_LOCAL()->Thd_Cur;
80160e78:	e30d3004 	movw	r3, #53252	@ 0xd004
80160e7c:	e3483016 	movt	r3, #32790	@ 0x8016
80160e80:	e5933004 	ldr	r3, [r3, #4]
80160e84:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    Inv_Top=RME_INVSTK_TOP(Thd_Cur);
80160e88:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80160e8c:	e593204c 	ldr	r2, [r3, #76]	@ 0x4c
80160e90:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80160e94:	e283304c 	add	r3, r3, #76	@ 0x4c
80160e98:	e1520003 	cmp	r2, r3
80160e9c:	0a000002 	beq	80160eac <_RME_Svc_Handler+0xa4>
80160ea0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80160ea4:	e593304c 	ldr	r3, [r3, #76]	@ 0x4c
80160ea8:	ea000000 	b	80160eb0 <_RME_Svc_Handler+0xa8>
80160eac:	e3a03000 	mov	r3, #0
80160eb0:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
    if(Inv_Top==RME_NULL)
80160eb4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80160eb8:	e3530000 	cmp	r3, #0
80160ebc:	1a000004 	bne	80160ed4 <_RME_Svc_Handler+0xcc>
    {
        RME_COV_MARKER();
        
        Cpt=Thd_Cur->Sched.Prc->Cpt;
80160ec0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80160ec4:	e593302c 	ldr	r3, [r3, #44]	@ 0x2c
80160ec8:	e5933014 	ldr	r3, [r3, #20]
80160ecc:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
80160ed0:	ea000003 	b	80160ee4 <_RME_Svc_Handler+0xdc>
    }
    else
    {
        RME_COV_MARKER();
        
        Cpt=Inv_Top->Prc->Cpt;
80160ed4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80160ed8:	e5933008 	ldr	r3, [r3, #8]
80160edc:	e5933014 	ldr	r3, [r3, #20]
80160ee0:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    }

    /* Fast path - synchronous invocation activation */
    if(Svc_Num==RME_SVC_INV_ACT)
80160ee4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80160ee8:	e3530001 	cmp	r3, #1
80160eec:	1a00000d 	bne	80160f28 <_RME_Svc_Handler+0x120>
    {
        RME_COV_MARKER();
        
        Retval=_RME_Inv_Act(Cpt,
                            Reg,                                            /* volatile struct RME_Reg_Struct* Reg */
                            (rme_cid_t)Param[0],                            /* rme_cid_t Cap_Inv */
80160ef0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
        Retval=_RME_Inv_Act(Cpt,
80160ef4:	e1a02003 	mov	r2, r3
80160ef8:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80160efc:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80160f00:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80160f04:	eb002795 	bl	8016ad60 <_RME_Inv_Act>
80160f08:	e50b0010 	str	r0, [fp, #-16]
                            Param[1]);                                      /* rme_ptr_t Param */
        RME_SWITCH_RETURN(Reg,Retval);
80160f0c:	e51b3010 	ldr	r3, [fp, #-16]
80160f10:	e3530000 	cmp	r3, #0
80160f14:	aa000204 	bge	8016172c <_RME_Svc_Handler+0x924>
80160f18:	e51b1010 	ldr	r1, [fp, #-16]
80160f1c:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80160f20:	eb002a9b 	bl	8016b994 <__RME_Svc_Retval_Set>
80160f24:	ea000200 	b	8016172c <_RME_Svc_Handler+0x924>
     * of these functions shall be: If the function is successful, they shall
     * perform the return value saving on proper register stacks by themselves;
     * if the function fails, it should not conduct such return value saving.
     * These paths are less optimized than synchronous invocation, but are still
     * optimized anyway. */
    switch(Svc_Num)
80160f28:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80160f2c:	e2433002 	sub	r3, r3, #2
80160f30:	e3530007 	cmp	r3, #7
80160f34:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
80160f38:	ea00009a 	b	801611a8 <_RME_Svc_Handler+0x3a0>
80160f3c:	80160f5c 	.word	0x80160f5c
80160f40:	80160f90 	.word	0x80160f90
80160f44:	80160fc8 	.word	0x80160fc8
80160f48:	80161028 	.word	0x80161028
80160f4c:	8016105c 	.word	0x8016105c
80160f50:	801610ac 	.word	0x801610ac
80160f54:	80161128 	.word	0x80161128
80160f58:	80161170 	.word	0x80161170
        {
            RME_COV_MARKER();
            
            Retval=_RME_Sig_Snd(Cpt,
                                Reg,                                        /* volatile struct RME_Reg_Struct* Reg */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Sig */
80160f5c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Sig_Snd(Cpt,
80160f60:	e1a02003 	mov	r2, r3
80160f64:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80160f68:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80160f6c:	eb002292 	bl	801699bc <_RME_Sig_Snd>
80160f70:	e50b0010 	str	r0, [fp, #-16]
            RME_SWITCH_RETURN(Reg,Retval);
80160f74:	e51b3010 	ldr	r3, [fp, #-16]
80160f78:	e3530000 	cmp	r3, #0
80160f7c:	aa0001ec 	bge	80161734 <_RME_Svc_Handler+0x92c>
80160f80:	e51b1010 	ldr	r1, [fp, #-16]
80160f84:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80160f88:	eb002a81 	bl	8016b994 <__RME_Svc_Retval_Set>
80160f8c:	ea0001e8 	b	80161734 <_RME_Svc_Handler+0x92c>
        {
            RME_COV_MARKER();
            
            Retval=_RME_Sig_Rcv(Cpt,
                                Reg,                                        /* volatile struct RME_Reg_Struct* Reg */
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Sig */
80160f90:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Sig_Rcv(Cpt,
80160f94:	e1a02003 	mov	r2, r3
80160f98:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80160f9c:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80160fa0:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80160fa4:	eb00234b 	bl	80169cd8 <_RME_Sig_Rcv>
80160fa8:	e50b0010 	str	r0, [fp, #-16]
                                Param[1]);                                  /* rme_ptr_t Option */
            RME_SWITCH_RETURN(Reg,Retval);
80160fac:	e51b3010 	ldr	r3, [fp, #-16]
80160fb0:	e3530000 	cmp	r3, #0
80160fb4:	aa0001e0 	bge	8016173c <_RME_Svc_Handler+0x934>
80160fb8:	e51b1010 	ldr	r1, [fp, #-16]
80160fbc:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80160fc0:	eb002a73 	bl	8016b994 <__RME_Svc_Retval_Set>
80160fc4:	ea0001dc 	b	8016173c <_RME_Svc_Handler+0x934>
        /* Call kernel functions */
        case RME_SVC_KFN:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Kfn_Act(Cpt,
80160fc8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80160fcc:	e1a0c003 	mov	ip, r3
                                Reg,                                        /* volatile struct RME_Reg_Struct* Reg */
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Kfn */
                                RME_PARAM_D0(Param[0]),                     /* rme_ptr_t Func_ID */
80160fd0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Kfn_Act(Cpt,
80160fd4:	e6ff0073 	uxth	r0, r3
                                RME_PARAM_D1(Param[0]),                     /* rme_ptr_t Sub_ID */
80160fd8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Kfn_Act(Cpt,
80160fdc:	e1a03823 	lsr	r3, r3, #16
80160fe0:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
80160fe4:	e51b102c 	ldr	r1, [fp, #-44]	@ 0xffffffd4
80160fe8:	e58d1008 	str	r1, [sp, #8]
80160fec:	e58d2004 	str	r2, [sp, #4]
80160ff0:	e58d3000 	str	r3, [sp]
80160ff4:	e1a03000 	mov	r3, r0
80160ff8:	e1a0200c 	mov	r2, ip
80160ffc:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80161000:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161004:	eb00289b 	bl	8016b278 <_RME_Kfn_Act>
80161008:	e50b0010 	str	r0, [fp, #-16]
                                Param[1],                                   /* rme_ptr_t Param1 */
                                Param[2]);                                  /* rme_ptr_t Param2 */
            RME_SWITCH_RETURN(Reg, Retval);
8016100c:	e51b3010 	ldr	r3, [fp, #-16]
80161010:	e3530000 	cmp	r3, #0
80161014:	aa0001ca 	bge	80161744 <_RME_Svc_Handler+0x93c>
80161018:	e51b1010 	ldr	r1, [fp, #-16]
8016101c:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80161020:	eb002a5b 	bl	8016b994 <__RME_Svc_Retval_Set>
80161024:	ea0001c6 	b	80161744 <_RME_Svc_Handler+0x93c>
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Sched_Free(Cpt,
                                       Reg,                                 /* volatile struct RME_Reg_Struct* Reg */
                                       (rme_cid_t)Param[0]);                /* rme_cid_t Cap_Thd */
80161028:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Sched_Free(Cpt,
8016102c:	e1a02003 	mov	r2, r3
80161030:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80161034:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161038:	eb001a60 	bl	801679c0 <_RME_Thd_Sched_Free>
8016103c:	e50b0010 	str	r0, [fp, #-16]
            RME_SWITCH_RETURN(Reg,Retval);
80161040:	e51b3010 	ldr	r3, [fp, #-16]
80161044:	e3530000 	cmp	r3, #0
80161048:	aa0001bf 	bge	8016174c <_RME_Svc_Handler+0x944>
8016104c:	e51b1010 	ldr	r1, [fp, #-16]
80161050:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80161054:	eb002a4e 	bl	8016b994 <__RME_Svc_Retval_Set>
80161058:	ea0001bb 	b	8016174c <_RME_Svc_Handler+0x944>
        /* Changing thread execution context */
        case RME_SVC_THD_EXEC_SET:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Exec_Set(Cpt,
8016105c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161060:	e1a00003 	mov	r0, r3
80161064:	e51b1034 	ldr	r1, [fp, #-52]	@ 0xffffffcc
80161068:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016106c:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
80161070:	e58d2004 	str	r2, [sp, #4]
80161074:	e58d3000 	str	r3, [sp]
80161078:	e1a03001 	mov	r3, r1
8016107c:	e1a02000 	mov	r2, r0
80161080:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80161084:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161088:	eb001b3d 	bl	80167d84 <_RME_Thd_Exec_Set>
8016108c:	e50b0010 	str	r0, [fp, #-16]
                                     Reg,                                   /* volatile struct RME_Reg_Struct* Reg */
                                     (rme_cid_t)Cid,                        /* rme_cid_t Cap_Thd */
                                     Param[0],                              /* rme_ptr_t Entry */
                                     Param[1],                              /* rme_ptr_t Stack */
                                     Param[2]);                             /* rme_ptr_t Param */
            RME_SWITCH_RETURN(Reg,Retval);
80161090:	e51b3010 	ldr	r3, [fp, #-16]
80161094:	e3530000 	cmp	r3, #0
80161098:	aa0001ad 	bge	80161754 <_RME_Svc_Handler+0x94c>
8016109c:	e51b1010 	ldr	r1, [fp, #-16]
801610a0:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
801610a4:	eb002a3a 	bl	8016b994 <__RME_Svc_Retval_Set>
801610a8:	ea0001a9 	b	80161754 <_RME_Svc_Handler+0x94c>
        /* Changing thread priority (up to three threads at once) */
        case RME_SVC_THD_SCHED_PRIO:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Sched_Prio(Cpt,
801610ac:	e51be028 	ldr	lr, [fp, #-40]	@ 0xffffffd8
                                       Reg,                                 /* volatile struct RME_Reg_Struct* Reg */
                                       Cid,                                 /* rme_ptr_t Number */
                                       (rme_cid_t)RME_PARAM_D0(Param[0]),   /* rme_cid_t Cap_Thd0 */
801610b0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Sched_Prio(Cpt,
801610b4:	e6ff4073 	uxth	r4, r3
                                       RME_PARAM_D1(Param[0]),              /* rme_ptr_t Prio0 */
801610b8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Sched_Prio(Cpt,
801610bc:	e1a03823 	lsr	r3, r3, #16
                                       (rme_cid_t)RME_PARAM_D0(Param[1]),   /* rme_cid_t Cap_Thd1 */
801610c0:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Thd_Sched_Prio(Cpt,
801610c4:	e6ff2072 	uxth	r2, r2
                                       RME_PARAM_D1(Param[1]),              /* rme_ptr_t Prio1 */
801610c8:	e51b1030 	ldr	r1, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Thd_Sched_Prio(Cpt,
801610cc:	e1a01821 	lsr	r1, r1, #16
                                       (rme_cid_t)RME_PARAM_D0(Param[2]),   /* rme_cid_t Cap_Thd2 */
801610d0:	e51b002c 	ldr	r0, [fp, #-44]	@ 0xffffffd4
            Retval=_RME_Thd_Sched_Prio(Cpt,
801610d4:	e6ff0070 	uxth	r0, r0
                                       RME_PARAM_D1(Param[2]));             /* rme_ptr_t Prio2 */
801610d8:	e51bc02c 	ldr	ip, [fp, #-44]	@ 0xffffffd4
            Retval=_RME_Thd_Sched_Prio(Cpt,
801610dc:	e1a0c82c 	lsr	ip, ip, #16
801610e0:	e58dc010 	str	ip, [sp, #16]
801610e4:	e58d000c 	str	r0, [sp, #12]
801610e8:	e58d1008 	str	r1, [sp, #8]
801610ec:	e58d2004 	str	r2, [sp, #4]
801610f0:	e58d3000 	str	r3, [sp]
801610f4:	e1a03004 	mov	r3, r4
801610f8:	e1a0200e 	mov	r2, lr
801610fc:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80161100:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161104:	eb001bc8 	bl	8016802c <_RME_Thd_Sched_Prio>
80161108:	e50b0010 	str	r0, [fp, #-16]
            RME_SWITCH_RETURN(Reg,Retval);
8016110c:	e51b3010 	ldr	r3, [fp, #-16]
80161110:	e3530000 	cmp	r3, #0
80161114:	aa000190 	bge	8016175c <_RME_Svc_Handler+0x954>
80161118:	e51b1010 	ldr	r1, [fp, #-16]
8016111c:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80161120:	eb002a1b 	bl	8016b994 <__RME_Svc_Retval_Set>
80161124:	ea00018c 	b	8016175c <_RME_Svc_Handler+0x954>
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Time_Xfer(Cpt,
                                      Reg,                                  /* volatile struct RME_Reg_Struct* Reg */
                                      (rme_cid_t)Param[0],                  /* rme_cid_t Cap_Thd_Dst */
80161128:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Time_Xfer(Cpt,
8016112c:	e1a02003 	mov	r2, r3
                                      (rme_cid_t)Param[1],                  /* rme_cid_t Cap_Thd_Src */
80161130:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Thd_Time_Xfer(Cpt,
80161134:	e1a01003 	mov	r1, r3
80161138:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016113c:	e58d3000 	str	r3, [sp]
80161140:	e1a03001 	mov	r3, r1
80161144:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80161148:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016114c:	eb001da0 	bl	801687d4 <_RME_Thd_Time_Xfer>
80161150:	e50b0010 	str	r0, [fp, #-16]
                                      Param[2]);                            /* rme_ptr_t Time */
            RME_SWITCH_RETURN(Reg,Retval);
80161154:	e51b3010 	ldr	r3, [fp, #-16]
80161158:	e3530000 	cmp	r3, #0
8016115c:	aa000180 	bge	80161764 <_RME_Svc_Handler+0x95c>
80161160:	e51b1010 	ldr	r1, [fp, #-16]
80161164:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80161168:	eb002a09 	bl	8016b994 <__RME_Svc_Retval_Set>
8016116c:	ea00017c 	b	80161764 <_RME_Svc_Handler+0x95c>
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Swt(Cpt,
                                Reg,                                        /* volatile struct RME_Reg_Struct* Reg */
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Thd */
80161170:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Swt(Cpt,
80161174:	e1a02003 	mov	r2, r3
80161178:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016117c:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80161180:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161184:	eb001f1f 	bl	80168e08 <_RME_Thd_Swt>
80161188:	e50b0010 	str	r0, [fp, #-16]
                                Param[1]);                                  /* rme_ptr_t Full_Yield */
            RME_SWITCH_RETURN(Reg,Retval);
8016118c:	e51b3010 	ldr	r3, [fp, #-16]
80161190:	e3530000 	cmp	r3, #0
80161194:	aa000174 	bge	8016176c <_RME_Svc_Handler+0x964>
80161198:	e51b1010 	ldr	r1, [fp, #-16]
8016119c:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
801611a0:	eb0029fb 	bl	8016b994 <__RME_Svc_Retval_Set>
801611a4:	ea000170 	b	8016176c <_RME_Svc_Handler+0x964>
        }
        default:
        {
            RME_COV_MARKER();
            break;
801611a8:	e320f000 	nop	{0}
        }
    } 

    /* It is guaranteed that these functions will never cause a context switch */
    switch(Svc_Num)
801611ac:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801611b0:	e243300a 	sub	r3, r3, #10
801611b4:	e3530017 	cmp	r3, #23
801611b8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
801611bc:	ea000151 	b	80161708 <_RME_Svc_Handler+0x900>
801611c0:	80161220 	.word	0x80161220
801611c4:	80161268 	.word	0x80161268
801611c8:	80161288 	.word	0x80161288
801611cc:	801612a8 	.word	0x801612a8
801611d0:	8016130c 	.word	0x8016130c
801611d4:	8016132c 	.word	0x8016132c
801611d8:	801613a0 	.word	0x801613a0
801611dc:	801613c0 	.word	0x801613c0
801611e0:	80161418 	.word	0x80161418
801611e4:	80161438 	.word	0x80161438
801611e8:	80161470 	.word	0x80161470
801611ec:	80161490 	.word	0x80161490
801611f0:	801614c4 	.word	0x801614c4
801611f4:	801614e4 	.word	0x801614e4
801611f8:	80161504 	.word	0x80161504
801611fc:	80161524 	.word	0x80161524
80161200:	80161598 	.word	0x80161598
80161204:	801615b8 	.word	0x801615b8
80161208:	80161614 	.word	0x80161614
8016120c:	8016162c 	.word	0x8016162c
80161210:	8016164c 	.word	0x8016164c
80161214:	8016166c 	.word	0x8016166c
80161218:	801616b8 	.word	0x801616b8
8016121c:	801616d8 	.word	0x801616d8
    {
        /* Capability table */
        case RME_SVC_CPT_CRT:
        {
            RME_COV_MARKER();
            Retval=_RME_Cpt_Crt(Cpt,
80161220:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161224:	e1a00003 	mov	r0, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt_Crt */
                                (rme_cid_t)RME_PARAM_D1(Param[0]),          /* rme_cid_t Cap_Kom */
80161228:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
8016122c:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Cpt_Crt(Cpt,
80161230:	e1a0c003 	mov	ip, r3
                                (rme_cid_t)RME_PARAM_D0(Param[0]),          /* rme_cid_t Cap_Crt */
80161234:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Cpt_Crt(Cpt,
80161238:	e6ff1073 	uxth	r1, r3
8016123c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80161240:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
80161244:	e58d2004 	str	r2, [sp, #4]
80161248:	e58d3000 	str	r3, [sp]
8016124c:	e1a03001 	mov	r3, r1
80161250:	e1a0200c 	mov	r2, ip
80161254:	e1a01000 	mov	r1, r0
80161258:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016125c:	eb000174 	bl	80161834 <_RME_Cpt_Crt>
80161260:	e50b0010 	str	r0, [fp, #-16]
                                Param[1],                                   /* rme_ptr_t Raddr */
                                Param[2]);                                  /* rme_ptr_t Entry_Num */
            break;
80161264:	ea00012a 	b	80161714 <_RME_Svc_Handler+0x90c>
        }
        case RME_SVC_CPT_DEL:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Cpt_Del(Cpt,
80161268:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016126c:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt_Del */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Cpt */
80161270:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Cpt_Del(Cpt,
80161274:	e1a02003 	mov	r2, r3
80161278:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016127c:	eb0002c2 	bl	80161d8c <_RME_Cpt_Del>
80161280:	e50b0010 	str	r0, [fp, #-16]
            break;
80161284:	ea000122 	b	80161714 <_RME_Svc_Handler+0x90c>
        }
        case RME_SVC_CPT_FRZ:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Cpt_Frz(Cpt,
80161288:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016128c:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt_Frz */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Frz */
80161290:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Cpt_Frz(Cpt,
80161294:	e1a02003 	mov	r2, r3
80161298:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016129c:	eb0003a7 	bl	80162140 <_RME_Cpt_Frz>
801612a0:	e50b0010 	str	r0, [fp, #-16]
            break;
801612a4:	ea00011a 	b	80161714 <_RME_Svc_Handler+0x90c>
        case RME_SVC_CPT_ADD:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Cpt_Add(Cpt,
                                (rme_cid_t)RME_PARAM_D1(Param[0]),          /* rme_cid_t Cap_Cpt_Dst */
801612a8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801612ac:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Cpt_Add(Cpt,
801612b0:	e1a0e003 	mov	lr, r3
                                (rme_cid_t)RME_PARAM_D0(Param[0]),          /* rme_cid_t Cap_Dst */
801612b4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Cpt_Add(Cpt,
801612b8:	e6ffc073 	uxth	ip, r3
                                (rme_cid_t)RME_PARAM_D1(Param[1]),          /* rme_cid_t Cap_Cpt_Src */
801612bc:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801612c0:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Cpt_Add(Cpt,
801612c4:	e1a04003 	mov	r4, r3
                                (rme_cid_t)RME_PARAM_D0(Param[1]),          /* rme_cid_t Cap_Src */
801612c8:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Cpt_Add(Cpt,
801612cc:	e6ff3073 	uxth	r3, r3
801612d0:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
                                Param[2],                                   /* rme_ptr_t Flag */
                                RME_PARAM_KM(Svc,Cid));                     /* rme_ptr_t Ext_Flag */
801612d4:	e51b1024 	ldr	r1, [fp, #-36]	@ 0xffffffdc
801612d8:	e1a00801 	lsl	r0, r1, #16
            Retval=_RME_Cpt_Add(Cpt,
801612dc:	e51b1028 	ldr	r1, [fp, #-40]	@ 0xffffffd8
801612e0:	e1801001 	orr	r1, r0, r1
801612e4:	e58d1008 	str	r1, [sp, #8]
801612e8:	e58d2004 	str	r2, [sp, #4]
801612ec:	e58d3000 	str	r3, [sp]
801612f0:	e1a03004 	mov	r3, r4
801612f4:	e1a0200c 	mov	r2, ip
801612f8:	e1a0100e 	mov	r1, lr
801612fc:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161300:	eb000435 	bl	801623dc <_RME_Cpt_Add>
80161304:	e50b0010 	str	r0, [fp, #-16]
            break;
80161308:	ea000101 	b	80161714 <_RME_Svc_Handler+0x90c>
        }
        case RME_SVC_CPT_REM:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Cpt_Rem(Cpt,
8016130c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161310:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt_Rem */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Rem */
80161314:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Cpt_Rem(Cpt,
80161318:	e1a02003 	mov	r2, r3
8016131c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161320:	eb00064c 	bl	80162c58 <_RME_Cpt_Rem>
80161324:	e50b0010 	str	r0, [fp, #-16]
            break;
80161328:	ea0000f9 	b	80161714 <_RME_Svc_Handler+0x90c>
#if(RME_PGT_RAW_ENABLE==0U)
        case RME_SVC_PGT_CRT:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Pgt_Crt(Cpt,
8016132c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161330:	e1a04003 	mov	r4, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)RME_PARAM_D1(Param[0]),          /* rme_cid_t Cap_Kom */
80161334:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80161338:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Pgt_Crt(Cpt,
8016133c:	e1a05003 	mov	r5, r3
                                (rme_cid_t)RME_PARAM_Q1(Param[0]),          /* rme_cid_t Cap_Pgt */
80161340:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80161344:	e1a03423 	lsr	r3, r3, #8
            Retval=_RME_Pgt_Crt(Cpt,
80161348:	e6efe073 	uxtb	lr, r3
8016134c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
                                Param[1],                                   /* rme_ptr_t Raddr */
                                Param[2]&RME_MASK_BEGIN(1U),                /* rme_ptr_t Base */
80161350:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
            Retval=_RME_Pgt_Crt(Cpt,
80161354:	e3c22001 	bic	r2, r2, #1
                                RME_PARAM_PT(Param[2]),                     /* rme_ptr_t Is_Top */
80161358:	e51b102c 	ldr	r1, [fp, #-44]	@ 0xffffffd4
            Retval=_RME_Pgt_Crt(Cpt,
8016135c:	e2011001 	and	r1, r1, #1
                                RME_PARAM_Q0(Param[0]),                     /* rme_ptr_t Size_Order */
80161360:	e51b0034 	ldr	r0, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Pgt_Crt(Cpt,
80161364:	e6ef0070 	uxtb	r0, r0
80161368:	e51bc024 	ldr	ip, [fp, #-36]	@ 0xffffffdc
8016136c:	e1a0c42c 	lsr	ip, ip, #8
80161370:	e58dc010 	str	ip, [sp, #16]
80161374:	e58d000c 	str	r0, [sp, #12]
80161378:	e58d1008 	str	r1, [sp, #8]
8016137c:	e58d2004 	str	r2, [sp, #4]
80161380:	e58d3000 	str	r3, [sp]
80161384:	e1a0300e 	mov	r3, lr
80161388:	e1a02005 	mov	r2, r5
8016138c:	e1a01004 	mov	r1, r4
80161390:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161394:	eb0006e6 	bl	80162f34 <_RME_Pgt_Crt>
80161398:	e50b0010 	str	r0, [fp, #-16]
                                RME_PARAM_PC(Svc));                         /* rme_ptr_t Num_Order */
            break;
8016139c:	ea0000dc 	b	80161714 <_RME_Svc_Handler+0x90c>
        }
        case RME_SVC_PGT_DEL:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Pgt_Del(Cpt,
801613a0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801613a4:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Pgt */
801613a8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Pgt_Del(Cpt,
801613ac:	e1a02003 	mov	r2, r3
801613b0:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801613b4:	eb00084b 	bl	801634e8 <_RME_Pgt_Del>
801613b8:	e50b0010 	str	r0, [fp, #-16]
            break;
801613bc:	ea0000d4 	b	80161714 <_RME_Svc_Handler+0x90c>
        case RME_SVC_PGT_ADD:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Pgt_Add(Cpt,
                                (rme_cid_t)RME_PARAM_D1(Param[0]),          /* rme_cid_t Cap_Pgt_Dst */
801613c0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801613c4:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Pgt_Add(Cpt,
801613c8:	e1a0e003 	mov	lr, r3
                                RME_PARAM_D0(Param[0]),                     /* rme_ptr_t Pos_Dst */
801613cc:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Pgt_Add(Cpt,
801613d0:	e6ff1073 	uxth	r1, r3
801613d4:	e51b0028 	ldr	r0, [fp, #-40]	@ 0xffffffd8
                                Cid,                                        /* rme_ptr_t Flag_Dst */
                                (rme_cid_t)RME_PARAM_D1(Param[1]),          /* rme_cid_t Cap_Pgt_Src */
801613d8:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801613dc:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Pgt_Add(Cpt,
801613e0:	e1a0c003 	mov	ip, r3
                                RME_PARAM_D0(Param[1]),                     /* rme_ptr_t Pos_Src */
801613e4:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Pgt_Add(Cpt,
801613e8:	e6ff3073 	uxth	r3, r3
801613ec:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
801613f0:	e58d2008 	str	r2, [sp, #8]
801613f4:	e58d3004 	str	r3, [sp, #4]
801613f8:	e58dc000 	str	ip, [sp]
801613fc:	e1a03000 	mov	r3, r0
80161400:	e1a02001 	mov	r2, r1
80161404:	e1a0100e 	mov	r1, lr
80161408:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016140c:	eb000913 	bl	80163860 <_RME_Pgt_Add>
80161410:	e50b0010 	str	r0, [fp, #-16]
                                Param[2]);                                  /* rme_ptr_t Index */
            break;
80161414:	ea0000be 	b	80161714 <_RME_Svc_Handler+0x90c>
        case RME_SVC_PGT_REM:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Pgt_Rem(Cpt,
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Pgt */
80161418:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Pgt_Rem(Cpt,
8016141c:	e1a01003 	mov	r1, r3
80161420:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80161424:	e1a02003 	mov	r2, r3
80161428:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016142c:	eb000a4d 	bl	80163d68 <_RME_Pgt_Rem>
80161430:	e50b0010 	str	r0, [fp, #-16]
                                Param[1]);                                  /* rme_ptr_t Pos */
            break;
80161434:	ea0000b6 	b	80161714 <_RME_Svc_Handler+0x90c>
        case RME_SVC_PGT_CON:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Pgt_Con(Cpt,
                                (rme_cid_t)RME_PARAM_D1(Param[0]),          /* rme_cid_t Cap_Pgt_Parent */
80161438:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
8016143c:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Pgt_Con(Cpt,
80161440:	e1a00003 	mov	r0, r3
80161444:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
                                Param[1],                                   /* rme_ptr_t Pos */
                                (rme_cid_t)RME_PARAM_D0(Param[0]),          /* rme_cid_t Cap_Pgt_Child */
80161448:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Pgt_Con(Cpt,
8016144c:	e6ff1073 	uxth	r1, r3
80161450:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161454:	e58d3000 	str	r3, [sp]
80161458:	e1a03001 	mov	r3, r1
8016145c:	e1a01000 	mov	r1, r0
80161460:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161464:	eb000acd 	bl	80163fa0 <_RME_Pgt_Con>
80161468:	e50b0010 	str	r0, [fp, #-16]
                                Param[2]);                                  /* rme_ptr_t Flag_Child */
            break;
8016146c:	ea0000a8 	b	80161714 <_RME_Svc_Handler+0x90c>
        case RME_SVC_PGT_DES:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Pgt_Des(Cpt,
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Pgt_Parent */
80161470:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Pgt_Des(Cpt,
80161474:	e1a01003 	mov	r1, r3
80161478:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
                                Param[1],                                   /* rme_ptr_t Pos */
                                (rme_cid_t)Param[2]);                       /* rme_cid_t Cap_Pgt_Child */
8016147c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
            Retval=_RME_Pgt_Des(Cpt,
80161480:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161484:	eb000bf5 	bl	80164460 <_RME_Pgt_Des>
80161488:	e50b0010 	str	r0, [fp, #-16]
            break;
8016148c:	ea0000a0 	b	80161714 <_RME_Svc_Handler+0x90c>
#endif
        /* Process */
        case RME_SVC_PRC_CRT:
        {
#if(RME_PGT_RAW_ENABLE==0U)
            Retval=_RME_Prc_Crt(Cpt,
80161490:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161494:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt_Crt */
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Prc */
80161498:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Prc_Crt(Cpt,
8016149c:	e1a02003 	mov	r2, r3
                                (rme_cid_t)Param[1],                        /* rme_cid_t Cap_Cpt */
801614a0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Prc_Crt(Cpt,
801614a4:	e1a00003 	mov	r0, r3
                                (rme_cid_t)Param[2]);                       /* rme_cid_t Cap_Pgt */
801614a8:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
            Retval=_RME_Prc_Crt(Cpt,
801614ac:	e58d3000 	str	r3, [sp]
801614b0:	e1a03000 	mov	r3, r0
801614b4:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801614b8:	eb000fe0 	bl	80165440 <_RME_Prc_Crt>
801614bc:	e50b0010 	str	r0, [fp, #-16]
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt_Crt */
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Prc */
                                (rme_cid_t)Param[1],                        /* rme_cid_t Cap_Cpt */
                                (rme_ptr_t)Param[2]);                       /* rme_ptr_t Raw_Pgt */
#endif
            break;
801614c0:	ea000093 	b	80161714 <_RME_Svc_Handler+0x90c>
        }
        case RME_SVC_PRC_DEL:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Prc_Del(Cpt,
801614c4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801614c8:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Prc */
801614cc:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Prc_Del(Cpt,
801614d0:	e1a02003 	mov	r2, r3
801614d4:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801614d8:	eb00116b 	bl	80165a8c <_RME_Prc_Del>
801614dc:	e50b0010 	str	r0, [fp, #-16]
            break;
801614e0:	ea00008b 	b	80161714 <_RME_Svc_Handler+0x90c>
        case RME_SVC_PRC_CPT:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Prc_Cpt(Cpt,
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Prc */
801614e4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Prc_Cpt(Cpt,
801614e8:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Param[1]);                       /* rme_cid_t Cap_Cpt */
801614ec:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Prc_Cpt(Cpt,
801614f0:	e1a02003 	mov	r2, r3
801614f4:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801614f8:	eb00122b 	bl	80165dac <_RME_Prc_Cpt>
801614fc:	e50b0010 	str	r0, [fp, #-16]
            break;
80161500:	ea000083 	b	80161714 <_RME_Svc_Handler+0x90c>
        case RME_SVC_PRC_PGT:
        {
            RME_COV_MARKER();
#if(RME_PGT_RAW_ENABLE==0U)
            Retval=_RME_Prc_Pgt(Cpt,
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Prc */
80161504:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Prc_Pgt(Cpt,
80161508:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Param[1]);                       /* rme_cid_t Cap_Pgt */
8016150c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Prc_Pgt(Cpt,
80161510:	e1a02003 	mov	r2, r3
80161514:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161518:	eb001321 	bl	801661a4 <_RME_Prc_Pgt>
8016151c:	e50b0010 	str	r0, [fp, #-16]
#else
            Retval=_RME_Prc_Pgt(Cpt,
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Prc */
                                Param[1]);                                  /* rme_ptr_t Raw_Pgt */
#endif
            break;
80161520:	ea00007b 	b	80161714 <_RME_Svc_Handler+0x90c>
        /* Thread */
        case RME_SVC_THD_CRT:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Crt(Cpt,
80161524:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161528:	e1a04003 	mov	r4, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)RME_PARAM_D1(Param[0]),          /* rme_cid_t Cap_Kom */
8016152c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80161530:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Thd_Crt(Cpt,
80161534:	e1a05003 	mov	r5, r3
                                (rme_cid_t)RME_PARAM_D0(Param[0]),          /* rme_cid_t Cap_Thd */
80161538:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Crt(Cpt,
8016153c:	e6ffc073 	uxth	ip, r3
                                (rme_cid_t)RME_PARAM_D1(Param[1]),          /* rme_cid_t Cap_Prc */
80161540:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80161544:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Thd_Crt(Cpt,
80161548:	e1a0e003 	mov	lr, r3
                                RME_PARAM_D0(Param[1]),                     /* rme_ptr_t Prio_Max */
8016154c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Thd_Crt(Cpt,
80161550:	e6ff3073 	uxth	r3, r3
80161554:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
80161558:	e51b1024 	ldr	r1, [fp, #-36]	@ 0xffffffdc
8016155c:	e1a013a1 	lsr	r1, r1, #7
80161560:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
80161564:	e2000040 	and	r0, r0, #64	@ 0x40
80161568:	e58d0010 	str	r0, [sp, #16]
8016156c:	e58d100c 	str	r1, [sp, #12]
80161570:	e58d2008 	str	r2, [sp, #8]
80161574:	e58d3004 	str	r3, [sp, #4]
80161578:	e58de000 	str	lr, [sp]
8016157c:	e1a0300c 	mov	r3, ip
80161580:	e1a02005 	mov	r2, r5
80161584:	e1a01004 	mov	r1, r4
80161588:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016158c:	eb001402 	bl	8016659c <_RME_Thd_Crt>
80161590:	e50b0010 	str	r0, [fp, #-16]
                                Param[2],                                   /* rme_ptr_t Raddr */
                                Svc>>7,                                     /* rme_ptr_t Attr */
                                Svc&0x40U);                                 /* rme_ptr_t Is_Hyp */
            break;
80161594:	ea00005e 	b	80161714 <_RME_Svc_Handler+0x90c>
        }
        case RME_SVC_THD_DEL:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Del(Cpt,
80161598:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016159c:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Thd */
801615a0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Del(Cpt,
801615a4:	e1a02003 	mov	r2, r3
801615a8:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801615ac:	eb0015f8 	bl	80166d94 <_RME_Thd_Del>
801615b0:	e50b0010 	str	r0, [fp, #-16]
            break;
801615b4:	ea000056 	b	80161714 <_RME_Svc_Handler+0x90c>
        }
        case RME_SVC_THD_SCHED_BIND:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Sched_Bind(Cpt,
801615b8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801615bc:	e1a0c003 	mov	ip, r3
                                       (rme_cid_t)Cid,                      /* rme_cid_t Cap_Thd */
                                       (rme_cid_t)RME_PARAM_D1(Param[0]),   /* rme_cid_t Cap_Thd_Sched */
801615c0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801615c4:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Thd_Sched_Bind(Cpt,
801615c8:	e1a0e003 	mov	lr, r3
                                       (rme_cid_t)RME_PARAM_D0(Param[0]),   /* rme_cid_t Cap_Sig */
801615cc:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Sched_Bind(Cpt,
801615d0:	e6ff1073 	uxth	r1, r3
                                       (rme_tid_t)RME_PARAM_D1(Param[1]),   /* rme_tid_t TID */
801615d4:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801615d8:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Thd_Sched_Bind(Cpt,
801615dc:	e1a00003 	mov	r0, r3
                                       RME_PARAM_D0(Param[1]),              /* rme_ptr_t Prio */
801615e0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Thd_Sched_Bind(Cpt,
801615e4:	e6ff3073 	uxth	r3, r3
801615e8:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
801615ec:	e58d2008 	str	r2, [sp, #8]
801615f0:	e58d3004 	str	r3, [sp, #4]
801615f4:	e58d0000 	str	r0, [sp]
801615f8:	e1a03001 	mov	r3, r1
801615fc:	e1a0200e 	mov	r2, lr
80161600:	e1a0100c 	mov	r1, ip
80161604:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161608:	eb0016f7 	bl	801671ec <_RME_Thd_Sched_Bind>
8016160c:	e50b0010 	str	r0, [fp, #-16]
                                       Param[2]);                           /* rme_ptr_t Haddr */
            break;
80161610:	ea00003f 	b	80161714 <_RME_Svc_Handler+0x90c>
        case RME_SVC_THD_SCHED_RCV:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Sched_Rcv(Cpt,
                                      (rme_cid_t)Param[0]);                 /* rme_cid_t Cap_Thd */
80161614:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Sched_Rcv(Cpt,
80161618:	e1a01003 	mov	r1, r3
8016161c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161620:	eb001bbd 	bl	8016851c <_RME_Thd_Sched_Rcv>
80161624:	e50b0010 	str	r0, [fp, #-16]
            break;
80161628:	ea000039 	b	80161714 <_RME_Svc_Handler+0x90c>
        /* Signal */
        case RME_SVC_SIG_CRT:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Sig_Crt(Cpt,
8016162c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161630:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Sig */
80161634:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Sig_Crt(Cpt,
80161638:	e1a02003 	mov	r2, r3
8016163c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161640:	eb001ef1 	bl	8016920c <_RME_Sig_Crt>
80161644:	e50b0010 	str	r0, [fp, #-16]
            break;
80161648:	ea000031 	b	80161714 <_RME_Svc_Handler+0x90c>
        }
        case RME_SVC_SIG_DEL:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Sig_Del(Cpt,
8016164c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161650:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Sig */
80161654:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Sig_Del(Cpt,
80161658:	e1a02003 	mov	r2, r3
8016165c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161660:	eb001f8b 	bl	80169494 <_RME_Sig_Del>
80161664:	e50b0010 	str	r0, [fp, #-16]
            break;
80161668:	ea000029 	b	80161714 <_RME_Svc_Handler+0x90c>
        /* Invocation */
        case RME_SVC_INV_CRT:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Inv_Crt(Cpt,
8016166c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161670:	e1a00003 	mov	r0, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)RME_PARAM_D1(Param[0]),          /* rme_cid_t Cap_Kom */
80161674:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80161678:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Inv_Crt(Cpt,
8016167c:	e1a0c003 	mov	ip, r3
                                (rme_cid_t)RME_PARAM_D0(Param[0]),          /* rme_cid_t Cap_Inv */
80161680:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Inv_Crt(Cpt,
80161684:	e6ff2073 	uxth	r2, r3
                                (rme_cid_t)Param[1],                        /* rme_cid_t Cap_Prc */
80161688:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Inv_Crt(Cpt,
8016168c:	e1a01003 	mov	r1, r3
80161690:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161694:	e58d3004 	str	r3, [sp, #4]
80161698:	e58d1000 	str	r1, [sp]
8016169c:	e1a03002 	mov	r3, r2
801616a0:	e1a0200c 	mov	r2, ip
801616a4:	e1a01000 	mov	r1, r0
801616a8:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801616ac:	eb00229a 	bl	8016a11c <_RME_Inv_Crt>
801616b0:	e50b0010 	str	r0, [fp, #-16]
                                Param[2]);                                  /* rme_ptr_t Raddr */
            break;
801616b4:	ea000016 	b	80161714 <_RME_Svc_Handler+0x90c>
        }
        case RME_SVC_INV_DEL:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Inv_Del(Cpt,
801616b8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801616bc:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Inv */
801616c0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Inv_Del(Cpt,
801616c4:	e1a02003 	mov	r2, r3
801616c8:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801616cc:	eb002446 	bl	8016a7ec <_RME_Inv_Del>
801616d0:	e50b0010 	str	r0, [fp, #-16]
            break;
801616d4:	ea00000e 	b	80161714 <_RME_Svc_Handler+0x90c>
        case RME_SVC_INV_SET:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Inv_Set(Cpt,
                                (rme_cid_t)RME_PARAM_D0(Param[0]),          /* rme_cid_t Cap_Inv */
801616d8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Inv_Set(Cpt,
801616dc:	e6ff1073 	uxth	r1, r3
801616e0:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
801616e4:	e51b002c 	ldr	r0, [fp, #-44]	@ 0xffffffd4
                                Param[1],                                   /* rme_ptr_t Entry */
                                Param[2],                                   /* rme_ptr_t Stack */
                                RME_PARAM_D1(Param[0]));                    /* rme_ptr_t Is_Exc_Ret */
801616e8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Inv_Set(Cpt,
801616ec:	e1a03823 	lsr	r3, r3, #16
801616f0:	e58d3000 	str	r3, [sp]
801616f4:	e1a03000 	mov	r3, r0
801616f8:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801616fc:	eb002517 	bl	8016ab60 <_RME_Inv_Set>
80161700:	e50b0010 	str	r0, [fp, #-16]
            break;
80161704:	ea000002 	b	80161714 <_RME_Svc_Handler+0x90c>
        /* This is an error */
        default: 
        {
            RME_COV_MARKER();
            
            Retval=RME_ERR_CPT_NULL;
80161708:	e3e03000 	mvn	r3, #0
8016170c:	e50b3010 	str	r3, [fp, #-16]
            break;
80161710:	e320f000 	nop	{0}
        }
    }
    
    /* We set the registers and return */
    __RME_Svc_Retval_Set(Reg,Retval);
80161714:	e51b1010 	ldr	r1, [fp, #-16]
80161718:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
8016171c:	eb00289c 	bl	8016b994 <__RME_Svc_Retval_Set>
80161720:	ea000012 	b	80161770 <_RME_Svc_Handler+0x968>
        RME_SWITCH_RETURN(Reg, Retval);
80161724:	e320f000 	nop	{0}
80161728:	ea000010 	b	80161770 <_RME_Svc_Handler+0x968>
        RME_SWITCH_RETURN(Reg,Retval);
8016172c:	e320f000 	nop	{0}
80161730:	ea00000e 	b	80161770 <_RME_Svc_Handler+0x968>
            RME_SWITCH_RETURN(Reg,Retval);
80161734:	e320f000 	nop	{0}
80161738:	ea00000c 	b	80161770 <_RME_Svc_Handler+0x968>
            RME_SWITCH_RETURN(Reg,Retval);
8016173c:	e320f000 	nop	{0}
80161740:	ea00000a 	b	80161770 <_RME_Svc_Handler+0x968>
            RME_SWITCH_RETURN(Reg, Retval);
80161744:	e320f000 	nop	{0}
80161748:	ea000008 	b	80161770 <_RME_Svc_Handler+0x968>
            RME_SWITCH_RETURN(Reg,Retval);
8016174c:	e320f000 	nop	{0}
80161750:	ea000006 	b	80161770 <_RME_Svc_Handler+0x968>
            RME_SWITCH_RETURN(Reg,Retval);
80161754:	e320f000 	nop	{0}
80161758:	ea000004 	b	80161770 <_RME_Svc_Handler+0x968>
            RME_SWITCH_RETURN(Reg,Retval);
8016175c:	e320f000 	nop	{0}
80161760:	ea000002 	b	80161770 <_RME_Svc_Handler+0x968>
            RME_SWITCH_RETURN(Reg,Retval);
80161764:	e320f000 	nop	{0}
80161768:	ea000000 	b	80161770 <_RME_Svc_Handler+0x968>
            RME_SWITCH_RETURN(Reg,Retval);
8016176c:	e320f000 	nop	{0}
}
80161770:	e24bd00c 	sub	sp, fp, #12
80161774:	e8bd8830 	pop	{r4, r5, fp, pc}

80161778 <_RME_Tim_Handler>:
Output      : struct RME_Reg_Struct* Reg - The updated register set.
Return      : None.
******************************************************************************/
void _RME_Tim_Handler(struct RME_Reg_Struct* Reg,
                      rme_ptr_t Slice)
{
80161778:	e92d4800 	push	{fp, lr}
8016177c:	e28db004 	add	fp, sp, #4
80161780:	e24dd010 	sub	sp, sp, #16
80161784:	e50b0010 	str	r0, [fp, #-16]
80161788:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
    struct RME_CPU_Local* Local;
    struct RME_Thd_Struct* Thd_Cur;
    
    Local=RME_CPU_LOCAL();
8016178c:	e30d3004 	movw	r3, #53252	@ 0xd004
80161790:	e3483016 	movt	r3, #32790	@ 0x8016
80161794:	e50b3008 	str	r3, [fp, #-8]
    Thd_Cur=Local->Thd_Cur;
80161798:	e51b3008 	ldr	r3, [fp, #-8]
8016179c:	e5933004 	ldr	r3, [r3, #4]
801617a0:	e50b300c 	str	r3, [fp, #-12]
    if(Thd_Cur->Sched.Slice<RME_THD_INF_TIME)
801617a4:	e51b300c 	ldr	r3, [fp, #-12]
801617a8:	e5933018 	ldr	r3, [r3, #24]
801617ac:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
801617b0:	8a000015 	bhi	8016180c <_RME_Tim_Handler+0x94>
    {
        RME_COV_MARKER();

        /* Decrease timeslice count, and see if the timeslice is used up */
        if(Slice<Thd_Cur->Sched.Slice)
801617b4:	e51b300c 	ldr	r3, [fp, #-12]
801617b8:	e5933018 	ldr	r3, [r3, #24]
801617bc:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
801617c0:	e1520003 	cmp	r2, r3
801617c4:	2a000006 	bcs	801617e4 <_RME_Tim_Handler+0x6c>
        {
            RME_COV_MARKER();
            
            Thd_Cur->Sched.Slice-=Slice;
801617c8:	e51b300c 	ldr	r3, [fp, #-12]
801617cc:	e5932018 	ldr	r2, [r3, #24]
801617d0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801617d4:	e0422003 	sub	r2, r2, r3
801617d8:	e51b300c 	ldr	r3, [fp, #-12]
801617dc:	e5832018 	str	r2, [r3, #24]
801617e0:	ea000009 	b	8016180c <_RME_Tim_Handler+0x94>
        else
        {
            RME_COV_MARKER();

            /* Deprive all timeslices and remove from runqueue */
            Thd_Cur->Sched.Slice=0U;
801617e4:	e51b300c 	ldr	r3, [fp, #-12]
801617e8:	e3a02000 	mov	r2, #0
801617ec:	e5832018 	str	r2, [r3, #24]
            _RME_Run_Del(Thd_Cur);
801617f0:	e51b000c 	ldr	r0, [fp, #-12]
801617f4:	eb000e1f 	bl	80165078 <_RME_Run_Del>
            
            /* Timeout and notify parent */
            Thd_Cur->Sched.State=RME_THD_TIMEOUT;
801617f8:	e51b300c 	ldr	r3, [fp, #-12]
801617fc:	e3a02002 	mov	r2, #2
80161800:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Notif(Thd_Cur);
80161804:	e51b000c 	ldr	r0, [fp, #-12]
80161808:	eb000e8e 	bl	80165248 <_RME_Run_Notif>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Send to the system tick timer endpoint. This endpoint is per-core */
    _RME_Kern_Snd(Local->Sig_Tim);
8016180c:	e51b3008 	ldr	r3, [fp, #-8]
80161810:	e5933008 	ldr	r3, [r3, #8]
80161814:	e1a00003 	mov	r0, r3
80161818:	eb002020 	bl	801698a0 <_RME_Kern_Snd>

    /* All kernel send complete, now pick the highest priority thread to run */
    _RME_Kern_High(Reg,Local);
8016181c:	e51b1008 	ldr	r1, [fp, #-8]
80161820:	e51b0010 	ldr	r0, [fp, #-16]
80161824:	eb001fde 	bl	801697a4 <_RME_Kern_High>
}
80161828:	e320f000 	nop	{0}
8016182c:	e24bd004 	sub	sp, fp, #4
80161830:	e8bd8800 	pop	{fp, pc}

80161834 <_RME_Cpt_Crt>:
                              rme_cid_t Cap_Cpt_Crt,
                              rme_cid_t Cap_Kom,
                              rme_cid_t Cap_Crt,
                              rme_ptr_t Raddr,
                              rme_ptr_t Entry_Num)
{
80161834:	e92d4800 	push	{fp, lr}
80161838:	e28db004 	add	fp, sp, #4
8016183c:	e24dd028 	sub	sp, sp, #40	@ 0x28
80161840:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
80161844:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
80161848:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
8016184c:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
    volatile struct RME_Cap_Cpt* Cpt_Crt;
    rme_ptr_t Type_Stat;
    rme_ptr_t Vaddr;

    /* See if the entry number is too big */
    if((Entry_Num==0U)||(Entry_Num>RME_CID_2L))
80161850:	e59b3008 	ldr	r3, [fp, #8]
80161854:	e3530000 	cmp	r3, #0
80161858:	0a000002 	beq	80161868 <_RME_Cpt_Crt+0x34>
8016185c:	e59b3008 	ldr	r3, [fp, #8]
80161860:	e3530080 	cmp	r3, #128	@ 0x80
80161864:	9a000001 	bls	80161870 <_RME_Cpt_Crt+0x3c>
    {
        RME_COV_MARKER();
        
        return RME_ERR_CPT_RANGE;
80161868:	e3e03002 	mvn	r3, #2
8016186c:	ea000143 	b	80161d80 <_RME_Cpt_Crt+0x54c>
        /* No action required */
    }
#endif

    /* Get the cap location that we care about */
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Crt,RME_CAP_TYPE_CPT,
80161870:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80161874:	e2033080 	and	r3, r3, #128	@ 0x80
80161878:	e3530000 	cmp	r3, #0
8016187c:	1a00001d 	bne	801618f8 <_RME_Cpt_Crt+0xc4>
80161880:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80161884:	e5932014 	ldr	r2, [r3, #20]
80161888:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016188c:	e1520003 	cmp	r2, r3
80161890:	8a000001 	bhi	8016189c <_RME_Cpt_Crt+0x68>
80161894:	e3e03002 	mvn	r3, #2
80161898:	ea000138 	b	80161d80 <_RME_Cpt_Crt+0x54c>
8016189c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801618a0:	e1a02283 	lsl	r2, r3, #5
801618a4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801618a8:	e593300c 	ldr	r3, [r3, #12]
801618ac:	e0823003 	add	r3, r2, r3
801618b0:	e50b300c 	str	r3, [fp, #-12]
801618b4:	e51b300c 	ldr	r3, [fp, #-12]
801618b8:	e1a00003 	mov	r0, r3
801618bc:	ebfffb8f 	bl	80160700 <__RME_A7A_Read_Acquire>
801618c0:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801618c4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801618c8:	e1a03823 	lsr	r3, r3, #16
801618cc:	e6ef3073 	uxtb	r3, r3
801618d0:	e3530002 	cmp	r3, #2
801618d4:	1a000001 	bne	801618e0 <_RME_Cpt_Crt+0xac>
801618d8:	e3e03008 	mvn	r3, #8
801618dc:	ea000127 	b	80161d80 <_RME_Cpt_Crt+0x54c>
801618e0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801618e4:	e1a03c23 	lsr	r3, r3, #24
801618e8:	e3530003 	cmp	r3, #3
801618ec:	0a000041 	beq	801619f8 <_RME_Cpt_Crt+0x1c4>
801618f0:	e3e03001 	mvn	r3, #1
801618f4:	ea000121 	b	80161d80 <_RME_Cpt_Crt+0x54c>
801618f8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801618fc:	e1a02423 	lsr	r2, r3, #8
80161900:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80161904:	e5933014 	ldr	r3, [r3, #20]
80161908:	e1520003 	cmp	r2, r3
8016190c:	3a000001 	bcc	80161918 <_RME_Cpt_Crt+0xe4>
80161910:	e3e03002 	mvn	r3, #2
80161914:	ea000119 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161918:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016191c:	e1a03423 	lsr	r3, r3, #8
80161920:	e1a02283 	lsl	r2, r3, #5
80161924:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80161928:	e593300c 	ldr	r3, [r3, #12]
8016192c:	e0823003 	add	r3, r2, r3
80161930:	e50b300c 	str	r3, [fp, #-12]
80161934:	e51b300c 	ldr	r3, [fp, #-12]
80161938:	e1a00003 	mov	r0, r3
8016193c:	ebfffb6f 	bl	80160700 <__RME_A7A_Read_Acquire>
80161940:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80161944:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161948:	e1a03823 	lsr	r3, r3, #16
8016194c:	e6ef3073 	uxtb	r3, r3
80161950:	e3530002 	cmp	r3, #2
80161954:	1a000001 	bne	80161960 <_RME_Cpt_Crt+0x12c>
80161958:	e3e03008 	mvn	r3, #8
8016195c:	ea000107 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161960:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161964:	e1a03c23 	lsr	r3, r3, #24
80161968:	e3530003 	cmp	r3, #3
8016196c:	0a000001 	beq	80161978 <_RME_Cpt_Crt+0x144>
80161970:	e3e03001 	mvn	r3, #1
80161974:	ea000101 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161978:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016197c:	e203207f 	and	r2, r3, #127	@ 0x7f
80161980:	e51b300c 	ldr	r3, [fp, #-12]
80161984:	e5933014 	ldr	r3, [r3, #20]
80161988:	e1520003 	cmp	r2, r3
8016198c:	3a000001 	bcc	80161998 <_RME_Cpt_Crt+0x164>
80161990:	e3e03002 	mvn	r3, #2
80161994:	ea0000f9 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161998:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016199c:	e203307f 	and	r3, r3, #127	@ 0x7f
801619a0:	e1a02283 	lsl	r2, r3, #5
801619a4:	e51b300c 	ldr	r3, [fp, #-12]
801619a8:	e593300c 	ldr	r3, [r3, #12]
801619ac:	e0823003 	add	r3, r2, r3
801619b0:	e50b300c 	str	r3, [fp, #-12]
801619b4:	e51b300c 	ldr	r3, [fp, #-12]
801619b8:	e1a00003 	mov	r0, r3
801619bc:	ebfffb4f 	bl	80160700 <__RME_A7A_Read_Acquire>
801619c0:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801619c4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801619c8:	e1a03823 	lsr	r3, r3, #16
801619cc:	e6ef3073 	uxtb	r3, r3
801619d0:	e3530002 	cmp	r3, #2
801619d4:	1a000001 	bne	801619e0 <_RME_Cpt_Crt+0x1ac>
801619d8:	e3e03008 	mvn	r3, #8
801619dc:	ea0000e7 	b	80161d80 <_RME_Cpt_Crt+0x54c>
801619e0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801619e4:	e1a03c23 	lsr	r3, r3, #24
801619e8:	e3530003 	cmp	r3, #3
801619ec:	0a000001 	beq	801619f8 <_RME_Cpt_Crt+0x1c4>
801619f0:	e3e03001 	mvn	r3, #1
801619f4:	ea0000e1 	b	80161d80 <_RME_Cpt_Crt+0x54c>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Kom,RME_CAP_TYPE_KOM,
801619f8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801619fc:	e2033080 	and	r3, r3, #128	@ 0x80
80161a00:	e3530000 	cmp	r3, #0
80161a04:	1a00001d 	bne	80161a80 <_RME_Cpt_Crt+0x24c>
80161a08:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80161a0c:	e5932014 	ldr	r2, [r3, #20]
80161a10:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161a14:	e1520003 	cmp	r2, r3
80161a18:	8a000001 	bhi	80161a24 <_RME_Cpt_Crt+0x1f0>
80161a1c:	e3e03002 	mvn	r3, #2
80161a20:	ea0000d6 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161a24:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161a28:	e1a02283 	lsl	r2, r3, #5
80161a2c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80161a30:	e593300c 	ldr	r3, [r3, #12]
80161a34:	e0823003 	add	r3, r2, r3
80161a38:	e50b3010 	str	r3, [fp, #-16]
80161a3c:	e51b3010 	ldr	r3, [fp, #-16]
80161a40:	e1a00003 	mov	r0, r3
80161a44:	ebfffb2d 	bl	80160700 <__RME_A7A_Read_Acquire>
80161a48:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80161a4c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161a50:	e1a03823 	lsr	r3, r3, #16
80161a54:	e6ef3073 	uxtb	r3, r3
80161a58:	e3530002 	cmp	r3, #2
80161a5c:	1a000001 	bne	80161a68 <_RME_Cpt_Crt+0x234>
80161a60:	e3e03008 	mvn	r3, #8
80161a64:	ea0000c5 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161a68:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161a6c:	e1a03c23 	lsr	r3, r3, #24
80161a70:	e3530002 	cmp	r3, #2
80161a74:	0a000041 	beq	80161b80 <_RME_Cpt_Crt+0x34c>
80161a78:	e3e03001 	mvn	r3, #1
80161a7c:	ea0000bf 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161a80:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161a84:	e1a02423 	lsr	r2, r3, #8
80161a88:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80161a8c:	e5933014 	ldr	r3, [r3, #20]
80161a90:	e1520003 	cmp	r2, r3
80161a94:	3a000001 	bcc	80161aa0 <_RME_Cpt_Crt+0x26c>
80161a98:	e3e03002 	mvn	r3, #2
80161a9c:	ea0000b7 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161aa0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161aa4:	e1a03423 	lsr	r3, r3, #8
80161aa8:	e1a02283 	lsl	r2, r3, #5
80161aac:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80161ab0:	e593300c 	ldr	r3, [r3, #12]
80161ab4:	e0823003 	add	r3, r2, r3
80161ab8:	e50b3010 	str	r3, [fp, #-16]
80161abc:	e51b3010 	ldr	r3, [fp, #-16]
80161ac0:	e1a00003 	mov	r0, r3
80161ac4:	ebfffb0d 	bl	80160700 <__RME_A7A_Read_Acquire>
80161ac8:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80161acc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161ad0:	e1a03823 	lsr	r3, r3, #16
80161ad4:	e6ef3073 	uxtb	r3, r3
80161ad8:	e3530002 	cmp	r3, #2
80161adc:	1a000001 	bne	80161ae8 <_RME_Cpt_Crt+0x2b4>
80161ae0:	e3e03008 	mvn	r3, #8
80161ae4:	ea0000a5 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161ae8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161aec:	e1a03c23 	lsr	r3, r3, #24
80161af0:	e3530003 	cmp	r3, #3
80161af4:	0a000001 	beq	80161b00 <_RME_Cpt_Crt+0x2cc>
80161af8:	e3e03001 	mvn	r3, #1
80161afc:	ea00009f 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161b00:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161b04:	e203207f 	and	r2, r3, #127	@ 0x7f
80161b08:	e51b3010 	ldr	r3, [fp, #-16]
80161b0c:	e5933014 	ldr	r3, [r3, #20]
80161b10:	e1520003 	cmp	r2, r3
80161b14:	3a000001 	bcc	80161b20 <_RME_Cpt_Crt+0x2ec>
80161b18:	e3e03002 	mvn	r3, #2
80161b1c:	ea000097 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161b20:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161b24:	e203307f 	and	r3, r3, #127	@ 0x7f
80161b28:	e1a02283 	lsl	r2, r3, #5
80161b2c:	e51b3010 	ldr	r3, [fp, #-16]
80161b30:	e593300c 	ldr	r3, [r3, #12]
80161b34:	e0823003 	add	r3, r2, r3
80161b38:	e50b3010 	str	r3, [fp, #-16]
80161b3c:	e51b3010 	ldr	r3, [fp, #-16]
80161b40:	e1a00003 	mov	r0, r3
80161b44:	ebfffaed 	bl	80160700 <__RME_A7A_Read_Acquire>
80161b48:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80161b4c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161b50:	e1a03823 	lsr	r3, r3, #16
80161b54:	e6ef3073 	uxtb	r3, r3
80161b58:	e3530002 	cmp	r3, #2
80161b5c:	1a000001 	bne	80161b68 <_RME_Cpt_Crt+0x334>
80161b60:	e3e03008 	mvn	r3, #8
80161b64:	ea000085 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161b68:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161b6c:	e1a03c23 	lsr	r3, r3, #24
80161b70:	e3530002 	cmp	r3, #2
80161b74:	0a000001 	beq	80161b80 <_RME_Cpt_Crt+0x34c>
80161b78:	e3e03001 	mvn	r3, #1
80161b7c:	ea00007f 	b	80161d80 <_RME_Cpt_Crt+0x54c>
                   struct RME_Cap_Kom*,Kom_Op,Type_Stat);
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_CRT);
80161b80:	e51b300c 	ldr	r3, [fp, #-12]
80161b84:	e5933008 	ldr	r3, [r3, #8]
80161b88:	e2033001 	and	r3, r3, #1
80161b8c:	e3530000 	cmp	r3, #0
80161b90:	1a000001 	bne	80161b9c <_RME_Cpt_Crt+0x368>
80161b94:	e3e03006 	mvn	r3, #6
80161b98:	ea000078 	b	80161d80 <_RME_Cpt_Crt+0x54c>
    /* See if the creation is valid for this kmem range */
    RME_KOM_CHECK(Kom_Op,RME_KOM_FLAG_CPT,Raddr,Vaddr,RME_CPT_SIZE(Entry_Num));
80161b9c:	e51b3010 	ldr	r3, [fp, #-16]
80161ba0:	e5933008 	ldr	r3, [r3, #8]
80161ba4:	e2033001 	and	r3, r3, #1
80161ba8:	e3530000 	cmp	r3, #0
80161bac:	1a000001 	bne	80161bb8 <_RME_Cpt_Crt+0x384>
80161bb0:	e3e03006 	mvn	r3, #6
80161bb4:	ea000071 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161bb8:	e51b3010 	ldr	r3, [fp, #-16]
80161bbc:	e5933014 	ldr	r3, [r3, #20]
80161bc0:	e59b2004 	ldr	r2, [fp, #4]
80161bc4:	e0823003 	add	r3, r2, r3
80161bc8:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
80161bcc:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80161bd0:	e59b3004 	ldr	r3, [fp, #4]
80161bd4:	e1520003 	cmp	r2, r3
80161bd8:	2a000001 	bcs	80161be4 <_RME_Cpt_Crt+0x3b0>
80161bdc:	e3e03006 	mvn	r3, #6
80161be0:	ea000066 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161be4:	e51b3010 	ldr	r3, [fp, #-16]
80161be8:	e5933014 	ldr	r3, [r3, #20]
80161bec:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80161bf0:	e1520003 	cmp	r2, r3
80161bf4:	2a000001 	bcs	80161c00 <_RME_Cpt_Crt+0x3cc>
80161bf8:	e3e03006 	mvn	r3, #6
80161bfc:	ea00005f 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161c00:	e59b3008 	ldr	r3, [fp, #8]
80161c04:	e1a02283 	lsl	r2, r3, #5
80161c08:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80161c0c:	e0823003 	add	r3, r2, r3
80161c10:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80161c14:	e1520003 	cmp	r2, r3
80161c18:	9a000001 	bls	80161c24 <_RME_Cpt_Crt+0x3f0>
80161c1c:	e3e03006 	mvn	r3, #6
80161c20:	ea000056 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161c24:	e51b3010 	ldr	r3, [fp, #-16]
80161c28:	e5932018 	ldr	r2, [r3, #24]
80161c2c:	e59b3008 	ldr	r3, [fp, #8]
80161c30:	e1a01283 	lsl	r1, r3, #5
80161c34:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80161c38:	e0813003 	add	r3, r1, r3
80161c3c:	e2433001 	sub	r3, r3, #1
80161c40:	e1520003 	cmp	r2, r3
80161c44:	2a000001 	bcs	80161c50 <_RME_Cpt_Crt+0x41c>
80161c48:	e3e03006 	mvn	r3, #6
80161c4c:	ea00004b 	b	80161d80 <_RME_Cpt_Crt+0x54c>

    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Crt,struct RME_Cap_Cpt*,Cpt_Crt);
80161c50:	e51b300c 	ldr	r3, [fp, #-12]
80161c54:	e5932014 	ldr	r2, [r3, #20]
80161c58:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161c5c:	e1520003 	cmp	r2, r3
80161c60:	8a000001 	bhi	80161c6c <_RME_Cpt_Crt+0x438>
80161c64:	e3e03002 	mvn	r3, #2
80161c68:	ea000044 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161c6c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161c70:	e1a02283 	lsl	r2, r3, #5
80161c74:	e51b300c 	ldr	r3, [fp, #-12]
80161c78:	e593300c 	ldr	r3, [r3, #12]
80161c7c:	e0823003 	add	r3, r2, r3
80161c80:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Cpt_Crt);
80161c84:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161c88:	e3a02801 	mov	r2, #65536	@ 0x10000
80161c8c:	e3a01000 	mov	r1, #0
80161c90:	e1a00003 	mov	r0, r3
80161c94:	ebfffbdb 	bl	80160c08 <_RME_Comp_Swap_Single>
80161c98:	e1a03000 	mov	r3, r0
80161c9c:	e3530000 	cmp	r3, #0
80161ca0:	1a000001 	bne	80161cac <_RME_Cpt_Crt+0x478>
80161ca4:	e3e03004 	mvn	r3, #4
80161ca8:	ea000034 	b	80161d80 <_RME_Cpt_Crt+0x54c>
80161cac:	e30d3000 	movw	r3, #53248	@ 0xd000
80161cb0:	e3483016 	movt	r3, #32790	@ 0x8016
80161cb4:	e5932000 	ldr	r2, [r3]
80161cb8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161cbc:	e5832010 	str	r2, [r3, #16]

    /* Try to mark this area as populated */
    if(_RME_Kot_Mark(Vaddr,RME_CPT_SIZE(Entry_Num))<0)
80161cc0:	e59b3008 	ldr	r3, [fp, #8]
80161cc4:	e1a03283 	lsl	r3, r3, #5
80161cc8:	e1a01003 	mov	r1, r3
80161ccc:	e51b0018 	ldr	r0, [fp, #-24]	@ 0xffffffe8
80161cd0:	eb000b1b 	bl	80164944 <_RME_Kot_Mark>
80161cd4:	e1a03000 	mov	r3, r0
80161cd8:	e3530000 	cmp	r3, #0
80161cdc:	aa000005 	bge	80161cf8 <_RME_Cpt_Crt+0x4c4>
    {
        RME_COV_MARKER();
        
        /* Failure. Set the Type_Stat back to 0 and abort the creation process */
        RME_WRITE_RELEASE(&(Cpt_Crt->Head.Type_Stat),0U);
80161ce0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161ce4:	e3a01000 	mov	r1, #0
80161ce8:	e1a00003 	mov	r0, r3
80161cec:	ebfffa86 	bl	8016070c <__RME_A7A_Write_Release>
        return RME_ERR_CPT_KOT;
80161cf0:	e3e03003 	mvn	r3, #3
80161cf4:	ea000021 	b	80161d80 <_RME_Cpt_Crt+0x54c>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Object init */
    for(Count=0U;Count<Entry_Num;Count++)
80161cf8:	e3a03000 	mov	r3, #0
80161cfc:	e50b3008 	str	r3, [fp, #-8]
80161d00:	ea000009 	b	80161d2c <_RME_Cpt_Crt+0x4f8>
    {
        RME_CAP_CLEAR(&(((struct RME_Cap_Struct*)Vaddr)[Count]));
80161d04:	e51b3008 	ldr	r3, [fp, #-8]
80161d08:	e1a02283 	lsl	r2, r3, #5
80161d0c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80161d10:	e0823003 	add	r3, r2, r3
80161d14:	e1a02003 	mov	r2, r3
80161d18:	e3a03000 	mov	r3, #0
80161d1c:	e5823000 	str	r3, [r2]
    for(Count=0U;Count<Entry_Num;Count++)
80161d20:	e51b3008 	ldr	r3, [fp, #-8]
80161d24:	e2833001 	add	r3, r3, #1
80161d28:	e50b3008 	str	r3, [fp, #-8]
80161d2c:	e51b2008 	ldr	r2, [fp, #-8]
80161d30:	e59b3008 	ldr	r3, [fp, #8]
80161d34:	e1520003 	cmp	r2, r3
80161d38:	3afffff1 	bcc	80161d04 <_RME_Cpt_Crt+0x4d0>
    }

    /* Header init */
    Cpt_Crt->Head.Root_Ref=0U;
80161d3c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161d40:	e3a02000 	mov	r2, #0
80161d44:	e5832004 	str	r2, [r3, #4]
    Cpt_Crt->Head.Object=Vaddr;
80161d48:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161d4c:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80161d50:	e583200c 	str	r2, [r3, #12]
    Cpt_Crt->Head.Flag=RME_CPT_FLAG_ALL;
80161d54:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161d58:	e3a020ff 	mov	r2, #255	@ 0xff
80161d5c:	e5832008 	str	r2, [r3, #8]
    
    /* Info init */
    Cpt_Crt->Entry_Num=Entry_Num;
80161d60:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161d64:	e59b2008 	ldr	r2, [fp, #8]
80161d68:	e5832014 	str	r2, [r3, #20]

    /* Establish cap */
    RME_WRITE_RELEASE(&(Cpt_Crt->Head.Type_Stat),
80161d6c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161d70:	e3a01403 	mov	r1, #50331648	@ 0x3000000
80161d74:	e1a00003 	mov	r0, r3
80161d78:	ebfffa63 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_CPT,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
80161d7c:	e3a03000 	mov	r3, #0
}
80161d80:	e1a00003 	mov	r0, r3
80161d84:	e24bd004 	sub	sp, fp, #4
80161d88:	e8bd8800 	pop	{fp, pc}

80161d8c <_RME_Cpt_Del>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Cpt_Del(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt_Del,
                              rme_cid_t Cap_Del)
{
80161d8c:	e92d4800 	push	{fp, lr}
80161d90:	e28db004 	add	fp, sp, #4
80161d94:	e24dd030 	sub	sp, sp, #48	@ 0x30
80161d98:	e50b0028 	str	r0, [fp, #-40]	@ 0xffffffd8
80161d9c:	e50b102c 	str	r1, [fp, #-44]	@ 0xffffffd4
80161da0:	e50b2030 	str	r2, [fp, #-48]	@ 0xffffffd0
    /* These are used for deletion */
    rme_ptr_t Object;
    rme_ptr_t Size;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Del,RME_CAP_TYPE_CPT,
80161da4:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161da8:	e2033080 	and	r3, r3, #128	@ 0x80
80161dac:	e3530000 	cmp	r3, #0
80161db0:	1a00001d 	bne	80161e2c <_RME_Cpt_Del+0xa0>
80161db4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161db8:	e5932014 	ldr	r2, [r3, #20]
80161dbc:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161dc0:	e1520003 	cmp	r2, r3
80161dc4:	8a000001 	bhi	80161dd0 <_RME_Cpt_Del+0x44>
80161dc8:	e3e03002 	mvn	r3, #2
80161dcc:	ea0000d8 	b	80162134 <_RME_Cpt_Del+0x3a8>
80161dd0:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161dd4:	e1a02283 	lsl	r2, r3, #5
80161dd8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161ddc:	e593300c 	ldr	r3, [r3, #12]
80161de0:	e0823003 	add	r3, r2, r3
80161de4:	e50b300c 	str	r3, [fp, #-12]
80161de8:	e51b300c 	ldr	r3, [fp, #-12]
80161dec:	e1a00003 	mov	r0, r3
80161df0:	ebfffa42 	bl	80160700 <__RME_A7A_Read_Acquire>
80161df4:	e50b0010 	str	r0, [fp, #-16]
80161df8:	e51b3010 	ldr	r3, [fp, #-16]
80161dfc:	e1a03823 	lsr	r3, r3, #16
80161e00:	e6ef3073 	uxtb	r3, r3
80161e04:	e3530002 	cmp	r3, #2
80161e08:	1a000001 	bne	80161e14 <_RME_Cpt_Del+0x88>
80161e0c:	e3e03008 	mvn	r3, #8
80161e10:	ea0000c7 	b	80162134 <_RME_Cpt_Del+0x3a8>
80161e14:	e51b3010 	ldr	r3, [fp, #-16]
80161e18:	e1a03c23 	lsr	r3, r3, #24
80161e1c:	e3530003 	cmp	r3, #3
80161e20:	0a000041 	beq	80161f2c <_RME_Cpt_Del+0x1a0>
80161e24:	e3e03001 	mvn	r3, #1
80161e28:	ea0000c1 	b	80162134 <_RME_Cpt_Del+0x3a8>
80161e2c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161e30:	e1a02423 	lsr	r2, r3, #8
80161e34:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161e38:	e5933014 	ldr	r3, [r3, #20]
80161e3c:	e1520003 	cmp	r2, r3
80161e40:	3a000001 	bcc	80161e4c <_RME_Cpt_Del+0xc0>
80161e44:	e3e03002 	mvn	r3, #2
80161e48:	ea0000b9 	b	80162134 <_RME_Cpt_Del+0x3a8>
80161e4c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161e50:	e1a03423 	lsr	r3, r3, #8
80161e54:	e1a02283 	lsl	r2, r3, #5
80161e58:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161e5c:	e593300c 	ldr	r3, [r3, #12]
80161e60:	e0823003 	add	r3, r2, r3
80161e64:	e50b300c 	str	r3, [fp, #-12]
80161e68:	e51b300c 	ldr	r3, [fp, #-12]
80161e6c:	e1a00003 	mov	r0, r3
80161e70:	ebfffa22 	bl	80160700 <__RME_A7A_Read_Acquire>
80161e74:	e50b0010 	str	r0, [fp, #-16]
80161e78:	e51b3010 	ldr	r3, [fp, #-16]
80161e7c:	e1a03823 	lsr	r3, r3, #16
80161e80:	e6ef3073 	uxtb	r3, r3
80161e84:	e3530002 	cmp	r3, #2
80161e88:	1a000001 	bne	80161e94 <_RME_Cpt_Del+0x108>
80161e8c:	e3e03008 	mvn	r3, #8
80161e90:	ea0000a7 	b	80162134 <_RME_Cpt_Del+0x3a8>
80161e94:	e51b3010 	ldr	r3, [fp, #-16]
80161e98:	e1a03c23 	lsr	r3, r3, #24
80161e9c:	e3530003 	cmp	r3, #3
80161ea0:	0a000001 	beq	80161eac <_RME_Cpt_Del+0x120>
80161ea4:	e3e03001 	mvn	r3, #1
80161ea8:	ea0000a1 	b	80162134 <_RME_Cpt_Del+0x3a8>
80161eac:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161eb0:	e203207f 	and	r2, r3, #127	@ 0x7f
80161eb4:	e51b300c 	ldr	r3, [fp, #-12]
80161eb8:	e5933014 	ldr	r3, [r3, #20]
80161ebc:	e1520003 	cmp	r2, r3
80161ec0:	3a000001 	bcc	80161ecc <_RME_Cpt_Del+0x140>
80161ec4:	e3e03002 	mvn	r3, #2
80161ec8:	ea000099 	b	80162134 <_RME_Cpt_Del+0x3a8>
80161ecc:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161ed0:	e203307f 	and	r3, r3, #127	@ 0x7f
80161ed4:	e1a02283 	lsl	r2, r3, #5
80161ed8:	e51b300c 	ldr	r3, [fp, #-12]
80161edc:	e593300c 	ldr	r3, [r3, #12]
80161ee0:	e0823003 	add	r3, r2, r3
80161ee4:	e50b300c 	str	r3, [fp, #-12]
80161ee8:	e51b300c 	ldr	r3, [fp, #-12]
80161eec:	e1a00003 	mov	r0, r3
80161ef0:	ebfffa02 	bl	80160700 <__RME_A7A_Read_Acquire>
80161ef4:	e50b0010 	str	r0, [fp, #-16]
80161ef8:	e51b3010 	ldr	r3, [fp, #-16]
80161efc:	e1a03823 	lsr	r3, r3, #16
80161f00:	e6ef3073 	uxtb	r3, r3
80161f04:	e3530002 	cmp	r3, #2
80161f08:	1a000001 	bne	80161f14 <_RME_Cpt_Del+0x188>
80161f0c:	e3e03008 	mvn	r3, #8
80161f10:	ea000087 	b	80162134 <_RME_Cpt_Del+0x3a8>
80161f14:	e51b3010 	ldr	r3, [fp, #-16]
80161f18:	e1a03c23 	lsr	r3, r3, #24
80161f1c:	e3530003 	cmp	r3, #3
80161f20:	0a000001 	beq	80161f2c <_RME_Cpt_Del+0x1a0>
80161f24:	e3e03001 	mvn	r3, #1
80161f28:	ea000081 	b	80162134 <_RME_Cpt_Del+0x3a8>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_DEL);
80161f2c:	e51b300c 	ldr	r3, [fp, #-12]
80161f30:	e5933008 	ldr	r3, [r3, #8]
80161f34:	e2033002 	and	r3, r3, #2
80161f38:	e3530000 	cmp	r3, #0
80161f3c:	1a000001 	bne	80161f48 <_RME_Cpt_Del+0x1bc>
80161f40:	e3e03006 	mvn	r3, #6
80161f44:	ea00007a 	b	80162134 <_RME_Cpt_Del+0x3a8>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Del,struct RME_Cap_Cpt*,Cpt_Del);
80161f48:	e51b300c 	ldr	r3, [fp, #-12]
80161f4c:	e5932014 	ldr	r2, [r3, #20]
80161f50:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80161f54:	e1520003 	cmp	r2, r3
80161f58:	8a000001 	bhi	80161f64 <_RME_Cpt_Del+0x1d8>
80161f5c:	e3e03002 	mvn	r3, #2
80161f60:	ea000073 	b	80162134 <_RME_Cpt_Del+0x3a8>
80161f64:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80161f68:	e1a02283 	lsl	r2, r3, #5
80161f6c:	e51b300c 	ldr	r3, [fp, #-12]
80161f70:	e593300c 	ldr	r3, [r3, #12]
80161f74:	e0823003 	add	r3, r2, r3
80161f78:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    /* Delete check */
    RME_CAP_DEL_CHECK(Cpt_Del,Type_Stat,RME_CAP_TYPE_CPT);
80161f7c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161f80:	e1a00003 	mov	r0, r3
80161f84:	ebfff9dd 	bl	80160700 <__RME_A7A_Read_Acquire>
80161f88:	e50b0010 	str	r0, [fp, #-16]
80161f8c:	e51b3010 	ldr	r3, [fp, #-16]
80161f90:	e1a03823 	lsr	r3, r3, #16
80161f94:	e6ef3073 	uxtb	r3, r3
80161f98:	e3530002 	cmp	r3, #2
80161f9c:	0a000001 	beq	80161fa8 <_RME_Cpt_Del+0x21c>
80161fa0:	e3e03008 	mvn	r3, #8
80161fa4:	ea000062 	b	80162134 <_RME_Cpt_Del+0x3a8>
80161fa8:	e51b3010 	ldr	r3, [fp, #-16]
80161fac:	e1a03c23 	lsr	r3, r3, #24
80161fb0:	e3530003 	cmp	r3, #3
80161fb4:	0a000001 	beq	80161fc0 <_RME_Cpt_Del+0x234>
80161fb8:	e3e03001 	mvn	r3, #1
80161fbc:	ea00005c 	b	80162134 <_RME_Cpt_Del+0x3a8>
80161fc0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161fc4:	e5933004 	ldr	r3, [r3, #4]
80161fc8:	e3530000 	cmp	r3, #0
80161fcc:	0a00000b 	beq	80162000 <_RME_Cpt_Del+0x274>
80161fd0:	e51b3010 	ldr	r3, [fp, #-16]
80161fd4:	e6ff3073 	uxth	r3, r3
80161fd8:	e3530000 	cmp	r3, #0
80161fdc:	1a000005 	bne	80161ff8 <_RME_Cpt_Del+0x26c>
80161fe0:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161fe4:	e51b3010 	ldr	r3, [fp, #-16]
80161fe8:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
80161fec:	e1a02003 	mov	r2, r3
80161ff0:	e51b1010 	ldr	r1, [fp, #-16]
80161ff4:	ebfffb03 	bl	80160c08 <_RME_Comp_Swap_Single>
80161ff8:	e3e03005 	mvn	r3, #5
80161ffc:	ea00004c 	b	80162134 <_RME_Cpt_Del+0x3a8>
80162000:	e51b3010 	ldr	r3, [fp, #-16]
80162004:	e6ff3073 	uxth	r3, r3
80162008:	e3530000 	cmp	r3, #0
8016200c:	0a000008 	beq	80162034 <_RME_Cpt_Del+0x2a8>
80162010:	e30c3318 	movw	r3, #49944	@ 0xc318
80162014:	e3483016 	movt	r3, #32790	@ 0x8016
80162018:	e30c2324 	movw	r2, #49956	@ 0xc324
8016201c:	e3482016 	movt	r2, #32790	@ 0x8016
80162020:	e30017f5 	movw	r1, #2037	@ 0x7f5
80162024:	e30c0330 	movw	r0, #49968	@ 0xc330
80162028:	e3480016 	movt	r0, #32790	@ 0x8016
8016202c:	ebfffad4 	bl	80160b84 <RME_Log>
80162030:	eafffffe 	b	80162030 <_RME_Cpt_Del+0x2a4>
    /* Is there any capability in this capability table? If yes, we cannot destroy it.
     * We will check every slot to make sure nothing is there. This is surely,
     * predictable but not so perfect. So, if the time of such operations is to be 
     * bounded, the user must control the maximum number of entries in the table
     * by configuring RME_CPT_ENTRY_MAX to a non-zero value. */
    Table=RME_CAP_GETOBJ(Cpt_Del,struct RME_Cap_Struct*);
80162034:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162038:	e593300c 	ldr	r3, [r3, #12]
8016203c:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Entry_Num=Cpt_Del->Entry_Num;
80162040:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162044:	e5933014 	ldr	r3, [r3, #20]
80162048:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    for(Count=0U;Count<Entry_Num;Count++)
8016204c:	e3a03000 	mov	r3, #0
80162050:	e50b3008 	str	r3, [fp, #-8]
80162054:	ea000011 	b	801620a0 <_RME_Cpt_Del+0x314>
    {
        if(Table[Count].Head.Type_Stat!=0U)
80162058:	e51b3008 	ldr	r3, [fp, #-8]
8016205c:	e1a03283 	lsl	r3, r3, #5
80162060:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80162064:	e0823003 	add	r3, r2, r3
80162068:	e5933000 	ldr	r3, [r3]
8016206c:	e3530000 	cmp	r3, #0
80162070:	0a000007 	beq	80162094 <_RME_Cpt_Del+0x308>
        {
            RME_COV_MARKER();
            
            RME_CAP_DEFROST(Cpt_Del,Type_Stat);
80162074:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80162078:	e51b3010 	ldr	r3, [fp, #-16]
8016207c:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
80162080:	e1a02003 	mov	r2, r3
80162084:	e51b1010 	ldr	r1, [fp, #-16]
80162088:	ebfffade 	bl	80160c08 <_RME_Comp_Swap_Single>
            return RME_ERR_CPT_EXIST;
8016208c:	e3e03004 	mvn	r3, #4
80162090:	ea000027 	b	80162134 <_RME_Cpt_Del+0x3a8>
    for(Count=0U;Count<Entry_Num;Count++)
80162094:	e51b3008 	ldr	r3, [fp, #-8]
80162098:	e2833001 	add	r3, r3, #1
8016209c:	e50b3008 	str	r3, [fp, #-8]
801620a0:	e51b2008 	ldr	r2, [fp, #-8]
801620a4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801620a8:	e1520003 	cmp	r2, r3
801620ac:	3affffe9 	bcc	80162058 <_RME_Cpt_Del+0x2cc>
            /* No action required */
        }
    }
    
    /* Remember these two variables for deletion */
    Object=RME_CAP_GETOBJ(Cpt_Del,rme_ptr_t);
801620b0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801620b4:	e593300c 	ldr	r3, [r3, #12]
801620b8:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
    Size=RME_CPT_SIZE(Cpt_Del->Entry_Num);
801620bc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801620c0:	e5933014 	ldr	r3, [r3, #20]
801620c4:	e1a03283 	lsl	r3, r3, #5
801620c8:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc

    /* Now we can safely delete the cap */
    RME_CAP_DELETE(Cpt_Del,Type_Stat);
801620cc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801620d0:	e3a02000 	mov	r2, #0
801620d4:	e51b1010 	ldr	r1, [fp, #-16]
801620d8:	e1a00003 	mov	r0, r3
801620dc:	ebfffac9 	bl	80160c08 <_RME_Comp_Swap_Single>
801620e0:	e1a03000 	mov	r3, r0
801620e4:	e3530000 	cmp	r3, #0
801620e8:	1a000001 	bne	801620f4 <_RME_Cpt_Del+0x368>
801620ec:	e3e03000 	mvn	r3, #0
801620f0:	ea00000f 	b	80162134 <_RME_Cpt_Del+0x3a8>

    /* Try to depopulate the area - this must be successful */
    RME_ASSERT(_RME_Kot_Erase(Object,Size)==0);
801620f4:	e51b1024 	ldr	r1, [fp, #-36]	@ 0xffffffdc
801620f8:	e51b0020 	ldr	r0, [fp, #-32]	@ 0xffffffe0
801620fc:	eb000ae1 	bl	80164c88 <_RME_Kot_Erase>
80162100:	e1a03000 	mov	r3, r0
80162104:	e3530000 	cmp	r3, #0
80162108:	0a000008 	beq	80162130 <_RME_Cpt_Del+0x3a4>
8016210c:	e30c3318 	movw	r3, #49944	@ 0xc318
80162110:	e3483016 	movt	r3, #32790	@ 0x8016
80162114:	e30c2324 	movw	r2, #49956	@ 0xc324
80162118:	e3482016 	movt	r2, #32790	@ 0x8016
8016211c:	e3001816 	movw	r1, #2070	@ 0x816
80162120:	e30c0330 	movw	r0, #49968	@ 0xc330
80162124:	e3480016 	movt	r0, #32790	@ 0x8016
80162128:	ebfffa95 	bl	80160b84 <RME_Log>
8016212c:	eafffffe 	b	8016212c <_RME_Cpt_Del+0x3a0>
    
    return 0;
80162130:	e3a03000 	mov	r3, #0
}
80162134:	e1a00003 	mov	r0, r3
80162138:	e24bd004 	sub	sp, fp, #4
8016213c:	e8bd8800 	pop	{fp, pc}

80162140 <_RME_Cpt_Frz>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Cpt_Frz(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt_Frz,
                              rme_cid_t Cap_Frz)
{
80162140:	e92d4800 	push	{fp, lr}
80162144:	e28db004 	add	fp, sp, #4
80162148:	e24dd020 	sub	sp, sp, #32
8016214c:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80162150:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
80162154:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    struct RME_Cap_Cpt* Cpt_Op;
    volatile struct RME_Cap_Struct* Capobj_Frz;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Frz,RME_CAP_TYPE_CPT,
80162158:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016215c:	e2033080 	and	r3, r3, #128	@ 0x80
80162160:	e3530000 	cmp	r3, #0
80162164:	1a00001d 	bne	801621e0 <_RME_Cpt_Frz+0xa0>
80162168:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016216c:	e5932014 	ldr	r2, [r3, #20]
80162170:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162174:	e1520003 	cmp	r2, r3
80162178:	8a000001 	bhi	80162184 <_RME_Cpt_Frz+0x44>
8016217c:	e3e03002 	mvn	r3, #2
80162180:	ea000092 	b	801623d0 <_RME_Cpt_Frz+0x290>
80162184:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162188:	e1a02283 	lsl	r2, r3, #5
8016218c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80162190:	e593300c 	ldr	r3, [r3, #12]
80162194:	e0823003 	add	r3, r2, r3
80162198:	e50b3008 	str	r3, [fp, #-8]
8016219c:	e51b3008 	ldr	r3, [fp, #-8]
801621a0:	e1a00003 	mov	r0, r3
801621a4:	ebfff955 	bl	80160700 <__RME_A7A_Read_Acquire>
801621a8:	e50b000c 	str	r0, [fp, #-12]
801621ac:	e51b300c 	ldr	r3, [fp, #-12]
801621b0:	e1a03823 	lsr	r3, r3, #16
801621b4:	e6ef3073 	uxtb	r3, r3
801621b8:	e3530002 	cmp	r3, #2
801621bc:	1a000001 	bne	801621c8 <_RME_Cpt_Frz+0x88>
801621c0:	e3e03008 	mvn	r3, #8
801621c4:	ea000081 	b	801623d0 <_RME_Cpt_Frz+0x290>
801621c8:	e51b300c 	ldr	r3, [fp, #-12]
801621cc:	e1a03c23 	lsr	r3, r3, #24
801621d0:	e3530003 	cmp	r3, #3
801621d4:	0a000041 	beq	801622e0 <_RME_Cpt_Frz+0x1a0>
801621d8:	e3e03001 	mvn	r3, #1
801621dc:	ea00007b 	b	801623d0 <_RME_Cpt_Frz+0x290>
801621e0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801621e4:	e1a02423 	lsr	r2, r3, #8
801621e8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801621ec:	e5933014 	ldr	r3, [r3, #20]
801621f0:	e1520003 	cmp	r2, r3
801621f4:	3a000001 	bcc	80162200 <_RME_Cpt_Frz+0xc0>
801621f8:	e3e03002 	mvn	r3, #2
801621fc:	ea000073 	b	801623d0 <_RME_Cpt_Frz+0x290>
80162200:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162204:	e1a03423 	lsr	r3, r3, #8
80162208:	e1a02283 	lsl	r2, r3, #5
8016220c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80162210:	e593300c 	ldr	r3, [r3, #12]
80162214:	e0823003 	add	r3, r2, r3
80162218:	e50b3008 	str	r3, [fp, #-8]
8016221c:	e51b3008 	ldr	r3, [fp, #-8]
80162220:	e1a00003 	mov	r0, r3
80162224:	ebfff935 	bl	80160700 <__RME_A7A_Read_Acquire>
80162228:	e50b000c 	str	r0, [fp, #-12]
8016222c:	e51b300c 	ldr	r3, [fp, #-12]
80162230:	e1a03823 	lsr	r3, r3, #16
80162234:	e6ef3073 	uxtb	r3, r3
80162238:	e3530002 	cmp	r3, #2
8016223c:	1a000001 	bne	80162248 <_RME_Cpt_Frz+0x108>
80162240:	e3e03008 	mvn	r3, #8
80162244:	ea000061 	b	801623d0 <_RME_Cpt_Frz+0x290>
80162248:	e51b300c 	ldr	r3, [fp, #-12]
8016224c:	e1a03c23 	lsr	r3, r3, #24
80162250:	e3530003 	cmp	r3, #3
80162254:	0a000001 	beq	80162260 <_RME_Cpt_Frz+0x120>
80162258:	e3e03001 	mvn	r3, #1
8016225c:	ea00005b 	b	801623d0 <_RME_Cpt_Frz+0x290>
80162260:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162264:	e203207f 	and	r2, r3, #127	@ 0x7f
80162268:	e51b3008 	ldr	r3, [fp, #-8]
8016226c:	e5933014 	ldr	r3, [r3, #20]
80162270:	e1520003 	cmp	r2, r3
80162274:	3a000001 	bcc	80162280 <_RME_Cpt_Frz+0x140>
80162278:	e3e03002 	mvn	r3, #2
8016227c:	ea000053 	b	801623d0 <_RME_Cpt_Frz+0x290>
80162280:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162284:	e203307f 	and	r3, r3, #127	@ 0x7f
80162288:	e1a02283 	lsl	r2, r3, #5
8016228c:	e51b3008 	ldr	r3, [fp, #-8]
80162290:	e593300c 	ldr	r3, [r3, #12]
80162294:	e0823003 	add	r3, r2, r3
80162298:	e50b3008 	str	r3, [fp, #-8]
8016229c:	e51b3008 	ldr	r3, [fp, #-8]
801622a0:	e1a00003 	mov	r0, r3
801622a4:	ebfff915 	bl	80160700 <__RME_A7A_Read_Acquire>
801622a8:	e50b000c 	str	r0, [fp, #-12]
801622ac:	e51b300c 	ldr	r3, [fp, #-12]
801622b0:	e1a03823 	lsr	r3, r3, #16
801622b4:	e6ef3073 	uxtb	r3, r3
801622b8:	e3530002 	cmp	r3, #2
801622bc:	1a000001 	bne	801622c8 <_RME_Cpt_Frz+0x188>
801622c0:	e3e03008 	mvn	r3, #8
801622c4:	ea000041 	b	801623d0 <_RME_Cpt_Frz+0x290>
801622c8:	e51b300c 	ldr	r3, [fp, #-12]
801622cc:	e1a03c23 	lsr	r3, r3, #24
801622d0:	e3530003 	cmp	r3, #3
801622d4:	0a000001 	beq	801622e0 <_RME_Cpt_Frz+0x1a0>
801622d8:	e3e03001 	mvn	r3, #1
801622dc:	ea00003b 	b	801623d0 <_RME_Cpt_Frz+0x290>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_FRZ);
801622e0:	e51b3008 	ldr	r3, [fp, #-8]
801622e4:	e5933008 	ldr	r3, [r3, #8]
801622e8:	e2033004 	and	r3, r3, #4
801622ec:	e3530000 	cmp	r3, #0
801622f0:	1a000001 	bne	801622fc <_RME_Cpt_Frz+0x1bc>
801622f4:	e3e03006 	mvn	r3, #6
801622f8:	ea000034 	b	801623d0 <_RME_Cpt_Frz+0x290>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Frz,struct RME_Cap_Struct*,Capobj_Frz);
801622fc:	e51b3008 	ldr	r3, [fp, #-8]
80162300:	e5932014 	ldr	r2, [r3, #20]
80162304:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162308:	e1520003 	cmp	r2, r3
8016230c:	8a000001 	bhi	80162318 <_RME_Cpt_Frz+0x1d8>
80162310:	e3e03002 	mvn	r3, #2
80162314:	ea00002d 	b	801623d0 <_RME_Cpt_Frz+0x290>
80162318:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016231c:	e1a02283 	lsl	r2, r3, #5
80162320:	e51b3008 	ldr	r3, [fp, #-8]
80162324:	e593300c 	ldr	r3, [r3, #12]
80162328:	e0823003 	add	r3, r2, r3
8016232c:	e50b3010 	str	r3, [fp, #-16]
    
    /* Check if anything is there. If nothing there, the Type_Stat must be 0. 
     * Need a read acquire barrier here to avoid stale reads below. */
    Type_Stat=RME_READ_ACQUIRE(&(Capobj_Frz->Head.Type_Stat));
80162330:	e51b3010 	ldr	r3, [fp, #-16]
80162334:	e1a00003 	mov	r0, r3
80162338:	ebfff8f0 	bl	80160700 <__RME_A7A_Read_Acquire>
8016233c:	e50b000c 	str	r0, [fp, #-12]
    /* See if there is a cap */
    if(RME_CAP_TYPE(Type_Stat)==RME_CAP_TYPE_NOP)
80162340:	e51b300c 	ldr	r3, [fp, #-12]
80162344:	e1a03c23 	lsr	r3, r3, #24
80162348:	e3530000 	cmp	r3, #0
8016234c:	1a000001 	bne	80162358 <_RME_Cpt_Frz+0x218>
    {
        RME_COV_MARKER();
        
        return RME_ERR_CPT_NULL;
80162350:	e3e03000 	mvn	r3, #0
80162354:	ea00001d 	b	801623d0 <_RME_Cpt_Frz+0x290>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* If this is a root capability, check if the reference count allows freezing */
    if(RME_CAP_ATTR(Type_Stat)==RME_CAP_ATTR_ROOT)
80162358:	e51b300c 	ldr	r3, [fp, #-12]
8016235c:	e6ff3073 	uxth	r3, r3
80162360:	e3530000 	cmp	r3, #0
80162364:	1a000005 	bne	80162380 <_RME_Cpt_Frz+0x240>
    {
        if(Capobj_Frz->Head.Root_Ref!=0U)
80162368:	e51b3010 	ldr	r3, [fp, #-16]
8016236c:	e5933004 	ldr	r3, [r3, #4]
80162370:	e3530000 	cmp	r3, #0
80162374:	0a000001 	beq	80162380 <_RME_Cpt_Frz+0x240>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_REFCNT;
80162378:	e3e03005 	mvn	r3, #5
8016237c:	ea000013 	b	801623d0 <_RME_Cpt_Frz+0x290>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* The capability is already frozen - why do it again? */
    if(RME_CAP_STAT(Type_Stat)==RME_CAP_STAT_FROZEN)
80162380:	e51b300c 	ldr	r3, [fp, #-12]
80162384:	e1a03823 	lsr	r3, r3, #16
80162388:	e6ef3073 	uxtb	r3, r3
8016238c:	e3530002 	cmp	r3, #2
80162390:	1a000001 	bne	8016239c <_RME_Cpt_Frz+0x25c>
    {
        RME_COV_MARKER();
        
        return RME_ERR_CPT_FROZEN;
80162394:	e3e03008 	mvn	r3, #8
80162398:	ea00000c 	b	801623d0 <_RME_Cpt_Frz+0x290>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Update the timestamp */
    Capobj_Frz->Head.Timestamp=RME_TIMESTAMP;
8016239c:	e30d3000 	movw	r3, #53248	@ 0xd000
801623a0:	e3483016 	movt	r3, #32790	@ 0x8016
801623a4:	e5932000 	ldr	r2, [r3]
801623a8:	e51b3010 	ldr	r3, [fp, #-16]
801623ac:	e5832010 	str	r2, [r3, #16]
    
    /* Finally, freeze it. We do not report error here because if we CASFAIL someone must have helped us */
    RME_COMP_SWAP(&(Capobj_Frz->Head.Type_Stat),Type_Stat,
801623b0:	e51b0010 	ldr	r0, [fp, #-16]
801623b4:	e51b300c 	ldr	r3, [fp, #-12]
801623b8:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
801623bc:	e3833802 	orr	r3, r3, #131072	@ 0x20000
801623c0:	e1a02003 	mov	r2, r3
801623c4:	e51b100c 	ldr	r1, [fp, #-12]
801623c8:	ebfffa0e 	bl	80160c08 <_RME_Comp_Swap_Single>
                  RME_CAP_TYPE_STAT(RME_CAP_TYPE(Type_Stat),
                                    RME_CAP_STAT_FROZEN,
                                    RME_CAP_ATTR(Type_Stat)));

    return 0;
801623cc:	e3a03000 	mov	r3, #0
}
801623d0:	e1a00003 	mov	r0, r3
801623d4:	e24bd004 	sub	sp, fp, #4
801623d8:	e8bd8800 	pop	{fp, pc}

801623dc <_RME_Cpt_Add>:
                              rme_cid_t Cap_Dst, 
                              rme_cid_t Cap_Cpt_Src,
                              rme_cid_t Cap_Src,
                              rme_ptr_t Flag,
                              rme_ptr_t Ext_Flag)
{
801623dc:	e92d4800 	push	{fp, lr}
801623e0:	e28db004 	add	fp, sp, #4
801623e4:	e24dd038 	sub	sp, sp, #56	@ 0x38
801623e8:	e50b0030 	str	r0, [fp, #-48]	@ 0xffffffd0
801623ec:	e50b1034 	str	r1, [fp, #-52]	@ 0xffffffcc
801623f0:	e50b2038 	str	r2, [fp, #-56]	@ 0xffffffc8
801623f4:	e50b303c 	str	r3, [fp, #-60]	@ 0xffffffc4
    rme_ptr_t Kom_Begin;
    rme_ptr_t Kom_End;
    rme_ptr_t Kom_Flag;

    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Dst,RME_CAP_TYPE_CPT,
801623f8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801623fc:	e2033080 	and	r3, r3, #128	@ 0x80
80162400:	e3530000 	cmp	r3, #0
80162404:	1a00001d 	bne	80162480 <_RME_Cpt_Add+0xa4>
80162408:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016240c:	e5932014 	ldr	r2, [r3, #20]
80162410:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80162414:	e1520003 	cmp	r2, r3
80162418:	8a000001 	bhi	80162424 <_RME_Cpt_Add+0x48>
8016241c:	e3e03002 	mvn	r3, #2
80162420:	ea000209 	b	80162c4c <_RME_Cpt_Add+0x870>
80162424:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80162428:	e1a02283 	lsl	r2, r3, #5
8016242c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80162430:	e593300c 	ldr	r3, [r3, #12]
80162434:	e0823003 	add	r3, r2, r3
80162438:	e50b3008 	str	r3, [fp, #-8]
8016243c:	e51b3008 	ldr	r3, [fp, #-8]
80162440:	e1a00003 	mov	r0, r3
80162444:	ebfff8ad 	bl	80160700 <__RME_A7A_Read_Acquire>
80162448:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
8016244c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162450:	e1a03823 	lsr	r3, r3, #16
80162454:	e6ef3073 	uxtb	r3, r3
80162458:	e3530002 	cmp	r3, #2
8016245c:	1a000001 	bne	80162468 <_RME_Cpt_Add+0x8c>
80162460:	e3e03008 	mvn	r3, #8
80162464:	ea0001f8 	b	80162c4c <_RME_Cpt_Add+0x870>
80162468:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016246c:	e1a03c23 	lsr	r3, r3, #24
80162470:	e3530003 	cmp	r3, #3
80162474:	0a000041 	beq	80162580 <_RME_Cpt_Add+0x1a4>
80162478:	e3e03001 	mvn	r3, #1
8016247c:	ea0001f2 	b	80162c4c <_RME_Cpt_Add+0x870>
80162480:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80162484:	e1a02423 	lsr	r2, r3, #8
80162488:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016248c:	e5933014 	ldr	r3, [r3, #20]
80162490:	e1520003 	cmp	r2, r3
80162494:	3a000001 	bcc	801624a0 <_RME_Cpt_Add+0xc4>
80162498:	e3e03002 	mvn	r3, #2
8016249c:	ea0001ea 	b	80162c4c <_RME_Cpt_Add+0x870>
801624a0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801624a4:	e1a03423 	lsr	r3, r3, #8
801624a8:	e1a02283 	lsl	r2, r3, #5
801624ac:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801624b0:	e593300c 	ldr	r3, [r3, #12]
801624b4:	e0823003 	add	r3, r2, r3
801624b8:	e50b3008 	str	r3, [fp, #-8]
801624bc:	e51b3008 	ldr	r3, [fp, #-8]
801624c0:	e1a00003 	mov	r0, r3
801624c4:	ebfff88d 	bl	80160700 <__RME_A7A_Read_Acquire>
801624c8:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
801624cc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801624d0:	e1a03823 	lsr	r3, r3, #16
801624d4:	e6ef3073 	uxtb	r3, r3
801624d8:	e3530002 	cmp	r3, #2
801624dc:	1a000001 	bne	801624e8 <_RME_Cpt_Add+0x10c>
801624e0:	e3e03008 	mvn	r3, #8
801624e4:	ea0001d8 	b	80162c4c <_RME_Cpt_Add+0x870>
801624e8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801624ec:	e1a03c23 	lsr	r3, r3, #24
801624f0:	e3530003 	cmp	r3, #3
801624f4:	0a000001 	beq	80162500 <_RME_Cpt_Add+0x124>
801624f8:	e3e03001 	mvn	r3, #1
801624fc:	ea0001d2 	b	80162c4c <_RME_Cpt_Add+0x870>
80162500:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80162504:	e203207f 	and	r2, r3, #127	@ 0x7f
80162508:	e51b3008 	ldr	r3, [fp, #-8]
8016250c:	e5933014 	ldr	r3, [r3, #20]
80162510:	e1520003 	cmp	r2, r3
80162514:	3a000001 	bcc	80162520 <_RME_Cpt_Add+0x144>
80162518:	e3e03002 	mvn	r3, #2
8016251c:	ea0001ca 	b	80162c4c <_RME_Cpt_Add+0x870>
80162520:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80162524:	e203307f 	and	r3, r3, #127	@ 0x7f
80162528:	e1a02283 	lsl	r2, r3, #5
8016252c:	e51b3008 	ldr	r3, [fp, #-8]
80162530:	e593300c 	ldr	r3, [r3, #12]
80162534:	e0823003 	add	r3, r2, r3
80162538:	e50b3008 	str	r3, [fp, #-8]
8016253c:	e51b3008 	ldr	r3, [fp, #-8]
80162540:	e1a00003 	mov	r0, r3
80162544:	ebfff86d 	bl	80160700 <__RME_A7A_Read_Acquire>
80162548:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
8016254c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162550:	e1a03823 	lsr	r3, r3, #16
80162554:	e6ef3073 	uxtb	r3, r3
80162558:	e3530002 	cmp	r3, #2
8016255c:	1a000001 	bne	80162568 <_RME_Cpt_Add+0x18c>
80162560:	e3e03008 	mvn	r3, #8
80162564:	ea0001b8 	b	80162c4c <_RME_Cpt_Add+0x870>
80162568:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016256c:	e1a03c23 	lsr	r3, r3, #24
80162570:	e3530003 	cmp	r3, #3
80162574:	0a000001 	beq	80162580 <_RME_Cpt_Add+0x1a4>
80162578:	e3e03001 	mvn	r3, #1
8016257c:	ea0001b2 	b	80162c4c <_RME_Cpt_Add+0x870>
                   struct RME_Cap_Cpt*,Cpt_Dst,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Src,RME_CAP_TYPE_CPT,
80162580:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80162584:	e2033080 	and	r3, r3, #128	@ 0x80
80162588:	e3530000 	cmp	r3, #0
8016258c:	1a00001d 	bne	80162608 <_RME_Cpt_Add+0x22c>
80162590:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80162594:	e5932014 	ldr	r2, [r3, #20]
80162598:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
8016259c:	e1520003 	cmp	r2, r3
801625a0:	8a000001 	bhi	801625ac <_RME_Cpt_Add+0x1d0>
801625a4:	e3e03002 	mvn	r3, #2
801625a8:	ea0001a7 	b	80162c4c <_RME_Cpt_Add+0x870>
801625ac:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
801625b0:	e1a02283 	lsl	r2, r3, #5
801625b4:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801625b8:	e593300c 	ldr	r3, [r3, #12]
801625bc:	e0823003 	add	r3, r2, r3
801625c0:	e50b300c 	str	r3, [fp, #-12]
801625c4:	e51b300c 	ldr	r3, [fp, #-12]
801625c8:	e1a00003 	mov	r0, r3
801625cc:	ebfff84b 	bl	80160700 <__RME_A7A_Read_Acquire>
801625d0:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
801625d4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801625d8:	e1a03823 	lsr	r3, r3, #16
801625dc:	e6ef3073 	uxtb	r3, r3
801625e0:	e3530002 	cmp	r3, #2
801625e4:	1a000001 	bne	801625f0 <_RME_Cpt_Add+0x214>
801625e8:	e3e03008 	mvn	r3, #8
801625ec:	ea000196 	b	80162c4c <_RME_Cpt_Add+0x870>
801625f0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801625f4:	e1a03c23 	lsr	r3, r3, #24
801625f8:	e3530003 	cmp	r3, #3
801625fc:	0a000041 	beq	80162708 <_RME_Cpt_Add+0x32c>
80162600:	e3e03001 	mvn	r3, #1
80162604:	ea000190 	b	80162c4c <_RME_Cpt_Add+0x870>
80162608:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
8016260c:	e1a02423 	lsr	r2, r3, #8
80162610:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80162614:	e5933014 	ldr	r3, [r3, #20]
80162618:	e1520003 	cmp	r2, r3
8016261c:	3a000001 	bcc	80162628 <_RME_Cpt_Add+0x24c>
80162620:	e3e03002 	mvn	r3, #2
80162624:	ea000188 	b	80162c4c <_RME_Cpt_Add+0x870>
80162628:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
8016262c:	e1a03423 	lsr	r3, r3, #8
80162630:	e1a02283 	lsl	r2, r3, #5
80162634:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80162638:	e593300c 	ldr	r3, [r3, #12]
8016263c:	e0823003 	add	r3, r2, r3
80162640:	e50b300c 	str	r3, [fp, #-12]
80162644:	e51b300c 	ldr	r3, [fp, #-12]
80162648:	e1a00003 	mov	r0, r3
8016264c:	ebfff82b 	bl	80160700 <__RME_A7A_Read_Acquire>
80162650:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
80162654:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162658:	e1a03823 	lsr	r3, r3, #16
8016265c:	e6ef3073 	uxtb	r3, r3
80162660:	e3530002 	cmp	r3, #2
80162664:	1a000001 	bne	80162670 <_RME_Cpt_Add+0x294>
80162668:	e3e03008 	mvn	r3, #8
8016266c:	ea000176 	b	80162c4c <_RME_Cpt_Add+0x870>
80162670:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162674:	e1a03c23 	lsr	r3, r3, #24
80162678:	e3530003 	cmp	r3, #3
8016267c:	0a000001 	beq	80162688 <_RME_Cpt_Add+0x2ac>
80162680:	e3e03001 	mvn	r3, #1
80162684:	ea000170 	b	80162c4c <_RME_Cpt_Add+0x870>
80162688:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
8016268c:	e203207f 	and	r2, r3, #127	@ 0x7f
80162690:	e51b300c 	ldr	r3, [fp, #-12]
80162694:	e5933014 	ldr	r3, [r3, #20]
80162698:	e1520003 	cmp	r2, r3
8016269c:	3a000001 	bcc	801626a8 <_RME_Cpt_Add+0x2cc>
801626a0:	e3e03002 	mvn	r3, #2
801626a4:	ea000168 	b	80162c4c <_RME_Cpt_Add+0x870>
801626a8:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
801626ac:	e203307f 	and	r3, r3, #127	@ 0x7f
801626b0:	e1a02283 	lsl	r2, r3, #5
801626b4:	e51b300c 	ldr	r3, [fp, #-12]
801626b8:	e593300c 	ldr	r3, [r3, #12]
801626bc:	e0823003 	add	r3, r2, r3
801626c0:	e50b300c 	str	r3, [fp, #-12]
801626c4:	e51b300c 	ldr	r3, [fp, #-12]
801626c8:	e1a00003 	mov	r0, r3
801626cc:	ebfff80b 	bl	80160700 <__RME_A7A_Read_Acquire>
801626d0:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
801626d4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801626d8:	e1a03823 	lsr	r3, r3, #16
801626dc:	e6ef3073 	uxtb	r3, r3
801626e0:	e3530002 	cmp	r3, #2
801626e4:	1a000001 	bne	801626f0 <_RME_Cpt_Add+0x314>
801626e8:	e3e03008 	mvn	r3, #8
801626ec:	ea000156 	b	80162c4c <_RME_Cpt_Add+0x870>
801626f0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801626f4:	e1a03c23 	lsr	r3, r3, #24
801626f8:	e3530003 	cmp	r3, #3
801626fc:	0a000001 	beq	80162708 <_RME_Cpt_Add+0x32c>
80162700:	e3e03001 	mvn	r3, #1
80162704:	ea000150 	b	80162c4c <_RME_Cpt_Add+0x870>
                   struct RME_Cap_Cpt*,Cpt_Src,Type_Stat);
    /* Check if both captbls are not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Dst,RME_CPT_FLAG_ADD_DST);
80162708:	e51b3008 	ldr	r3, [fp, #-8]
8016270c:	e5933008 	ldr	r3, [r3, #8]
80162710:	e2033010 	and	r3, r3, #16
80162714:	e3530000 	cmp	r3, #0
80162718:	1a000001 	bne	80162724 <_RME_Cpt_Add+0x348>
8016271c:	e3e03006 	mvn	r3, #6
80162720:	ea000149 	b	80162c4c <_RME_Cpt_Add+0x870>
    RME_CAP_CHECK(Cpt_Src,RME_CPT_FLAG_ADD_SRC);
80162724:	e51b300c 	ldr	r3, [fp, #-12]
80162728:	e5933008 	ldr	r3, [r3, #8]
8016272c:	e2033008 	and	r3, r3, #8
80162730:	e3530000 	cmp	r3, #0
80162734:	1a000001 	bne	80162740 <_RME_Cpt_Add+0x364>
80162738:	e3e03006 	mvn	r3, #6
8016273c:	ea000142 	b	80162c4c <_RME_Cpt_Add+0x870>
    
    /* Get the cap slots */
    RME_CPT_GETSLOT(Cpt_Dst,Cap_Dst,struct RME_Cap_Struct*,Capobj_Dst);
80162740:	e51b3008 	ldr	r3, [fp, #-8]
80162744:	e5932014 	ldr	r2, [r3, #20]
80162748:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
8016274c:	e1520003 	cmp	r2, r3
80162750:	8a000001 	bhi	8016275c <_RME_Cpt_Add+0x380>
80162754:	e3e03002 	mvn	r3, #2
80162758:	ea00013b 	b	80162c4c <_RME_Cpt_Add+0x870>
8016275c:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80162760:	e1a02283 	lsl	r2, r3, #5
80162764:	e51b3008 	ldr	r3, [fp, #-8]
80162768:	e593300c 	ldr	r3, [r3, #12]
8016276c:	e0823003 	add	r3, r2, r3
80162770:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
    RME_CPT_GETSLOT(Cpt_Src,Cap_Src,struct RME_Cap_Struct*,Capobj_Src);
80162774:	e51b300c 	ldr	r3, [fp, #-12]
80162778:	e5932014 	ldr	r2, [r3, #20]
8016277c:	e59b3004 	ldr	r3, [fp, #4]
80162780:	e1520003 	cmp	r2, r3
80162784:	8a000001 	bhi	80162790 <_RME_Cpt_Add+0x3b4>
80162788:	e3e03002 	mvn	r3, #2
8016278c:	ea00012e 	b	80162c4c <_RME_Cpt_Add+0x870>
80162790:	e59b3004 	ldr	r3, [fp, #4]
80162794:	e1a02283 	lsl	r2, r3, #5
80162798:	e51b300c 	ldr	r3, [fp, #-12]
8016279c:	e593300c 	ldr	r3, [r3, #12]
801627a0:	e0823003 	add	r3, r2, r3
801627a4:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    
    /* Atomic read - Read barrier to avoid premature checking of the rest */
    Type_Stat=RME_READ_ACQUIRE(&(Capobj_Src->Head.Type_Stat));
801627a8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801627ac:	e1a00003 	mov	r0, r3
801627b0:	ebfff7d2 	bl	80160700 <__RME_A7A_Read_Acquire>
801627b4:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
    /* Is the source cap frozen? */
    if(RME_CAP_STAT(Type_Stat)==RME_CAP_STAT_FROZEN)
801627b8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801627bc:	e1a03823 	lsr	r3, r3, #16
801627c0:	e6ef3073 	uxtb	r3, r3
801627c4:	e3530002 	cmp	r3, #2
801627c8:	1a000001 	bne	801627d4 <_RME_Cpt_Add+0x3f8>
    {
        RME_COV_MARKER();
        
        return RME_ERR_CPT_FROZEN;
801627cc:	e3e03008 	mvn	r3, #8
801627d0:	ea00011d 	b	80162c4c <_RME_Cpt_Add+0x870>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Does the source cap exist at all? */
    if(Type_Stat==0U)
801627d4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801627d8:	e3530000 	cmp	r3, #0
801627dc:	1a000001 	bne	801627e8 <_RME_Cpt_Add+0x40c>
    {
        RME_COV_MARKER();
        
        return RME_ERR_CPT_NULL;
801627e0:	e3e03000 	mvn	r3, #0
801627e4:	ea000118 	b	80162c4c <_RME_Cpt_Add+0x870>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Dewarn some compilers that complain about uninitialized variables */
    Kom_Begin=0U;
801627e8:	e3a03000 	mov	r3, #0
801627ec:	e50b3010 	str	r3, [fp, #-16]
    Kom_End=0U;
801627f0:	e3a03000 	mov	r3, #0
801627f4:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Kom_Flag=0U;
801627f8:	e3a03000 	mov	r3, #0
801627fc:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    
    /* Is there a flag conflict? - For page tables, we have different checking mechanisms */
    Src_Type=RME_CAP_TYPE(Type_Stat);
80162800:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162804:	e1a03c23 	lsr	r3, r3, #24
80162808:	e50b3028 	str	r3, [fp, #-40]	@ 0xffffffd8
    if(Src_Type==RME_CAP_TYPE_PGT)
8016280c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162810:	e3530004 	cmp	r3, #4
80162814:	1a00002d 	bne	801628d0 <_RME_Cpt_Add+0x4f4>
    {
        RME_COV_MARKER();
        
        /* Check the delegation range */
        if(RME_PGT_FLAG_HIGH(Flag)>RME_PGT_FLAG_HIGH(Capobj_Src->Head.Flag))
80162818:	e59b3008 	ldr	r3, [fp, #8]
8016281c:	e1a02a23 	lsr	r2, r3, #20
80162820:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162824:	e5933008 	ldr	r3, [r3, #8]
80162828:	e1a03a23 	lsr	r3, r3, #20
8016282c:	e1520003 	cmp	r2, r3
80162830:	9a000001 	bls	8016283c <_RME_Cpt_Add+0x460>
        {
            RME_COV_MARKER();
        
            return RME_ERR_CPT_FLAG;
80162834:	e3e03006 	mvn	r3, #6
80162838:	ea000103 	b	80162c4c <_RME_Cpt_Add+0x870>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        if(RME_PGT_FLAG_LOW(Flag)<RME_PGT_FLAG_LOW(Capobj_Src->Head.Flag))
8016283c:	e59b3008 	ldr	r3, [fp, #8]
80162840:	e1a03423 	lsr	r3, r3, #8
80162844:	e7eb2053 	ubfx	r2, r3, #0, #12
80162848:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016284c:	e5933008 	ldr	r3, [r3, #8]
80162850:	e1a03423 	lsr	r3, r3, #8
80162854:	e7eb3053 	ubfx	r3, r3, #0, #12
80162858:	e1520003 	cmp	r2, r3
8016285c:	2a000001 	bcs	80162868 <_RME_Cpt_Add+0x48c>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162860:	e3e03006 	mvn	r3, #6
80162864:	ea0000f8 	b	80162c4c <_RME_Cpt_Add+0x870>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        if(RME_PGT_FLAG_HIGH(Flag)<RME_PGT_FLAG_LOW(Flag))
80162868:	e59b3008 	ldr	r3, [fp, #8]
8016286c:	e1a02a23 	lsr	r2, r3, #20
80162870:	e59b3008 	ldr	r3, [fp, #8]
80162874:	e1a03423 	lsr	r3, r3, #8
80162878:	e7eb3053 	ubfx	r3, r3, #0, #12
8016287c:	e1520003 	cmp	r2, r3
80162880:	2a000001 	bcs	8016288c <_RME_Cpt_Add+0x4b0>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162884:	e3e03006 	mvn	r3, #6
80162888:	ea0000ef 	b	80162c4c <_RME_Cpt_Add+0x870>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Check the flags - if there are extra ones, or all zero */
        if(RME_PGT_FLAG_FLAG(Flag)==0U)
8016288c:	e59b3008 	ldr	r3, [fp, #8]
80162890:	e6ef3073 	uxtb	r3, r3
80162894:	e3530000 	cmp	r3, #0
80162898:	1a000001 	bne	801628a4 <_RME_Cpt_Add+0x4c8>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
8016289c:	e3e03006 	mvn	r3, #6
801628a0:	ea0000e9 	b	80162c4c <_RME_Cpt_Add+0x870>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        if((RME_PGT_FLAG_FLAG(Flag)&(~RME_PGT_FLAG_FLAG(Capobj_Src->Head.Flag)))!=0U)
801628a4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801628a8:	e5933008 	ldr	r3, [r3, #8]
801628ac:	e6ef3073 	uxtb	r3, r3
801628b0:	e1e02003 	mvn	r2, r3
801628b4:	e59b3008 	ldr	r3, [fp, #8]
801628b8:	e0033002 	and	r3, r3, r2
801628bc:	e6ef3073 	uxtb	r3, r3
801628c0:	e3530000 	cmp	r3, #0
801628c4:	0a000077 	beq	80162aa8 <_RME_Cpt_Add+0x6cc>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
801628c8:	e3e03006 	mvn	r3, #6
801628cc:	ea0000de 	b	80162c4c <_RME_Cpt_Add+0x870>
        {
            RME_COV_MARKER();
            /* No action required */
        }
    }
    else if(Src_Type==RME_CAP_TYPE_KFN)
801628d0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801628d4:	e3530001 	cmp	r3, #1
801628d8:	1a000019 	bne	80162944 <_RME_Cpt_Add+0x568>
    {
        RME_COV_MARKER();
        
        /* Kernel funcrions only have ranges, no flags - check the delegation range */
        if(RME_KFN_FLAG_HIGH(Flag)>RME_KFN_FLAG_HIGH(Capobj_Src->Head.Flag))
801628dc:	e59b3008 	ldr	r3, [fp, #8]
801628e0:	e1a02823 	lsr	r2, r3, #16
801628e4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801628e8:	e5933008 	ldr	r3, [r3, #8]
801628ec:	e1a03823 	lsr	r3, r3, #16
801628f0:	e1520003 	cmp	r2, r3
801628f4:	9a000001 	bls	80162900 <_RME_Cpt_Add+0x524>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
801628f8:	e3e03006 	mvn	r3, #6
801628fc:	ea0000d2 	b	80162c4c <_RME_Cpt_Add+0x870>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        if(RME_KFN_FLAG_LOW(Flag)<RME_KFN_FLAG_LOW(Capobj_Src->Head.Flag))
80162900:	e59b3008 	ldr	r3, [fp, #8]
80162904:	e6ff2073 	uxth	r2, r3
80162908:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016290c:	e5933008 	ldr	r3, [r3, #8]
80162910:	e6ff3073 	uxth	r3, r3
80162914:	e1520003 	cmp	r2, r3
80162918:	2a000001 	bcs	80162924 <_RME_Cpt_Add+0x548>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
8016291c:	e3e03006 	mvn	r3, #6
80162920:	ea0000c9 	b	80162c4c <_RME_Cpt_Add+0x870>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        if(RME_KFN_FLAG_HIGH(Flag)<RME_KFN_FLAG_LOW(Flag))
80162924:	e59b3008 	ldr	r3, [fp, #8]
80162928:	e1a02823 	lsr	r2, r3, #16
8016292c:	e59b3008 	ldr	r3, [fp, #8]
80162930:	e6ff3073 	uxth	r3, r3
80162934:	e1520003 	cmp	r2, r3
80162938:	2a00005a 	bcs	80162aa8 <_RME_Cpt_Add+0x6cc>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
8016293c:	e3e03006 	mvn	r3, #6
80162940:	ea0000c1 	b	80162c4c <_RME_Cpt_Add+0x870>
        {
            RME_COV_MARKER();
            /* No action required */
        }
    }
    else if(Src_Type==RME_CAP_TYPE_KOM)
80162944:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162948:	e3530002 	cmp	r3, #2
8016294c:	1a000047 	bne	80162a70 <_RME_Cpt_Add+0x694>
    {
        RME_COV_MARKER();
        
        /* The Kom_End here is exclusive */
        Kom_Begin=RME_KOM_FLAG_LOW(Flag,Ext_Flag);
80162950:	e59b3008 	ldr	r3, [fp, #8]
80162954:	e1a03803 	lsl	r3, r3, #16
80162958:	e50b3010 	str	r3, [fp, #-16]
        Kom_End=RME_KOM_FLAG_HIGH(Flag,Ext_Flag);
8016295c:	e59b3008 	ldr	r3, [fp, #8]
80162960:	e1a03823 	lsr	r3, r3, #16
80162964:	e1a03803 	lsl	r3, r3, #16
80162968:	e59b200c 	ldr	r2, [fp, #12]
8016296c:	e1a02822 	lsr	r2, r2, #16
80162970:	e3c2203f 	bic	r2, r2, #63	@ 0x3f
80162974:	e1833002 	orr	r3, r3, r2
80162978:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
        Kom_Flag=RME_KOM_FLAG_KOM(Ext_Flag);
8016297c:	e3a03000 	mov	r3, #0
80162980:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
        /* Round start and end to the slot boundary, if we are using slots bigger than 64 bytes */
#if(RME_KOM_SLOT_ORDER>6U)
        Kom_End=RME_ROUND_DOWN(Kom_End,RME_KOM_SLOT_ORDER);
        Kom_Begin=RME_ROUND_UP(Kom_Begin,RME_KOM_SLOT_ORDER);
#endif
        if(Kom_End<=Kom_Begin)
80162984:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80162988:	e51b3010 	ldr	r3, [fp, #-16]
8016298c:	e1520003 	cmp	r2, r3
80162990:	8a000001 	bhi	8016299c <_RME_Cpt_Add+0x5c0>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162994:	e3e03006 	mvn	r3, #6
80162998:	ea0000ab 	b	80162c4c <_RME_Cpt_Add+0x870>
            RME_COV_MARKER();
            /* No action required */
        }

        /* Convert relative addresses to absolute addresses and check for overflow */
        Kom_Begin+=((volatile struct RME_Cap_Kom*)Capobj_Src)->Begin;
8016299c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801629a0:	e5933014 	ldr	r3, [r3, #20]
801629a4:	e51b2010 	ldr	r2, [fp, #-16]
801629a8:	e0823003 	add	r3, r2, r3
801629ac:	e50b3010 	str	r3, [fp, #-16]
        if(Kom_Begin<((volatile struct RME_Cap_Kom*)Capobj_Src)->Begin)
801629b0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801629b4:	e5933014 	ldr	r3, [r3, #20]
801629b8:	e51b2010 	ldr	r2, [fp, #-16]
801629bc:	e1520003 	cmp	r2, r3
801629c0:	2a000001 	bcs	801629cc <_RME_Cpt_Add+0x5f0>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
801629c4:	e3e03006 	mvn	r3, #6
801629c8:	ea00009f 	b	80162c4c <_RME_Cpt_Add+0x870>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        Kom_End+=((volatile struct RME_Cap_Kom*)Capobj_Src)->Begin;
801629cc:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801629d0:	e5933014 	ldr	r3, [r3, #20]
801629d4:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
801629d8:	e0823003 	add	r3, r2, r3
801629dc:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
        if(Kom_End<((volatile struct RME_Cap_Kom*)Capobj_Src)->Begin)
801629e0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801629e4:	e5933014 	ldr	r3, [r3, #20]
801629e8:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
801629ec:	e1520003 	cmp	r2, r3
801629f0:	2a000001 	bcs	801629fc <_RME_Cpt_Add+0x620>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
801629f4:	e3e03006 	mvn	r3, #6
801629f8:	ea000093 	b	80162c4c <_RME_Cpt_Add+0x870>
            RME_COV_MARKER();
            /* No action required */
        }

        /* Check the ranges of kernel memory */
        if(((volatile struct RME_Cap_Kom*)Capobj_Src)->Begin>Kom_Begin)
801629fc:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162a00:	e5933014 	ldr	r3, [r3, #20]
80162a04:	e51b2010 	ldr	r2, [fp, #-16]
80162a08:	e1520003 	cmp	r2, r3
80162a0c:	2a000001 	bcs	80162a18 <_RME_Cpt_Add+0x63c>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162a10:	e3e03006 	mvn	r3, #6
80162a14:	ea00008c 	b	80162c4c <_RME_Cpt_Add+0x870>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Internal encoding of 'end' is inclusive */
        if(((volatile struct RME_Cap_Kom*)Capobj_Src)->End<(Kom_End-1U))
80162a18:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162a1c:	e5932018 	ldr	r2, [r3, #24]
80162a20:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162a24:	e2433001 	sub	r3, r3, #1
80162a28:	e1520003 	cmp	r2, r3
80162a2c:	2a000001 	bcs	80162a38 <_RME_Cpt_Add+0x65c>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162a30:	e3e03006 	mvn	r3, #6
80162a34:	ea000084 	b	80162c4c <_RME_Cpt_Add+0x870>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Check the flags - if there are extra ones, or all zero */
        if(Kom_Flag==0U)
80162a38:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80162a3c:	e3530000 	cmp	r3, #0
80162a40:	1a000001 	bne	80162a4c <_RME_Cpt_Add+0x670>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162a44:	e3e03006 	mvn	r3, #6
80162a48:	ea00007f 	b	80162c4c <_RME_Cpt_Add+0x870>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        if((Kom_Flag&(~(Capobj_Src->Head.Flag)))!=0U)
80162a4c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162a50:	e5933008 	ldr	r3, [r3, #8]
80162a54:	e1e02003 	mvn	r2, r3
80162a58:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80162a5c:	e0033002 	and	r3, r3, r2
80162a60:	e3530000 	cmp	r3, #0
80162a64:	0a00000f 	beq	80162aa8 <_RME_Cpt_Add+0x6cc>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162a68:	e3e03006 	mvn	r3, #6
80162a6c:	ea000076 	b	80162c4c <_RME_Cpt_Add+0x870>
    else
    {
        RME_COV_MARKER();
        
        /* Check the flags - if there are extra ones, or all zero */
        if(Flag==0U)
80162a70:	e59b3008 	ldr	r3, [fp, #8]
80162a74:	e3530000 	cmp	r3, #0
80162a78:	1a000001 	bne	80162a84 <_RME_Cpt_Add+0x6a8>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162a7c:	e3e03006 	mvn	r3, #6
80162a80:	ea000071 	b	80162c4c <_RME_Cpt_Add+0x870>
        else
        {
            RME_COV_MARKER();
            /* No action required */
        }
        if((Flag&(~(Capobj_Src->Head.Flag)))!=0U)
80162a84:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162a88:	e5933008 	ldr	r3, [r3, #8]
80162a8c:	e1e02003 	mvn	r2, r3
80162a90:	e59b3008 	ldr	r3, [fp, #8]
80162a94:	e0033002 	and	r3, r3, r2
80162a98:	e3530000 	cmp	r3, #0
80162a9c:	0a000001 	beq	80162aa8 <_RME_Cpt_Add+0x6cc>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162aa0:	e3e03006 	mvn	r3, #6
80162aa4:	ea000068 	b	80162c4c <_RME_Cpt_Add+0x870>
            /* No action required */
        }
    }
    
    /* Is the destination slot unoccupied? */
    if(Capobj_Dst->Head.Type_Stat!=0U)
80162aa8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162aac:	e5933000 	ldr	r3, [r3]
80162ab0:	e3530000 	cmp	r3, #0
80162ab4:	0a000001 	beq	80162ac0 <_RME_Cpt_Add+0x6e4>
    {
        RME_COV_MARKER();
            
        return RME_ERR_CPT_EXIST;
80162ab8:	e3e03004 	mvn	r3, #4
80162abc:	ea000062 	b	80162c4c <_RME_Cpt_Add+0x870>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Try to take the empty slot */
    RME_CPT_OCCUPY(Capobj_Dst);
80162ac0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162ac4:	e3a02801 	mov	r2, #65536	@ 0x10000
80162ac8:	e3a01000 	mov	r1, #0
80162acc:	e1a00003 	mov	r0, r3
80162ad0:	ebfff84c 	bl	80160c08 <_RME_Comp_Swap_Single>
80162ad4:	e1a03000 	mov	r3, r0
80162ad8:	e3530000 	cmp	r3, #0
80162adc:	1a000001 	bne	80162ae8 <_RME_Cpt_Add+0x70c>
80162ae0:	e3e03004 	mvn	r3, #4
80162ae4:	ea000058 	b	80162c4c <_RME_Cpt_Add+0x870>
80162ae8:	e30d3000 	movw	r3, #53248	@ 0xd000
80162aec:	e3483016 	movt	r3, #32790	@ 0x8016
80162af0:	e5932000 	ldr	r2, [r3]
80162af4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162af8:	e5832010 	str	r2, [r3, #16]
    
    /* All done, we replicate the cap with flags */
    if(Src_Type==RME_CAP_TYPE_KOM)
80162afc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162b00:	e3530002 	cmp	r3, #2
80162b04:	1a00001a 	bne	80162b74 <_RME_Cpt_Add+0x798>
    {
        RME_COV_MARKER();
            
        RME_CAP_COPY(Capobj_Dst,Capobj_Src,Kom_Flag);
80162b08:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162b0c:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80162b10:	e5832008 	str	r2, [r3, #8]
80162b14:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162b18:	e593200c 	ldr	r2, [r3, #12]
80162b1c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162b20:	e583200c 	str	r2, [r3, #12]
80162b24:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162b28:	e5932014 	ldr	r2, [r3, #20]
80162b2c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162b30:	e5832014 	str	r2, [r3, #20]
80162b34:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162b38:	e5932018 	ldr	r2, [r3, #24]
80162b3c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162b40:	e5832018 	str	r2, [r3, #24]
80162b44:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162b48:	e593201c 	ldr	r2, [r3, #28]
80162b4c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162b50:	e583201c 	str	r2, [r3, #28]
        /* Write absolute range information for kernel memory caps */
        ((volatile struct RME_Cap_Kom*)Capobj_Dst)->Begin=Kom_Begin;
80162b54:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162b58:	e51b2010 	ldr	r2, [fp, #-16]
80162b5c:	e5832014 	str	r2, [r3, #20]
        /* The Kom_End encoded inclusively to avoid overflow at max address */
        ((volatile struct RME_Cap_Kom*)Capobj_Dst)->End=Kom_End-1U;
80162b60:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162b64:	e2432001 	sub	r2, r3, #1
80162b68:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162b6c:	e5832018 	str	r2, [r3, #24]
80162b70:	ea000012 	b	80162bc0 <_RME_Cpt_Add+0x7e4>
    }
    else
    {
        RME_COV_MARKER();
        
        RME_CAP_COPY(Capobj_Dst,Capobj_Src,Flag);
80162b74:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162b78:	e59b2008 	ldr	r2, [fp, #8]
80162b7c:	e5832008 	str	r2, [r3, #8]
80162b80:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162b84:	e593200c 	ldr	r2, [r3, #12]
80162b88:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162b8c:	e583200c 	str	r2, [r3, #12]
80162b90:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162b94:	e5932014 	ldr	r2, [r3, #20]
80162b98:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162b9c:	e5832014 	str	r2, [r3, #20]
80162ba0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162ba4:	e5932018 	ldr	r2, [r3, #24]
80162ba8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162bac:	e5832018 	str	r2, [r3, #24]
80162bb0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162bb4:	e593201c 	ldr	r2, [r3, #28]
80162bb8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162bbc:	e583201c 	str	r2, [r3, #28]
     * their parent, nor will they update the parent's reference count. This
     * design decision comes from the fact that these two capability types are
     * always created on boot and delegated everywhere, and they don't actually
     * have an object. If we use refcnt on these, we may cause scalability 
     * issues. The parent cap can't be deleted anyway, so this is fine. */
    if((Src_Type!=RME_CAP_TYPE_KOM)&&(Src_Type!=RME_CAP_TYPE_KFN))
80162bc0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162bc4:	e3530002 	cmp	r3, #2
80162bc8:	0a000014 	beq	80162c20 <_RME_Cpt_Add+0x844>
80162bcc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162bd0:	e3530001 	cmp	r3, #1
80162bd4:	0a000011 	beq	80162c20 <_RME_Cpt_Add+0x844>
    {
        RME_COV_MARKER();
        
        /* Register root */
        Capobj_Dst->Head.Root_Ref=RME_CAP_CONV_ROOT(Capobj_Src,rme_ptr_t);
80162bd8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162bdc:	e5933000 	ldr	r3, [r3]
80162be0:	e6ff3073 	uxth	r3, r3
80162be4:	e3530000 	cmp	r3, #0
80162be8:	0a000002 	beq	80162bf8 <_RME_Cpt_Add+0x81c>
80162bec:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162bf0:	e5933004 	ldr	r3, [r3, #4]
80162bf4:	ea000000 	b	80162bfc <_RME_Cpt_Add+0x820>
80162bf8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162bfc:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80162c00:	e5823004 	str	r3, [r2, #4]
    
        /* Increase the parent's refcnt - never overflows, guaranteed by field size */
        RME_FETCH_ADD(&(((volatile struct RME_Cap_Struct*)
80162c04:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162c08:	e5933004 	ldr	r3, [r3, #4]
80162c0c:	e2833004 	add	r3, r3, #4
80162c10:	e3a01001 	mov	r1, #1
80162c14:	e1a00003 	mov	r0, r3
80162c18:	ebfff80f 	bl	80160c5c <_RME_Fetch_Add_Single>
80162c1c:	ea000002 	b	80162c2c <_RME_Cpt_Add+0x850>
    else
    {
        RME_COV_MARKER();
        
        /* No root for KOM and KFN */
        Capobj_Dst->Head.Root_Ref=0U;
80162c20:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162c24:	e3a02000 	mov	r2, #0
80162c28:	e5832004 	str	r2, [r3, #4]
    }

    /* Establish cap */
    RME_WRITE_RELEASE(&(Capobj_Dst->Head.Type_Stat),
80162c2c:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80162c30:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162c34:	e1a03c03 	lsl	r3, r3, #24
80162c38:	e3833001 	orr	r3, r3, #1
80162c3c:	e1a01003 	mov	r1, r3
80162c40:	e1a00002 	mov	r0, r2
80162c44:	ebfff6b0 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(Src_Type,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_LEAF));

    return 0;
80162c48:	e3a03000 	mov	r3, #0
}
80162c4c:	e1a00003 	mov	r0, r3
80162c50:	e24bd004 	sub	sp, fp, #4
80162c54:	e8bd8800 	pop	{fp, pc}

80162c58 <_RME_Cpt_Rem>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Cpt_Rem(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt_Rem,
                              rme_cid_t Cap_Rem)
{
80162c58:	e92d4800 	push	{fp, lr}
80162c5c:	e28db004 	add	fp, sp, #4
80162c60:	e24dd028 	sub	sp, sp, #40	@ 0x28
80162c64:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
80162c68:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
80162c6c:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
    rme_ptr_t Rem_Type;
    /* This is used for removal */
    volatile struct RME_Cap_Struct* Capobj_Root;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Rem,RME_CAP_TYPE_CPT,
80162c70:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162c74:	e2033080 	and	r3, r3, #128	@ 0x80
80162c78:	e3530000 	cmp	r3, #0
80162c7c:	1a00001d 	bne	80162cf8 <_RME_Cpt_Rem+0xa0>
80162c80:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162c84:	e5932014 	ldr	r2, [r3, #20]
80162c88:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162c8c:	e1520003 	cmp	r2, r3
80162c90:	8a000001 	bhi	80162c9c <_RME_Cpt_Rem+0x44>
80162c94:	e3e03002 	mvn	r3, #2
80162c98:	ea0000a2 	b	80162f28 <_RME_Cpt_Rem+0x2d0>
80162c9c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162ca0:	e1a02283 	lsl	r2, r3, #5
80162ca4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162ca8:	e593300c 	ldr	r3, [r3, #12]
80162cac:	e0823003 	add	r3, r2, r3
80162cb0:	e50b3008 	str	r3, [fp, #-8]
80162cb4:	e51b3008 	ldr	r3, [fp, #-8]
80162cb8:	e1a00003 	mov	r0, r3
80162cbc:	ebfff68f 	bl	80160700 <__RME_A7A_Read_Acquire>
80162cc0:	e50b000c 	str	r0, [fp, #-12]
80162cc4:	e51b300c 	ldr	r3, [fp, #-12]
80162cc8:	e1a03823 	lsr	r3, r3, #16
80162ccc:	e6ef3073 	uxtb	r3, r3
80162cd0:	e3530002 	cmp	r3, #2
80162cd4:	1a000001 	bne	80162ce0 <_RME_Cpt_Rem+0x88>
80162cd8:	e3e03008 	mvn	r3, #8
80162cdc:	ea000091 	b	80162f28 <_RME_Cpt_Rem+0x2d0>
80162ce0:	e51b300c 	ldr	r3, [fp, #-12]
80162ce4:	e1a03c23 	lsr	r3, r3, #24
80162ce8:	e3530003 	cmp	r3, #3
80162cec:	0a000041 	beq	80162df8 <_RME_Cpt_Rem+0x1a0>
80162cf0:	e3e03001 	mvn	r3, #1
80162cf4:	ea00008b 	b	80162f28 <_RME_Cpt_Rem+0x2d0>
80162cf8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162cfc:	e1a02423 	lsr	r2, r3, #8
80162d00:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162d04:	e5933014 	ldr	r3, [r3, #20]
80162d08:	e1520003 	cmp	r2, r3
80162d0c:	3a000001 	bcc	80162d18 <_RME_Cpt_Rem+0xc0>
80162d10:	e3e03002 	mvn	r3, #2
80162d14:	ea000083 	b	80162f28 <_RME_Cpt_Rem+0x2d0>
80162d18:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162d1c:	e1a03423 	lsr	r3, r3, #8
80162d20:	e1a02283 	lsl	r2, r3, #5
80162d24:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162d28:	e593300c 	ldr	r3, [r3, #12]
80162d2c:	e0823003 	add	r3, r2, r3
80162d30:	e50b3008 	str	r3, [fp, #-8]
80162d34:	e51b3008 	ldr	r3, [fp, #-8]
80162d38:	e1a00003 	mov	r0, r3
80162d3c:	ebfff66f 	bl	80160700 <__RME_A7A_Read_Acquire>
80162d40:	e50b000c 	str	r0, [fp, #-12]
80162d44:	e51b300c 	ldr	r3, [fp, #-12]
80162d48:	e1a03823 	lsr	r3, r3, #16
80162d4c:	e6ef3073 	uxtb	r3, r3
80162d50:	e3530002 	cmp	r3, #2
80162d54:	1a000001 	bne	80162d60 <_RME_Cpt_Rem+0x108>
80162d58:	e3e03008 	mvn	r3, #8
80162d5c:	ea000071 	b	80162f28 <_RME_Cpt_Rem+0x2d0>
80162d60:	e51b300c 	ldr	r3, [fp, #-12]
80162d64:	e1a03c23 	lsr	r3, r3, #24
80162d68:	e3530003 	cmp	r3, #3
80162d6c:	0a000001 	beq	80162d78 <_RME_Cpt_Rem+0x120>
80162d70:	e3e03001 	mvn	r3, #1
80162d74:	ea00006b 	b	80162f28 <_RME_Cpt_Rem+0x2d0>
80162d78:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162d7c:	e203207f 	and	r2, r3, #127	@ 0x7f
80162d80:	e51b3008 	ldr	r3, [fp, #-8]
80162d84:	e5933014 	ldr	r3, [r3, #20]
80162d88:	e1520003 	cmp	r2, r3
80162d8c:	3a000001 	bcc	80162d98 <_RME_Cpt_Rem+0x140>
80162d90:	e3e03002 	mvn	r3, #2
80162d94:	ea000063 	b	80162f28 <_RME_Cpt_Rem+0x2d0>
80162d98:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162d9c:	e203307f 	and	r3, r3, #127	@ 0x7f
80162da0:	e1a02283 	lsl	r2, r3, #5
80162da4:	e51b3008 	ldr	r3, [fp, #-8]
80162da8:	e593300c 	ldr	r3, [r3, #12]
80162dac:	e0823003 	add	r3, r2, r3
80162db0:	e50b3008 	str	r3, [fp, #-8]
80162db4:	e51b3008 	ldr	r3, [fp, #-8]
80162db8:	e1a00003 	mov	r0, r3
80162dbc:	ebfff64f 	bl	80160700 <__RME_A7A_Read_Acquire>
80162dc0:	e50b000c 	str	r0, [fp, #-12]
80162dc4:	e51b300c 	ldr	r3, [fp, #-12]
80162dc8:	e1a03823 	lsr	r3, r3, #16
80162dcc:	e6ef3073 	uxtb	r3, r3
80162dd0:	e3530002 	cmp	r3, #2
80162dd4:	1a000001 	bne	80162de0 <_RME_Cpt_Rem+0x188>
80162dd8:	e3e03008 	mvn	r3, #8
80162ddc:	ea000051 	b	80162f28 <_RME_Cpt_Rem+0x2d0>
80162de0:	e51b300c 	ldr	r3, [fp, #-12]
80162de4:	e1a03c23 	lsr	r3, r3, #24
80162de8:	e3530003 	cmp	r3, #3
80162dec:	0a000001 	beq	80162df8 <_RME_Cpt_Rem+0x1a0>
80162df0:	e3e03001 	mvn	r3, #1
80162df4:	ea00004b 	b	80162f28 <_RME_Cpt_Rem+0x2d0>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_REM);
80162df8:	e51b3008 	ldr	r3, [fp, #-8]
80162dfc:	e5933008 	ldr	r3, [r3, #8]
80162e00:	e2033020 	and	r3, r3, #32
80162e04:	e3530000 	cmp	r3, #0
80162e08:	1a000001 	bne	80162e14 <_RME_Cpt_Rem+0x1bc>
80162e0c:	e3e03006 	mvn	r3, #6
80162e10:	ea000044 	b	80162f28 <_RME_Cpt_Rem+0x2d0>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Rem,struct RME_Cap_Struct*,Capobj_Rem);
80162e14:	e51b3008 	ldr	r3, [fp, #-8]
80162e18:	e5932014 	ldr	r2, [r3, #20]
80162e1c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162e20:	e1520003 	cmp	r2, r3
80162e24:	8a000001 	bhi	80162e30 <_RME_Cpt_Rem+0x1d8>
80162e28:	e3e03002 	mvn	r3, #2
80162e2c:	ea00003d 	b	80162f28 <_RME_Cpt_Rem+0x2d0>
80162e30:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162e34:	e1a02283 	lsl	r2, r3, #5
80162e38:	e51b3008 	ldr	r3, [fp, #-8]
80162e3c:	e593300c 	ldr	r3, [r3, #12]
80162e40:	e0823003 	add	r3, r2, r3
80162e44:	e50b3010 	str	r3, [fp, #-16]
    /* Removal check */
    RME_CAP_REM_CHECK(Capobj_Rem,Type_Stat);
80162e48:	e51b3010 	ldr	r3, [fp, #-16]
80162e4c:	e1a00003 	mov	r0, r3
80162e50:	ebfff62a 	bl	80160700 <__RME_A7A_Read_Acquire>
80162e54:	e50b000c 	str	r0, [fp, #-12]
80162e58:	e51b300c 	ldr	r3, [fp, #-12]
80162e5c:	e1a03823 	lsr	r3, r3, #16
80162e60:	e6ef3073 	uxtb	r3, r3
80162e64:	e3530002 	cmp	r3, #2
80162e68:	0a000001 	beq	80162e74 <_RME_Cpt_Rem+0x21c>
80162e6c:	e3e03008 	mvn	r3, #8
80162e70:	ea00002c 	b	80162f28 <_RME_Cpt_Rem+0x2d0>
80162e74:	e51b300c 	ldr	r3, [fp, #-12]
80162e78:	e6ff3073 	uxth	r3, r3
80162e7c:	e3530000 	cmp	r3, #0
80162e80:	1a000001 	bne	80162e8c <_RME_Cpt_Rem+0x234>
80162e84:	e3e03009 	mvn	r3, #9
80162e88:	ea000026 	b	80162f28 <_RME_Cpt_Rem+0x2d0>
    
    /* If we are KFN or KOM, we don't care about parent or refcnt */
    Rem_Type=RME_CAP_TYPE(Type_Stat);
80162e8c:	e51b300c 	ldr	r3, [fp, #-12]
80162e90:	e1a03c23 	lsr	r3, r3, #24
80162e94:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    if((Rem_Type!=RME_CAP_TYPE_KOM)&&(Rem_Type!=RME_CAP_TYPE_KFN))
80162e98:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162e9c:	e3530002 	cmp	r3, #2
80162ea0:	0a000015 	beq	80162efc <_RME_Cpt_Rem+0x2a4>
80162ea4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162ea8:	e3530001 	cmp	r3, #1
80162eac:	0a000012 	beq	80162efc <_RME_Cpt_Rem+0x2a4>
    {
        RME_COV_MARKER();
        
        /* Remember this for refcnt operations */
        Capobj_Root=(struct RME_Cap_Struct*)(Capobj_Rem->Head.Root_Ref);
80162eb0:	e51b3010 	ldr	r3, [fp, #-16]
80162eb4:	e5933004 	ldr	r3, [r3, #4]
80162eb8:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
        
        RME_CAP_DELETE(Capobj_Rem,Type_Stat);
80162ebc:	e51b3010 	ldr	r3, [fp, #-16]
80162ec0:	e3a02000 	mov	r2, #0
80162ec4:	e51b100c 	ldr	r1, [fp, #-12]
80162ec8:	e1a00003 	mov	r0, r3
80162ecc:	ebfff74d 	bl	80160c08 <_RME_Comp_Swap_Single>
80162ed0:	e1a03000 	mov	r3, r0
80162ed4:	e3530000 	cmp	r3, #0
80162ed8:	1a000001 	bne	80162ee4 <_RME_Cpt_Rem+0x28c>
80162edc:	e3e03000 	mvn	r3, #0
80162ee0:	ea000010 	b	80162f28 <_RME_Cpt_Rem+0x2d0>

        /* Check done, decrease its parent's refcnt. This must be done at last */
        RME_FETCH_ADD(&(Capobj_Root->Head.Root_Ref),-1);
80162ee4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80162ee8:	e2833004 	add	r3, r3, #4
80162eec:	e3e01000 	mvn	r1, #0
80162ef0:	e1a00003 	mov	r0, r3
80162ef4:	ebfff758 	bl	80160c5c <_RME_Fetch_Add_Single>
80162ef8:	ea000009 	b	80162f24 <_RME_Cpt_Rem+0x2cc>
    else
    {
        RME_COV_MARKER();

        /* Helping also applies here */
        RME_CAP_DELETE(Capobj_Rem,Type_Stat);
80162efc:	e51b3010 	ldr	r3, [fp, #-16]
80162f00:	e3a02000 	mov	r2, #0
80162f04:	e51b100c 	ldr	r1, [fp, #-12]
80162f08:	e1a00003 	mov	r0, r3
80162f0c:	ebfff73d 	bl	80160c08 <_RME_Comp_Swap_Single>
80162f10:	e1a03000 	mov	r3, r0
80162f14:	e3530000 	cmp	r3, #0
80162f18:	1a000001 	bne	80162f24 <_RME_Cpt_Rem+0x2cc>
80162f1c:	e3e03000 	mvn	r3, #0
80162f20:	ea000000 	b	80162f28 <_RME_Cpt_Rem+0x2d0>
    }
    
    return 0;
80162f24:	e3a03000 	mov	r3, #0
}
80162f28:	e1a00003 	mov	r0, r3
80162f2c:	e24bd004 	sub	sp, fp, #4
80162f30:	e8bd8800 	pop	{fp, pc}

80162f34 <_RME_Pgt_Crt>:
                              rme_ptr_t Raddr,
                              rme_ptr_t Base,
                              rme_ptr_t Is_Top,
                              rme_ptr_t Size_Order,
                              rme_ptr_t Num_Order)
{
80162f34:	e92d4800 	push	{fp, lr}
80162f38:	e28db004 	add	fp, sp, #4
80162f3c:	e24dd030 	sub	sp, sp, #48	@ 0x30
80162f40:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
80162f44:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
80162f48:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
80162f4c:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
    rme_ptr_t Vaddr;
    rme_ptr_t Table_Size;
    
    /* Check if the total representable memory exceeds our maximum possible
     * addressible memory under the machine word length */
    if((Size_Order+Num_Order)>RME_POW2(RME_WORD_ORDER))
80162f50:	e59b2010 	ldr	r2, [fp, #16]
80162f54:	e59b3014 	ldr	r3, [fp, #20]
80162f58:	e0823003 	add	r3, r2, r3
80162f5c:	e3530020 	cmp	r3, #32
80162f60:	9a000001 	bls	80162f6c <_RME_Pgt_Crt+0x38>
    {
        RME_COV_MARKER();
        
        return RME_ERR_PGT_HW;
80162f64:	e3e03066 	mvn	r3, #102	@ 0x66
80162f68:	ea00015b 	b	801634dc <_RME_Pgt_Crt+0x5a8>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Get the cap location that we care about */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
80162f6c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162f70:	e2033080 	and	r3, r3, #128	@ 0x80
80162f74:	e3530000 	cmp	r3, #0
80162f78:	1a00001d 	bne	80162ff4 <_RME_Pgt_Crt+0xc0>
80162f7c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162f80:	e5932014 	ldr	r2, [r3, #20]
80162f84:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162f88:	e1520003 	cmp	r2, r3
80162f8c:	8a000001 	bhi	80162f98 <_RME_Pgt_Crt+0x64>
80162f90:	e3e03002 	mvn	r3, #2
80162f94:	ea000150 	b	801634dc <_RME_Pgt_Crt+0x5a8>
80162f98:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162f9c:	e1a02283 	lsl	r2, r3, #5
80162fa0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162fa4:	e593300c 	ldr	r3, [r3, #12]
80162fa8:	e0823003 	add	r3, r2, r3
80162fac:	e50b300c 	str	r3, [fp, #-12]
80162fb0:	e51b300c 	ldr	r3, [fp, #-12]
80162fb4:	e1a00003 	mov	r0, r3
80162fb8:	ebfff5d0 	bl	80160700 <__RME_A7A_Read_Acquire>
80162fbc:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80162fc0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162fc4:	e1a03823 	lsr	r3, r3, #16
80162fc8:	e6ef3073 	uxtb	r3, r3
80162fcc:	e3530002 	cmp	r3, #2
80162fd0:	1a000001 	bne	80162fdc <_RME_Pgt_Crt+0xa8>
80162fd4:	e3e03008 	mvn	r3, #8
80162fd8:	ea00013f 	b	801634dc <_RME_Pgt_Crt+0x5a8>
80162fdc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162fe0:	e1a03c23 	lsr	r3, r3, #24
80162fe4:	e3530003 	cmp	r3, #3
80162fe8:	0a000041 	beq	801630f4 <_RME_Pgt_Crt+0x1c0>
80162fec:	e3e03001 	mvn	r3, #1
80162ff0:	ea000139 	b	801634dc <_RME_Pgt_Crt+0x5a8>
80162ff4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162ff8:	e1a02423 	lsr	r2, r3, #8
80162ffc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163000:	e5933014 	ldr	r3, [r3, #20]
80163004:	e1520003 	cmp	r2, r3
80163008:	3a000001 	bcc	80163014 <_RME_Pgt_Crt+0xe0>
8016300c:	e3e03002 	mvn	r3, #2
80163010:	ea000131 	b	801634dc <_RME_Pgt_Crt+0x5a8>
80163014:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163018:	e1a03423 	lsr	r3, r3, #8
8016301c:	e1a02283 	lsl	r2, r3, #5
80163020:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163024:	e593300c 	ldr	r3, [r3, #12]
80163028:	e0823003 	add	r3, r2, r3
8016302c:	e50b300c 	str	r3, [fp, #-12]
80163030:	e51b300c 	ldr	r3, [fp, #-12]
80163034:	e1a00003 	mov	r0, r3
80163038:	ebfff5b0 	bl	80160700 <__RME_A7A_Read_Acquire>
8016303c:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80163040:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163044:	e1a03823 	lsr	r3, r3, #16
80163048:	e6ef3073 	uxtb	r3, r3
8016304c:	e3530002 	cmp	r3, #2
80163050:	1a000001 	bne	8016305c <_RME_Pgt_Crt+0x128>
80163054:	e3e03008 	mvn	r3, #8
80163058:	ea00011f 	b	801634dc <_RME_Pgt_Crt+0x5a8>
8016305c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163060:	e1a03c23 	lsr	r3, r3, #24
80163064:	e3530003 	cmp	r3, #3
80163068:	0a000001 	beq	80163074 <_RME_Pgt_Crt+0x140>
8016306c:	e3e03001 	mvn	r3, #1
80163070:	ea000119 	b	801634dc <_RME_Pgt_Crt+0x5a8>
80163074:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163078:	e203207f 	and	r2, r3, #127	@ 0x7f
8016307c:	e51b300c 	ldr	r3, [fp, #-12]
80163080:	e5933014 	ldr	r3, [r3, #20]
80163084:	e1520003 	cmp	r2, r3
80163088:	3a000001 	bcc	80163094 <_RME_Pgt_Crt+0x160>
8016308c:	e3e03002 	mvn	r3, #2
80163090:	ea000111 	b	801634dc <_RME_Pgt_Crt+0x5a8>
80163094:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163098:	e203307f 	and	r3, r3, #127	@ 0x7f
8016309c:	e1a02283 	lsl	r2, r3, #5
801630a0:	e51b300c 	ldr	r3, [fp, #-12]
801630a4:	e593300c 	ldr	r3, [r3, #12]
801630a8:	e0823003 	add	r3, r2, r3
801630ac:	e50b300c 	str	r3, [fp, #-12]
801630b0:	e51b300c 	ldr	r3, [fp, #-12]
801630b4:	e1a00003 	mov	r0, r3
801630b8:	ebfff590 	bl	80160700 <__RME_A7A_Read_Acquire>
801630bc:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801630c0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801630c4:	e1a03823 	lsr	r3, r3, #16
801630c8:	e6ef3073 	uxtb	r3, r3
801630cc:	e3530002 	cmp	r3, #2
801630d0:	1a000001 	bne	801630dc <_RME_Pgt_Crt+0x1a8>
801630d4:	e3e03008 	mvn	r3, #8
801630d8:	ea0000ff 	b	801634dc <_RME_Pgt_Crt+0x5a8>
801630dc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801630e0:	e1a03c23 	lsr	r3, r3, #24
801630e4:	e3530003 	cmp	r3, #3
801630e8:	0a000001 	beq	801630f4 <_RME_Pgt_Crt+0x1c0>
801630ec:	e3e03001 	mvn	r3, #1
801630f0:	ea0000f9 	b	801634dc <_RME_Pgt_Crt+0x5a8>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Kom,RME_CAP_TYPE_KOM,
801630f4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801630f8:	e2033080 	and	r3, r3, #128	@ 0x80
801630fc:	e3530000 	cmp	r3, #0
80163100:	1a00001d 	bne	8016317c <_RME_Pgt_Crt+0x248>
80163104:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163108:	e5932014 	ldr	r2, [r3, #20]
8016310c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163110:	e1520003 	cmp	r2, r3
80163114:	8a000001 	bhi	80163120 <_RME_Pgt_Crt+0x1ec>
80163118:	e3e03002 	mvn	r3, #2
8016311c:	ea0000ee 	b	801634dc <_RME_Pgt_Crt+0x5a8>
80163120:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163124:	e1a02283 	lsl	r2, r3, #5
80163128:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016312c:	e593300c 	ldr	r3, [r3, #12]
80163130:	e0823003 	add	r3, r2, r3
80163134:	e50b3008 	str	r3, [fp, #-8]
80163138:	e51b3008 	ldr	r3, [fp, #-8]
8016313c:	e1a00003 	mov	r0, r3
80163140:	ebfff56e 	bl	80160700 <__RME_A7A_Read_Acquire>
80163144:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80163148:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016314c:	e1a03823 	lsr	r3, r3, #16
80163150:	e6ef3073 	uxtb	r3, r3
80163154:	e3530002 	cmp	r3, #2
80163158:	1a000001 	bne	80163164 <_RME_Pgt_Crt+0x230>
8016315c:	e3e03008 	mvn	r3, #8
80163160:	ea0000dd 	b	801634dc <_RME_Pgt_Crt+0x5a8>
80163164:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163168:	e1a03c23 	lsr	r3, r3, #24
8016316c:	e3530002 	cmp	r3, #2
80163170:	0a000041 	beq	8016327c <_RME_Pgt_Crt+0x348>
80163174:	e3e03001 	mvn	r3, #1
80163178:	ea0000d7 	b	801634dc <_RME_Pgt_Crt+0x5a8>
8016317c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163180:	e1a02423 	lsr	r2, r3, #8
80163184:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163188:	e5933014 	ldr	r3, [r3, #20]
8016318c:	e1520003 	cmp	r2, r3
80163190:	3a000001 	bcc	8016319c <_RME_Pgt_Crt+0x268>
80163194:	e3e03002 	mvn	r3, #2
80163198:	ea0000cf 	b	801634dc <_RME_Pgt_Crt+0x5a8>
8016319c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801631a0:	e1a03423 	lsr	r3, r3, #8
801631a4:	e1a02283 	lsl	r2, r3, #5
801631a8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801631ac:	e593300c 	ldr	r3, [r3, #12]
801631b0:	e0823003 	add	r3, r2, r3
801631b4:	e50b3008 	str	r3, [fp, #-8]
801631b8:	e51b3008 	ldr	r3, [fp, #-8]
801631bc:	e1a00003 	mov	r0, r3
801631c0:	ebfff54e 	bl	80160700 <__RME_A7A_Read_Acquire>
801631c4:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801631c8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801631cc:	e1a03823 	lsr	r3, r3, #16
801631d0:	e6ef3073 	uxtb	r3, r3
801631d4:	e3530002 	cmp	r3, #2
801631d8:	1a000001 	bne	801631e4 <_RME_Pgt_Crt+0x2b0>
801631dc:	e3e03008 	mvn	r3, #8
801631e0:	ea0000bd 	b	801634dc <_RME_Pgt_Crt+0x5a8>
801631e4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801631e8:	e1a03c23 	lsr	r3, r3, #24
801631ec:	e3530003 	cmp	r3, #3
801631f0:	0a000001 	beq	801631fc <_RME_Pgt_Crt+0x2c8>
801631f4:	e3e03001 	mvn	r3, #1
801631f8:	ea0000b7 	b	801634dc <_RME_Pgt_Crt+0x5a8>
801631fc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163200:	e203207f 	and	r2, r3, #127	@ 0x7f
80163204:	e51b3008 	ldr	r3, [fp, #-8]
80163208:	e5933014 	ldr	r3, [r3, #20]
8016320c:	e1520003 	cmp	r2, r3
80163210:	3a000001 	bcc	8016321c <_RME_Pgt_Crt+0x2e8>
80163214:	e3e03002 	mvn	r3, #2
80163218:	ea0000af 	b	801634dc <_RME_Pgt_Crt+0x5a8>
8016321c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163220:	e203307f 	and	r3, r3, #127	@ 0x7f
80163224:	e1a02283 	lsl	r2, r3, #5
80163228:	e51b3008 	ldr	r3, [fp, #-8]
8016322c:	e593300c 	ldr	r3, [r3, #12]
80163230:	e0823003 	add	r3, r2, r3
80163234:	e50b3008 	str	r3, [fp, #-8]
80163238:	e51b3008 	ldr	r3, [fp, #-8]
8016323c:	e1a00003 	mov	r0, r3
80163240:	ebfff52e 	bl	80160700 <__RME_A7A_Read_Acquire>
80163244:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80163248:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016324c:	e1a03823 	lsr	r3, r3, #16
80163250:	e6ef3073 	uxtb	r3, r3
80163254:	e3530002 	cmp	r3, #2
80163258:	1a000001 	bne	80163264 <_RME_Pgt_Crt+0x330>
8016325c:	e3e03008 	mvn	r3, #8
80163260:	ea00009d 	b	801634dc <_RME_Pgt_Crt+0x5a8>
80163264:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163268:	e1a03c23 	lsr	r3, r3, #24
8016326c:	e3530002 	cmp	r3, #2
80163270:	0a000001 	beq	8016327c <_RME_Pgt_Crt+0x348>
80163274:	e3e03001 	mvn	r3, #1
80163278:	ea000097 	b	801634dc <_RME_Pgt_Crt+0x5a8>
                   struct RME_Cap_Kom*,Kom_Op,Type_Stat);
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op, RME_CPT_FLAG_CRT);
8016327c:	e51b300c 	ldr	r3, [fp, #-12]
80163280:	e5933008 	ldr	r3, [r3, #8]
80163284:	e2033001 	and	r3, r3, #1
80163288:	e3530000 	cmp	r3, #0
8016328c:	1a000001 	bne	80163298 <_RME_Pgt_Crt+0x364>
80163290:	e3e03006 	mvn	r3, #6
80163294:	ea000090 	b	801634dc <_RME_Pgt_Crt+0x5a8>
    
    /* Are we creating the top-level? */
    if(Is_Top!=0U)
80163298:	e59b300c 	ldr	r3, [fp, #12]
8016329c:	e3530000 	cmp	r3, #0
801632a0:	0a000004 	beq	801632b8 <_RME_Pgt_Crt+0x384>
    {
        RME_COV_MARKER();

        Table_Size=RME_PGT_SIZE_TOP(Num_Order);
801632a4:	e3a02001 	mov	r2, #1
801632a8:	e59b3014 	ldr	r3, [fp, #20]
801632ac:	e1a03312 	lsl	r3, r2, r3
801632b0:	e50b3010 	str	r3, [fp, #-16]
801632b4:	ea000003 	b	801632c8 <_RME_Pgt_Crt+0x394>
    }
    else
    {
        RME_COV_MARKER();

        Table_Size=RME_PGT_SIZE_NOM(Num_Order);
801632b8:	e3a02001 	mov	r2, #1
801632bc:	e59b3014 	ldr	r3, [fp, #20]
801632c0:	e1a03312 	lsl	r3, r2, r3
801632c4:	e50b3010 	str	r3, [fp, #-16]
    }
    
    /* See if the creation is valid for this kmem range */
    RME_KOM_CHECK(Kom_Op,RME_KOM_FLAG_PGT,Raddr,Vaddr,Table_Size);
801632c8:	e51b3008 	ldr	r3, [fp, #-8]
801632cc:	e5933008 	ldr	r3, [r3, #8]
801632d0:	e2033002 	and	r3, r3, #2
801632d4:	e3530000 	cmp	r3, #0
801632d8:	1a000001 	bne	801632e4 <_RME_Pgt_Crt+0x3b0>
801632dc:	e3e03006 	mvn	r3, #6
801632e0:	ea00007d 	b	801634dc <_RME_Pgt_Crt+0x5a8>
801632e4:	e51b3008 	ldr	r3, [fp, #-8]
801632e8:	e5933014 	ldr	r3, [r3, #20]
801632ec:	e59b2004 	ldr	r2, [fp, #4]
801632f0:	e0823003 	add	r3, r2, r3
801632f4:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
801632f8:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
801632fc:	e59b3004 	ldr	r3, [fp, #4]
80163300:	e1520003 	cmp	r2, r3
80163304:	2a000001 	bcs	80163310 <_RME_Pgt_Crt+0x3dc>
80163308:	e3e03006 	mvn	r3, #6
8016330c:	ea000072 	b	801634dc <_RME_Pgt_Crt+0x5a8>
80163310:	e51b3008 	ldr	r3, [fp, #-8]
80163314:	e5933014 	ldr	r3, [r3, #20]
80163318:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016331c:	e1520003 	cmp	r2, r3
80163320:	2a000001 	bcs	8016332c <_RME_Pgt_Crt+0x3f8>
80163324:	e3e03006 	mvn	r3, #6
80163328:	ea00006b 	b	801634dc <_RME_Pgt_Crt+0x5a8>
8016332c:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80163330:	e51b3010 	ldr	r3, [fp, #-16]
80163334:	e0823003 	add	r3, r2, r3
80163338:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016333c:	e1520003 	cmp	r2, r3
80163340:	9a000001 	bls	8016334c <_RME_Pgt_Crt+0x418>
80163344:	e3e03006 	mvn	r3, #6
80163348:	ea000063 	b	801634dc <_RME_Pgt_Crt+0x5a8>
8016334c:	e51b3008 	ldr	r3, [fp, #-8]
80163350:	e5932018 	ldr	r2, [r3, #24]
80163354:	e51b1018 	ldr	r1, [fp, #-24]	@ 0xffffffe8
80163358:	e51b3010 	ldr	r3, [fp, #-16]
8016335c:	e0813003 	add	r3, r1, r3
80163360:	e2433001 	sub	r3, r3, #1
80163364:	e1520003 	cmp	r2, r3
80163368:	2a000001 	bcs	80163374 <_RME_Pgt_Crt+0x440>
8016336c:	e3e03006 	mvn	r3, #6
80163370:	ea000059 	b	801634dc <_RME_Pgt_Crt+0x5a8>

    /* Check if these parameters are feasible */
    if(__RME_Pgt_Check(Base,Is_Top,Size_Order,Num_Order,Vaddr)<0)
80163374:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80163378:	e58d3000 	str	r3, [sp]
8016337c:	e59b3014 	ldr	r3, [fp, #20]
80163380:	e59b2010 	ldr	r2, [fp, #16]
80163384:	e59b100c 	ldr	r1, [fp, #12]
80163388:	e59b0008 	ldr	r0, [fp, #8]
8016338c:	eb0022aa 	bl	8016be3c <__RME_Pgt_Check>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Check if the start address is properly aligned to the total order of the page table */
    if((Base&RME_MASK_END(Size_Order+Num_Order-1U))!=0U)
80163390:	e59b2010 	ldr	r2, [fp, #16]
80163394:	e59b3014 	ldr	r3, [fp, #20]
80163398:	e0823003 	add	r3, r2, r3
8016339c:	e2633020 	rsb	r3, r3, #32
801633a0:	e3e02000 	mvn	r2, #0
801633a4:	e1a02332 	lsr	r2, r2, r3
801633a8:	e59b3008 	ldr	r3, [fp, #8]
801633ac:	e0033002 	and	r3, r3, r2
801633b0:	e3530000 	cmp	r3, #0
801633b4:	0a000001 	beq	801633c0 <_RME_Pgt_Crt+0x48c>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_HW;
801633b8:	e3e03066 	mvn	r3, #102	@ 0x66
801633bc:	ea000046 	b	801634dc <_RME_Pgt_Crt+0x5a8>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Pgt,struct RME_Cap_Pgt*,Pgt_Crt);
801633c0:	e51b300c 	ldr	r3, [fp, #-12]
801633c4:	e5932014 	ldr	r2, [r3, #20]
801633c8:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801633cc:	e1520003 	cmp	r2, r3
801633d0:	8a000001 	bhi	801633dc <_RME_Pgt_Crt+0x4a8>
801633d4:	e3e03002 	mvn	r3, #2
801633d8:	ea00003f 	b	801634dc <_RME_Pgt_Crt+0x5a8>
801633dc:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801633e0:	e1a02283 	lsl	r2, r3, #5
801633e4:	e51b300c 	ldr	r3, [fp, #-12]
801633e8:	e593300c 	ldr	r3, [r3, #12]
801633ec:	e0823003 	add	r3, r2, r3
801633f0:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Pgt_Crt);
801633f4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801633f8:	e3a02801 	mov	r2, #65536	@ 0x10000
801633fc:	e3a01000 	mov	r1, #0
80163400:	e1a00003 	mov	r0, r3
80163404:	ebfff5ff 	bl	80160c08 <_RME_Comp_Swap_Single>
80163408:	e1a03000 	mov	r3, r0
8016340c:	e3530000 	cmp	r3, #0
80163410:	1a000001 	bne	8016341c <_RME_Pgt_Crt+0x4e8>
80163414:	e3e03004 	mvn	r3, #4
80163418:	ea00002f 	b	801634dc <_RME_Pgt_Crt+0x5a8>
8016341c:	e30d3000 	movw	r3, #53248	@ 0xd000
80163420:	e3483016 	movt	r3, #32790	@ 0x8016
80163424:	e5932000 	ldr	r2, [r3]
80163428:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016342c:	e5832010 	str	r2, [r3, #16]

    /* Try to populate the area */
    if(_RME_Kot_Mark(Vaddr,Table_Size)!=0)
80163430:	e51b1010 	ldr	r1, [fp, #-16]
80163434:	e51b0018 	ldr	r0, [fp, #-24]	@ 0xffffffe8
80163438:	eb000541 	bl	80164944 <_RME_Kot_Mark>
8016343c:	e1a03000 	mov	r3, r0
80163440:	e3530000 	cmp	r3, #0
80163444:	0a000005 	beq	80163460 <_RME_Pgt_Crt+0x52c>
    {
        RME_COV_MARKER();

        RME_WRITE_RELEASE(&(Pgt_Crt->Head.Type_Stat),0U);
80163448:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016344c:	e3a01000 	mov	r1, #0
80163450:	e1a00003 	mov	r0, r3
80163454:	ebfff4ac 	bl	8016070c <__RME_A7A_Write_Release>
        return RME_ERR_CPT_KOT;
80163458:	e3e03003 	mvn	r3, #3
8016345c:	ea00001e 	b	801634dc <_RME_Pgt_Crt+0x5a8>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Header init */
    Pgt_Crt->Head.Root_Ref=0U;
80163460:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163464:	e3a02000 	mov	r2, #0
80163468:	e5832004 	str	r2, [r3, #4]
    Pgt_Crt->Head.Object=Vaddr;
8016346c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163470:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80163474:	e583200c 	str	r2, [r3, #12]
    Pgt_Crt->Head.Flag=RME_PGT_FLAG_FULL_RANGE|RME_PGT_FLAG_ALL;
80163478:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
8016347c:	e3a030ff 	mov	r3, #255	@ 0xff
80163480:	e34f3ff0 	movt	r3, #65520	@ 0xfff0
80163484:	e5823008 	str	r3, [r2, #8]
    
    /* Info init */
    Pgt_Crt->Base=Base|Is_Top;
80163488:	e59b2008 	ldr	r2, [fp, #8]
8016348c:	e59b300c 	ldr	r3, [fp, #12]
80163490:	e1822003 	orr	r2, r2, r3
80163494:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163498:	e5832018 	str	r2, [r3, #24]
    Pgt_Crt->Order=RME_PGT_ORDER(Size_Order,Num_Order);
8016349c:	e59b3010 	ldr	r3, [fp, #16]
801634a0:	e1a02803 	lsl	r2, r3, #16
801634a4:	e59b3014 	ldr	r3, [fp, #20]
801634a8:	e1822003 	orr	r2, r2, r3
801634ac:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801634b0:	e5832014 	str	r2, [r3, #20]
    Pgt_Crt->ASID=0U;
801634b4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801634b8:	e3a02000 	mov	r2, #0
801634bc:	e583201c 	str	r2, [r3, #28]
    
    /* Object init - need to add all kernel pages if they are top-level */
    if(__RME_Pgt_Init(Pgt_Crt)<0)
801634c0:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
801634c4:	eb00228b 	bl	8016bef8 <__RME_Pgt_Init>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Creation complete */
    RME_WRITE_RELEASE(&(Pgt_Crt->Head.Type_Stat),
801634c8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801634cc:	e3a01301 	mov	r1, #67108864	@ 0x4000000
801634d0:	e1a00003 	mov	r0, r3
801634d4:	ebfff48c 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_PGT,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
801634d8:	e3a03000 	mov	r3, #0
}
801634dc:	e1a00003 	mov	r0, r3
801634e0:	e24bd004 	sub	sp, fp, #4
801634e4:	e8bd8800 	pop	{fp, pc}

801634e8 <_RME_Pgt_Del>:
******************************************************************************/
#if(RME_PGT_RAW_ENABLE==0U)
static rme_ret_t _RME_Pgt_Del(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt,
                              rme_cid_t Cap_Pgt)
{
801634e8:	e92d4800 	push	{fp, lr}
801634ec:	e28db004 	add	fp, sp, #4
801634f0:	e24dd028 	sub	sp, sp, #40	@ 0x28
801634f4:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
801634f8:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
801634fc:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
    /* These are used for deletion */
    rme_ptr_t Object;
    rme_ptr_t Table_Size;
    
    /* Get the cap location that we care about */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
80163500:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163504:	e2033080 	and	r3, r3, #128	@ 0x80
80163508:	e3530000 	cmp	r3, #0
8016350c:	1a00001d 	bne	80163588 <_RME_Pgt_Del+0xa0>
80163510:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163514:	e5932014 	ldr	r2, [r3, #20]
80163518:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016351c:	e1520003 	cmp	r2, r3
80163520:	8a000001 	bhi	8016352c <_RME_Pgt_Del+0x44>
80163524:	e3e03002 	mvn	r3, #2
80163528:	ea0000c9 	b	80163854 <_RME_Pgt_Del+0x36c>
8016352c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163530:	e1a02283 	lsl	r2, r3, #5
80163534:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163538:	e593300c 	ldr	r3, [r3, #12]
8016353c:	e0823003 	add	r3, r2, r3
80163540:	e50b3008 	str	r3, [fp, #-8]
80163544:	e51b3008 	ldr	r3, [fp, #-8]
80163548:	e1a00003 	mov	r0, r3
8016354c:	ebfff46b 	bl	80160700 <__RME_A7A_Read_Acquire>
80163550:	e50b0010 	str	r0, [fp, #-16]
80163554:	e51b3010 	ldr	r3, [fp, #-16]
80163558:	e1a03823 	lsr	r3, r3, #16
8016355c:	e6ef3073 	uxtb	r3, r3
80163560:	e3530002 	cmp	r3, #2
80163564:	1a000001 	bne	80163570 <_RME_Pgt_Del+0x88>
80163568:	e3e03008 	mvn	r3, #8
8016356c:	ea0000b8 	b	80163854 <_RME_Pgt_Del+0x36c>
80163570:	e51b3010 	ldr	r3, [fp, #-16]
80163574:	e1a03c23 	lsr	r3, r3, #24
80163578:	e3530003 	cmp	r3, #3
8016357c:	0a000041 	beq	80163688 <_RME_Pgt_Del+0x1a0>
80163580:	e3e03001 	mvn	r3, #1
80163584:	ea0000b2 	b	80163854 <_RME_Pgt_Del+0x36c>
80163588:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016358c:	e1a02423 	lsr	r2, r3, #8
80163590:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163594:	e5933014 	ldr	r3, [r3, #20]
80163598:	e1520003 	cmp	r2, r3
8016359c:	3a000001 	bcc	801635a8 <_RME_Pgt_Del+0xc0>
801635a0:	e3e03002 	mvn	r3, #2
801635a4:	ea0000aa 	b	80163854 <_RME_Pgt_Del+0x36c>
801635a8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801635ac:	e1a03423 	lsr	r3, r3, #8
801635b0:	e1a02283 	lsl	r2, r3, #5
801635b4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801635b8:	e593300c 	ldr	r3, [r3, #12]
801635bc:	e0823003 	add	r3, r2, r3
801635c0:	e50b3008 	str	r3, [fp, #-8]
801635c4:	e51b3008 	ldr	r3, [fp, #-8]
801635c8:	e1a00003 	mov	r0, r3
801635cc:	ebfff44b 	bl	80160700 <__RME_A7A_Read_Acquire>
801635d0:	e50b0010 	str	r0, [fp, #-16]
801635d4:	e51b3010 	ldr	r3, [fp, #-16]
801635d8:	e1a03823 	lsr	r3, r3, #16
801635dc:	e6ef3073 	uxtb	r3, r3
801635e0:	e3530002 	cmp	r3, #2
801635e4:	1a000001 	bne	801635f0 <_RME_Pgt_Del+0x108>
801635e8:	e3e03008 	mvn	r3, #8
801635ec:	ea000098 	b	80163854 <_RME_Pgt_Del+0x36c>
801635f0:	e51b3010 	ldr	r3, [fp, #-16]
801635f4:	e1a03c23 	lsr	r3, r3, #24
801635f8:	e3530003 	cmp	r3, #3
801635fc:	0a000001 	beq	80163608 <_RME_Pgt_Del+0x120>
80163600:	e3e03001 	mvn	r3, #1
80163604:	ea000092 	b	80163854 <_RME_Pgt_Del+0x36c>
80163608:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016360c:	e203207f 	and	r2, r3, #127	@ 0x7f
80163610:	e51b3008 	ldr	r3, [fp, #-8]
80163614:	e5933014 	ldr	r3, [r3, #20]
80163618:	e1520003 	cmp	r2, r3
8016361c:	3a000001 	bcc	80163628 <_RME_Pgt_Del+0x140>
80163620:	e3e03002 	mvn	r3, #2
80163624:	ea00008a 	b	80163854 <_RME_Pgt_Del+0x36c>
80163628:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016362c:	e203307f 	and	r3, r3, #127	@ 0x7f
80163630:	e1a02283 	lsl	r2, r3, #5
80163634:	e51b3008 	ldr	r3, [fp, #-8]
80163638:	e593300c 	ldr	r3, [r3, #12]
8016363c:	e0823003 	add	r3, r2, r3
80163640:	e50b3008 	str	r3, [fp, #-8]
80163644:	e51b3008 	ldr	r3, [fp, #-8]
80163648:	e1a00003 	mov	r0, r3
8016364c:	ebfff42b 	bl	80160700 <__RME_A7A_Read_Acquire>
80163650:	e50b0010 	str	r0, [fp, #-16]
80163654:	e51b3010 	ldr	r3, [fp, #-16]
80163658:	e1a03823 	lsr	r3, r3, #16
8016365c:	e6ef3073 	uxtb	r3, r3
80163660:	e3530002 	cmp	r3, #2
80163664:	1a000001 	bne	80163670 <_RME_Pgt_Del+0x188>
80163668:	e3e03008 	mvn	r3, #8
8016366c:	ea000078 	b	80163854 <_RME_Pgt_Del+0x36c>
80163670:	e51b3010 	ldr	r3, [fp, #-16]
80163674:	e1a03c23 	lsr	r3, r3, #24
80163678:	e3530003 	cmp	r3, #3
8016367c:	0a000001 	beq	80163688 <_RME_Pgt_Del+0x1a0>
80163680:	e3e03001 	mvn	r3, #1
80163684:	ea000072 	b	80163854 <_RME_Pgt_Del+0x36c>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_DEL);
80163688:	e51b3008 	ldr	r3, [fp, #-8]
8016368c:	e5933008 	ldr	r3, [r3, #8]
80163690:	e2033002 	and	r3, r3, #2
80163694:	e3530000 	cmp	r3, #0
80163698:	1a000001 	bne	801636a4 <_RME_Pgt_Del+0x1bc>
8016369c:	e3e03006 	mvn	r3, #6
801636a0:	ea00006b 	b	80163854 <_RME_Pgt_Del+0x36c>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Pgt,struct RME_Cap_Pgt*,Pgt_Del);
801636a4:	e51b3008 	ldr	r3, [fp, #-8]
801636a8:	e5932014 	ldr	r2, [r3, #20]
801636ac:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801636b0:	e1520003 	cmp	r2, r3
801636b4:	8a000001 	bhi	801636c0 <_RME_Pgt_Del+0x1d8>
801636b8:	e3e03002 	mvn	r3, #2
801636bc:	ea000064 	b	80163854 <_RME_Pgt_Del+0x36c>
801636c0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801636c4:	e1a02283 	lsl	r2, r3, #5
801636c8:	e51b3008 	ldr	r3, [fp, #-8]
801636cc:	e593300c 	ldr	r3, [r3, #12]
801636d0:	e0823003 	add	r3, r2, r3
801636d4:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    /* Delete check */
    RME_CAP_DEL_CHECK(Pgt_Del,Type_Stat,RME_CAP_TYPE_PGT);
801636d8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801636dc:	e1a00003 	mov	r0, r3
801636e0:	ebfff406 	bl	80160700 <__RME_A7A_Read_Acquire>
801636e4:	e50b0010 	str	r0, [fp, #-16]
801636e8:	e51b3010 	ldr	r3, [fp, #-16]
801636ec:	e1a03823 	lsr	r3, r3, #16
801636f0:	e6ef3073 	uxtb	r3, r3
801636f4:	e3530002 	cmp	r3, #2
801636f8:	0a000001 	beq	80163704 <_RME_Pgt_Del+0x21c>
801636fc:	e3e03008 	mvn	r3, #8
80163700:	ea000053 	b	80163854 <_RME_Pgt_Del+0x36c>
80163704:	e51b3010 	ldr	r3, [fp, #-16]
80163708:	e1a03c23 	lsr	r3, r3, #24
8016370c:	e3530004 	cmp	r3, #4
80163710:	0a000001 	beq	8016371c <_RME_Pgt_Del+0x234>
80163714:	e3e03001 	mvn	r3, #1
80163718:	ea00004d 	b	80163854 <_RME_Pgt_Del+0x36c>
8016371c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163720:	e5933004 	ldr	r3, [r3, #4]
80163724:	e3530000 	cmp	r3, #0
80163728:	0a00000b 	beq	8016375c <_RME_Pgt_Del+0x274>
8016372c:	e51b3010 	ldr	r3, [fp, #-16]
80163730:	e6ff3073 	uxth	r3, r3
80163734:	e3530000 	cmp	r3, #0
80163738:	1a000005 	bne	80163754 <_RME_Pgt_Del+0x26c>
8016373c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80163740:	e51b3010 	ldr	r3, [fp, #-16]
80163744:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
80163748:	e1a02003 	mov	r2, r3
8016374c:	e51b1010 	ldr	r1, [fp, #-16]
80163750:	ebfff52c 	bl	80160c08 <_RME_Comp_Swap_Single>
80163754:	e3e03005 	mvn	r3, #5
80163758:	ea00003d 	b	80163854 <_RME_Pgt_Del+0x36c>
8016375c:	e51b3010 	ldr	r3, [fp, #-16]
80163760:	e6ff3073 	uxth	r3, r3
80163764:	e3530000 	cmp	r3, #0
80163768:	0a000008 	beq	80163790 <_RME_Pgt_Del+0x2a8>
8016376c:	e30c3318 	movw	r3, #49944	@ 0xc318
80163770:	e3483016 	movt	r3, #32790	@ 0x8016
80163774:	e30c2324 	movw	r2, #49956	@ 0xc324
80163778:	e3482016 	movt	r2, #32790	@ 0x8016
8016377c:	e3a01d33 	mov	r1, #3264	@ 0xcc0
80163780:	e30c0330 	movw	r0, #49968	@ 0xc330
80163784:	e3480016 	movt	r0, #32790	@ 0x8016
80163788:	ebfff4fd 	bl	80160b84 <RME_Log>
8016378c:	eafffffe 	b	8016378c <_RME_Pgt_Del+0x2a4>
    /* Hardware related deletion check passed down to the HAL. The driver should make
     * sure that it does not reference any lower level tables. If the driver layer does
     * not conform to this, the deletion of page table is not guaranteed to main kernel
     * consistency, and such consistency must be maintained by the user-level. It is 
     * recommended that the driver layer enforce such consistency. */
    if(__RME_Pgt_Del_Check(Pgt_Del)<0)
80163790:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80163794:	eb0021e0 	bl	8016bf1c <__RME_Pgt_Del_Check>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Remember these two variables for deletion */
    Object=RME_CAP_GETOBJ(Pgt_Del,rme_ptr_t);
80163798:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016379c:	e593300c 	ldr	r3, [r3, #12]
801637a0:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    if(((Pgt_Del->Base)&RME_PGT_TOP)!=0U)
801637a4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801637a8:	e5933018 	ldr	r3, [r3, #24]
801637ac:	e2033001 	and	r3, r3, #1
801637b0:	e3530000 	cmp	r3, #0
801637b4:	0a000006 	beq	801637d4 <_RME_Pgt_Del+0x2ec>
    {
        RME_COV_MARKER();

        Table_Size=RME_PGT_SIZE_TOP(RME_PGT_NMORD(Pgt_Del->Order));
801637b8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801637bc:	e5933014 	ldr	r3, [r3, #20]
801637c0:	e6ff3073 	uxth	r3, r3
801637c4:	e3a02001 	mov	r2, #1
801637c8:	e1a03312 	lsl	r3, r2, r3
801637cc:	e50b300c 	str	r3, [fp, #-12]
801637d0:	ea000005 	b	801637ec <_RME_Pgt_Del+0x304>
    }
    else
    {
        RME_COV_MARKER();

        Table_Size=RME_PGT_SIZE_NOM(RME_PGT_NMORD(Pgt_Del->Order));
801637d4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801637d8:	e5933014 	ldr	r3, [r3, #20]
801637dc:	e6ff3073 	uxth	r3, r3
801637e0:	e3a02001 	mov	r2, #1
801637e4:	e1a03312 	lsl	r3, r2, r3
801637e8:	e50b300c 	str	r3, [fp, #-12]
    }
    
    /* Now we can safely delete the cap */
    RME_CAP_DELETE(Pgt_Del,Type_Stat);
801637ec:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801637f0:	e3a02000 	mov	r2, #0
801637f4:	e51b1010 	ldr	r1, [fp, #-16]
801637f8:	e1a00003 	mov	r0, r3
801637fc:	ebfff501 	bl	80160c08 <_RME_Comp_Swap_Single>
80163800:	e1a03000 	mov	r3, r0
80163804:	e3530000 	cmp	r3, #0
80163808:	1a000001 	bne	80163814 <_RME_Pgt_Del+0x32c>
8016380c:	e3e03000 	mvn	r3, #0
80163810:	ea00000f 	b	80163854 <_RME_Pgt_Del+0x36c>

    /* Try to erase the area - This must be successful */
    RME_ASSERT(_RME_Kot_Erase(Object,Table_Size)==0);
80163814:	e51b100c 	ldr	r1, [fp, #-12]
80163818:	e51b0018 	ldr	r0, [fp, #-24]	@ 0xffffffe8
8016381c:	eb000519 	bl	80164c88 <_RME_Kot_Erase>
80163820:	e1a03000 	mov	r3, r0
80163824:	e3530000 	cmp	r3, #0
80163828:	0a000008 	beq	80163850 <_RME_Pgt_Del+0x368>
8016382c:	e30c3318 	movw	r3, #49944	@ 0xc318
80163830:	e3483016 	movt	r3, #32790	@ 0x8016
80163834:	e30c2324 	movw	r2, #49956	@ 0xc324
80163838:	e3482016 	movt	r2, #32790	@ 0x8016
8016383c:	e3001ce7 	movw	r1, #3303	@ 0xce7
80163840:	e30c0330 	movw	r0, #49968	@ 0xc330
80163844:	e3480016 	movt	r0, #32790	@ 0x8016
80163848:	ebfff4cd 	bl	80160b84 <RME_Log>
8016384c:	eafffffe 	b	8016384c <_RME_Pgt_Del+0x364>

    return 0;
80163850:	e3a03000 	mov	r3, #0
}
80163854:	e1a00003 	mov	r0, r3
80163858:	e24bd004 	sub	sp, fp, #4
8016385c:	e8bd8800 	pop	{fp, pc}

80163860 <_RME_Pgt_Add>:
                              rme_ptr_t Pos_Dst,
                              rme_ptr_t Flag_Dst,
                              rme_cid_t Cap_Pgt_Src,
                              rme_ptr_t Pos_Src,
                              rme_ptr_t Index)
{
80163860:	e92d4800 	push	{fp, lr}
80163864:	e28db004 	add	fp, sp, #4
80163868:	e24dd030 	sub	sp, sp, #48	@ 0x30
8016386c:	e50b0028 	str	r0, [fp, #-40]	@ 0xffffffd8
80163870:	e50b102c 	str	r1, [fp, #-44]	@ 0xffffffd4
80163874:	e50b2030 	str	r2, [fp, #-48]	@ 0xffffffd0
80163878:	e50b3034 	str	r3, [fp, #-52]	@ 0xffffffcc
    rme_ptr_t Type_Stat;
    rme_ptr_t Szord_Src;
    rme_ptr_t Szord_Dst;

    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Pgt_Dst,RME_CAP_TYPE_PGT,
8016387c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80163880:	e2033080 	and	r3, r3, #128	@ 0x80
80163884:	e3530000 	cmp	r3, #0
80163888:	1a00001d 	bne	80163904 <_RME_Pgt_Add+0xa4>
8016388c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163890:	e5932014 	ldr	r2, [r3, #20]
80163894:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80163898:	e1520003 	cmp	r2, r3
8016389c:	8a000001 	bhi	801638a8 <_RME_Pgt_Add+0x48>
801638a0:	e3e03002 	mvn	r3, #2
801638a4:	ea00012c 	b	80163d5c <_RME_Pgt_Add+0x4fc>
801638a8:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801638ac:	e1a02283 	lsl	r2, r3, #5
801638b0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801638b4:	e593300c 	ldr	r3, [r3, #12]
801638b8:	e0823003 	add	r3, r2, r3
801638bc:	e50b300c 	str	r3, [fp, #-12]
801638c0:	e51b300c 	ldr	r3, [fp, #-12]
801638c4:	e1a00003 	mov	r0, r3
801638c8:	ebfff38c 	bl	80160700 <__RME_A7A_Read_Acquire>
801638cc:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801638d0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801638d4:	e1a03823 	lsr	r3, r3, #16
801638d8:	e6ef3073 	uxtb	r3, r3
801638dc:	e3530002 	cmp	r3, #2
801638e0:	1a000001 	bne	801638ec <_RME_Pgt_Add+0x8c>
801638e4:	e3e03008 	mvn	r3, #8
801638e8:	ea00011b 	b	80163d5c <_RME_Pgt_Add+0x4fc>
801638ec:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801638f0:	e1a03c23 	lsr	r3, r3, #24
801638f4:	e3530004 	cmp	r3, #4
801638f8:	0a000041 	beq	80163a04 <_RME_Pgt_Add+0x1a4>
801638fc:	e3e03001 	mvn	r3, #1
80163900:	ea000115 	b	80163d5c <_RME_Pgt_Add+0x4fc>
80163904:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80163908:	e1a02423 	lsr	r2, r3, #8
8016390c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163910:	e5933014 	ldr	r3, [r3, #20]
80163914:	e1520003 	cmp	r2, r3
80163918:	3a000001 	bcc	80163924 <_RME_Pgt_Add+0xc4>
8016391c:	e3e03002 	mvn	r3, #2
80163920:	ea00010d 	b	80163d5c <_RME_Pgt_Add+0x4fc>
80163924:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80163928:	e1a03423 	lsr	r3, r3, #8
8016392c:	e1a02283 	lsl	r2, r3, #5
80163930:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163934:	e593300c 	ldr	r3, [r3, #12]
80163938:	e0823003 	add	r3, r2, r3
8016393c:	e50b300c 	str	r3, [fp, #-12]
80163940:	e51b300c 	ldr	r3, [fp, #-12]
80163944:	e1a00003 	mov	r0, r3
80163948:	ebfff36c 	bl	80160700 <__RME_A7A_Read_Acquire>
8016394c:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80163950:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163954:	e1a03823 	lsr	r3, r3, #16
80163958:	e6ef3073 	uxtb	r3, r3
8016395c:	e3530002 	cmp	r3, #2
80163960:	1a000001 	bne	8016396c <_RME_Pgt_Add+0x10c>
80163964:	e3e03008 	mvn	r3, #8
80163968:	ea0000fb 	b	80163d5c <_RME_Pgt_Add+0x4fc>
8016396c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163970:	e1a03c23 	lsr	r3, r3, #24
80163974:	e3530003 	cmp	r3, #3
80163978:	0a000001 	beq	80163984 <_RME_Pgt_Add+0x124>
8016397c:	e3e03001 	mvn	r3, #1
80163980:	ea0000f5 	b	80163d5c <_RME_Pgt_Add+0x4fc>
80163984:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80163988:	e203207f 	and	r2, r3, #127	@ 0x7f
8016398c:	e51b300c 	ldr	r3, [fp, #-12]
80163990:	e5933014 	ldr	r3, [r3, #20]
80163994:	e1520003 	cmp	r2, r3
80163998:	3a000001 	bcc	801639a4 <_RME_Pgt_Add+0x144>
8016399c:	e3e03002 	mvn	r3, #2
801639a0:	ea0000ed 	b	80163d5c <_RME_Pgt_Add+0x4fc>
801639a4:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801639a8:	e203307f 	and	r3, r3, #127	@ 0x7f
801639ac:	e1a02283 	lsl	r2, r3, #5
801639b0:	e51b300c 	ldr	r3, [fp, #-12]
801639b4:	e593300c 	ldr	r3, [r3, #12]
801639b8:	e0823003 	add	r3, r2, r3
801639bc:	e50b300c 	str	r3, [fp, #-12]
801639c0:	e51b300c 	ldr	r3, [fp, #-12]
801639c4:	e1a00003 	mov	r0, r3
801639c8:	ebfff34c 	bl	80160700 <__RME_A7A_Read_Acquire>
801639cc:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801639d0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801639d4:	e1a03823 	lsr	r3, r3, #16
801639d8:	e6ef3073 	uxtb	r3, r3
801639dc:	e3530002 	cmp	r3, #2
801639e0:	1a000001 	bne	801639ec <_RME_Pgt_Add+0x18c>
801639e4:	e3e03008 	mvn	r3, #8
801639e8:	ea0000db 	b	80163d5c <_RME_Pgt_Add+0x4fc>
801639ec:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801639f0:	e1a03c23 	lsr	r3, r3, #24
801639f4:	e3530004 	cmp	r3, #4
801639f8:	0a000001 	beq	80163a04 <_RME_Pgt_Add+0x1a4>
801639fc:	e3e03001 	mvn	r3, #1
80163a00:	ea0000d5 	b	80163d5c <_RME_Pgt_Add+0x4fc>
                   struct RME_Cap_Pgt*,Pgt_Dst,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Pgt_Src,RME_CAP_TYPE_PGT,
80163a04:	e59b3004 	ldr	r3, [fp, #4]
80163a08:	e2033080 	and	r3, r3, #128	@ 0x80
80163a0c:	e3530000 	cmp	r3, #0
80163a10:	1a00001d 	bne	80163a8c <_RME_Pgt_Add+0x22c>
80163a14:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163a18:	e5932014 	ldr	r2, [r3, #20]
80163a1c:	e59b3004 	ldr	r3, [fp, #4]
80163a20:	e1520003 	cmp	r2, r3
80163a24:	8a000001 	bhi	80163a30 <_RME_Pgt_Add+0x1d0>
80163a28:	e3e03002 	mvn	r3, #2
80163a2c:	ea0000ca 	b	80163d5c <_RME_Pgt_Add+0x4fc>
80163a30:	e59b3004 	ldr	r3, [fp, #4]
80163a34:	e1a02283 	lsl	r2, r3, #5
80163a38:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163a3c:	e593300c 	ldr	r3, [r3, #12]
80163a40:	e0823003 	add	r3, r2, r3
80163a44:	e50b3008 	str	r3, [fp, #-8]
80163a48:	e51b3008 	ldr	r3, [fp, #-8]
80163a4c:	e1a00003 	mov	r0, r3
80163a50:	ebfff32a 	bl	80160700 <__RME_A7A_Read_Acquire>
80163a54:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80163a58:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163a5c:	e1a03823 	lsr	r3, r3, #16
80163a60:	e6ef3073 	uxtb	r3, r3
80163a64:	e3530002 	cmp	r3, #2
80163a68:	1a000001 	bne	80163a74 <_RME_Pgt_Add+0x214>
80163a6c:	e3e03008 	mvn	r3, #8
80163a70:	ea0000b9 	b	80163d5c <_RME_Pgt_Add+0x4fc>
80163a74:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163a78:	e1a03c23 	lsr	r3, r3, #24
80163a7c:	e3530004 	cmp	r3, #4
80163a80:	0a000041 	beq	80163b8c <_RME_Pgt_Add+0x32c>
80163a84:	e3e03001 	mvn	r3, #1
80163a88:	ea0000b3 	b	80163d5c <_RME_Pgt_Add+0x4fc>
80163a8c:	e59b3004 	ldr	r3, [fp, #4]
80163a90:	e1a02423 	lsr	r2, r3, #8
80163a94:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163a98:	e5933014 	ldr	r3, [r3, #20]
80163a9c:	e1520003 	cmp	r2, r3
80163aa0:	3a000001 	bcc	80163aac <_RME_Pgt_Add+0x24c>
80163aa4:	e3e03002 	mvn	r3, #2
80163aa8:	ea0000ab 	b	80163d5c <_RME_Pgt_Add+0x4fc>
80163aac:	e59b3004 	ldr	r3, [fp, #4]
80163ab0:	e1a03423 	lsr	r3, r3, #8
80163ab4:	e1a02283 	lsl	r2, r3, #5
80163ab8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163abc:	e593300c 	ldr	r3, [r3, #12]
80163ac0:	e0823003 	add	r3, r2, r3
80163ac4:	e50b3008 	str	r3, [fp, #-8]
80163ac8:	e51b3008 	ldr	r3, [fp, #-8]
80163acc:	e1a00003 	mov	r0, r3
80163ad0:	ebfff30a 	bl	80160700 <__RME_A7A_Read_Acquire>
80163ad4:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80163ad8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163adc:	e1a03823 	lsr	r3, r3, #16
80163ae0:	e6ef3073 	uxtb	r3, r3
80163ae4:	e3530002 	cmp	r3, #2
80163ae8:	1a000001 	bne	80163af4 <_RME_Pgt_Add+0x294>
80163aec:	e3e03008 	mvn	r3, #8
80163af0:	ea000099 	b	80163d5c <_RME_Pgt_Add+0x4fc>
80163af4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163af8:	e1a03c23 	lsr	r3, r3, #24
80163afc:	e3530003 	cmp	r3, #3
80163b00:	0a000001 	beq	80163b0c <_RME_Pgt_Add+0x2ac>
80163b04:	e3e03001 	mvn	r3, #1
80163b08:	ea000093 	b	80163d5c <_RME_Pgt_Add+0x4fc>
80163b0c:	e59b3004 	ldr	r3, [fp, #4]
80163b10:	e203207f 	and	r2, r3, #127	@ 0x7f
80163b14:	e51b3008 	ldr	r3, [fp, #-8]
80163b18:	e5933014 	ldr	r3, [r3, #20]
80163b1c:	e1520003 	cmp	r2, r3
80163b20:	3a000001 	bcc	80163b2c <_RME_Pgt_Add+0x2cc>
80163b24:	e3e03002 	mvn	r3, #2
80163b28:	ea00008b 	b	80163d5c <_RME_Pgt_Add+0x4fc>
80163b2c:	e59b3004 	ldr	r3, [fp, #4]
80163b30:	e203307f 	and	r3, r3, #127	@ 0x7f
80163b34:	e1a02283 	lsl	r2, r3, #5
80163b38:	e51b3008 	ldr	r3, [fp, #-8]
80163b3c:	e593300c 	ldr	r3, [r3, #12]
80163b40:	e0823003 	add	r3, r2, r3
80163b44:	e50b3008 	str	r3, [fp, #-8]
80163b48:	e51b3008 	ldr	r3, [fp, #-8]
80163b4c:	e1a00003 	mov	r0, r3
80163b50:	ebfff2ea 	bl	80160700 <__RME_A7A_Read_Acquire>
80163b54:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80163b58:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163b5c:	e1a03823 	lsr	r3, r3, #16
80163b60:	e6ef3073 	uxtb	r3, r3
80163b64:	e3530002 	cmp	r3, #2
80163b68:	1a000001 	bne	80163b74 <_RME_Pgt_Add+0x314>
80163b6c:	e3e03008 	mvn	r3, #8
80163b70:	ea000079 	b	80163d5c <_RME_Pgt_Add+0x4fc>
80163b74:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163b78:	e1a03c23 	lsr	r3, r3, #24
80163b7c:	e3530004 	cmp	r3, #4
80163b80:	0a000001 	beq	80163b8c <_RME_Pgt_Add+0x32c>
80163b84:	e3e03001 	mvn	r3, #1
80163b88:	ea000073 	b	80163d5c <_RME_Pgt_Add+0x4fc>
                   struct RME_Cap_Pgt*,Pgt_Src,Type_Stat);
    /* Check if both page table caps are not frozen and allows such operations */
    RME_CAP_CHECK(Pgt_Dst,RME_PGT_FLAG_ADD_DST);
80163b8c:	e51b300c 	ldr	r3, [fp, #-12]
80163b90:	e5933008 	ldr	r3, [r3, #8]
80163b94:	e2033002 	and	r3, r3, #2
80163b98:	e3530000 	cmp	r3, #0
80163b9c:	1a000001 	bne	80163ba8 <_RME_Pgt_Add+0x348>
80163ba0:	e3e03006 	mvn	r3, #6
80163ba4:	ea00006c 	b	80163d5c <_RME_Pgt_Add+0x4fc>
    RME_CAP_CHECK(Pgt_Src,RME_PGT_FLAG_ADD_SRC);
80163ba8:	e51b3008 	ldr	r3, [fp, #-8]
80163bac:	e5933008 	ldr	r3, [r3, #8]
80163bb0:	e2033001 	and	r3, r3, #1
80163bb4:	e3530000 	cmp	r3, #0
80163bb8:	1a000001 	bne	80163bc4 <_RME_Pgt_Add+0x364>
80163bbc:	e3e03006 	mvn	r3, #6
80163bc0:	ea000065 	b	80163d5c <_RME_Pgt_Add+0x4fc>
    /* Check the operation range - This is page table specific */
    if((Pos_Dst>RME_PGT_FLAG_HIGH(Pgt_Dst->Head.Flag))||
80163bc4:	e51b300c 	ldr	r3, [fp, #-12]
80163bc8:	e5933008 	ldr	r3, [r3, #8]
80163bcc:	e1a03a23 	lsr	r3, r3, #20
80163bd0:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
80163bd4:	e1520003 	cmp	r2, r3
80163bd8:	8a000013 	bhi	80163c2c <_RME_Pgt_Add+0x3cc>
       (Pos_Dst<RME_PGT_FLAG_LOW(Pgt_Dst->Head.Flag))||
80163bdc:	e51b300c 	ldr	r3, [fp, #-12]
80163be0:	e5933008 	ldr	r3, [r3, #8]
80163be4:	e1a03423 	lsr	r3, r3, #8
80163be8:	e7eb3053 	ubfx	r3, r3, #0, #12
    if((Pos_Dst>RME_PGT_FLAG_HIGH(Pgt_Dst->Head.Flag))||
80163bec:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
80163bf0:	e1520003 	cmp	r2, r3
80163bf4:	3a00000c 	bcc	80163c2c <_RME_Pgt_Add+0x3cc>
       (Pos_Src>RME_PGT_FLAG_HIGH(Pgt_Src->Head.Flag))||
80163bf8:	e51b3008 	ldr	r3, [fp, #-8]
80163bfc:	e5933008 	ldr	r3, [r3, #8]
80163c00:	e1a03a23 	lsr	r3, r3, #20
       (Pos_Dst<RME_PGT_FLAG_LOW(Pgt_Dst->Head.Flag))||
80163c04:	e59b2008 	ldr	r2, [fp, #8]
80163c08:	e1520003 	cmp	r2, r3
80163c0c:	8a000006 	bhi	80163c2c <_RME_Pgt_Add+0x3cc>
       (Pos_Src<RME_PGT_FLAG_LOW(Pgt_Src->Head.Flag)))
80163c10:	e51b3008 	ldr	r3, [fp, #-8]
80163c14:	e5933008 	ldr	r3, [r3, #8]
80163c18:	e1a03423 	lsr	r3, r3, #8
80163c1c:	e7eb3053 	ubfx	r3, r3, #0, #12
       (Pos_Src>RME_PGT_FLAG_HIGH(Pgt_Src->Head.Flag))||
80163c20:	e59b2008 	ldr	r2, [fp, #8]
80163c24:	e1520003 	cmp	r2, r3
80163c28:	2a000001 	bcs	80163c34 <_RME_Pgt_Add+0x3d4>
    {
        RME_COV_MARKER();

        return RME_ERR_CPT_FLAG;
80163c2c:	e3e03006 	mvn	r3, #6
80163c30:	ea000049 	b	80163d5c <_RME_Pgt_Add+0x4fc>
        RME_COV_MARKER();
        /* No action required */
    }

    /* See if the size order relationship is correct */
    Szord_Dst=RME_PGT_SZORD(Pgt_Dst->Order);
80163c34:	e51b300c 	ldr	r3, [fp, #-12]
80163c38:	e5933014 	ldr	r3, [r3, #20]
80163c3c:	e1a03823 	lsr	r3, r3, #16
80163c40:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Szord_Src=RME_PGT_SZORD(Pgt_Src->Order);
80163c44:	e51b3008 	ldr	r3, [fp, #-8]
80163c48:	e5933014 	ldr	r3, [r3, #20]
80163c4c:	e1a03823 	lsr	r3, r3, #16
80163c50:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    if(Szord_Dst>Szord_Src)
80163c54:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80163c58:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163c5c:	e1520003 	cmp	r2, r3
80163c60:	9a000001 	bls	80163c6c <_RME_Pgt_Add+0x40c>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_ADDR;
80163c64:	e3e03064 	mvn	r3, #100	@ 0x64
80163c68:	ea00003b 	b	80163d5c <_RME_Pgt_Add+0x4fc>
        RME_COV_MARKER();
        /* No action required */
    }

    /* See if the positions are out of range - NMORD is restricted, no UB */
    if(((Pos_Dst>>RME_PGT_NMORD(Pgt_Dst->Order))!=0U)||
80163c6c:	e51b300c 	ldr	r3, [fp, #-12]
80163c70:	e5933014 	ldr	r3, [r3, #20]
80163c74:	e6ff3073 	uxth	r3, r3
80163c78:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
80163c7c:	e1a03332 	lsr	r3, r2, r3
80163c80:	e3530000 	cmp	r3, #0
80163c84:	1a000006 	bne	80163ca4 <_RME_Pgt_Add+0x444>
       ((Pos_Src>>RME_PGT_NMORD(Pgt_Src->Order))!=0U))
80163c88:	e51b3008 	ldr	r3, [fp, #-8]
80163c8c:	e5933014 	ldr	r3, [r3, #20]
80163c90:	e6ff3073 	uxth	r3, r3
80163c94:	e59b2008 	ldr	r2, [fp, #8]
80163c98:	e1a03332 	lsr	r3, r2, r3
    if(((Pos_Dst>>RME_PGT_NMORD(Pgt_Dst->Order))!=0U)||
80163c9c:	e3530000 	cmp	r3, #0
80163ca0:	0a000001 	beq	80163cac <_RME_Pgt_Add+0x44c>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_ADDR;
80163ca4:	e3e03064 	mvn	r3, #100	@ 0x64
80163ca8:	ea00002b 	b	80163d5c <_RME_Pgt_Add+0x4fc>
        RME_COV_MARKER();
        /* No action required */
    }

    /* See if the source subposition is out of range - avoid UB */
    if(Szord_Src<RME_WORD_BIT)
80163cac:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163cb0:	e353001f 	cmp	r3, #31
80163cb4:	8a000009 	bhi	80163ce0 <_RME_Pgt_Add+0x480>
    {
        RME_COV_MARKER();
        
        /* No UB because Szord_Dst<=Szord_Src */
        if(RME_POW2(Szord_Src)<=(Index<<Szord_Dst))
80163cb8:	e3a02001 	mov	r2, #1
80163cbc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163cc0:	e1a02312 	lsl	r2, r2, r3
80163cc4:	e59b100c 	ldr	r1, [fp, #12]
80163cc8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80163ccc:	e1a03311 	lsl	r3, r1, r3
80163cd0:	e1520003 	cmp	r2, r3
80163cd4:	8a000001 	bhi	80163ce0 <_RME_Pgt_Add+0x480>
        {
            RME_COV_MARKER();

            return RME_ERR_PGT_ADDR;
80163cd8:	e3e03064 	mvn	r3, #100	@ 0x64
80163cdc:	ea00001e 	b	80163d5c <_RME_Pgt_Add+0x4fc>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Get the physical address and RME standard flags of that source page */
    if(__RME_Pgt_Lookup(Pgt_Src,Pos_Src,&Paddr_Src,&Flag_Src)<0)
80163ce0:	e24b3024 	sub	r3, fp, #36	@ 0x24
80163ce4:	e24b2020 	sub	r2, fp, #32
80163ce8:	e59b1008 	ldr	r1, [fp, #8]
80163cec:	e51b0008 	ldr	r0, [fp, #-8]
80163cf0:	eb0020bf 	bl	8016bff4 <__RME_Pgt_Lookup>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Calculate the destination physical address - avoid UB */
    if(Szord_Dst<RME_WORD_BIT)
80163cf4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80163cf8:	e353001f 	cmp	r3, #31
80163cfc:	8a000006 	bhi	80163d1c <_RME_Pgt_Add+0x4bc>
    {
        RME_COV_MARKER();
        
        Paddr_Dst=Paddr_Src+(Index<<Szord_Dst);
80163d00:	e59b200c 	ldr	r2, [fp, #12]
80163d04:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80163d08:	e1a02312 	lsl	r2, r2, r3
80163d0c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163d10:	e0823003 	add	r3, r2, r3
80163d14:	e50b3010 	str	r3, [fp, #-16]
80163d18:	ea000001 	b	80163d24 <_RME_Pgt_Add+0x4c4>
    /* The destination is also full range */
    else
    {
        RME_COV_MARKER();
        
        Paddr_Dst=Paddr_Src;
80163d1c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163d20:	e50b3010 	str	r3, [fp, #-16]
        }
#endif
    }
    
    /* Analyze the flags - we do not allow expansion of access permissions */
    if(((Flag_Dst)&(~Flag_Src))!=0U)
80163d24:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163d28:	e1e02003 	mvn	r2, r3
80163d2c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80163d30:	e0033002 	and	r3, r3, r2
80163d34:	e3530000 	cmp	r3, #0
80163d38:	0a000001 	beq	80163d44 <_RME_Pgt_Add+0x4e4>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_PERM;
80163d3c:	e3e03067 	mvn	r3, #103	@ 0x67
80163d40:	ea000005 	b	80163d5c <_RME_Pgt_Add+0x4fc>
        /* No action required */
    }

    /* Actually do the mapping - This work is passed down to the HAL. 
     * Under multi-core, HAL should use CAS to avoid a conflict */
    if(__RME_Pgt_Page_Map(Pgt_Dst,Paddr_Dst,Pos_Dst,Flag_Dst)<0)
80163d44:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80163d48:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
80163d4c:	e51b1010 	ldr	r1, [fp, #-16]
80163d50:	e51b000c 	ldr	r0, [fp, #-12]
80163d54:	eb002079 	bl	8016bf40 <__RME_Pgt_Page_Map>
    {
        RME_COV_MARKER();
        /* No action required */
    }

    return 0;
80163d58:	e3a03000 	mov	r3, #0
}
80163d5c:	e1a00003 	mov	r0, r3
80163d60:	e24bd004 	sub	sp, fp, #4
80163d64:	e8bd8800 	pop	{fp, pc}

80163d68 <_RME_Pgt_Rem>:
******************************************************************************/
#if(RME_PGT_RAW_ENABLE==0U)
static rme_ret_t _RME_Pgt_Rem(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Pgt,
                              rme_ptr_t Pos)
{
80163d68:	e92d4800 	push	{fp, lr}
80163d6c:	e28db004 	add	fp, sp, #4
80163d70:	e24dd018 	sub	sp, sp, #24
80163d74:	e50b0010 	str	r0, [fp, #-16]
80163d78:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
80163d7c:	e50b2018 	str	r2, [fp, #-24]	@ 0xffffffe8
    struct RME_Cap_Pgt* Pgt_Rem;
    rme_ptr_t Type_Stat;
    
    /* Get the cap location that we care about */
    RME_CPT_GETCAP(Cpt,Cap_Pgt,RME_CAP_TYPE_CPT,
80163d80:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163d84:	e2033080 	and	r3, r3, #128	@ 0x80
80163d88:	e3530000 	cmp	r3, #0
80163d8c:	1a00001d 	bne	80163e08 <_RME_Pgt_Rem+0xa0>
80163d90:	e51b3010 	ldr	r3, [fp, #-16]
80163d94:	e5932014 	ldr	r2, [r3, #20]
80163d98:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163d9c:	e1520003 	cmp	r2, r3
80163da0:	8a000001 	bhi	80163dac <_RME_Pgt_Rem+0x44>
80163da4:	e3e03002 	mvn	r3, #2
80163da8:	ea000079 	b	80163f94 <_RME_Pgt_Rem+0x22c>
80163dac:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163db0:	e1a02283 	lsl	r2, r3, #5
80163db4:	e51b3010 	ldr	r3, [fp, #-16]
80163db8:	e593300c 	ldr	r3, [r3, #12]
80163dbc:	e0823003 	add	r3, r2, r3
80163dc0:	e50b3008 	str	r3, [fp, #-8]
80163dc4:	e51b3008 	ldr	r3, [fp, #-8]
80163dc8:	e1a00003 	mov	r0, r3
80163dcc:	ebfff24b 	bl	80160700 <__RME_A7A_Read_Acquire>
80163dd0:	e50b000c 	str	r0, [fp, #-12]
80163dd4:	e51b300c 	ldr	r3, [fp, #-12]
80163dd8:	e1a03823 	lsr	r3, r3, #16
80163ddc:	e6ef3073 	uxtb	r3, r3
80163de0:	e3530002 	cmp	r3, #2
80163de4:	1a000001 	bne	80163df0 <_RME_Pgt_Rem+0x88>
80163de8:	e3e03008 	mvn	r3, #8
80163dec:	ea000068 	b	80163f94 <_RME_Pgt_Rem+0x22c>
80163df0:	e51b300c 	ldr	r3, [fp, #-12]
80163df4:	e1a03c23 	lsr	r3, r3, #24
80163df8:	e3530003 	cmp	r3, #3
80163dfc:	0a000041 	beq	80163f08 <_RME_Pgt_Rem+0x1a0>
80163e00:	e3e03001 	mvn	r3, #1
80163e04:	ea000062 	b	80163f94 <_RME_Pgt_Rem+0x22c>
80163e08:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163e0c:	e1a02423 	lsr	r2, r3, #8
80163e10:	e51b3010 	ldr	r3, [fp, #-16]
80163e14:	e5933014 	ldr	r3, [r3, #20]
80163e18:	e1520003 	cmp	r2, r3
80163e1c:	3a000001 	bcc	80163e28 <_RME_Pgt_Rem+0xc0>
80163e20:	e3e03002 	mvn	r3, #2
80163e24:	ea00005a 	b	80163f94 <_RME_Pgt_Rem+0x22c>
80163e28:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163e2c:	e1a03423 	lsr	r3, r3, #8
80163e30:	e1a02283 	lsl	r2, r3, #5
80163e34:	e51b3010 	ldr	r3, [fp, #-16]
80163e38:	e593300c 	ldr	r3, [r3, #12]
80163e3c:	e0823003 	add	r3, r2, r3
80163e40:	e50b3008 	str	r3, [fp, #-8]
80163e44:	e51b3008 	ldr	r3, [fp, #-8]
80163e48:	e1a00003 	mov	r0, r3
80163e4c:	ebfff22b 	bl	80160700 <__RME_A7A_Read_Acquire>
80163e50:	e50b000c 	str	r0, [fp, #-12]
80163e54:	e51b300c 	ldr	r3, [fp, #-12]
80163e58:	e1a03823 	lsr	r3, r3, #16
80163e5c:	e6ef3073 	uxtb	r3, r3
80163e60:	e3530002 	cmp	r3, #2
80163e64:	1a000001 	bne	80163e70 <_RME_Pgt_Rem+0x108>
80163e68:	e3e03008 	mvn	r3, #8
80163e6c:	ea000048 	b	80163f94 <_RME_Pgt_Rem+0x22c>
80163e70:	e51b300c 	ldr	r3, [fp, #-12]
80163e74:	e1a03c23 	lsr	r3, r3, #24
80163e78:	e3530003 	cmp	r3, #3
80163e7c:	0a000001 	beq	80163e88 <_RME_Pgt_Rem+0x120>
80163e80:	e3e03001 	mvn	r3, #1
80163e84:	ea000042 	b	80163f94 <_RME_Pgt_Rem+0x22c>
80163e88:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163e8c:	e203207f 	and	r2, r3, #127	@ 0x7f
80163e90:	e51b3008 	ldr	r3, [fp, #-8]
80163e94:	e5933014 	ldr	r3, [r3, #20]
80163e98:	e1520003 	cmp	r2, r3
80163e9c:	3a000001 	bcc	80163ea8 <_RME_Pgt_Rem+0x140>
80163ea0:	e3e03002 	mvn	r3, #2
80163ea4:	ea00003a 	b	80163f94 <_RME_Pgt_Rem+0x22c>
80163ea8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163eac:	e203307f 	and	r3, r3, #127	@ 0x7f
80163eb0:	e1a02283 	lsl	r2, r3, #5
80163eb4:	e51b3008 	ldr	r3, [fp, #-8]
80163eb8:	e593300c 	ldr	r3, [r3, #12]
80163ebc:	e0823003 	add	r3, r2, r3
80163ec0:	e50b3008 	str	r3, [fp, #-8]
80163ec4:	e51b3008 	ldr	r3, [fp, #-8]
80163ec8:	e1a00003 	mov	r0, r3
80163ecc:	ebfff20b 	bl	80160700 <__RME_A7A_Read_Acquire>
80163ed0:	e50b000c 	str	r0, [fp, #-12]
80163ed4:	e51b300c 	ldr	r3, [fp, #-12]
80163ed8:	e1a03823 	lsr	r3, r3, #16
80163edc:	e6ef3073 	uxtb	r3, r3
80163ee0:	e3530002 	cmp	r3, #2
80163ee4:	1a000001 	bne	80163ef0 <_RME_Pgt_Rem+0x188>
80163ee8:	e3e03008 	mvn	r3, #8
80163eec:	ea000028 	b	80163f94 <_RME_Pgt_Rem+0x22c>
80163ef0:	e51b300c 	ldr	r3, [fp, #-12]
80163ef4:	e1a03c23 	lsr	r3, r3, #24
80163ef8:	e3530003 	cmp	r3, #3
80163efc:	0a000001 	beq	80163f08 <_RME_Pgt_Rem+0x1a0>
80163f00:	e3e03001 	mvn	r3, #1
80163f04:	ea000022 	b	80163f94 <_RME_Pgt_Rem+0x22c>
                   struct RME_Cap_Pgt*,Pgt_Rem,Type_Stat);
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Pgt_Rem,RME_PGT_FLAG_REM);
80163f08:	e51b3008 	ldr	r3, [fp, #-8]
80163f0c:	e5933008 	ldr	r3, [r3, #8]
80163f10:	e2033004 	and	r3, r3, #4
80163f14:	e3530000 	cmp	r3, #0
80163f18:	1a000001 	bne	80163f24 <_RME_Pgt_Rem+0x1bc>
80163f1c:	e3e03006 	mvn	r3, #6
80163f20:	ea00001b 	b	80163f94 <_RME_Pgt_Rem+0x22c>
    /* Check the operation range - This is page table specific */
    if((Pos>RME_PGT_FLAG_HIGH(Pgt_Rem->Head.Flag))||
80163f24:	e51b3008 	ldr	r3, [fp, #-8]
80163f28:	e5933008 	ldr	r3, [r3, #8]
80163f2c:	e1a03a23 	lsr	r3, r3, #20
80163f30:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80163f34:	e1520003 	cmp	r2, r3
80163f38:	8a000006 	bhi	80163f58 <_RME_Pgt_Rem+0x1f0>
       (Pos<RME_PGT_FLAG_LOW(Pgt_Rem->Head.Flag)))
80163f3c:	e51b3008 	ldr	r3, [fp, #-8]
80163f40:	e5933008 	ldr	r3, [r3, #8]
80163f44:	e1a03423 	lsr	r3, r3, #8
80163f48:	e7eb3053 	ubfx	r3, r3, #0, #12
    if((Pos>RME_PGT_FLAG_HIGH(Pgt_Rem->Head.Flag))||
80163f4c:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80163f50:	e1520003 	cmp	r2, r3
80163f54:	2a000001 	bcs	80163f60 <_RME_Pgt_Rem+0x1f8>
    {
        RME_COV_MARKER();

        return RME_ERR_CPT_FLAG;
80163f58:	e3e03006 	mvn	r3, #6
80163f5c:	ea00000c 	b	80163f94 <_RME_Pgt_Rem+0x22c>
        RME_COV_MARKER();
        /* No action required */
    }

    /* See if the unmapping range is allowed */
    if((Pos>>RME_PGT_NMORD(Pgt_Rem->Order))!=0U)
80163f60:	e51b3008 	ldr	r3, [fp, #-8]
80163f64:	e5933014 	ldr	r3, [r3, #20]
80163f68:	e6ff3073 	uxth	r3, r3
80163f6c:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80163f70:	e1a03332 	lsr	r3, r2, r3
80163f74:	e3530000 	cmp	r3, #0
80163f78:	0a000001 	beq	80163f84 <_RME_Pgt_Rem+0x21c>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_ADDR;
80163f7c:	e3e03064 	mvn	r3, #100	@ 0x64
80163f80:	ea000003 	b	80163f94 <_RME_Pgt_Rem+0x22c>
        /* No action required */
    }

    /* Actually do the mapping - This work is passed down to the HAL. 
     * Under multi-core, HAL should use CAS to avoid a conflict */
    if(__RME_Pgt_Page_Unmap(Pgt_Rem,Pos)<0)
80163f84:	e51b1018 	ldr	r1, [fp, #-24]	@ 0xffffffe8
80163f88:	e51b0008 	ldr	r0, [fp, #-8]
80163f8c:	eb001ff7 	bl	8016bf70 <__RME_Pgt_Page_Unmap>
    {
        RME_COV_MARKER();
        /* No action required */
    }

    return 0;
80163f90:	e3a03000 	mov	r3, #0
}
80163f94:	e1a00003 	mov	r0, r3
80163f98:	e24bd004 	sub	sp, fp, #4
80163f9c:	e8bd8800 	pop	{fp, pc}

80163fa0 <_RME_Pgt_Con>:
static rme_ret_t _RME_Pgt_Con(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Pgt_Parent,
                              rme_ptr_t Pos,
                              rme_cid_t Cap_Pgt_Child,
                              rme_ptr_t Flag_Child)
{
80163fa0:	e92d4800 	push	{fp, lr}
80163fa4:	e28db004 	add	fp, sp, #4
80163fa8:	e24dd028 	sub	sp, sp, #40	@ 0x28
80163fac:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
80163fb0:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
80163fb4:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
80163fb8:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
    rme_ptr_t End_Parent;
#endif
    rme_ptr_t Type_Stat;
    
    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Pgt_Parent,RME_CAP_TYPE_PGT,
80163fbc:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163fc0:	e2033080 	and	r3, r3, #128	@ 0x80
80163fc4:	e3530000 	cmp	r3, #0
80163fc8:	1a00001d 	bne	80164044 <_RME_Pgt_Con+0xa4>
80163fcc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163fd0:	e5932014 	ldr	r2, [r3, #20]
80163fd4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163fd8:	e1520003 	cmp	r2, r3
80163fdc:	8a000001 	bhi	80163fe8 <_RME_Pgt_Con+0x48>
80163fe0:	e3e03002 	mvn	r3, #2
80163fe4:	ea00011a 	b	80164454 <_RME_Pgt_Con+0x4b4>
80163fe8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163fec:	e1a02283 	lsl	r2, r3, #5
80163ff0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163ff4:	e593300c 	ldr	r3, [r3, #12]
80163ff8:	e0823003 	add	r3, r2, r3
80163ffc:	e50b3008 	str	r3, [fp, #-8]
80164000:	e51b3008 	ldr	r3, [fp, #-8]
80164004:	e1a00003 	mov	r0, r3
80164008:	ebfff1bc 	bl	80160700 <__RME_A7A_Read_Acquire>
8016400c:	e50b0010 	str	r0, [fp, #-16]
80164010:	e51b3010 	ldr	r3, [fp, #-16]
80164014:	e1a03823 	lsr	r3, r3, #16
80164018:	e6ef3073 	uxtb	r3, r3
8016401c:	e3530002 	cmp	r3, #2
80164020:	1a000001 	bne	8016402c <_RME_Pgt_Con+0x8c>
80164024:	e3e03008 	mvn	r3, #8
80164028:	ea000109 	b	80164454 <_RME_Pgt_Con+0x4b4>
8016402c:	e51b3010 	ldr	r3, [fp, #-16]
80164030:	e1a03c23 	lsr	r3, r3, #24
80164034:	e3530004 	cmp	r3, #4
80164038:	0a000041 	beq	80164144 <_RME_Pgt_Con+0x1a4>
8016403c:	e3e03001 	mvn	r3, #1
80164040:	ea000103 	b	80164454 <_RME_Pgt_Con+0x4b4>
80164044:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164048:	e1a02423 	lsr	r2, r3, #8
8016404c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80164050:	e5933014 	ldr	r3, [r3, #20]
80164054:	e1520003 	cmp	r2, r3
80164058:	3a000001 	bcc	80164064 <_RME_Pgt_Con+0xc4>
8016405c:	e3e03002 	mvn	r3, #2
80164060:	ea0000fb 	b	80164454 <_RME_Pgt_Con+0x4b4>
80164064:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164068:	e1a03423 	lsr	r3, r3, #8
8016406c:	e1a02283 	lsl	r2, r3, #5
80164070:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80164074:	e593300c 	ldr	r3, [r3, #12]
80164078:	e0823003 	add	r3, r2, r3
8016407c:	e50b3008 	str	r3, [fp, #-8]
80164080:	e51b3008 	ldr	r3, [fp, #-8]
80164084:	e1a00003 	mov	r0, r3
80164088:	ebfff19c 	bl	80160700 <__RME_A7A_Read_Acquire>
8016408c:	e50b0010 	str	r0, [fp, #-16]
80164090:	e51b3010 	ldr	r3, [fp, #-16]
80164094:	e1a03823 	lsr	r3, r3, #16
80164098:	e6ef3073 	uxtb	r3, r3
8016409c:	e3530002 	cmp	r3, #2
801640a0:	1a000001 	bne	801640ac <_RME_Pgt_Con+0x10c>
801640a4:	e3e03008 	mvn	r3, #8
801640a8:	ea0000e9 	b	80164454 <_RME_Pgt_Con+0x4b4>
801640ac:	e51b3010 	ldr	r3, [fp, #-16]
801640b0:	e1a03c23 	lsr	r3, r3, #24
801640b4:	e3530003 	cmp	r3, #3
801640b8:	0a000001 	beq	801640c4 <_RME_Pgt_Con+0x124>
801640bc:	e3e03001 	mvn	r3, #1
801640c0:	ea0000e3 	b	80164454 <_RME_Pgt_Con+0x4b4>
801640c4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801640c8:	e203207f 	and	r2, r3, #127	@ 0x7f
801640cc:	e51b3008 	ldr	r3, [fp, #-8]
801640d0:	e5933014 	ldr	r3, [r3, #20]
801640d4:	e1520003 	cmp	r2, r3
801640d8:	3a000001 	bcc	801640e4 <_RME_Pgt_Con+0x144>
801640dc:	e3e03002 	mvn	r3, #2
801640e0:	ea0000db 	b	80164454 <_RME_Pgt_Con+0x4b4>
801640e4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801640e8:	e203307f 	and	r3, r3, #127	@ 0x7f
801640ec:	e1a02283 	lsl	r2, r3, #5
801640f0:	e51b3008 	ldr	r3, [fp, #-8]
801640f4:	e593300c 	ldr	r3, [r3, #12]
801640f8:	e0823003 	add	r3, r2, r3
801640fc:	e50b3008 	str	r3, [fp, #-8]
80164100:	e51b3008 	ldr	r3, [fp, #-8]
80164104:	e1a00003 	mov	r0, r3
80164108:	ebfff17c 	bl	80160700 <__RME_A7A_Read_Acquire>
8016410c:	e50b0010 	str	r0, [fp, #-16]
80164110:	e51b3010 	ldr	r3, [fp, #-16]
80164114:	e1a03823 	lsr	r3, r3, #16
80164118:	e6ef3073 	uxtb	r3, r3
8016411c:	e3530002 	cmp	r3, #2
80164120:	1a000001 	bne	8016412c <_RME_Pgt_Con+0x18c>
80164124:	e3e03008 	mvn	r3, #8
80164128:	ea0000c9 	b	80164454 <_RME_Pgt_Con+0x4b4>
8016412c:	e51b3010 	ldr	r3, [fp, #-16]
80164130:	e1a03c23 	lsr	r3, r3, #24
80164134:	e3530004 	cmp	r3, #4
80164138:	0a000001 	beq	80164144 <_RME_Pgt_Con+0x1a4>
8016413c:	e3e03001 	mvn	r3, #1
80164140:	ea0000c3 	b	80164454 <_RME_Pgt_Con+0x4b4>
                   struct RME_Cap_Pgt*,Pgt_Parent,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Pgt_Child,RME_CAP_TYPE_PGT,
80164144:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80164148:	e2033080 	and	r3, r3, #128	@ 0x80
8016414c:	e3530000 	cmp	r3, #0
80164150:	1a00001d 	bne	801641cc <_RME_Pgt_Con+0x22c>
80164154:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80164158:	e5932014 	ldr	r2, [r3, #20]
8016415c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80164160:	e1520003 	cmp	r2, r3
80164164:	8a000001 	bhi	80164170 <_RME_Pgt_Con+0x1d0>
80164168:	e3e03002 	mvn	r3, #2
8016416c:	ea0000b8 	b	80164454 <_RME_Pgt_Con+0x4b4>
80164170:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80164174:	e1a02283 	lsl	r2, r3, #5
80164178:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016417c:	e593300c 	ldr	r3, [r3, #12]
80164180:	e0823003 	add	r3, r2, r3
80164184:	e50b300c 	str	r3, [fp, #-12]
80164188:	e51b300c 	ldr	r3, [fp, #-12]
8016418c:	e1a00003 	mov	r0, r3
80164190:	ebfff15a 	bl	80160700 <__RME_A7A_Read_Acquire>
80164194:	e50b0010 	str	r0, [fp, #-16]
80164198:	e51b3010 	ldr	r3, [fp, #-16]
8016419c:	e1a03823 	lsr	r3, r3, #16
801641a0:	e6ef3073 	uxtb	r3, r3
801641a4:	e3530002 	cmp	r3, #2
801641a8:	1a000001 	bne	801641b4 <_RME_Pgt_Con+0x214>
801641ac:	e3e03008 	mvn	r3, #8
801641b0:	ea0000a7 	b	80164454 <_RME_Pgt_Con+0x4b4>
801641b4:	e51b3010 	ldr	r3, [fp, #-16]
801641b8:	e1a03c23 	lsr	r3, r3, #24
801641bc:	e3530004 	cmp	r3, #4
801641c0:	0a000041 	beq	801642cc <_RME_Pgt_Con+0x32c>
801641c4:	e3e03001 	mvn	r3, #1
801641c8:	ea0000a1 	b	80164454 <_RME_Pgt_Con+0x4b4>
801641cc:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801641d0:	e1a02423 	lsr	r2, r3, #8
801641d4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801641d8:	e5933014 	ldr	r3, [r3, #20]
801641dc:	e1520003 	cmp	r2, r3
801641e0:	3a000001 	bcc	801641ec <_RME_Pgt_Con+0x24c>
801641e4:	e3e03002 	mvn	r3, #2
801641e8:	ea000099 	b	80164454 <_RME_Pgt_Con+0x4b4>
801641ec:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801641f0:	e1a03423 	lsr	r3, r3, #8
801641f4:	e1a02283 	lsl	r2, r3, #5
801641f8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801641fc:	e593300c 	ldr	r3, [r3, #12]
80164200:	e0823003 	add	r3, r2, r3
80164204:	e50b300c 	str	r3, [fp, #-12]
80164208:	e51b300c 	ldr	r3, [fp, #-12]
8016420c:	e1a00003 	mov	r0, r3
80164210:	ebfff13a 	bl	80160700 <__RME_A7A_Read_Acquire>
80164214:	e50b0010 	str	r0, [fp, #-16]
80164218:	e51b3010 	ldr	r3, [fp, #-16]
8016421c:	e1a03823 	lsr	r3, r3, #16
80164220:	e6ef3073 	uxtb	r3, r3
80164224:	e3530002 	cmp	r3, #2
80164228:	1a000001 	bne	80164234 <_RME_Pgt_Con+0x294>
8016422c:	e3e03008 	mvn	r3, #8
80164230:	ea000087 	b	80164454 <_RME_Pgt_Con+0x4b4>
80164234:	e51b3010 	ldr	r3, [fp, #-16]
80164238:	e1a03c23 	lsr	r3, r3, #24
8016423c:	e3530003 	cmp	r3, #3
80164240:	0a000001 	beq	8016424c <_RME_Pgt_Con+0x2ac>
80164244:	e3e03001 	mvn	r3, #1
80164248:	ea000081 	b	80164454 <_RME_Pgt_Con+0x4b4>
8016424c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80164250:	e203207f 	and	r2, r3, #127	@ 0x7f
80164254:	e51b300c 	ldr	r3, [fp, #-12]
80164258:	e5933014 	ldr	r3, [r3, #20]
8016425c:	e1520003 	cmp	r2, r3
80164260:	3a000001 	bcc	8016426c <_RME_Pgt_Con+0x2cc>
80164264:	e3e03002 	mvn	r3, #2
80164268:	ea000079 	b	80164454 <_RME_Pgt_Con+0x4b4>
8016426c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80164270:	e203307f 	and	r3, r3, #127	@ 0x7f
80164274:	e1a02283 	lsl	r2, r3, #5
80164278:	e51b300c 	ldr	r3, [fp, #-12]
8016427c:	e593300c 	ldr	r3, [r3, #12]
80164280:	e0823003 	add	r3, r2, r3
80164284:	e50b300c 	str	r3, [fp, #-12]
80164288:	e51b300c 	ldr	r3, [fp, #-12]
8016428c:	e1a00003 	mov	r0, r3
80164290:	ebfff11a 	bl	80160700 <__RME_A7A_Read_Acquire>
80164294:	e50b0010 	str	r0, [fp, #-16]
80164298:	e51b3010 	ldr	r3, [fp, #-16]
8016429c:	e1a03823 	lsr	r3, r3, #16
801642a0:	e6ef3073 	uxtb	r3, r3
801642a4:	e3530002 	cmp	r3, #2
801642a8:	1a000001 	bne	801642b4 <_RME_Pgt_Con+0x314>
801642ac:	e3e03008 	mvn	r3, #8
801642b0:	ea000067 	b	80164454 <_RME_Pgt_Con+0x4b4>
801642b4:	e51b3010 	ldr	r3, [fp, #-16]
801642b8:	e1a03c23 	lsr	r3, r3, #24
801642bc:	e3530004 	cmp	r3, #4
801642c0:	0a000001 	beq	801642cc <_RME_Pgt_Con+0x32c>
801642c4:	e3e03001 	mvn	r3, #1
801642c8:	ea000061 	b	80164454 <_RME_Pgt_Con+0x4b4>
                   struct RME_Cap_Pgt*,Pgt_Child,Type_Stat);
    /* Check if both page table caps are not frozen and allows such operations */
    RME_CAP_CHECK(Pgt_Parent, RME_PGT_FLAG_CON_PARENT);
801642cc:	e51b3008 	ldr	r3, [fp, #-8]
801642d0:	e5933008 	ldr	r3, [r3, #8]
801642d4:	e2033010 	and	r3, r3, #16
801642d8:	e3530000 	cmp	r3, #0
801642dc:	1a000001 	bne	801642e8 <_RME_Pgt_Con+0x348>
801642e0:	e3e03006 	mvn	r3, #6
801642e4:	ea00005a 	b	80164454 <_RME_Pgt_Con+0x4b4>
    RME_CAP_CHECK(Pgt_Child, RME_PGT_FLAG_CHILD);
801642e8:	e51b300c 	ldr	r3, [fp, #-12]
801642ec:	e5933008 	ldr	r3, [r3, #8]
801642f0:	e2033008 	and	r3, r3, #8
801642f4:	e3530000 	cmp	r3, #0
801642f8:	1a000001 	bne	80164304 <_RME_Pgt_Con+0x364>
801642fc:	e3e03006 	mvn	r3, #6
80164300:	ea000053 	b	80164454 <_RME_Pgt_Con+0x4b4>
    /* Check the operation range - This is page table specific */
    if((Pos>RME_PGT_FLAG_HIGH(Pgt_Parent->Head.Flag))||
80164304:	e51b3008 	ldr	r3, [fp, #-8]
80164308:	e5933008 	ldr	r3, [r3, #8]
8016430c:	e1a03a23 	lsr	r3, r3, #20
80164310:	e51b2028 	ldr	r2, [fp, #-40]	@ 0xffffffd8
80164314:	e1520003 	cmp	r2, r3
80164318:	8a000006 	bhi	80164338 <_RME_Pgt_Con+0x398>
       (Pos<RME_PGT_FLAG_LOW(Pgt_Parent->Head.Flag)))
8016431c:	e51b3008 	ldr	r3, [fp, #-8]
80164320:	e5933008 	ldr	r3, [r3, #8]
80164324:	e1a03423 	lsr	r3, r3, #8
80164328:	e7eb3053 	ubfx	r3, r3, #0, #12
    if((Pos>RME_PGT_FLAG_HIGH(Pgt_Parent->Head.Flag))||
8016432c:	e51b2028 	ldr	r2, [fp, #-40]	@ 0xffffffd8
80164330:	e1520003 	cmp	r2, r3
80164334:	2a000001 	bcs	80164340 <_RME_Pgt_Con+0x3a0>
    {
        RME_COV_MARKER();

        return RME_ERR_CPT_FLAG;
80164338:	e3e03006 	mvn	r3, #6
8016433c:	ea000044 	b	80164454 <_RME_Pgt_Con+0x4b4>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* See if the mapping range is allowed */
    if((Pos>>RME_PGT_NMORD(Pgt_Parent->Order))!=0U)
80164340:	e51b3008 	ldr	r3, [fp, #-8]
80164344:	e5933014 	ldr	r3, [r3, #20]
80164348:	e6ff3073 	uxth	r3, r3
8016434c:	e51b2028 	ldr	r2, [fp, #-40]	@ 0xffffffd8
80164350:	e1a03332 	lsr	r3, r2, r3
80164354:	e3530000 	cmp	r3, #0
80164358:	0a000001 	beq	80164364 <_RME_Pgt_Con+0x3c4>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_ADDR;
8016435c:	e3e03064 	mvn	r3, #100	@ 0x64
80164360:	ea00003b 	b	80164454 <_RME_Pgt_Con+0x4b4>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* See if the child table falls within one slot of the parent table */
    Order_Child=RME_PGT_NMORD(Pgt_Child->Order)+RME_PGT_SZORD(Pgt_Child->Order);
80164364:	e51b300c 	ldr	r3, [fp, #-12]
80164368:	e5933014 	ldr	r3, [r3, #20]
8016436c:	e6ff2073 	uxth	r2, r3
80164370:	e51b300c 	ldr	r3, [fp, #-12]
80164374:	e5933014 	ldr	r3, [r3, #20]
80164378:	e1a03823 	lsr	r3, r3, #16
8016437c:	e0823003 	add	r3, r2, r3
80164380:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Szord_Parent=RME_PGT_SZORD(Pgt_Parent->Order);
80164384:	e51b3008 	ldr	r3, [fp, #-8]
80164388:	e5933014 	ldr	r3, [r3, #20]
8016438c:	e1a03823 	lsr	r3, r3, #16
80164390:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    if(Szord_Parent<Order_Child)
80164394:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80164398:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016439c:	e1520003 	cmp	r2, r3
801643a0:	2a000001 	bcs	801643ac <_RME_Pgt_Con+0x40c>
    {
        RME_COV_MARKER();
        
        return RME_ERR_PGT_ADDR;
801643a4:	e3e03064 	mvn	r3, #100	@ 0x64
801643a8:	ea000029 	b	80164454 <_RME_Pgt_Con+0x4b4>
        RME_COV_MARKER();
        /* No action required */
    }
#else
    /* Force no path compression when virtual mappings are enabled */
    if(Szord_Parent!=Order_Child)
801643ac:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
801643b0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801643b4:	e1520003 	cmp	r2, r3
801643b8:	0a000001 	beq	801643c4 <_RME_Pgt_Con+0x424>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_ADDR;
801643bc:	e3e03064 	mvn	r3, #100	@ 0x64
801643c0:	ea000023 	b	80164454 <_RME_Pgt_Con+0x4b4>
    }
#endif

    /* Actually do the mapping - This work is passed down to the HAL. 
     * Under multi-core, HAL should use CAS to avoid a conflict */
    if(__RME_Pgt_Pgdir_Map(Pgt_Parent,Pos,Pgt_Child,Flag_Child)<0)
801643c4:	e59b3004 	ldr	r3, [fp, #4]
801643c8:	e51b200c 	ldr	r2, [fp, #-12]
801643cc:	e51b1028 	ldr	r1, [fp, #-40]	@ 0xffffffd8
801643d0:	e51b0008 	ldr	r0, [fp, #-8]
801643d4:	eb001eef 	bl	8016bf98 <__RME_Pgt_Pgdir_Map>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Increase refcnt for both parent/child */
    Pgt_Root=RME_CAP_CONV_ROOT(Pgt_Parent,struct RME_Cap_Pgt*);
801643d8:	e51b3008 	ldr	r3, [fp, #-8]
801643dc:	e5933000 	ldr	r3, [r3]
801643e0:	e6ff3073 	uxth	r3, r3
801643e4:	e3530000 	cmp	r3, #0
801643e8:	0a000002 	beq	801643f8 <_RME_Pgt_Con+0x458>
801643ec:	e51b3008 	ldr	r3, [fp, #-8]
801643f0:	e5933004 	ldr	r3, [r3, #4]
801643f4:	ea000000 	b	801643fc <_RME_Pgt_Con+0x45c>
801643f8:	e51b3008 	ldr	r3, [fp, #-8]
801643fc:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    RME_FETCH_ADD(&(Pgt_Root->Head.Root_Ref),1);
80164400:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164404:	e2833004 	add	r3, r3, #4
80164408:	e3a01001 	mov	r1, #1
8016440c:	e1a00003 	mov	r0, r3
80164410:	ebfff211 	bl	80160c5c <_RME_Fetch_Add_Single>
    Pgt_Root=RME_CAP_CONV_ROOT(Pgt_Child,struct RME_Cap_Pgt*);
80164414:	e51b300c 	ldr	r3, [fp, #-12]
80164418:	e5933000 	ldr	r3, [r3]
8016441c:	e6ff3073 	uxth	r3, r3
80164420:	e3530000 	cmp	r3, #0
80164424:	0a000002 	beq	80164434 <_RME_Pgt_Con+0x494>
80164428:	e51b300c 	ldr	r3, [fp, #-12]
8016442c:	e5933004 	ldr	r3, [r3, #4]
80164430:	ea000000 	b	80164438 <_RME_Pgt_Con+0x498>
80164434:	e51b300c 	ldr	r3, [fp, #-12]
80164438:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    RME_FETCH_ADD(&(Pgt_Root->Head.Root_Ref),1);
8016443c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164440:	e2833004 	add	r3, r3, #4
80164444:	e3a01001 	mov	r1, #1
80164448:	e1a00003 	mov	r0, r3
8016444c:	ebfff202 	bl	80160c5c <_RME_Fetch_Add_Single>

    return 0;
80164450:	e3a03000 	mov	r3, #0
}
80164454:	e1a00003 	mov	r0, r3
80164458:	e24bd004 	sub	sp, fp, #4
8016445c:	e8bd8800 	pop	{fp, pc}

80164460 <_RME_Pgt_Des>:
#if(RME_PGT_RAW_ENABLE==0U)
static rme_ret_t _RME_Pgt_Des(struct RME_Cap_Cpt* Cpt, 
                              rme_cid_t Cap_Pgt_Parent,
                              rme_ptr_t Pos,
                              rme_cid_t Cap_Pgt_Child)
{
80164460:	e92d4800 	push	{fp, lr}
80164464:	e28db004 	add	fp, sp, #4
80164468:	e24dd020 	sub	sp, sp, #32
8016446c:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80164470:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
80164474:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
80164478:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    struct RME_Cap_Pgt* Pgt_Child;
    struct RME_Cap_Pgt* Pgt_Root;
    rme_ptr_t Type_Stat;
    
    /* Get the cap location that we care about */
    RME_CPT_GETCAP(Cpt,Cap_Pgt_Parent,RME_CAP_TYPE_CPT,
8016447c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164480:	e2033080 	and	r3, r3, #128	@ 0x80
80164484:	e3530000 	cmp	r3, #0
80164488:	1a00001d 	bne	80164504 <_RME_Pgt_Des+0xa4>
8016448c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164490:	e5932014 	ldr	r2, [r3, #20]
80164494:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164498:	e1520003 	cmp	r2, r3
8016449c:	8a000001 	bhi	801644a8 <_RME_Pgt_Des+0x48>
801644a0:	e3e03002 	mvn	r3, #2
801644a4:	ea000106 	b	801648c4 <_RME_Pgt_Des+0x464>
801644a8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801644ac:	e1a02283 	lsl	r2, r3, #5
801644b0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801644b4:	e593300c 	ldr	r3, [r3, #12]
801644b8:	e0823003 	add	r3, r2, r3
801644bc:	e50b3008 	str	r3, [fp, #-8]
801644c0:	e51b3008 	ldr	r3, [fp, #-8]
801644c4:	e1a00003 	mov	r0, r3
801644c8:	ebfff08c 	bl	80160700 <__RME_A7A_Read_Acquire>
801644cc:	e50b0010 	str	r0, [fp, #-16]
801644d0:	e51b3010 	ldr	r3, [fp, #-16]
801644d4:	e1a03823 	lsr	r3, r3, #16
801644d8:	e6ef3073 	uxtb	r3, r3
801644dc:	e3530002 	cmp	r3, #2
801644e0:	1a000001 	bne	801644ec <_RME_Pgt_Des+0x8c>
801644e4:	e3e03008 	mvn	r3, #8
801644e8:	ea0000f5 	b	801648c4 <_RME_Pgt_Des+0x464>
801644ec:	e51b3010 	ldr	r3, [fp, #-16]
801644f0:	e1a03c23 	lsr	r3, r3, #24
801644f4:	e3530003 	cmp	r3, #3
801644f8:	0a000041 	beq	80164604 <_RME_Pgt_Des+0x1a4>
801644fc:	e3e03001 	mvn	r3, #1
80164500:	ea0000ef 	b	801648c4 <_RME_Pgt_Des+0x464>
80164504:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164508:	e1a02423 	lsr	r2, r3, #8
8016450c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164510:	e5933014 	ldr	r3, [r3, #20]
80164514:	e1520003 	cmp	r2, r3
80164518:	3a000001 	bcc	80164524 <_RME_Pgt_Des+0xc4>
8016451c:	e3e03002 	mvn	r3, #2
80164520:	ea0000e7 	b	801648c4 <_RME_Pgt_Des+0x464>
80164524:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164528:	e1a03423 	lsr	r3, r3, #8
8016452c:	e1a02283 	lsl	r2, r3, #5
80164530:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164534:	e593300c 	ldr	r3, [r3, #12]
80164538:	e0823003 	add	r3, r2, r3
8016453c:	e50b3008 	str	r3, [fp, #-8]
80164540:	e51b3008 	ldr	r3, [fp, #-8]
80164544:	e1a00003 	mov	r0, r3
80164548:	ebfff06c 	bl	80160700 <__RME_A7A_Read_Acquire>
8016454c:	e50b0010 	str	r0, [fp, #-16]
80164550:	e51b3010 	ldr	r3, [fp, #-16]
80164554:	e1a03823 	lsr	r3, r3, #16
80164558:	e6ef3073 	uxtb	r3, r3
8016455c:	e3530002 	cmp	r3, #2
80164560:	1a000001 	bne	8016456c <_RME_Pgt_Des+0x10c>
80164564:	e3e03008 	mvn	r3, #8
80164568:	ea0000d5 	b	801648c4 <_RME_Pgt_Des+0x464>
8016456c:	e51b3010 	ldr	r3, [fp, #-16]
80164570:	e1a03c23 	lsr	r3, r3, #24
80164574:	e3530003 	cmp	r3, #3
80164578:	0a000001 	beq	80164584 <_RME_Pgt_Des+0x124>
8016457c:	e3e03001 	mvn	r3, #1
80164580:	ea0000cf 	b	801648c4 <_RME_Pgt_Des+0x464>
80164584:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164588:	e203207f 	and	r2, r3, #127	@ 0x7f
8016458c:	e51b3008 	ldr	r3, [fp, #-8]
80164590:	e5933014 	ldr	r3, [r3, #20]
80164594:	e1520003 	cmp	r2, r3
80164598:	3a000001 	bcc	801645a4 <_RME_Pgt_Des+0x144>
8016459c:	e3e03002 	mvn	r3, #2
801645a0:	ea0000c7 	b	801648c4 <_RME_Pgt_Des+0x464>
801645a4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801645a8:	e203307f 	and	r3, r3, #127	@ 0x7f
801645ac:	e1a02283 	lsl	r2, r3, #5
801645b0:	e51b3008 	ldr	r3, [fp, #-8]
801645b4:	e593300c 	ldr	r3, [r3, #12]
801645b8:	e0823003 	add	r3, r2, r3
801645bc:	e50b3008 	str	r3, [fp, #-8]
801645c0:	e51b3008 	ldr	r3, [fp, #-8]
801645c4:	e1a00003 	mov	r0, r3
801645c8:	ebfff04c 	bl	80160700 <__RME_A7A_Read_Acquire>
801645cc:	e50b0010 	str	r0, [fp, #-16]
801645d0:	e51b3010 	ldr	r3, [fp, #-16]
801645d4:	e1a03823 	lsr	r3, r3, #16
801645d8:	e6ef3073 	uxtb	r3, r3
801645dc:	e3530002 	cmp	r3, #2
801645e0:	1a000001 	bne	801645ec <_RME_Pgt_Des+0x18c>
801645e4:	e3e03008 	mvn	r3, #8
801645e8:	ea0000b5 	b	801648c4 <_RME_Pgt_Des+0x464>
801645ec:	e51b3010 	ldr	r3, [fp, #-16]
801645f0:	e1a03c23 	lsr	r3, r3, #24
801645f4:	e3530003 	cmp	r3, #3
801645f8:	0a000001 	beq	80164604 <_RME_Pgt_Des+0x1a4>
801645fc:	e3e03001 	mvn	r3, #1
80164600:	ea0000af 	b	801648c4 <_RME_Pgt_Des+0x464>
                   struct RME_Cap_Pgt*,Pgt_Parent,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Pgt_Child,RME_CAP_TYPE_CPT,
80164604:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164608:	e2033080 	and	r3, r3, #128	@ 0x80
8016460c:	e3530000 	cmp	r3, #0
80164610:	1a00001d 	bne	8016468c <_RME_Pgt_Des+0x22c>
80164614:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164618:	e5932014 	ldr	r2, [r3, #20]
8016461c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164620:	e1520003 	cmp	r2, r3
80164624:	8a000001 	bhi	80164630 <_RME_Pgt_Des+0x1d0>
80164628:	e3e03002 	mvn	r3, #2
8016462c:	ea0000a4 	b	801648c4 <_RME_Pgt_Des+0x464>
80164630:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164634:	e1a02283 	lsl	r2, r3, #5
80164638:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016463c:	e593300c 	ldr	r3, [r3, #12]
80164640:	e0823003 	add	r3, r2, r3
80164644:	e50b300c 	str	r3, [fp, #-12]
80164648:	e51b300c 	ldr	r3, [fp, #-12]
8016464c:	e1a00003 	mov	r0, r3
80164650:	ebfff02a 	bl	80160700 <__RME_A7A_Read_Acquire>
80164654:	e50b0010 	str	r0, [fp, #-16]
80164658:	e51b3010 	ldr	r3, [fp, #-16]
8016465c:	e1a03823 	lsr	r3, r3, #16
80164660:	e6ef3073 	uxtb	r3, r3
80164664:	e3530002 	cmp	r3, #2
80164668:	1a000001 	bne	80164674 <_RME_Pgt_Des+0x214>
8016466c:	e3e03008 	mvn	r3, #8
80164670:	ea000093 	b	801648c4 <_RME_Pgt_Des+0x464>
80164674:	e51b3010 	ldr	r3, [fp, #-16]
80164678:	e1a03c23 	lsr	r3, r3, #24
8016467c:	e3530003 	cmp	r3, #3
80164680:	0a000041 	beq	8016478c <_RME_Pgt_Des+0x32c>
80164684:	e3e03001 	mvn	r3, #1
80164688:	ea00008d 	b	801648c4 <_RME_Pgt_Des+0x464>
8016468c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164690:	e1a02423 	lsr	r2, r3, #8
80164694:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164698:	e5933014 	ldr	r3, [r3, #20]
8016469c:	e1520003 	cmp	r2, r3
801646a0:	3a000001 	bcc	801646ac <_RME_Pgt_Des+0x24c>
801646a4:	e3e03002 	mvn	r3, #2
801646a8:	ea000085 	b	801648c4 <_RME_Pgt_Des+0x464>
801646ac:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801646b0:	e1a03423 	lsr	r3, r3, #8
801646b4:	e1a02283 	lsl	r2, r3, #5
801646b8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801646bc:	e593300c 	ldr	r3, [r3, #12]
801646c0:	e0823003 	add	r3, r2, r3
801646c4:	e50b300c 	str	r3, [fp, #-12]
801646c8:	e51b300c 	ldr	r3, [fp, #-12]
801646cc:	e1a00003 	mov	r0, r3
801646d0:	ebfff00a 	bl	80160700 <__RME_A7A_Read_Acquire>
801646d4:	e50b0010 	str	r0, [fp, #-16]
801646d8:	e51b3010 	ldr	r3, [fp, #-16]
801646dc:	e1a03823 	lsr	r3, r3, #16
801646e0:	e6ef3073 	uxtb	r3, r3
801646e4:	e3530002 	cmp	r3, #2
801646e8:	1a000001 	bne	801646f4 <_RME_Pgt_Des+0x294>
801646ec:	e3e03008 	mvn	r3, #8
801646f0:	ea000073 	b	801648c4 <_RME_Pgt_Des+0x464>
801646f4:	e51b3010 	ldr	r3, [fp, #-16]
801646f8:	e1a03c23 	lsr	r3, r3, #24
801646fc:	e3530003 	cmp	r3, #3
80164700:	0a000001 	beq	8016470c <_RME_Pgt_Des+0x2ac>
80164704:	e3e03001 	mvn	r3, #1
80164708:	ea00006d 	b	801648c4 <_RME_Pgt_Des+0x464>
8016470c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164710:	e203207f 	and	r2, r3, #127	@ 0x7f
80164714:	e51b300c 	ldr	r3, [fp, #-12]
80164718:	e5933014 	ldr	r3, [r3, #20]
8016471c:	e1520003 	cmp	r2, r3
80164720:	3a000001 	bcc	8016472c <_RME_Pgt_Des+0x2cc>
80164724:	e3e03002 	mvn	r3, #2
80164728:	ea000065 	b	801648c4 <_RME_Pgt_Des+0x464>
8016472c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164730:	e203307f 	and	r3, r3, #127	@ 0x7f
80164734:	e1a02283 	lsl	r2, r3, #5
80164738:	e51b300c 	ldr	r3, [fp, #-12]
8016473c:	e593300c 	ldr	r3, [r3, #12]
80164740:	e0823003 	add	r3, r2, r3
80164744:	e50b300c 	str	r3, [fp, #-12]
80164748:	e51b300c 	ldr	r3, [fp, #-12]
8016474c:	e1a00003 	mov	r0, r3
80164750:	ebffefea 	bl	80160700 <__RME_A7A_Read_Acquire>
80164754:	e50b0010 	str	r0, [fp, #-16]
80164758:	e51b3010 	ldr	r3, [fp, #-16]
8016475c:	e1a03823 	lsr	r3, r3, #16
80164760:	e6ef3073 	uxtb	r3, r3
80164764:	e3530002 	cmp	r3, #2
80164768:	1a000001 	bne	80164774 <_RME_Pgt_Des+0x314>
8016476c:	e3e03008 	mvn	r3, #8
80164770:	ea000053 	b	801648c4 <_RME_Pgt_Des+0x464>
80164774:	e51b3010 	ldr	r3, [fp, #-16]
80164778:	e1a03c23 	lsr	r3, r3, #24
8016477c:	e3530003 	cmp	r3, #3
80164780:	0a000001 	beq	8016478c <_RME_Pgt_Des+0x32c>
80164784:	e3e03001 	mvn	r3, #1
80164788:	ea00004d 	b	801648c4 <_RME_Pgt_Des+0x464>
                   struct RME_Cap_Pgt*,Pgt_Child,Type_Stat);
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Pgt_Parent, RME_PGT_FLAG_DES_PARENT);
8016478c:	e51b3008 	ldr	r3, [fp, #-8]
80164790:	e5933008 	ldr	r3, [r3, #8]
80164794:	e2033020 	and	r3, r3, #32
80164798:	e3530000 	cmp	r3, #0
8016479c:	1a000001 	bne	801647a8 <_RME_Pgt_Des+0x348>
801647a0:	e3e03006 	mvn	r3, #6
801647a4:	ea000046 	b	801648c4 <_RME_Pgt_Des+0x464>
    RME_CAP_CHECK(Pgt_Child, RME_PGT_FLAG_CHILD);
801647a8:	e51b300c 	ldr	r3, [fp, #-12]
801647ac:	e5933008 	ldr	r3, [r3, #8]
801647b0:	e2033008 	and	r3, r3, #8
801647b4:	e3530000 	cmp	r3, #0
801647b8:	1a000001 	bne	801647c4 <_RME_Pgt_Des+0x364>
801647bc:	e3e03006 	mvn	r3, #6
801647c0:	ea00003f 	b	801648c4 <_RME_Pgt_Des+0x464>
    /* Check the operation range - This is page table specific */
    if((Pos>RME_PGT_FLAG_HIGH(Pgt_Parent->Head.Flag))||
801647c4:	e51b3008 	ldr	r3, [fp, #-8]
801647c8:	e5933008 	ldr	r3, [r3, #8]
801647cc:	e1a03a23 	lsr	r3, r3, #20
801647d0:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
801647d4:	e1520003 	cmp	r2, r3
801647d8:	8a000006 	bhi	801647f8 <_RME_Pgt_Des+0x398>
       (Pos<RME_PGT_FLAG_LOW(Pgt_Parent->Head.Flag)))
801647dc:	e51b3008 	ldr	r3, [fp, #-8]
801647e0:	e5933008 	ldr	r3, [r3, #8]
801647e4:	e1a03423 	lsr	r3, r3, #8
801647e8:	e7eb3053 	ubfx	r3, r3, #0, #12
    if((Pos>RME_PGT_FLAG_HIGH(Pgt_Parent->Head.Flag))||
801647ec:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
801647f0:	e1520003 	cmp	r2, r3
801647f4:	2a000001 	bcs	80164800 <_RME_Pgt_Des+0x3a0>
    {
        RME_COV_MARKER();

        return RME_ERR_CPT_FLAG;
801647f8:	e3e03006 	mvn	r3, #6
801647fc:	ea000030 	b	801648c4 <_RME_Pgt_Des+0x464>
        RME_COV_MARKER();
        /* No action required */
    }

    /* See if the unmapping range is allowed */
    if((Pos>>RME_PGT_NMORD(Pgt_Parent->Order))!=0U)
80164800:	e51b3008 	ldr	r3, [fp, #-8]
80164804:	e5933014 	ldr	r3, [r3, #20]
80164808:	e6ff3073 	uxth	r3, r3
8016480c:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80164810:	e1a03332 	lsr	r3, r2, r3
80164814:	e3530000 	cmp	r3, #0
80164818:	0a000001 	beq	80164824 <_RME_Pgt_Des+0x3c4>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_ADDR;
8016481c:	e3e03064 	mvn	r3, #100	@ 0x64
80164820:	ea000027 	b	801648c4 <_RME_Pgt_Des+0x464>

    /* Actually do the mapping - This work is passed down to the HAL. 
     * Under multi-core, HAL should use CAS to avoid a conflict. Also,
     * the HAL needs to guarantee that the Child is actually mapped there,
     * and use that as the old value in CAS */
    if(__RME_Pgt_Pgdir_Unmap(Pgt_Parent,Pos,Pgt_Child)<0)
80164824:	e51b200c 	ldr	r2, [fp, #-12]
80164828:	e51b1020 	ldr	r1, [fp, #-32]	@ 0xffffffe0
8016482c:	e51b0008 	ldr	r0, [fp, #-8]
80164830:	eb001de4 	bl	8016bfc8 <__RME_Pgt_Pgdir_Unmap>
80164834:	e1a03000 	mov	r3, r0
80164838:	e3530000 	cmp	r3, #0
8016483c:	aa000001 	bge	80164848 <_RME_Pgt_Des+0x3e8>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_MAP;
80164840:	e3e03065 	mvn	r3, #101	@ 0x65
80164844:	ea00001e 	b	801648c4 <_RME_Pgt_Des+0x464>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Decrease refcnt for both parent/child */
    Pgt_Root=RME_CAP_CONV_ROOT(Pgt_Parent,struct RME_Cap_Pgt*);
80164848:	e51b3008 	ldr	r3, [fp, #-8]
8016484c:	e5933000 	ldr	r3, [r3]
80164850:	e6ff3073 	uxth	r3, r3
80164854:	e3530000 	cmp	r3, #0
80164858:	0a000002 	beq	80164868 <_RME_Pgt_Des+0x408>
8016485c:	e51b3008 	ldr	r3, [fp, #-8]
80164860:	e5933004 	ldr	r3, [r3, #4]
80164864:	ea000000 	b	8016486c <_RME_Pgt_Des+0x40c>
80164868:	e51b3008 	ldr	r3, [fp, #-8]
8016486c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    RME_FETCH_ADD(&(Pgt_Root->Head.Root_Ref),-1);
80164870:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164874:	e2833004 	add	r3, r3, #4
80164878:	e3e01000 	mvn	r1, #0
8016487c:	e1a00003 	mov	r0, r3
80164880:	ebfff0f5 	bl	80160c5c <_RME_Fetch_Add_Single>
    Pgt_Root=RME_CAP_CONV_ROOT(Pgt_Child,struct RME_Cap_Pgt*);
80164884:	e51b300c 	ldr	r3, [fp, #-12]
80164888:	e5933000 	ldr	r3, [r3]
8016488c:	e6ff3073 	uxth	r3, r3
80164890:	e3530000 	cmp	r3, #0
80164894:	0a000002 	beq	801648a4 <_RME_Pgt_Des+0x444>
80164898:	e51b300c 	ldr	r3, [fp, #-12]
8016489c:	e5933004 	ldr	r3, [r3, #4]
801648a0:	ea000000 	b	801648a8 <_RME_Pgt_Des+0x448>
801648a4:	e51b300c 	ldr	r3, [fp, #-12]
801648a8:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    RME_FETCH_ADD(&(Pgt_Root->Head.Root_Ref),-1);
801648ac:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801648b0:	e2833004 	add	r3, r3, #4
801648b4:	e3e01000 	mvn	r1, #0
801648b8:	e1a00003 	mov	r0, r3
801648bc:	ebfff0e6 	bl	80160c5c <_RME_Fetch_Add_Single>

    return 0;
801648c0:	e3a03000 	mov	r3, #0
}
801648c4:	e1a00003 	mov	r0, r3
801648c8:	e24bd004 	sub	sp, fp, #4
801648cc:	e8bd8800 	pop	{fp, pc}

801648d0 <_RME_Kot_Init>:
Output      : None.
Return      : rme_ret_t - If the number of words are is not sufficient to hold 
                          all kernel memory, -1; else 0.
******************************************************************************/
rme_ret_t _RME_Kot_Init(rme_ptr_t Word)
{
801648d0:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
801648d4:	e28db000 	add	fp, sp, #0
801648d8:	e24dd014 	sub	sp, sp, #20
801648dc:	e50b0010 	str	r0, [fp, #-16]
    rme_ptr_t Count;
    
    if(Word<RME_KOT_WORD_NUM)
801648e0:	e51b3010 	ldr	r3, [fp, #-16]
801648e4:	e3530602 	cmp	r3, #2097152	@ 0x200000
801648e8:	2a000001 	bcs	801648f4 <_RME_Kot_Init+0x24>
    {
        RME_COV_MARKER();

        return -1;
801648ec:	e3e03000 	mvn	r3, #0
801648f0:	ea00000f 	b	80164934 <_RME_Kot_Init+0x64>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Zero out the whole table */
    for(Count=0U;Count<Word;Count++)
801648f4:	e3a03000 	mov	r3, #0
801648f8:	e50b3008 	str	r3, [fp, #-8]
801648fc:	ea000007 	b	80164920 <_RME_Kot_Init+0x50>
    {
        RME_KOT_VA_BASE[Count]=0U;
80164900:	e30d3118 	movw	r3, #53528	@ 0xd118
80164904:	e3483016 	movt	r3, #32790	@ 0x8016
80164908:	e51b2008 	ldr	r2, [fp, #-8]
8016490c:	e3a01000 	mov	r1, #0
80164910:	e7831102 	str	r1, [r3, r2, lsl #2]
    for(Count=0U;Count<Word;Count++)
80164914:	e51b3008 	ldr	r3, [fp, #-8]
80164918:	e2833001 	add	r3, r3, #1
8016491c:	e50b3008 	str	r3, [fp, #-8]
80164920:	e51b2008 	ldr	r2, [fp, #-8]
80164924:	e51b3010 	ldr	r3, [fp, #-16]
80164928:	e1520003 	cmp	r2, r3
8016492c:	3afffff3 	bcc	80164900 <_RME_Kot_Init+0x30>
    }

    return 0;
80164930:	e3a03000 	mov	r3, #0
}
80164934:	e1a00003 	mov	r0, r3
80164938:	e28bd000 	add	sp, fp, #0
8016493c:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80164940:	e12fff1e 	bx	lr

80164944 <_RME_Kot_Mark>:
Output      : None.
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
rme_ret_t _RME_Kot_Mark(rme_ptr_t Kaddr,
                        rme_ptr_t Size)
{
80164944:	e92d4800 	push	{fp, lr}
80164948:	e28db004 	add	fp, sp, #4
8016494c:	e24dd028 	sub	sp, sp, #40	@ 0x28
80164950:	e50b0028 	str	r0, [fp, #-40]	@ 0xffffffd8
80164954:	e50b102c 	str	r1, [fp, #-44]	@ 0xffffffd4
    rme_ptr_t Mask_Begin;
    /* The mask at the end word */
    rme_ptr_t Mask_End;

    /* Check if the marking is well aligned */
    if((Kaddr&RME_MASK_END(RME_KOM_SLOT_ORDER-1U))!=0U)
80164958:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016495c:	e203300f 	and	r3, r3, #15
80164960:	e3530000 	cmp	r3, #0
80164964:	0a000001 	beq	80164970 <_RME_Kot_Mark+0x2c>
    {
        RME_COV_MARKER();

        return RME_ERR_KOT_BMP;
80164968:	e3e03000 	mvn	r3, #0
8016496c:	ea0000c2 	b	80164c7c <_RME_Kot_Mark+0x338>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Round the marking to RME_KOM_SLOT_ORDER boundary, and rely on compiler for optimization */
    Start=(Kaddr-RME_KOM_VA_BASE)>>RME_KOM_SLOT_ORDER;
80164970:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80164974:	e283347f 	add	r3, r3, #2130706432	@ 0x7f000000
80164978:	e1a03223 	lsr	r3, r3, #4
8016497c:	e50b3010 	str	r3, [fp, #-16]
    Mask_Begin=RME_MASK_BEGIN(Start&RME_MASK_END(RME_WORD_ORDER-1U));
80164980:	e51b3010 	ldr	r3, [fp, #-16]
80164984:	e203301f 	and	r3, r3, #31
80164988:	e3e02000 	mvn	r2, #0
8016498c:	e1a03312 	lsl	r3, r2, r3
80164990:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Start=Start>>RME_WORD_ORDER;
80164994:	e51b3010 	ldr	r3, [fp, #-16]
80164998:	e1a032a3 	lsr	r3, r3, #5
8016499c:	e50b3010 	str	r3, [fp, #-16]
    
    End=(Kaddr+Size-1U-RME_KOM_VA_BASE)>>RME_KOM_SLOT_ORDER;
801649a0:	e51b2028 	ldr	r2, [fp, #-40]	@ 0xffffffd8
801649a4:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801649a8:	e0823003 	add	r3, r2, r3
801649ac:	e283347f 	add	r3, r3, #2130706432	@ 0x7f000000
801649b0:	e2433001 	sub	r3, r3, #1
801649b4:	e1a03223 	lsr	r3, r3, #4
801649b8:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Mask_End=RME_MASK_END(End&RME_MASK_END(RME_WORD_ORDER-1U));
801649bc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801649c0:	e1e03003 	mvn	r3, r3
801649c4:	e203301f 	and	r3, r3, #31
801649c8:	e3e02000 	mvn	r2, #0
801649cc:	e1a03332 	lsr	r3, r2, r3
801649d0:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    End=End>>RME_WORD_ORDER;
801649d4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801649d8:	e1a032a3 	lsr	r3, r3, #5
801649dc:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    
    /* See if the start and end are in the same word */
    if(Start==End)
801649e0:	e51b2010 	ldr	r2, [fp, #-16]
801649e4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801649e8:	e1520003 	cmp	r2, r3
801649ec:	1a00001f 	bne	80164a70 <_RME_Kot_Mark+0x12c>
    {
        RME_COV_MARKER();

        /* Someone already populated something here */
        Old_Val=RME_KOT_VA_BASE[Start];
801649f0:	e30d3118 	movw	r3, #53528	@ 0xd118
801649f4:	e3483016 	movt	r3, #32790	@ 0x8016
801649f8:	e51b2010 	ldr	r2, [fp, #-16]
801649fc:	e7933102 	ldr	r3, [r3, r2, lsl #2]
80164a00:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
        if((Old_Val&(Mask_Begin&Mask_End))!=0U)
80164a04:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80164a08:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164a0c:	e0022003 	and	r2, r2, r3
80164a10:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80164a14:	e0033002 	and	r3, r3, r2
80164a18:	e3530000 	cmp	r3, #0
80164a1c:	0a000001 	beq	80164a28 <_RME_Kot_Mark+0xe4>
        {
            RME_COV_MARKER();

            return RME_ERR_KOT_BMP;
80164a20:	e3e03000 	mvn	r3, #0
80164a24:	ea000094 	b	80164c7c <_RME_Kot_Mark+0x338>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Check done, do the marking with CAS */
        if(RME_COMP_SWAP(&RME_KOT_VA_BASE[Start],
80164a28:	e51b3010 	ldr	r3, [fp, #-16]
80164a2c:	e1a02103 	lsl	r2, r3, #2
80164a30:	e30d3118 	movw	r3, #53528	@ 0xd118
80164a34:	e3483016 	movt	r3, #32790	@ 0x8016
80164a38:	e0820003 	add	r0, r2, r3
80164a3c:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80164a40:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164a44:	e0022003 	and	r2, r2, r3
80164a48:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80164a4c:	e1823003 	orr	r3, r2, r3
80164a50:	e1a02003 	mov	r2, r3
80164a54:	e51b1020 	ldr	r1, [fp, #-32]	@ 0xffffffe0
80164a58:	ebfff06a 	bl	80160c08 <_RME_Comp_Swap_Single>
80164a5c:	e1a03000 	mov	r3, r0
80164a60:	e3530000 	cmp	r3, #0
80164a64:	1a000083 	bne	80164c78 <_RME_Kot_Mark+0x334>
                         Old_Val,
                         Old_Val|(Mask_Begin&Mask_End))==RME_CASFAIL)
        {
            RME_COV_MARKER();

            return RME_ERR_KOT_BMP;
80164a68:	e3e03000 	mvn	r3, #0
80164a6c:	ea000082 	b	80164c7c <_RME_Kot_Mark+0x338>
    }
    else
    {
        RME_COV_MARKER();
        
        Undo=0U;
80164a70:	e3a03000 	mov	r3, #0
80164a74:	e50b300c 	str	r3, [fp, #-12]
        /* Check&Mark the start */
        Old_Val=RME_KOT_VA_BASE[Start];
80164a78:	e30d3118 	movw	r3, #53528	@ 0xd118
80164a7c:	e3483016 	movt	r3, #32790	@ 0x8016
80164a80:	e51b2010 	ldr	r2, [fp, #-16]
80164a84:	e7933102 	ldr	r3, [r3, r2, lsl #2]
80164a88:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
        if((Old_Val&Mask_Begin)!=0U)
80164a8c:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80164a90:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164a94:	e0033002 	and	r3, r3, r2
80164a98:	e3530000 	cmp	r3, #0
80164a9c:	0a000001 	beq	80164aa8 <_RME_Kot_Mark+0x164>
        {
            RME_COV_MARKER();

            return RME_ERR_KOT_BMP;
80164aa0:	e3e03000 	mvn	r3, #0
80164aa4:	ea000074 	b	80164c7c <_RME_Kot_Mark+0x338>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        if(RME_COMP_SWAP(&RME_KOT_VA_BASE[Start],
80164aa8:	e51b3010 	ldr	r3, [fp, #-16]
80164aac:	e1a02103 	lsl	r2, r3, #2
80164ab0:	e30d3118 	movw	r3, #53528	@ 0xd118
80164ab4:	e3483016 	movt	r3, #32790	@ 0x8016
80164ab8:	e0820003 	add	r0, r2, r3
80164abc:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80164ac0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164ac4:	e1823003 	orr	r3, r2, r3
80164ac8:	e1a02003 	mov	r2, r3
80164acc:	e51b1020 	ldr	r1, [fp, #-32]	@ 0xffffffe0
80164ad0:	ebfff04c 	bl	80160c08 <_RME_Comp_Swap_Single>
80164ad4:	e1a03000 	mov	r3, r0
80164ad8:	e3530000 	cmp	r3, #0
80164adc:	1a000001 	bne	80164ae8 <_RME_Kot_Mark+0x1a4>
                         Old_Val,
                         Old_Val|Mask_Begin)==RME_CASFAIL)
        {
            RME_COV_MARKER();

            return RME_ERR_KOT_BMP;
80164ae0:	e3e03000 	mvn	r3, #0
80164ae4:	ea000064 	b	80164c7c <_RME_Kot_Mark+0x338>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Check&Mark the middle */
        for(Count=Start+1U;Count<End;Count++)
80164ae8:	e51b3010 	ldr	r3, [fp, #-16]
80164aec:	e2833001 	add	r3, r3, #1
80164af0:	e50b3008 	str	r3, [fp, #-8]
80164af4:	ea00001c 	b	80164b6c <_RME_Kot_Mark+0x228>
        {
            Old_Val=RME_KOT_VA_BASE[Count];
80164af8:	e30d3118 	movw	r3, #53528	@ 0xd118
80164afc:	e3483016 	movt	r3, #32790	@ 0x8016
80164b00:	e51b2008 	ldr	r2, [fp, #-8]
80164b04:	e7933102 	ldr	r3, [r3, r2, lsl #2]
80164b08:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
            if(Old_Val!=0U)
80164b0c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80164b10:	e3530000 	cmp	r3, #0
80164b14:	0a000002 	beq	80164b24 <_RME_Kot_Mark+0x1e0>
            {
                RME_COV_MARKER();

                Undo=1U;
80164b18:	e3a03001 	mov	r3, #1
80164b1c:	e50b300c 	str	r3, [fp, #-12]
                break;
80164b20:	ea000015 	b	80164b7c <_RME_Kot_Mark+0x238>
            }
            else
            {
                RME_COV_MARKER();
                
                if(RME_COMP_SWAP(&RME_KOT_VA_BASE[Count],
80164b24:	e51b3008 	ldr	r3, [fp, #-8]
80164b28:	e1a02103 	lsl	r2, r3, #2
80164b2c:	e30d3118 	movw	r3, #53528	@ 0xd118
80164b30:	e3483016 	movt	r3, #32790	@ 0x8016
80164b34:	e0823003 	add	r3, r2, r3
80164b38:	e3e02000 	mvn	r2, #0
80164b3c:	e51b1020 	ldr	r1, [fp, #-32]	@ 0xffffffe0
80164b40:	e1a00003 	mov	r0, r3
80164b44:	ebfff02f 	bl	80160c08 <_RME_Comp_Swap_Single>
80164b48:	e1a03000 	mov	r3, r0
80164b4c:	e3530000 	cmp	r3, #0
80164b50:	1a000002 	bne	80164b60 <_RME_Kot_Mark+0x21c>
                                 Old_Val,
                                 RME_MASK_FULL)==RME_CASFAIL)
                {
                    RME_COV_MARKER();
                    
                    Undo=1U;
80164b54:	e3a03001 	mov	r3, #1
80164b58:	e50b300c 	str	r3, [fp, #-12]
                    break;
80164b5c:	ea000006 	b	80164b7c <_RME_Kot_Mark+0x238>
        for(Count=Start+1U;Count<End;Count++)
80164b60:	e51b3008 	ldr	r3, [fp, #-8]
80164b64:	e2833001 	add	r3, r3, #1
80164b68:	e50b3008 	str	r3, [fp, #-8]
80164b6c:	e51b2008 	ldr	r2, [fp, #-8]
80164b70:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164b74:	e1520003 	cmp	r2, r3
80164b78:	3affffde 	bcc	80164af8 <_RME_Kot_Mark+0x1b4>
                }
            }
        }
        
        /* See if the middle part failed. If yes, we skip the end marking */
        if(Undo==0U)
80164b7c:	e51b300c 	ldr	r3, [fp, #-12]
80164b80:	e3530000 	cmp	r3, #0
80164b84:	1a00001c 	bne	80164bfc <_RME_Kot_Mark+0x2b8>
        {
            RME_COV_MARKER();

            /* Check&Mark the end */
            Old_Val=RME_KOT_VA_BASE[End];
80164b88:	e30d3118 	movw	r3, #53528	@ 0xd118
80164b8c:	e3483016 	movt	r3, #32790	@ 0x8016
80164b90:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80164b94:	e7933102 	ldr	r3, [r3, r2, lsl #2]
80164b98:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
            if((Old_Val&Mask_End)!=0U)
80164b9c:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80164ba0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164ba4:	e0033002 	and	r3, r3, r2
80164ba8:	e3530000 	cmp	r3, #0
80164bac:	0a000002 	beq	80164bbc <_RME_Kot_Mark+0x278>
            {
                RME_COV_MARKER();

                Undo=1U;
80164bb0:	e3a03001 	mov	r3, #1
80164bb4:	e50b300c 	str	r3, [fp, #-12]
80164bb8:	ea00000f 	b	80164bfc <_RME_Kot_Mark+0x2b8>
            }
            else
            {
                RME_COV_MARKER();

                if(RME_COMP_SWAP(&RME_KOT_VA_BASE[End],
80164bbc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164bc0:	e1a02103 	lsl	r2, r3, #2
80164bc4:	e30d3118 	movw	r3, #53528	@ 0xd118
80164bc8:	e3483016 	movt	r3, #32790	@ 0x8016
80164bcc:	e0820003 	add	r0, r2, r3
80164bd0:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80164bd4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164bd8:	e1823003 	orr	r3, r2, r3
80164bdc:	e1a02003 	mov	r2, r3
80164be0:	e51b1020 	ldr	r1, [fp, #-32]	@ 0xffffffe0
80164be4:	ebfff007 	bl	80160c08 <_RME_Comp_Swap_Single>
80164be8:	e1a03000 	mov	r3, r0
80164bec:	e3530000 	cmp	r3, #0
80164bf0:	1a000001 	bne	80164bfc <_RME_Kot_Mark+0x2b8>
                                 Old_Val,
                                 Old_Val|Mask_End)==RME_CASFAIL)
                {
                    RME_COV_MARKER();

                    Undo=1U;
80164bf4:	e3a03001 	mov	r3, #1
80164bf8:	e50b300c 	str	r3, [fp, #-12]
        {
            RME_COV_MARKER();
        }
        
        /* See if we need to undo. If yes, proceed to unroll and return error */
        if(Undo!=0U)
80164bfc:	e51b300c 	ldr	r3, [fp, #-12]
80164c00:	e3530000 	cmp	r3, #0
80164c04:	0a00001b 	beq	80164c78 <_RME_Kot_Mark+0x334>
        {
            RME_COV_MARKER();

            /* Undo the middle part - no CAS neeeded, write back is always atomic */
            for(Count--;Count>Start;Count--)
80164c08:	e51b3008 	ldr	r3, [fp, #-8]
80164c0c:	e2433001 	sub	r3, r3, #1
80164c10:	e50b3008 	str	r3, [fp, #-8]
80164c14:	ea000007 	b	80164c38 <_RME_Kot_Mark+0x2f4>
            {
                RME_KOT_VA_BASE[Count]=0U;
80164c18:	e30d3118 	movw	r3, #53528	@ 0xd118
80164c1c:	e3483016 	movt	r3, #32790	@ 0x8016
80164c20:	e51b2008 	ldr	r2, [fp, #-8]
80164c24:	e3a01000 	mov	r1, #0
80164c28:	e7831102 	str	r1, [r3, r2, lsl #2]
            for(Count--;Count>Start;Count--)
80164c2c:	e51b3008 	ldr	r3, [fp, #-8]
80164c30:	e2433001 	sub	r3, r3, #1
80164c34:	e50b3008 	str	r3, [fp, #-8]
80164c38:	e51b2008 	ldr	r2, [fp, #-8]
80164c3c:	e51b3010 	ldr	r3, [fp, #-16]
80164c40:	e1520003 	cmp	r2, r3
80164c44:	8afffff3 	bhi	80164c18 <_RME_Kot_Mark+0x2d4>
            }
            /* Undo the first word - need atomic instructions */
            RME_FETCH_AND(&(RME_KOT_VA_BASE[Start]),~Mask_Begin);
80164c48:	e51b3010 	ldr	r3, [fp, #-16]
80164c4c:	e1a02103 	lsl	r2, r3, #2
80164c50:	e30d3118 	movw	r3, #53528	@ 0xd118
80164c54:	e3483016 	movt	r3, #32790	@ 0x8016
80164c58:	e0822003 	add	r2, r2, r3
80164c5c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164c60:	e1e03003 	mvn	r3, r3
80164c64:	e1a01003 	mov	r1, r3
80164c68:	e1a00002 	mov	r0, r2
80164c6c:	ebfff00d 	bl	80160ca8 <_RME_Fetch_And_Single>
            /* Return failure */
            return RME_ERR_KOT_BMP;
80164c70:	e3e03000 	mvn	r3, #0
80164c74:	ea000000 	b	80164c7c <_RME_Kot_Mark+0x338>
            RME_COV_MARKER();
            /* No action required */
        }
    }

    return 0;
80164c78:	e3a03000 	mov	r3, #0
}
80164c7c:	e1a00003 	mov	r0, r3
80164c80:	e24bd004 	sub	sp, fp, #4
80164c84:	e8bd8800 	pop	{fp, pc}

80164c88 <_RME_Kot_Erase>:
Output      : None.
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
rme_ret_t _RME_Kot_Erase(rme_ptr_t Kaddr,
                         rme_ptr_t Size)
{
80164c88:	e92d4800 	push	{fp, lr}
80164c8c:	e28db004 	add	fp, sp, #4
80164c90:	e24dd020 	sub	sp, sp, #32
80164c94:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
80164c98:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
    /* The mask at the end word */
    rme_ptr_t Mask_End;
    rme_ptr_t Count;

    /* Check if the marking is well aligned */
    if((Kaddr&RME_MASK_END(RME_KOM_SLOT_ORDER-1U))!=0U)
80164c9c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80164ca0:	e203300f 	and	r3, r3, #15
80164ca4:	e3530000 	cmp	r3, #0
80164ca8:	0a000001 	beq	80164cb4 <_RME_Kot_Erase+0x2c>
    {
        RME_COV_MARKER();

        return RME_ERR_KOT_BMP;
80164cac:	e3e03000 	mvn	r3, #0
80164cb0:	ea00008a 	b	80164ee0 <_RME_Kot_Erase+0x258>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Round the marking to RME_KOM_SLOT_ORDER boundary, and rely on compiler for optimization */
    Start=(Kaddr-RME_KOM_VA_BASE)>>RME_KOM_SLOT_ORDER;
80164cb4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80164cb8:	e283347f 	add	r3, r3, #2130706432	@ 0x7f000000
80164cbc:	e1a03223 	lsr	r3, r3, #4
80164cc0:	e50b300c 	str	r3, [fp, #-12]
    Mask_Begin=RME_MASK_BEGIN(Start&RME_MASK_END(RME_WORD_ORDER-1U));
80164cc4:	e51b300c 	ldr	r3, [fp, #-12]
80164cc8:	e203301f 	and	r3, r3, #31
80164ccc:	e3e02000 	mvn	r2, #0
80164cd0:	e1a03312 	lsl	r3, r2, r3
80164cd4:	e50b3010 	str	r3, [fp, #-16]
    Start=Start>>RME_WORD_ORDER;
80164cd8:	e51b300c 	ldr	r3, [fp, #-12]
80164cdc:	e1a032a3 	lsr	r3, r3, #5
80164ce0:	e50b300c 	str	r3, [fp, #-12]
    
    End=(Kaddr+Size-1U-RME_KOM_VA_BASE)>>RME_KOM_SLOT_ORDER;
80164ce4:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80164ce8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164cec:	e0823003 	add	r3, r2, r3
80164cf0:	e283347f 	add	r3, r3, #2130706432	@ 0x7f000000
80164cf4:	e2433001 	sub	r3, r3, #1
80164cf8:	e1a03223 	lsr	r3, r3, #4
80164cfc:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Mask_End=RME_MASK_END(End&RME_MASK_END(RME_WORD_ORDER-1U));
80164d00:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164d04:	e1e03003 	mvn	r3, r3
80164d08:	e203301f 	and	r3, r3, #31
80164d0c:	e3e02000 	mvn	r2, #0
80164d10:	e1a03332 	lsr	r3, r2, r3
80164d14:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    End=End>>RME_WORD_ORDER;
80164d18:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164d1c:	e1a032a3 	lsr	r3, r3, #5
80164d20:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    
    /* See if the start and end are in the same word */
    if(Start==End)
80164d24:	e51b200c 	ldr	r2, [fp, #-12]
80164d28:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164d2c:	e1520003 	cmp	r2, r3
80164d30:	1a00001a 	bne	80164da0 <_RME_Kot_Erase+0x118>
    {
        RME_COV_MARKER();

        /* This address range is not fully populated */
        if((RME_KOT_VA_BASE[Start]&(Mask_Begin&Mask_End))!=(Mask_Begin&Mask_End))
80164d34:	e30d3118 	movw	r3, #53528	@ 0xd118
80164d38:	e3483016 	movt	r3, #32790	@ 0x8016
80164d3c:	e51b200c 	ldr	r2, [fp, #-12]
80164d40:	e7932102 	ldr	r2, [r3, r2, lsl #2]
80164d44:	e51b1010 	ldr	r1, [fp, #-16]
80164d48:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164d4c:	e0033001 	and	r3, r3, r1
80164d50:	e0022003 	and	r2, r2, r3
80164d54:	e51b1010 	ldr	r1, [fp, #-16]
80164d58:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164d5c:	e0033001 	and	r3, r3, r1
80164d60:	e1520003 	cmp	r2, r3
80164d64:	0a000001 	beq	80164d70 <_RME_Kot_Erase+0xe8>
        {
            RME_COV_MARKER();

            return RME_ERR_KOT_BMP;
80164d68:	e3e03000 	mvn	r3, #0
80164d6c:	ea00005b 	b	80164ee0 <_RME_Kot_Erase+0x258>
            RME_COV_MARKER();
            /* No action required */
        }

        /* Check done, do the unmarking - need atomic operations */
        RME_FETCH_AND(&(RME_KOT_VA_BASE[Start]),~(Mask_Begin&Mask_End));
80164d70:	e51b300c 	ldr	r3, [fp, #-12]
80164d74:	e1a02103 	lsl	r2, r3, #2
80164d78:	e30d3118 	movw	r3, #53528	@ 0xd118
80164d7c:	e3483016 	movt	r3, #32790	@ 0x8016
80164d80:	e0820003 	add	r0, r2, r3
80164d84:	e51b2010 	ldr	r2, [fp, #-16]
80164d88:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164d8c:	e0033002 	and	r3, r3, r2
80164d90:	e1e03003 	mvn	r3, r3
80164d94:	e1a01003 	mov	r1, r3
80164d98:	ebffefc2 	bl	80160ca8 <_RME_Fetch_And_Single>
80164d9c:	ea00004e 	b	80164edc <_RME_Kot_Erase+0x254>
    else
    {
        RME_COV_MARKER();

        /* Check the start */
        if((RME_KOT_VA_BASE[Start]&Mask_Begin)!=Mask_Begin)
80164da0:	e30d3118 	movw	r3, #53528	@ 0xd118
80164da4:	e3483016 	movt	r3, #32790	@ 0x8016
80164da8:	e51b200c 	ldr	r2, [fp, #-12]
80164dac:	e7932102 	ldr	r2, [r3, r2, lsl #2]
80164db0:	e51b3010 	ldr	r3, [fp, #-16]
80164db4:	e0033002 	and	r3, r3, r2
80164db8:	e51b2010 	ldr	r2, [fp, #-16]
80164dbc:	e1520003 	cmp	r2, r3
80164dc0:	0a000001 	beq	80164dcc <_RME_Kot_Erase+0x144>
        {
            RME_COV_MARKER();

            return RME_ERR_KOT_BMP;
80164dc4:	e3e03000 	mvn	r3, #0
80164dc8:	ea000044 	b	80164ee0 <_RME_Kot_Erase+0x258>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Check the middle */
        for(Count=Start+1U;Count<End-1U;Count++)
80164dcc:	e51b300c 	ldr	r3, [fp, #-12]
80164dd0:	e2833001 	add	r3, r3, #1
80164dd4:	e50b3008 	str	r3, [fp, #-8]
80164dd8:	ea00000a 	b	80164e08 <_RME_Kot_Erase+0x180>
        {
            if(RME_KOT_VA_BASE[Count]!=RME_MASK_FULL)
80164ddc:	e30d3118 	movw	r3, #53528	@ 0xd118
80164de0:	e3483016 	movt	r3, #32790	@ 0x8016
80164de4:	e51b2008 	ldr	r2, [fp, #-8]
80164de8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
80164dec:	e3730001 	cmn	r3, #1
80164df0:	0a000001 	beq	80164dfc <_RME_Kot_Erase+0x174>
            {
                RME_COV_MARKER();

                return RME_ERR_KOT_BMP;
80164df4:	e3e03000 	mvn	r3, #0
80164df8:	ea000038 	b	80164ee0 <_RME_Kot_Erase+0x258>
        for(Count=Start+1U;Count<End-1U;Count++)
80164dfc:	e51b3008 	ldr	r3, [fp, #-8]
80164e00:	e2833001 	add	r3, r3, #1
80164e04:	e50b3008 	str	r3, [fp, #-8]
80164e08:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164e0c:	e2433001 	sub	r3, r3, #1
80164e10:	e51b2008 	ldr	r2, [fp, #-8]
80164e14:	e1520003 	cmp	r2, r3
80164e18:	3affffef 	bcc	80164ddc <_RME_Kot_Erase+0x154>
                /* No action required */
            }
        }

        /* Check the end */
        if((RME_KOT_VA_BASE[End]&Mask_End)!=Mask_End)
80164e1c:	e30d3118 	movw	r3, #53528	@ 0xd118
80164e20:	e3483016 	movt	r3, #32790	@ 0x8016
80164e24:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80164e28:	e7932102 	ldr	r2, [r3, r2, lsl #2]
80164e2c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164e30:	e0033002 	and	r3, r3, r2
80164e34:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80164e38:	e1520003 	cmp	r2, r3
80164e3c:	0a000001 	beq	80164e48 <_RME_Kot_Erase+0x1c0>
        {
            RME_COV_MARKER();

            return RME_ERR_KOT_BMP;
80164e40:	e3e03000 	mvn	r3, #0
80164e44:	ea000025 	b	80164ee0 <_RME_Kot_Erase+0x258>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Erase the start - make it atomic */
        RME_FETCH_AND(&(RME_KOT_VA_BASE[Start]),~Mask_Begin);
80164e48:	e51b300c 	ldr	r3, [fp, #-12]
80164e4c:	e1a02103 	lsl	r2, r3, #2
80164e50:	e30d3118 	movw	r3, #53528	@ 0xd118
80164e54:	e3483016 	movt	r3, #32790	@ 0x8016
80164e58:	e0822003 	add	r2, r2, r3
80164e5c:	e51b3010 	ldr	r3, [fp, #-16]
80164e60:	e1e03003 	mvn	r3, r3
80164e64:	e1a01003 	mov	r1, r3
80164e68:	e1a00002 	mov	r0, r2
80164e6c:	ebffef8d 	bl	80160ca8 <_RME_Fetch_And_Single>
        /* Erase the middle - do not need atomics here */
        for(Count=Start+1U;Count<End-1U;Count++)
80164e70:	e51b300c 	ldr	r3, [fp, #-12]
80164e74:	e2833001 	add	r3, r3, #1
80164e78:	e50b3008 	str	r3, [fp, #-8]
80164e7c:	ea000007 	b	80164ea0 <_RME_Kot_Erase+0x218>
        {
            RME_KOT_VA_BASE[Count]=0U;
80164e80:	e30d3118 	movw	r3, #53528	@ 0xd118
80164e84:	e3483016 	movt	r3, #32790	@ 0x8016
80164e88:	e51b2008 	ldr	r2, [fp, #-8]
80164e8c:	e3a01000 	mov	r1, #0
80164e90:	e7831102 	str	r1, [r3, r2, lsl #2]
        for(Count=Start+1U;Count<End-1U;Count++)
80164e94:	e51b3008 	ldr	r3, [fp, #-8]
80164e98:	e2833001 	add	r3, r3, #1
80164e9c:	e50b3008 	str	r3, [fp, #-8]
80164ea0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164ea4:	e2433001 	sub	r3, r3, #1
80164ea8:	e51b2008 	ldr	r2, [fp, #-8]
80164eac:	e1520003 	cmp	r2, r3
80164eb0:	3afffff2 	bcc	80164e80 <_RME_Kot_Erase+0x1f8>
        }
        /* Erase the end - make it atomic */
        RME_FETCH_AND(&(RME_KOT_VA_BASE[End]),~Mask_End);
80164eb4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164eb8:	e1a02103 	lsl	r2, r3, #2
80164ebc:	e30d3118 	movw	r3, #53528	@ 0xd118
80164ec0:	e3483016 	movt	r3, #32790	@ 0x8016
80164ec4:	e0822003 	add	r2, r2, r3
80164ec8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164ecc:	e1e03003 	mvn	r3, r3
80164ed0:	e1a01003 	mov	r1, r3
80164ed4:	e1a00002 	mov	r0, r2
80164ed8:	ebffef72 	bl	80160ca8 <_RME_Fetch_And_Single>
    }

    return 0;
80164edc:	e3a03000 	mov	r3, #0
}
80164ee0:	e1a00003 	mov	r0, r3
80164ee4:	e24bd004 	sub	sp, fp, #4
80164ee8:	e8bd8800 	pop	{fp, pc}

80164eec <_RME_CPU_Local_Init>:
Output      : None.
Return      : None.
******************************************************************************/
void _RME_CPU_Local_Init(struct RME_CPU_Local* Local,
                         rme_ptr_t CPUID)
{
80164eec:	e92d4800 	push	{fp, lr}
80164ef0:	e28db004 	add	fp, sp, #4
80164ef4:	e24dd010 	sub	sp, sp, #16
80164ef8:	e50b0010 	str	r0, [fp, #-16]
80164efc:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
    rme_ptr_t Prio_Cnt;
    
    Local->CPUID=CPUID;
80164f00:	e51b3010 	ldr	r3, [fp, #-16]
80164f04:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80164f08:	e5832000 	str	r2, [r3]
    Local->Thd_Cur=RME_NULL;
80164f0c:	e51b3010 	ldr	r3, [fp, #-16]
80164f10:	e3a02000 	mov	r2, #0
80164f14:	e5832004 	str	r2, [r3, #4]
    Local->Sig_Vct=RME_NULL;
80164f18:	e51b3010 	ldr	r3, [fp, #-16]
80164f1c:	e3a02000 	mov	r2, #0
80164f20:	e583200c 	str	r2, [r3, #12]
    Local->Sig_Tim=RME_NULL;
80164f24:	e51b3010 	ldr	r3, [fp, #-16]
80164f28:	e3a02000 	mov	r2, #0
80164f2c:	e5832008 	str	r2, [r3, #8]
    
    /* Initialize the run-queue and bitmap */
    for(Prio_Cnt=0U;Prio_Cnt<RME_PREEMPT_PRIO_NUM;Prio_Cnt++)
80164f30:	e3a03000 	mov	r3, #0
80164f34:	e50b3008 	str	r3, [fp, #-8]
80164f38:	ea000010 	b	80164f80 <_RME_CPU_Local_Init+0x94>
    {
        Local->Run.Bitmap[Prio_Cnt>>RME_WORD_ORDER]=0U;
80164f3c:	e51b3008 	ldr	r3, [fp, #-8]
80164f40:	e1a022a3 	lsr	r2, r3, #5
80164f44:	e51b3010 	ldr	r3, [fp, #-16]
80164f48:	e2822004 	add	r2, r2, #4
80164f4c:	e3a01000 	mov	r1, #0
80164f50:	e7831102 	str	r1, [r3, r2, lsl #2]
        _RME_List_Crt(&(Local->Run.List[Prio_Cnt]));
80164f54:	e51b3008 	ldr	r3, [fp, #-8]
80164f58:	e2833002 	add	r3, r3, #2
80164f5c:	e1a03183 	lsl	r3, r3, #3
80164f60:	e51b2010 	ldr	r2, [fp, #-16]
80164f64:	e0823003 	add	r3, r2, r3
80164f68:	e2833004 	add	r3, r3, #4
80164f6c:	e1a00003 	mov	r0, r3
80164f70:	ebffef5e 	bl	80160cf0 <_RME_List_Crt>
    for(Prio_Cnt=0U;Prio_Cnt<RME_PREEMPT_PRIO_NUM;Prio_Cnt++)
80164f74:	e51b3008 	ldr	r3, [fp, #-8]
80164f78:	e2833001 	add	r3, r3, #1
80164f7c:	e50b3008 	str	r3, [fp, #-8]
80164f80:	e51b3008 	ldr	r3, [fp, #-8]
80164f84:	e353001f 	cmp	r3, #31
80164f88:	9affffeb 	bls	80164f3c <_RME_CPU_Local_Init+0x50>
    }
}
80164f8c:	e320f000 	nop	{0}
80164f90:	e320f000 	nop	{0}
80164f94:	e24bd004 	sub	sp, fp, #4
80164f98:	e8bd8800 	pop	{fp, pc}

80164f9c <_RME_Run_Ins>:
              rme_ptr_t CPUID - The cpu to consult.
Output      : None.
Return      : None.
******************************************************************************/
static void _RME_Run_Ins(struct RME_Thd_Struct* Thd)
{
80164f9c:	e92d4800 	push	{fp, lr}
80164fa0:	e28db004 	add	fp, sp, #4
80164fa4:	e24dd010 	sub	sp, sp, #16
80164fa8:	e50b0010 	str	r0, [fp, #-16]
    rme_ptr_t Prio;
    struct RME_CPU_Local* Local;
    
    Prio=Thd->Sched.Prio;
80164fac:	e51b3010 	ldr	r3, [fp, #-16]
80164fb0:	e5933020 	ldr	r3, [r3, #32]
80164fb4:	e50b3008 	str	r3, [fp, #-8]
    Local=Thd->Sched.Local;
80164fb8:	e51b3010 	ldr	r3, [fp, #-16]
80164fbc:	e5933014 	ldr	r3, [r3, #20]
80164fc0:	e50b300c 	str	r3, [fp, #-12]
    
    /* It can't be free or there must be an error */
    RME_ASSERT(Local!=RME_THD_FREE);
80164fc4:	e51b300c 	ldr	r3, [fp, #-12]
80164fc8:	e3730001 	cmn	r3, #1
80164fcc:	1a000008 	bne	80164ff4 <_RME_Run_Ins+0x58>
80164fd0:	e30c3318 	movw	r3, #49944	@ 0xc318
80164fd4:	e3483016 	movt	r3, #32790	@ 0x8016
80164fd8:	e30c2324 	movw	r2, #49956	@ 0xc324
80164fdc:	e3482016 	movt	r2, #32790	@ 0x8016
80164fe0:	e301113b 	movw	r1, #4411	@ 0x113b
80164fe4:	e30c0330 	movw	r0, #49968	@ 0xc330
80164fe8:	e3480016 	movt	r0, #32790	@ 0x8016
80164fec:	ebffeee4 	bl	80160b84 <RME_Log>
80164ff0:	eafffffe 	b	80164ff0 <_RME_Run_Ins+0x54>
    
    /* Insert this thread into the runqueue */
    _RME_List_Ins(&(Thd->Sched.Run),
80164ff4:	e51b0010 	ldr	r0, [fp, #-16]
80164ff8:	e51b200c 	ldr	r2, [fp, #-12]
80164ffc:	e51b3008 	ldr	r3, [fp, #-8]
80165000:	e2833002 	add	r3, r3, #2
80165004:	e1a03183 	lsl	r3, r3, #3
80165008:	e0823003 	add	r3, r2, r3
8016500c:	e5931008 	ldr	r1, [r3, #8]
80165010:	e51b3008 	ldr	r3, [fp, #-8]
80165014:	e2833002 	add	r3, r3, #2
80165018:	e1a03183 	lsl	r3, r3, #3
8016501c:	e51b200c 	ldr	r2, [fp, #-12]
80165020:	e0823003 	add	r3, r2, r3
80165024:	e2833004 	add	r3, r3, #4
80165028:	e1a02003 	mov	r2, r3
8016502c:	ebffef4c 	bl	80160d64 <_RME_List_Ins>
                  Local->Run.List[Prio].Prev,
                  &(Local->Run.List[Prio]));
    
    /* Set the bit in the bitmap */
    RME_BITMAP_SET(Local->Run.Bitmap,Prio);
80165030:	e51b3008 	ldr	r3, [fp, #-8]
80165034:	e1a022a3 	lsr	r2, r3, #5
80165038:	e51b300c 	ldr	r3, [fp, #-12]
8016503c:	e2822004 	add	r2, r2, #4
80165040:	e7931102 	ldr	r1, [r3, r2, lsl #2]
80165044:	e51b3008 	ldr	r3, [fp, #-8]
80165048:	e203301f 	and	r3, r3, #31
8016504c:	e3a02001 	mov	r2, #1
80165050:	e1a03312 	lsl	r3, r2, r3
80165054:	e51b2008 	ldr	r2, [fp, #-8]
80165058:	e1a022a2 	lsr	r2, r2, #5
8016505c:	e1811003 	orr	r1, r1, r3
80165060:	e51b300c 	ldr	r3, [fp, #-12]
80165064:	e2822004 	add	r2, r2, #4
80165068:	e7831102 	str	r1, [r3, r2, lsl #2]
}
8016506c:	e320f000 	nop	{0}
80165070:	e24bd004 	sub	sp, fp, #4
80165074:	e8bd8800 	pop	{fp, pc}

80165078 <_RME_Run_Del>:
Input       : struct RME_Thd_Struct* Thd - The thread to delete.
Output      : None.
Return      : None.
******************************************************************************/
static void _RME_Run_Del(struct RME_Thd_Struct* Thd)
{
80165078:	e92d4800 	push	{fp, lr}
8016507c:	e28db004 	add	fp, sp, #4
80165080:	e24dd010 	sub	sp, sp, #16
80165084:	e50b0010 	str	r0, [fp, #-16]
    rme_ptr_t Prio;
    struct RME_CPU_Local* Local;
    
    Prio=Thd->Sched.Prio;
80165088:	e51b3010 	ldr	r3, [fp, #-16]
8016508c:	e5933020 	ldr	r3, [r3, #32]
80165090:	e50b3008 	str	r3, [fp, #-8]
    Local=Thd->Sched.Local;
80165094:	e51b3010 	ldr	r3, [fp, #-16]
80165098:	e5933014 	ldr	r3, [r3, #20]
8016509c:	e50b300c 	str	r3, [fp, #-12]
    /* It can't be free or there must be an error */
    RME_ASSERT(Local!=RME_THD_FREE);
801650a0:	e51b300c 	ldr	r3, [fp, #-12]
801650a4:	e3730001 	cmn	r3, #1
801650a8:	1a000008 	bne	801650d0 <_RME_Run_Del+0x58>
801650ac:	e30c3318 	movw	r3, #49944	@ 0xc318
801650b0:	e3483016 	movt	r3, #32790	@ 0x8016
801650b4:	e30c2324 	movw	r2, #49956	@ 0xc324
801650b8:	e3482016 	movt	r2, #32790	@ 0x8016
801650bc:	e3011155 	movw	r1, #4437	@ 0x1155
801650c0:	e30c0330 	movw	r0, #49968	@ 0xc330
801650c4:	e3480016 	movt	r0, #32790	@ 0x8016
801650c8:	ebffeead 	bl	80160b84 <RME_Log>
801650cc:	eafffffe 	b	801650cc <_RME_Run_Del+0x54>
    
    /* Delete this thread from the runqueue */
    _RME_List_Del(Thd->Sched.Run.Prev,Thd->Sched.Run.Next);
801650d0:	e51b3010 	ldr	r3, [fp, #-16]
801650d4:	e5932004 	ldr	r2, [r3, #4]
801650d8:	e51b3010 	ldr	r3, [fp, #-16]
801650dc:	e5933000 	ldr	r3, [r3]
801650e0:	e1a01003 	mov	r1, r3
801650e4:	e1a00002 	mov	r0, r2
801650e8:	ebffef0e 	bl	80160d28 <_RME_List_Del>
    
    /* See if there are any thread on this priority level */
    if(Local->Run.List[Prio].Next==&(Local->Run.List[Prio]))
801650ec:	e51b200c 	ldr	r2, [fp, #-12]
801650f0:	e51b3008 	ldr	r3, [fp, #-8]
801650f4:	e2833002 	add	r3, r3, #2
801650f8:	e1a03183 	lsl	r3, r3, #3
801650fc:	e0823003 	add	r3, r2, r3
80165100:	e5932004 	ldr	r2, [r3, #4]
80165104:	e51b3008 	ldr	r3, [fp, #-8]
80165108:	e2833002 	add	r3, r3, #2
8016510c:	e1a03183 	lsl	r3, r3, #3
80165110:	e51b100c 	ldr	r1, [fp, #-12]
80165114:	e0813003 	add	r3, r1, r3
80165118:	e2833004 	add	r3, r3, #4
8016511c:	e1520003 	cmp	r2, r3
80165120:	1a00000f 	bne	80165164 <_RME_Run_Del+0xec>
    {
        RME_COV_MARKER();

        /* Nothing running, clear the bit in the bitmap */
        RME_BITMAP_CLR(Local->Run.Bitmap,Prio);
80165124:	e51b3008 	ldr	r3, [fp, #-8]
80165128:	e1a022a3 	lsr	r2, r3, #5
8016512c:	e51b300c 	ldr	r3, [fp, #-12]
80165130:	e2822004 	add	r2, r2, #4
80165134:	e7931102 	ldr	r1, [r3, r2, lsl #2]
80165138:	e51b3008 	ldr	r3, [fp, #-8]
8016513c:	e203301f 	and	r3, r3, #31
80165140:	e3a02001 	mov	r2, #1
80165144:	e1a03312 	lsl	r3, r2, r3
80165148:	e1e03003 	mvn	r3, r3
8016514c:	e51b2008 	ldr	r2, [fp, #-8]
80165150:	e1a022a2 	lsr	r2, r2, #5
80165154:	e0011003 	and	r1, r1, r3
80165158:	e51b300c 	ldr	r3, [fp, #-12]
8016515c:	e2822004 	add	r2, r2, #4
80165160:	e7831102 	str	r1, [r3, r2, lsl #2]
    else
    {
        RME_COV_MARKER();
        /* No action required */
    }
}
80165164:	e320f000 	nop	{0}
80165168:	e24bd004 	sub	sp, fp, #4
8016516c:	e8bd8800 	pop	{fp, pc}

80165170 <_RME_Run_High>:
Input       : struct RME_CPU_Local* Local - The CPU-local data structure.
Output      : None.
Return      : struct RME_Thd_Struct* - The thread returned.
******************************************************************************/
static struct RME_Thd_Struct* _RME_Run_High(struct RME_CPU_Local* Local)
{
80165170:	e92d4800 	push	{fp, lr}
80165174:	e28db004 	add	fp, sp, #4
80165178:	e24dd010 	sub	sp, sp, #16
8016517c:	e50b0010 	str	r0, [fp, #-16]
    rme_cnt_t Count;
    rme_ptr_t Prio;
    
    /* We start looking for preemption priority levels from the highest */
    for(Count=(rme_cnt_t)(RME_PRIO_WORD_NUM-1U);Count>=0;Count--)
80165180:	e3a03000 	mov	r3, #0
80165184:	e50b3008 	str	r3, [fp, #-8]
80165188:	ea000008 	b	801651b0 <_RME_Run_High+0x40>
    {
        if(Local->Run.Bitmap[Count]!=0U)
8016518c:	e51b3010 	ldr	r3, [fp, #-16]
80165190:	e51b2008 	ldr	r2, [fp, #-8]
80165194:	e2822004 	add	r2, r2, #4
80165198:	e7933102 	ldr	r3, [r3, r2, lsl #2]
8016519c:	e3530000 	cmp	r3, #0
801651a0:	1a000006 	bne	801651c0 <_RME_Run_High+0x50>
    for(Count=(rme_cnt_t)(RME_PRIO_WORD_NUM-1U);Count>=0;Count--)
801651a4:	e51b3008 	ldr	r3, [fp, #-8]
801651a8:	e2433001 	sub	r3, r3, #1
801651ac:	e50b3008 	str	r3, [fp, #-8]
801651b0:	e51b3008 	ldr	r3, [fp, #-8]
801651b4:	e3530000 	cmp	r3, #0
801651b8:	aafffff3 	bge	8016518c <_RME_Run_High+0x1c>
801651bc:	ea000000 	b	801651c4 <_RME_Run_High+0x54>
        {
            RME_COV_MARKER();
            
            break;
801651c0:	e320f000 	nop	{0}
            /* No action required */
        }
    }
    
    /* It must be possible to find one thread per core */
    RME_ASSERT(Count>=0);
801651c4:	e51b3008 	ldr	r3, [fp, #-8]
801651c8:	e3530000 	cmp	r3, #0
801651cc:	aa000008 	bge	801651f4 <_RME_Run_High+0x84>
801651d0:	e30c3318 	movw	r3, #49944	@ 0xc318
801651d4:	e3483016 	movt	r3, #32790	@ 0x8016
801651d8:	e30c2324 	movw	r2, #49956	@ 0xc324
801651dc:	e3482016 	movt	r2, #32790	@ 0x8016
801651e0:	e3011186 	movw	r1, #4486	@ 0x1186
801651e4:	e30c0330 	movw	r0, #49968	@ 0xc330
801651e8:	e3480016 	movt	r0, #32790	@ 0x8016
801651ec:	ebffee64 	bl	80160b84 <RME_Log>
801651f0:	eafffffe 	b	801651f0 <_RME_Run_High+0x80>

    /* Get the first "1"'s position in the word */
    Prio=RME_MSB_GET(Local->Run.Bitmap[Count]);
801651f4:	e51b3010 	ldr	r3, [fp, #-16]
801651f8:	e51b2008 	ldr	r2, [fp, #-8]
801651fc:	e2822004 	add	r2, r2, #4
80165200:	e7933102 	ldr	r3, [r3, r2, lsl #2]
80165204:	e1a00003 	mov	r0, r3
80165208:	ebffed4a 	bl	80160738 <__RME_A7A_MSB_Get>
8016520c:	e50b000c 	str	r0, [fp, #-12]
    Prio+=((rme_ptr_t)Count)<<RME_WORD_ORDER;
80165210:	e51b3008 	ldr	r3, [fp, #-8]
80165214:	e1a03283 	lsl	r3, r3, #5
80165218:	e51b200c 	ldr	r2, [fp, #-12]
8016521c:	e0823003 	add	r3, r2, r3
80165220:	e50b300c 	str	r3, [fp, #-12]

    /* Now there is something at this priority level. Get it and start to run */
    return (struct RME_Thd_Struct*)(Local->Run.List[Prio].Next);
80165224:	e51b2010 	ldr	r2, [fp, #-16]
80165228:	e51b300c 	ldr	r3, [fp, #-12]
8016522c:	e2833002 	add	r3, r3, #2
80165230:	e1a03183 	lsl	r3, r3, #3
80165234:	e0823003 	add	r3, r2, r3
80165238:	e5933004 	ldr	r3, [r3, #4]
}
8016523c:	e1a00003 	mov	r0, r3
80165240:	e24bd004 	sub	sp, fp, #4
80165244:	e8bd8800 	pop	{fp, pc}

80165248 <_RME_Run_Notif>:
Input       : struct RME_Thd_Struct* Thd - The thread to send notification for.
Output      : None.
Return      : None.
******************************************************************************/
static void _RME_Run_Notif(struct RME_Thd_Struct* Thd)
{
80165248:	e92d4800 	push	{fp, lr}
8016524c:	e28db004 	add	fp, sp, #4
80165250:	e24dd010 	sub	sp, sp, #16
80165254:	e50b0010 	str	r0, [fp, #-16]
    struct RME_Thd_Struct* Sched_Thd;
    
    Sched_Thd=Thd->Sched.Sched_Thd;
80165258:	e51b3010 	ldr	r3, [fp, #-16]
8016525c:	e5933034 	ldr	r3, [r3, #52]	@ 0x34
80165260:	e50b3008 	str	r3, [fp, #-8]
    
    /* See if there is already a notification. If yes, do not do the send again */
    if(Thd->Sched.Notif.Next==&(Thd->Sched.Notif))
80165264:	e51b3010 	ldr	r3, [fp, #-16]
80165268:	e5932008 	ldr	r2, [r3, #8]
8016526c:	e51b3010 	ldr	r3, [fp, #-16]
80165270:	e2833008 	add	r3, r3, #8
80165274:	e1520003 	cmp	r2, r3
80165278:	1a000007 	bne	8016529c <_RME_Run_Notif+0x54>
    {
        RME_COV_MARKER();

        _RME_List_Ins(&(Thd->Sched.Notif), 
8016527c:	e51b3010 	ldr	r3, [fp, #-16]
80165280:	e2830008 	add	r0, r3, #8
80165284:	e51b3008 	ldr	r3, [fp, #-8]
80165288:	e5931040 	ldr	r1, [r3, #64]	@ 0x40
8016528c:	e51b3008 	ldr	r3, [fp, #-8]
80165290:	e283303c 	add	r3, r3, #60	@ 0x3c
80165294:	e1a02003 	mov	r2, r3
80165298:	ebffeeb1 	bl	80160d64 <_RME_List_Ins>
        RME_COV_MARKER();
        /* No action required */
    }

    /* If this guy have an endpoint, send to it */
    if(Thd->Sched.Sched_Sig!=0U)
8016529c:	e51b3010 	ldr	r3, [fp, #-16]
801652a0:	e5933038 	ldr	r3, [r3, #56]	@ 0x38
801652a4:	e3530000 	cmp	r3, #0
801652a8:	0a000003 	beq	801652bc <_RME_Run_Notif+0x74>
    {
        RME_COV_MARKER();
        _RME_Kern_Snd(Thd->Sched.Sched_Sig);
801652ac:	e51b3010 	ldr	r3, [fp, #-16]
801652b0:	e5933038 	ldr	r3, [r3, #56]	@ 0x38
801652b4:	e1a00003 	mov	r0, r3
801652b8:	eb001178 	bl	801698a0 <_RME_Kern_Snd>
    else
    {
        RME_COV_MARKER();
        /* No action required */
    }
}
801652bc:	e320f000 	nop	{0}
801652c0:	e24bd004 	sub	sp, fp, #4
801652c4:	e8bd8800 	pop	{fp, pc}

801652c8 <_RME_Thd_Pgt>:
#if(RME_PGT_RAW_ENABLE==0U)
struct RME_Cap_Pgt* _RME_Thd_Pgt(struct RME_Thd_Struct* Thd)
#else
rme_ptr_t _RME_Thd_Pgt(struct RME_Thd_Struct* Thd)
#endif
{
801652c8:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
801652cc:	e28db000 	add	fp, sp, #0
801652d0:	e24dd014 	sub	sp, sp, #20
801652d4:	e50b0010 	str	r0, [fp, #-16]
    struct RME_Inv_Struct* Inv_Top;
    
    Inv_Top=RME_INVSTK_TOP(Thd);
801652d8:	e51b3010 	ldr	r3, [fp, #-16]
801652dc:	e593204c 	ldr	r2, [r3, #76]	@ 0x4c
801652e0:	e51b3010 	ldr	r3, [fp, #-16]
801652e4:	e283304c 	add	r3, r3, #76	@ 0x4c
801652e8:	e1520003 	cmp	r2, r3
801652ec:	0a000002 	beq	801652fc <_RME_Thd_Pgt+0x34>
801652f0:	e51b3010 	ldr	r3, [fp, #-16]
801652f4:	e593304c 	ldr	r3, [r3, #76]	@ 0x4c
801652f8:	ea000000 	b	80165300 <_RME_Thd_Pgt+0x38>
801652fc:	e3a03000 	mov	r3, #0
80165300:	e50b3008 	str	r3, [fp, #-8]
    
    if(Inv_Top==RME_NULL)
80165304:	e51b3008 	ldr	r3, [fp, #-8]
80165308:	e3530000 	cmp	r3, #0
8016530c:	1a000003 	bne	80165320 <_RME_Thd_Pgt+0x58>
    {
        RME_COV_MARKER();

        return Thd->Sched.Prc->Pgt;
80165310:	e51b3010 	ldr	r3, [fp, #-16]
80165314:	e593302c 	ldr	r3, [r3, #44]	@ 0x2c
80165318:	e5933018 	ldr	r3, [r3, #24]
8016531c:	ea000002 	b	8016532c <_RME_Thd_Pgt+0x64>
    }
    else
    {
        RME_COV_MARKER();

        return Inv_Top->Prc->Pgt;
80165320:	e51b3008 	ldr	r3, [fp, #-8]
80165324:	e5933008 	ldr	r3, [r3, #8]
80165328:	e5933018 	ldr	r3, [r3, #24]
    }
}
8016532c:	e1a00003 	mov	r0, r3
80165330:	e28bd000 	add	sp, fp, #0
80165334:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80165338:	e12fff1e 	bx	lr

8016533c <_RME_Run_Swt>:
Return      : rme_ret_t - Always 0.
******************************************************************************/
static rme_ret_t _RME_Run_Swt(struct RME_Reg_Struct* Reg,
                              struct RME_Thd_Struct* Thd_Cur, 
                              struct RME_Thd_Struct* Thd_New)
{
8016533c:	e92d4800 	push	{fp, lr}
80165340:	e28db004 	add	fp, sp, #4
80165344:	e24dd020 	sub	sp, sp, #32
80165348:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
8016534c:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
80165350:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    rme_ptr_t Pgt_New;
#endif
    struct RME_Reg_Struct* Reg_Cur;
    struct RME_Reg_Struct* Reg_New;
    
    Reg_Cur=&(Thd_Cur->Ctx.Reg->Reg);
80165354:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80165358:	e5933048 	ldr	r3, [r3, #72]	@ 0x48
8016535c:	e50b3008 	str	r3, [fp, #-8]
    Reg_New=&(Thd_New->Ctx.Reg->Reg);
80165360:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165364:	e5933048 	ldr	r3, [r3, #72]	@ 0x48
80165368:	e50b300c 	str	r3, [fp, #-12]
    
    /* Save register context */
    __RME_Thd_Reg_Copy(Reg_Cur,Reg);
8016536c:	e51b1018 	ldr	r1, [fp, #-24]	@ 0xffffffe8
80165370:	e51b0008 	ldr	r0, [fp, #-8]
80165374:	eb0019a6 	bl	8016ba14 <__RME_Thd_Reg_Copy>
                       RME_THD_IS_HYP(Thd_Cur->Ctx.Hyp_Attr),
                       Reg_Cur,Thd_Cur->Ctx.Reg->Cop);
#endif

    /* Load register context */
    __RME_Thd_Reg_Copy(Reg,Reg_New);
80165378:	e51b100c 	ldr	r1, [fp, #-12]
8016537c:	e51b0018 	ldr	r0, [fp, #-24]	@ 0xffffffe8
80165380:	eb0019a3 	bl	8016ba14 <__RME_Thd_Reg_Copy>

    /* Are we going to switch page tables? If yes, we change it now */
    Pgt_Cur=_RME_Thd_Pgt(Thd_Cur);
80165384:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80165388:	ebffffce 	bl	801652c8 <_RME_Thd_Pgt>
8016538c:	e50b0010 	str	r0, [fp, #-16]
    Pgt_New=_RME_Thd_Pgt(Thd_New);
80165390:	e51b0020 	ldr	r0, [fp, #-32]	@ 0xffffffe0
80165394:	ebffffcb 	bl	801652c8 <_RME_Thd_Pgt>
80165398:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
    
#if(RME_PGT_RAW_ENABLE==0U)
    /* The page tables here must be root cap */
    RME_ASSERT(RME_CAP_IS_ROOT(Pgt_Cur)!=0U);
8016539c:	e51b3010 	ldr	r3, [fp, #-16]
801653a0:	e5933000 	ldr	r3, [r3]
801653a4:	e6ff3073 	uxth	r3, r3
801653a8:	e3530000 	cmp	r3, #0
801653ac:	0a000008 	beq	801653d4 <_RME_Run_Swt+0x98>
801653b0:	e30c3318 	movw	r3, #49944	@ 0xc318
801653b4:	e3483016 	movt	r3, #32790	@ 0x8016
801653b8:	e30c2324 	movw	r2, #49956	@ 0xc324
801653bc:	e3482016 	movt	r2, #32790	@ 0x8016
801653c0:	e301120b 	movw	r1, #4619	@ 0x120b
801653c4:	e30c0330 	movw	r0, #49968	@ 0xc330
801653c8:	e3480016 	movt	r0, #32790	@ 0x8016
801653cc:	ebffedec 	bl	80160b84 <RME_Log>
801653d0:	eafffffe 	b	801653d0 <_RME_Run_Swt+0x94>
    RME_ASSERT(RME_CAP_IS_ROOT(Pgt_New)!=0U);
801653d4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801653d8:	e5933000 	ldr	r3, [r3]
801653dc:	e6ff3073 	uxth	r3, r3
801653e0:	e3530000 	cmp	r3, #0
801653e4:	0a000008 	beq	8016540c <_RME_Run_Swt+0xd0>
801653e8:	e30c3318 	movw	r3, #49944	@ 0xc318
801653ec:	e3483016 	movt	r3, #32790	@ 0x8016
801653f0:	e30c2324 	movw	r2, #49956	@ 0xc324
801653f4:	e3482016 	movt	r2, #32790	@ 0x8016
801653f8:	e301120c 	movw	r1, #4620	@ 0x120c
801653fc:	e30c0330 	movw	r0, #49968	@ 0xc330
80165400:	e3480016 	movt	r0, #32790	@ 0x8016
80165404:	ebffedde 	bl	80160b84 <RME_Log>
80165408:	eafffffe 	b	80165408 <_RME_Run_Swt+0xcc>
#endif
    
#if(RME_PGT_RAW_ENABLE==0U)
    if(RME_CAP_GETOBJ(Pgt_Cur,rme_ptr_t)!=RME_CAP_GETOBJ(Pgt_New,rme_ptr_t))
8016540c:	e51b3010 	ldr	r3, [fp, #-16]
80165410:	e593200c 	ldr	r2, [r3, #12]
80165414:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165418:	e593300c 	ldr	r3, [r3, #12]
8016541c:	e1520003 	cmp	r2, r3
80165420:	0a000002 	beq	80165430 <_RME_Run_Swt+0xf4>
    if(Pgt_Cur!=Pgt_New)
#endif
    {
        RME_COV_MARKER();
        
        __RME_Pgt_Set(Pgt_New);
80165424:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165428:	e1a00003 	mov	r0, r3
8016542c:	eb001a7a 	bl	8016be1c <__RME_Pgt_Set>
    {
        RME_COV_MARKER();
        /* No action required */
    }

    return 0;
80165430:	e3a03000 	mov	r3, #0
}
80165434:	e1a00003 	mov	r0, r3
80165438:	e24bd004 	sub	sp, fp, #4
8016543c:	e8bd8800 	pop	{fp, pc}

80165440 <_RME_Prc_Crt>:
                              rme_cid_t Cap_Cpt_Crt,
                              rme_cid_t Cap_Prc,
                              rme_cid_t Cap_Cpt,
                              rme_ptr_t Raw_Pgt)
#endif
{
80165440:	e92d4800 	push	{fp, lr}
80165444:	e28db004 	add	fp, sp, #4
80165448:	e24dd030 	sub	sp, sp, #48	@ 0x30
8016544c:	e50b0028 	str	r0, [fp, #-40]	@ 0xffffffd8
80165450:	e50b102c 	str	r1, [fp, #-44]	@ 0xffffffd4
80165454:	e50b2030 	str	r2, [fp, #-48]	@ 0xffffffd0
80165458:	e50b3034 	str	r3, [fp, #-52]	@ 0xffffffcc
    struct RME_Cap_Pgt* Prc_Pgt;
#endif
    rme_ptr_t Type_Stat;
    
    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Crt,RME_CAP_TYPE_CPT,
8016545c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80165460:	e2033080 	and	r3, r3, #128	@ 0x80
80165464:	e3530000 	cmp	r3, #0
80165468:	1a00001d 	bne	801654e4 <_RME_Prc_Crt+0xa4>
8016546c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165470:	e5932014 	ldr	r2, [r3, #20]
80165474:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80165478:	e1520003 	cmp	r2, r3
8016547c:	8a000001 	bhi	80165488 <_RME_Prc_Crt+0x48>
80165480:	e3e03002 	mvn	r3, #2
80165484:	ea00017d 	b	80165a80 <_RME_Prc_Crt+0x640>
80165488:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016548c:	e1a02283 	lsl	r2, r3, #5
80165490:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165494:	e593300c 	ldr	r3, [r3, #12]
80165498:	e0823003 	add	r3, r2, r3
8016549c:	e50b3008 	str	r3, [fp, #-8]
801654a0:	e51b3008 	ldr	r3, [fp, #-8]
801654a4:	e1a00003 	mov	r0, r3
801654a8:	ebffec94 	bl	80160700 <__RME_A7A_Read_Acquire>
801654ac:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801654b0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801654b4:	e1a03823 	lsr	r3, r3, #16
801654b8:	e6ef3073 	uxtb	r3, r3
801654bc:	e3530002 	cmp	r3, #2
801654c0:	1a000001 	bne	801654cc <_RME_Prc_Crt+0x8c>
801654c4:	e3e03008 	mvn	r3, #8
801654c8:	ea00016c 	b	80165a80 <_RME_Prc_Crt+0x640>
801654cc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801654d0:	e1a03c23 	lsr	r3, r3, #24
801654d4:	e3530003 	cmp	r3, #3
801654d8:	0a000041 	beq	801655e4 <_RME_Prc_Crt+0x1a4>
801654dc:	e3e03001 	mvn	r3, #1
801654e0:	ea000166 	b	80165a80 <_RME_Prc_Crt+0x640>
801654e4:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801654e8:	e1a02423 	lsr	r2, r3, #8
801654ec:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801654f0:	e5933014 	ldr	r3, [r3, #20]
801654f4:	e1520003 	cmp	r2, r3
801654f8:	3a000001 	bcc	80165504 <_RME_Prc_Crt+0xc4>
801654fc:	e3e03002 	mvn	r3, #2
80165500:	ea00015e 	b	80165a80 <_RME_Prc_Crt+0x640>
80165504:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80165508:	e1a03423 	lsr	r3, r3, #8
8016550c:	e1a02283 	lsl	r2, r3, #5
80165510:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165514:	e593300c 	ldr	r3, [r3, #12]
80165518:	e0823003 	add	r3, r2, r3
8016551c:	e50b3008 	str	r3, [fp, #-8]
80165520:	e51b3008 	ldr	r3, [fp, #-8]
80165524:	e1a00003 	mov	r0, r3
80165528:	ebffec74 	bl	80160700 <__RME_A7A_Read_Acquire>
8016552c:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80165530:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165534:	e1a03823 	lsr	r3, r3, #16
80165538:	e6ef3073 	uxtb	r3, r3
8016553c:	e3530002 	cmp	r3, #2
80165540:	1a000001 	bne	8016554c <_RME_Prc_Crt+0x10c>
80165544:	e3e03008 	mvn	r3, #8
80165548:	ea00014c 	b	80165a80 <_RME_Prc_Crt+0x640>
8016554c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165550:	e1a03c23 	lsr	r3, r3, #24
80165554:	e3530003 	cmp	r3, #3
80165558:	0a000001 	beq	80165564 <_RME_Prc_Crt+0x124>
8016555c:	e3e03001 	mvn	r3, #1
80165560:	ea000146 	b	80165a80 <_RME_Prc_Crt+0x640>
80165564:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80165568:	e203207f 	and	r2, r3, #127	@ 0x7f
8016556c:	e51b3008 	ldr	r3, [fp, #-8]
80165570:	e5933014 	ldr	r3, [r3, #20]
80165574:	e1520003 	cmp	r2, r3
80165578:	3a000001 	bcc	80165584 <_RME_Prc_Crt+0x144>
8016557c:	e3e03002 	mvn	r3, #2
80165580:	ea00013e 	b	80165a80 <_RME_Prc_Crt+0x640>
80165584:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80165588:	e203307f 	and	r3, r3, #127	@ 0x7f
8016558c:	e1a02283 	lsl	r2, r3, #5
80165590:	e51b3008 	ldr	r3, [fp, #-8]
80165594:	e593300c 	ldr	r3, [r3, #12]
80165598:	e0823003 	add	r3, r2, r3
8016559c:	e50b3008 	str	r3, [fp, #-8]
801655a0:	e51b3008 	ldr	r3, [fp, #-8]
801655a4:	e1a00003 	mov	r0, r3
801655a8:	ebffec54 	bl	80160700 <__RME_A7A_Read_Acquire>
801655ac:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801655b0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801655b4:	e1a03823 	lsr	r3, r3, #16
801655b8:	e6ef3073 	uxtb	r3, r3
801655bc:	e3530002 	cmp	r3, #2
801655c0:	1a000001 	bne	801655cc <_RME_Prc_Crt+0x18c>
801655c4:	e3e03008 	mvn	r3, #8
801655c8:	ea00012c 	b	80165a80 <_RME_Prc_Crt+0x640>
801655cc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801655d0:	e1a03c23 	lsr	r3, r3, #24
801655d4:	e3530003 	cmp	r3, #3
801655d8:	0a000001 	beq	801655e4 <_RME_Prc_Crt+0x1a4>
801655dc:	e3e03001 	mvn	r3, #1
801655e0:	ea000126 	b	80165a80 <_RME_Prc_Crt+0x640>
                   struct RME_Cap_Cpt*,Cpt_Crt,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
801655e4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801655e8:	e2033080 	and	r3, r3, #128	@ 0x80
801655ec:	e3530000 	cmp	r3, #0
801655f0:	1a00001d 	bne	8016566c <_RME_Prc_Crt+0x22c>
801655f4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801655f8:	e5932014 	ldr	r2, [r3, #20]
801655fc:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80165600:	e1520003 	cmp	r2, r3
80165604:	8a000001 	bhi	80165610 <_RME_Prc_Crt+0x1d0>
80165608:	e3e03002 	mvn	r3, #2
8016560c:	ea00011b 	b	80165a80 <_RME_Prc_Crt+0x640>
80165610:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80165614:	e1a02283 	lsl	r2, r3, #5
80165618:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016561c:	e593300c 	ldr	r3, [r3, #12]
80165620:	e0823003 	add	r3, r2, r3
80165624:	e50b300c 	str	r3, [fp, #-12]
80165628:	e51b300c 	ldr	r3, [fp, #-12]
8016562c:	e1a00003 	mov	r0, r3
80165630:	ebffec32 	bl	80160700 <__RME_A7A_Read_Acquire>
80165634:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80165638:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016563c:	e1a03823 	lsr	r3, r3, #16
80165640:	e6ef3073 	uxtb	r3, r3
80165644:	e3530002 	cmp	r3, #2
80165648:	1a000001 	bne	80165654 <_RME_Prc_Crt+0x214>
8016564c:	e3e03008 	mvn	r3, #8
80165650:	ea00010a 	b	80165a80 <_RME_Prc_Crt+0x640>
80165654:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165658:	e1a03c23 	lsr	r3, r3, #24
8016565c:	e3530003 	cmp	r3, #3
80165660:	0a000041 	beq	8016576c <_RME_Prc_Crt+0x32c>
80165664:	e3e03001 	mvn	r3, #1
80165668:	ea000104 	b	80165a80 <_RME_Prc_Crt+0x640>
8016566c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80165670:	e1a02423 	lsr	r2, r3, #8
80165674:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165678:	e5933014 	ldr	r3, [r3, #20]
8016567c:	e1520003 	cmp	r2, r3
80165680:	3a000001 	bcc	8016568c <_RME_Prc_Crt+0x24c>
80165684:	e3e03002 	mvn	r3, #2
80165688:	ea0000fc 	b	80165a80 <_RME_Prc_Crt+0x640>
8016568c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80165690:	e1a03423 	lsr	r3, r3, #8
80165694:	e1a02283 	lsl	r2, r3, #5
80165698:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016569c:	e593300c 	ldr	r3, [r3, #12]
801656a0:	e0823003 	add	r3, r2, r3
801656a4:	e50b300c 	str	r3, [fp, #-12]
801656a8:	e51b300c 	ldr	r3, [fp, #-12]
801656ac:	e1a00003 	mov	r0, r3
801656b0:	ebffec12 	bl	80160700 <__RME_A7A_Read_Acquire>
801656b4:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801656b8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801656bc:	e1a03823 	lsr	r3, r3, #16
801656c0:	e6ef3073 	uxtb	r3, r3
801656c4:	e3530002 	cmp	r3, #2
801656c8:	1a000001 	bne	801656d4 <_RME_Prc_Crt+0x294>
801656cc:	e3e03008 	mvn	r3, #8
801656d0:	ea0000ea 	b	80165a80 <_RME_Prc_Crt+0x640>
801656d4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801656d8:	e1a03c23 	lsr	r3, r3, #24
801656dc:	e3530003 	cmp	r3, #3
801656e0:	0a000001 	beq	801656ec <_RME_Prc_Crt+0x2ac>
801656e4:	e3e03001 	mvn	r3, #1
801656e8:	ea0000e4 	b	80165a80 <_RME_Prc_Crt+0x640>
801656ec:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801656f0:	e203207f 	and	r2, r3, #127	@ 0x7f
801656f4:	e51b300c 	ldr	r3, [fp, #-12]
801656f8:	e5933014 	ldr	r3, [r3, #20]
801656fc:	e1520003 	cmp	r2, r3
80165700:	3a000001 	bcc	8016570c <_RME_Prc_Crt+0x2cc>
80165704:	e3e03002 	mvn	r3, #2
80165708:	ea0000dc 	b	80165a80 <_RME_Prc_Crt+0x640>
8016570c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80165710:	e203307f 	and	r3, r3, #127	@ 0x7f
80165714:	e1a02283 	lsl	r2, r3, #5
80165718:	e51b300c 	ldr	r3, [fp, #-12]
8016571c:	e593300c 	ldr	r3, [r3, #12]
80165720:	e0823003 	add	r3, r2, r3
80165724:	e50b300c 	str	r3, [fp, #-12]
80165728:	e51b300c 	ldr	r3, [fp, #-12]
8016572c:	e1a00003 	mov	r0, r3
80165730:	ebffebf2 	bl	80160700 <__RME_A7A_Read_Acquire>
80165734:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80165738:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016573c:	e1a03823 	lsr	r3, r3, #16
80165740:	e6ef3073 	uxtb	r3, r3
80165744:	e3530002 	cmp	r3, #2
80165748:	1a000001 	bne	80165754 <_RME_Prc_Crt+0x314>
8016574c:	e3e03008 	mvn	r3, #8
80165750:	ea0000ca 	b	80165a80 <_RME_Prc_Crt+0x640>
80165754:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165758:	e1a03c23 	lsr	r3, r3, #24
8016575c:	e3530003 	cmp	r3, #3
80165760:	0a000001 	beq	8016576c <_RME_Prc_Crt+0x32c>
80165764:	e3e03001 	mvn	r3, #1
80165768:	ea0000c4 	b	80165a80 <_RME_Prc_Crt+0x640>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
#if(RME_PGT_RAW_ENABLE==0U)
    RME_CPT_GETCAP(Cpt,Cap_Pgt,RME_CAP_TYPE_PGT,
8016576c:	e59b3004 	ldr	r3, [fp, #4]
80165770:	e2033080 	and	r3, r3, #128	@ 0x80
80165774:	e3530000 	cmp	r3, #0
80165778:	1a00001d 	bne	801657f4 <_RME_Prc_Crt+0x3b4>
8016577c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165780:	e5932014 	ldr	r2, [r3, #20]
80165784:	e59b3004 	ldr	r3, [fp, #4]
80165788:	e1520003 	cmp	r2, r3
8016578c:	8a000001 	bhi	80165798 <_RME_Prc_Crt+0x358>
80165790:	e3e03002 	mvn	r3, #2
80165794:	ea0000b9 	b	80165a80 <_RME_Prc_Crt+0x640>
80165798:	e59b3004 	ldr	r3, [fp, #4]
8016579c:	e1a02283 	lsl	r2, r3, #5
801657a0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801657a4:	e593300c 	ldr	r3, [r3, #12]
801657a8:	e0823003 	add	r3, r2, r3
801657ac:	e50b3010 	str	r3, [fp, #-16]
801657b0:	e51b3010 	ldr	r3, [fp, #-16]
801657b4:	e1a00003 	mov	r0, r3
801657b8:	ebffebd0 	bl	80160700 <__RME_A7A_Read_Acquire>
801657bc:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801657c0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801657c4:	e1a03823 	lsr	r3, r3, #16
801657c8:	e6ef3073 	uxtb	r3, r3
801657cc:	e3530002 	cmp	r3, #2
801657d0:	1a000001 	bne	801657dc <_RME_Prc_Crt+0x39c>
801657d4:	e3e03008 	mvn	r3, #8
801657d8:	ea0000a8 	b	80165a80 <_RME_Prc_Crt+0x640>
801657dc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801657e0:	e1a03c23 	lsr	r3, r3, #24
801657e4:	e3530004 	cmp	r3, #4
801657e8:	0a000041 	beq	801658f4 <_RME_Prc_Crt+0x4b4>
801657ec:	e3e03001 	mvn	r3, #1
801657f0:	ea0000a2 	b	80165a80 <_RME_Prc_Crt+0x640>
801657f4:	e59b3004 	ldr	r3, [fp, #4]
801657f8:	e1a02423 	lsr	r2, r3, #8
801657fc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165800:	e5933014 	ldr	r3, [r3, #20]
80165804:	e1520003 	cmp	r2, r3
80165808:	3a000001 	bcc	80165814 <_RME_Prc_Crt+0x3d4>
8016580c:	e3e03002 	mvn	r3, #2
80165810:	ea00009a 	b	80165a80 <_RME_Prc_Crt+0x640>
80165814:	e59b3004 	ldr	r3, [fp, #4]
80165818:	e1a03423 	lsr	r3, r3, #8
8016581c:	e1a02283 	lsl	r2, r3, #5
80165820:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165824:	e593300c 	ldr	r3, [r3, #12]
80165828:	e0823003 	add	r3, r2, r3
8016582c:	e50b3010 	str	r3, [fp, #-16]
80165830:	e51b3010 	ldr	r3, [fp, #-16]
80165834:	e1a00003 	mov	r0, r3
80165838:	ebffebb0 	bl	80160700 <__RME_A7A_Read_Acquire>
8016583c:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80165840:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165844:	e1a03823 	lsr	r3, r3, #16
80165848:	e6ef3073 	uxtb	r3, r3
8016584c:	e3530002 	cmp	r3, #2
80165850:	1a000001 	bne	8016585c <_RME_Prc_Crt+0x41c>
80165854:	e3e03008 	mvn	r3, #8
80165858:	ea000088 	b	80165a80 <_RME_Prc_Crt+0x640>
8016585c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165860:	e1a03c23 	lsr	r3, r3, #24
80165864:	e3530003 	cmp	r3, #3
80165868:	0a000001 	beq	80165874 <_RME_Prc_Crt+0x434>
8016586c:	e3e03001 	mvn	r3, #1
80165870:	ea000082 	b	80165a80 <_RME_Prc_Crt+0x640>
80165874:	e59b3004 	ldr	r3, [fp, #4]
80165878:	e203207f 	and	r2, r3, #127	@ 0x7f
8016587c:	e51b3010 	ldr	r3, [fp, #-16]
80165880:	e5933014 	ldr	r3, [r3, #20]
80165884:	e1520003 	cmp	r2, r3
80165888:	3a000001 	bcc	80165894 <_RME_Prc_Crt+0x454>
8016588c:	e3e03002 	mvn	r3, #2
80165890:	ea00007a 	b	80165a80 <_RME_Prc_Crt+0x640>
80165894:	e59b3004 	ldr	r3, [fp, #4]
80165898:	e203307f 	and	r3, r3, #127	@ 0x7f
8016589c:	e1a02283 	lsl	r2, r3, #5
801658a0:	e51b3010 	ldr	r3, [fp, #-16]
801658a4:	e593300c 	ldr	r3, [r3, #12]
801658a8:	e0823003 	add	r3, r2, r3
801658ac:	e50b3010 	str	r3, [fp, #-16]
801658b0:	e51b3010 	ldr	r3, [fp, #-16]
801658b4:	e1a00003 	mov	r0, r3
801658b8:	ebffeb90 	bl	80160700 <__RME_A7A_Read_Acquire>
801658bc:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801658c0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801658c4:	e1a03823 	lsr	r3, r3, #16
801658c8:	e6ef3073 	uxtb	r3, r3
801658cc:	e3530002 	cmp	r3, #2
801658d0:	1a000001 	bne	801658dc <_RME_Prc_Crt+0x49c>
801658d4:	e3e03008 	mvn	r3, #8
801658d8:	ea000068 	b	80165a80 <_RME_Prc_Crt+0x640>
801658dc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801658e0:	e1a03c23 	lsr	r3, r3, #24
801658e4:	e3530004 	cmp	r3, #4
801658e8:	0a000001 	beq	801658f4 <_RME_Prc_Crt+0x4b4>
801658ec:	e3e03001 	mvn	r3, #1
801658f0:	ea000062 	b	80165a80 <_RME_Prc_Crt+0x640>
                   struct RME_Cap_Pgt*,Pgt_Op,Type_Stat);
#endif
    /* Check if the captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Crt,RME_CPT_FLAG_CRT);
801658f4:	e51b3008 	ldr	r3, [fp, #-8]
801658f8:	e5933008 	ldr	r3, [r3, #8]
801658fc:	e2033001 	and	r3, r3, #1
80165900:	e3530000 	cmp	r3, #0
80165904:	1a000001 	bne	80165910 <_RME_Prc_Crt+0x4d0>
80165908:	e3e03006 	mvn	r3, #6
8016590c:	ea00005b 	b	80165a80 <_RME_Prc_Crt+0x640>
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_PRC_CRT);
80165910:	e51b300c 	ldr	r3, [fp, #-12]
80165914:	e5933008 	ldr	r3, [r3, #8]
80165918:	e2033040 	and	r3, r3, #64	@ 0x40
8016591c:	e3530000 	cmp	r3, #0
80165920:	1a000001 	bne	8016592c <_RME_Prc_Crt+0x4ec>
80165924:	e3e03006 	mvn	r3, #6
80165928:	ea000054 	b	80165a80 <_RME_Prc_Crt+0x640>
#if(RME_PGT_RAW_ENABLE==0U)
    RME_CAP_CHECK(Pgt_Op,RME_PGT_FLAG_PRC_CRT);
8016592c:	e51b3010 	ldr	r3, [fp, #-16]
80165930:	e5933008 	ldr	r3, [r3, #8]
80165934:	e2033040 	and	r3, r3, #64	@ 0x40
80165938:	e3530000 	cmp	r3, #0
8016593c:	1a000001 	bne	80165948 <_RME_Prc_Crt+0x508>
80165940:	e3e03006 	mvn	r3, #6
80165944:	ea00004d 	b	80165a80 <_RME_Prc_Crt+0x640>
#endif
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Crt,Cap_Prc,struct RME_Cap_Prc*,Prc_Crt);
80165948:	e51b3008 	ldr	r3, [fp, #-8]
8016594c:	e5932014 	ldr	r2, [r3, #20]
80165950:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80165954:	e1520003 	cmp	r2, r3
80165958:	8a000001 	bhi	80165964 <_RME_Prc_Crt+0x524>
8016595c:	e3e03002 	mvn	r3, #2
80165960:	ea000046 	b	80165a80 <_RME_Prc_Crt+0x640>
80165964:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80165968:	e1a02283 	lsl	r2, r3, #5
8016596c:	e51b3008 	ldr	r3, [fp, #-8]
80165970:	e593300c 	ldr	r3, [r3, #12]
80165974:	e0823003 	add	r3, r2, r3
80165978:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Prc_Crt);
8016597c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165980:	e3a02801 	mov	r2, #65536	@ 0x10000
80165984:	e3a01000 	mov	r1, #0
80165988:	e1a00003 	mov	r0, r3
8016598c:	ebffec9d 	bl	80160c08 <_RME_Comp_Swap_Single>
80165990:	e1a03000 	mov	r3, r0
80165994:	e3530000 	cmp	r3, #0
80165998:	1a000001 	bne	801659a4 <_RME_Prc_Crt+0x564>
8016599c:	e3e03004 	mvn	r3, #4
801659a0:	ea000036 	b	80165a80 <_RME_Prc_Crt+0x640>
801659a4:	e30d3000 	movw	r3, #53248	@ 0xd000
801659a8:	e3483016 	movt	r3, #32790	@ 0x8016
801659ac:	e5932000 	ldr	r2, [r3]
801659b0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801659b4:	e5832010 	str	r2, [r3, #16]
    
    /* Header init */
    Prc_Crt->Head.Root_Ref=0U;
801659b8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801659bc:	e3a02000 	mov	r2, #0
801659c0:	e5832004 	str	r2, [r3, #4]
    Prc_Crt->Head.Object=0U;
801659c4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801659c8:	e3a02000 	mov	r2, #0
801659cc:	e583200c 	str	r2, [r3, #12]
    Prc_Crt->Head.Flag=RME_PRC_FLAG_ALL;
801659d0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801659d4:	e3a0200f 	mov	r2, #15
801659d8:	e5832008 	str	r2, [r3, #8]
    
    /* Info init */
    Prc_Cpt=RME_CAP_CONV_ROOT(Cpt_Op,struct RME_Cap_Cpt*);
801659dc:	e51b300c 	ldr	r3, [fp, #-12]
801659e0:	e5933000 	ldr	r3, [r3]
801659e4:	e6ff3073 	uxth	r3, r3
801659e8:	e3530000 	cmp	r3, #0
801659ec:	0a000002 	beq	801659fc <_RME_Prc_Crt+0x5bc>
801659f0:	e51b300c 	ldr	r3, [fp, #-12]
801659f4:	e5933004 	ldr	r3, [r3, #4]
801659f8:	ea000000 	b	80165a00 <_RME_Prc_Crt+0x5c0>
801659fc:	e51b300c 	ldr	r3, [fp, #-12]
80165a00:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
#if(RME_PGT_RAW_ENABLE==0U)
    Prc_Pgt=RME_CAP_CONV_ROOT(Pgt_Op,struct RME_Cap_Pgt*);
80165a04:	e51b3010 	ldr	r3, [fp, #-16]
80165a08:	e5933000 	ldr	r3, [r3]
80165a0c:	e6ff3073 	uxth	r3, r3
80165a10:	e3530000 	cmp	r3, #0
80165a14:	0a000002 	beq	80165a24 <_RME_Prc_Crt+0x5e4>
80165a18:	e51b3010 	ldr	r3, [fp, #-16]
80165a1c:	e5933004 	ldr	r3, [r3, #4]
80165a20:	ea000000 	b	80165a28 <_RME_Prc_Crt+0x5e8>
80165a24:	e51b3010 	ldr	r3, [fp, #-16]
80165a28:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
#endif
    Prc_Crt->Cpt=Prc_Cpt;
80165a2c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165a30:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
80165a34:	e5832014 	str	r2, [r3, #20]
#if(RME_PGT_RAW_ENABLE==0U)
    Prc_Crt->Pgt=Prc_Pgt;
80165a38:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165a3c:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80165a40:	e5832018 	str	r2, [r3, #24]
#else
    Prc_Crt->Pgt=Raw_Pgt;
#endif
    
    /* Reference objects */
    RME_FETCH_ADD(&(Prc_Cpt->Head.Root_Ref),1U);
80165a44:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80165a48:	e2833004 	add	r3, r3, #4
80165a4c:	e3a01001 	mov	r1, #1
80165a50:	e1a00003 	mov	r0, r3
80165a54:	ebffec80 	bl	80160c5c <_RME_Fetch_Add_Single>
#if(RME_PGT_RAW_ENABLE==0U)
    RME_FETCH_ADD(&(Prc_Pgt->Head.Root_Ref),1U);
80165a58:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165a5c:	e2833004 	add	r3, r3, #4
80165a60:	e3a01001 	mov	r1, #1
80165a64:	e1a00003 	mov	r0, r3
80165a68:	ebffec7b 	bl	80160c5c <_RME_Fetch_Add_Single>
#endif

    /* Establish cap */
    RME_WRITE_RELEASE(&(Prc_Crt->Head.Type_Stat),
80165a6c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165a70:	e3a01405 	mov	r1, #83886080	@ 0x5000000
80165a74:	e1a00003 	mov	r0, r3
80165a78:	ebffeb23 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_PRC,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
80165a7c:	e3a03000 	mov	r3, #0
}
80165a80:	e1a00003 	mov	r0, r3
80165a84:	e24bd004 	sub	sp, fp, #4
80165a88:	e8bd8800 	pop	{fp, pc}

80165a8c <_RME_Prc_Del>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Prc_Del(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt,
                              rme_cid_t Cap_Prc)
{
80165a8c:	e92d4800 	push	{fp, lr}
80165a90:	e28db004 	add	fp, sp, #4
80165a94:	e24dd028 	sub	sp, sp, #40	@ 0x28
80165a98:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
80165a9c:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
80165aa0:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
#if(RME_PGT_RAW_ENABLE==0U)
    struct RME_Cap_Pgt* Prc_Pgt;
#endif

    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
80165aa4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80165aa8:	e2033080 	and	r3, r3, #128	@ 0x80
80165aac:	e3530000 	cmp	r3, #0
80165ab0:	1a00001d 	bne	80165b2c <_RME_Prc_Del+0xa0>
80165ab4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165ab8:	e5932014 	ldr	r2, [r3, #20]
80165abc:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80165ac0:	e1520003 	cmp	r2, r3
80165ac4:	8a000001 	bhi	80165ad0 <_RME_Prc_Del+0x44>
80165ac8:	e3e03002 	mvn	r3, #2
80165acc:	ea0000b3 	b	80165da0 <_RME_Prc_Del+0x314>
80165ad0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80165ad4:	e1a02283 	lsl	r2, r3, #5
80165ad8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165adc:	e593300c 	ldr	r3, [r3, #12]
80165ae0:	e0823003 	add	r3, r2, r3
80165ae4:	e50b3008 	str	r3, [fp, #-8]
80165ae8:	e51b3008 	ldr	r3, [fp, #-8]
80165aec:	e1a00003 	mov	r0, r3
80165af0:	ebffeb02 	bl	80160700 <__RME_A7A_Read_Acquire>
80165af4:	e50b000c 	str	r0, [fp, #-12]
80165af8:	e51b300c 	ldr	r3, [fp, #-12]
80165afc:	e1a03823 	lsr	r3, r3, #16
80165b00:	e6ef3073 	uxtb	r3, r3
80165b04:	e3530002 	cmp	r3, #2
80165b08:	1a000001 	bne	80165b14 <_RME_Prc_Del+0x88>
80165b0c:	e3e03008 	mvn	r3, #8
80165b10:	ea0000a2 	b	80165da0 <_RME_Prc_Del+0x314>
80165b14:	e51b300c 	ldr	r3, [fp, #-12]
80165b18:	e1a03c23 	lsr	r3, r3, #24
80165b1c:	e3530003 	cmp	r3, #3
80165b20:	0a000041 	beq	80165c2c <_RME_Prc_Del+0x1a0>
80165b24:	e3e03001 	mvn	r3, #1
80165b28:	ea00009c 	b	80165da0 <_RME_Prc_Del+0x314>
80165b2c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80165b30:	e1a02423 	lsr	r2, r3, #8
80165b34:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165b38:	e5933014 	ldr	r3, [r3, #20]
80165b3c:	e1520003 	cmp	r2, r3
80165b40:	3a000001 	bcc	80165b4c <_RME_Prc_Del+0xc0>
80165b44:	e3e03002 	mvn	r3, #2
80165b48:	ea000094 	b	80165da0 <_RME_Prc_Del+0x314>
80165b4c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80165b50:	e1a03423 	lsr	r3, r3, #8
80165b54:	e1a02283 	lsl	r2, r3, #5
80165b58:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165b5c:	e593300c 	ldr	r3, [r3, #12]
80165b60:	e0823003 	add	r3, r2, r3
80165b64:	e50b3008 	str	r3, [fp, #-8]
80165b68:	e51b3008 	ldr	r3, [fp, #-8]
80165b6c:	e1a00003 	mov	r0, r3
80165b70:	ebffeae2 	bl	80160700 <__RME_A7A_Read_Acquire>
80165b74:	e50b000c 	str	r0, [fp, #-12]
80165b78:	e51b300c 	ldr	r3, [fp, #-12]
80165b7c:	e1a03823 	lsr	r3, r3, #16
80165b80:	e6ef3073 	uxtb	r3, r3
80165b84:	e3530002 	cmp	r3, #2
80165b88:	1a000001 	bne	80165b94 <_RME_Prc_Del+0x108>
80165b8c:	e3e03008 	mvn	r3, #8
80165b90:	ea000082 	b	80165da0 <_RME_Prc_Del+0x314>
80165b94:	e51b300c 	ldr	r3, [fp, #-12]
80165b98:	e1a03c23 	lsr	r3, r3, #24
80165b9c:	e3530003 	cmp	r3, #3
80165ba0:	0a000001 	beq	80165bac <_RME_Prc_Del+0x120>
80165ba4:	e3e03001 	mvn	r3, #1
80165ba8:	ea00007c 	b	80165da0 <_RME_Prc_Del+0x314>
80165bac:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80165bb0:	e203207f 	and	r2, r3, #127	@ 0x7f
80165bb4:	e51b3008 	ldr	r3, [fp, #-8]
80165bb8:	e5933014 	ldr	r3, [r3, #20]
80165bbc:	e1520003 	cmp	r2, r3
80165bc0:	3a000001 	bcc	80165bcc <_RME_Prc_Del+0x140>
80165bc4:	e3e03002 	mvn	r3, #2
80165bc8:	ea000074 	b	80165da0 <_RME_Prc_Del+0x314>
80165bcc:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80165bd0:	e203307f 	and	r3, r3, #127	@ 0x7f
80165bd4:	e1a02283 	lsl	r2, r3, #5
80165bd8:	e51b3008 	ldr	r3, [fp, #-8]
80165bdc:	e593300c 	ldr	r3, [r3, #12]
80165be0:	e0823003 	add	r3, r2, r3
80165be4:	e50b3008 	str	r3, [fp, #-8]
80165be8:	e51b3008 	ldr	r3, [fp, #-8]
80165bec:	e1a00003 	mov	r0, r3
80165bf0:	ebffeac2 	bl	80160700 <__RME_A7A_Read_Acquire>
80165bf4:	e50b000c 	str	r0, [fp, #-12]
80165bf8:	e51b300c 	ldr	r3, [fp, #-12]
80165bfc:	e1a03823 	lsr	r3, r3, #16
80165c00:	e6ef3073 	uxtb	r3, r3
80165c04:	e3530002 	cmp	r3, #2
80165c08:	1a000001 	bne	80165c14 <_RME_Prc_Del+0x188>
80165c0c:	e3e03008 	mvn	r3, #8
80165c10:	ea000062 	b	80165da0 <_RME_Prc_Del+0x314>
80165c14:	e51b300c 	ldr	r3, [fp, #-12]
80165c18:	e1a03c23 	lsr	r3, r3, #24
80165c1c:	e3530003 	cmp	r3, #3
80165c20:	0a000001 	beq	80165c2c <_RME_Prc_Del+0x1a0>
80165c24:	e3e03001 	mvn	r3, #1
80165c28:	ea00005c 	b	80165da0 <_RME_Prc_Del+0x314>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_DEL);
80165c2c:	e51b3008 	ldr	r3, [fp, #-8]
80165c30:	e5933008 	ldr	r3, [r3, #8]
80165c34:	e2033002 	and	r3, r3, #2
80165c38:	e3530000 	cmp	r3, #0
80165c3c:	1a000001 	bne	80165c48 <_RME_Prc_Del+0x1bc>
80165c40:	e3e03006 	mvn	r3, #6
80165c44:	ea000055 	b	80165da0 <_RME_Prc_Del+0x314>

    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Prc,struct RME_Cap_Prc*,Prc_Del);
80165c48:	e51b3008 	ldr	r3, [fp, #-8]
80165c4c:	e5932014 	ldr	r2, [r3, #20]
80165c50:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165c54:	e1520003 	cmp	r2, r3
80165c58:	8a000001 	bhi	80165c64 <_RME_Prc_Del+0x1d8>
80165c5c:	e3e03002 	mvn	r3, #2
80165c60:	ea00004e 	b	80165da0 <_RME_Prc_Del+0x314>
80165c64:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165c68:	e1a02283 	lsl	r2, r3, #5
80165c6c:	e51b3008 	ldr	r3, [fp, #-8]
80165c70:	e593300c 	ldr	r3, [r3, #12]
80165c74:	e0823003 	add	r3, r2, r3
80165c78:	e50b3010 	str	r3, [fp, #-16]
    /* Delete check */
    RME_CAP_DEL_CHECK(Prc_Del,Type_Stat,RME_CAP_TYPE_PRC);
80165c7c:	e51b3010 	ldr	r3, [fp, #-16]
80165c80:	e1a00003 	mov	r0, r3
80165c84:	ebffea9d 	bl	80160700 <__RME_A7A_Read_Acquire>
80165c88:	e50b000c 	str	r0, [fp, #-12]
80165c8c:	e51b300c 	ldr	r3, [fp, #-12]
80165c90:	e1a03823 	lsr	r3, r3, #16
80165c94:	e6ef3073 	uxtb	r3, r3
80165c98:	e3530002 	cmp	r3, #2
80165c9c:	0a000001 	beq	80165ca8 <_RME_Prc_Del+0x21c>
80165ca0:	e3e03008 	mvn	r3, #8
80165ca4:	ea00003d 	b	80165da0 <_RME_Prc_Del+0x314>
80165ca8:	e51b300c 	ldr	r3, [fp, #-12]
80165cac:	e1a03c23 	lsr	r3, r3, #24
80165cb0:	e3530005 	cmp	r3, #5
80165cb4:	0a000001 	beq	80165cc0 <_RME_Prc_Del+0x234>
80165cb8:	e3e03001 	mvn	r3, #1
80165cbc:	ea000037 	b	80165da0 <_RME_Prc_Del+0x314>
80165cc0:	e51b3010 	ldr	r3, [fp, #-16]
80165cc4:	e5933004 	ldr	r3, [r3, #4]
80165cc8:	e3530000 	cmp	r3, #0
80165ccc:	0a00000b 	beq	80165d00 <_RME_Prc_Del+0x274>
80165cd0:	e51b300c 	ldr	r3, [fp, #-12]
80165cd4:	e6ff3073 	uxth	r3, r3
80165cd8:	e3530000 	cmp	r3, #0
80165cdc:	1a000005 	bne	80165cf8 <_RME_Prc_Del+0x26c>
80165ce0:	e51b0010 	ldr	r0, [fp, #-16]
80165ce4:	e51b300c 	ldr	r3, [fp, #-12]
80165ce8:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
80165cec:	e1a02003 	mov	r2, r3
80165cf0:	e51b100c 	ldr	r1, [fp, #-12]
80165cf4:	ebffebc3 	bl	80160c08 <_RME_Comp_Swap_Single>
80165cf8:	e3e03005 	mvn	r3, #5
80165cfc:	ea000027 	b	80165da0 <_RME_Prc_Del+0x314>
80165d00:	e51b300c 	ldr	r3, [fp, #-12]
80165d04:	e6ff3073 	uxth	r3, r3
80165d08:	e3530000 	cmp	r3, #0
80165d0c:	0a000008 	beq	80165d34 <_RME_Prc_Del+0x2a8>
80165d10:	e30c3318 	movw	r3, #49944	@ 0xc318
80165d14:	e3483016 	movt	r3, #32790	@ 0x8016
80165d18:	e30c2324 	movw	r2, #49956	@ 0xc324
80165d1c:	e3482016 	movt	r2, #32790	@ 0x8016
80165d20:	e301130f 	movw	r1, #4879	@ 0x130f
80165d24:	e30c0330 	movw	r0, #49968	@ 0xc330
80165d28:	e3480016 	movt	r0, #32790	@ 0x8016
80165d2c:	ebffeb94 	bl	80160b84 <RME_Log>
80165d30:	eafffffe 	b	80165d30 <_RME_Prc_Del+0x2a4>

    /* Remember for deletion */
    Prc_Cpt=Prc_Del->Cpt;
80165d34:	e51b3010 	ldr	r3, [fp, #-16]
80165d38:	e5933014 	ldr	r3, [r3, #20]
80165d3c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
#if(RME_PGT_RAW_ENABLE==0U)
    Prc_Pgt=Prc_Del->Pgt;
80165d40:	e51b3010 	ldr	r3, [fp, #-16]
80165d44:	e5933018 	ldr	r3, [r3, #24]
80165d48:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
#endif

    /* Now we can safely delete the cap */
    RME_CAP_DELETE(Prc_Del,Type_Stat);
80165d4c:	e51b3010 	ldr	r3, [fp, #-16]
80165d50:	e3a02000 	mov	r2, #0
80165d54:	e51b100c 	ldr	r1, [fp, #-12]
80165d58:	e1a00003 	mov	r0, r3
80165d5c:	ebffeba9 	bl	80160c08 <_RME_Comp_Swap_Single>
80165d60:	e1a03000 	mov	r3, r0
80165d64:	e3530000 	cmp	r3, #0
80165d68:	1a000001 	bne	80165d74 <_RME_Prc_Del+0x2e8>
80165d6c:	e3e03000 	mvn	r3, #0
80165d70:	ea00000a 	b	80165da0 <_RME_Prc_Del+0x314>

    /* Dereference caps */
    RME_FETCH_ADD(&(Prc_Cpt->Head.Root_Ref),-1);
80165d74:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165d78:	e2833004 	add	r3, r3, #4
80165d7c:	e3e01000 	mvn	r1, #0
80165d80:	e1a00003 	mov	r0, r3
80165d84:	ebffebb4 	bl	80160c5c <_RME_Fetch_Add_Single>
#if(RME_PGT_RAW_ENABLE==0U)
    RME_FETCH_ADD(&(Prc_Pgt->Head.Root_Ref),-1);
80165d88:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165d8c:	e2833004 	add	r3, r3, #4
80165d90:	e3e01000 	mvn	r1, #0
80165d94:	e1a00003 	mov	r0, r3
80165d98:	ebffebaf 	bl	80160c5c <_RME_Fetch_Add_Single>
#endif
    
    return 0;
80165d9c:	e3a03000 	mov	r3, #0
}
80165da0:	e1a00003 	mov	r0, r3
80165da4:	e24bd004 	sub	sp, fp, #4
80165da8:	e8bd8800 	pop	{fp, pc}

80165dac <_RME_Prc_Cpt>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Prc_Cpt(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Prc,
                              rme_cid_t Cap_Cpt)
{
80165dac:	e92d4800 	push	{fp, lr}
80165db0:	e28db004 	add	fp, sp, #4
80165db4:	e24dd020 	sub	sp, sp, #32
80165db8:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80165dbc:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
80165dc0:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    struct RME_Cap_Cpt* Cpt_New;
    struct RME_Cap_Cpt* Cpt_Old;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Prc,RME_CAP_TYPE_PRC,
80165dc4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80165dc8:	e2033080 	and	r3, r3, #128	@ 0x80
80165dcc:	e3530000 	cmp	r3, #0
80165dd0:	1a00001d 	bne	80165e4c <_RME_Prc_Cpt+0xa0>
80165dd4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165dd8:	e5932014 	ldr	r2, [r3, #20]
80165ddc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80165de0:	e1520003 	cmp	r2, r3
80165de4:	8a000001 	bhi	80165df0 <_RME_Prc_Cpt+0x44>
80165de8:	e3e03002 	mvn	r3, #2
80165dec:	ea0000e9 	b	80166198 <_RME_Prc_Cpt+0x3ec>
80165df0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80165df4:	e1a02283 	lsl	r2, r3, #5
80165df8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165dfc:	e593300c 	ldr	r3, [r3, #12]
80165e00:	e0823003 	add	r3, r2, r3
80165e04:	e50b3008 	str	r3, [fp, #-8]
80165e08:	e51b3008 	ldr	r3, [fp, #-8]
80165e0c:	e1a00003 	mov	r0, r3
80165e10:	ebffea3a 	bl	80160700 <__RME_A7A_Read_Acquire>
80165e14:	e50b0010 	str	r0, [fp, #-16]
80165e18:	e51b3010 	ldr	r3, [fp, #-16]
80165e1c:	e1a03823 	lsr	r3, r3, #16
80165e20:	e6ef3073 	uxtb	r3, r3
80165e24:	e3530002 	cmp	r3, #2
80165e28:	1a000001 	bne	80165e34 <_RME_Prc_Cpt+0x88>
80165e2c:	e3e03008 	mvn	r3, #8
80165e30:	ea0000d8 	b	80166198 <_RME_Prc_Cpt+0x3ec>
80165e34:	e51b3010 	ldr	r3, [fp, #-16]
80165e38:	e1a03c23 	lsr	r3, r3, #24
80165e3c:	e3530005 	cmp	r3, #5
80165e40:	0a000041 	beq	80165f4c <_RME_Prc_Cpt+0x1a0>
80165e44:	e3e03001 	mvn	r3, #1
80165e48:	ea0000d2 	b	80166198 <_RME_Prc_Cpt+0x3ec>
80165e4c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80165e50:	e1a02423 	lsr	r2, r3, #8
80165e54:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165e58:	e5933014 	ldr	r3, [r3, #20]
80165e5c:	e1520003 	cmp	r2, r3
80165e60:	3a000001 	bcc	80165e6c <_RME_Prc_Cpt+0xc0>
80165e64:	e3e03002 	mvn	r3, #2
80165e68:	ea0000ca 	b	80166198 <_RME_Prc_Cpt+0x3ec>
80165e6c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80165e70:	e1a03423 	lsr	r3, r3, #8
80165e74:	e1a02283 	lsl	r2, r3, #5
80165e78:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165e7c:	e593300c 	ldr	r3, [r3, #12]
80165e80:	e0823003 	add	r3, r2, r3
80165e84:	e50b3008 	str	r3, [fp, #-8]
80165e88:	e51b3008 	ldr	r3, [fp, #-8]
80165e8c:	e1a00003 	mov	r0, r3
80165e90:	ebffea1a 	bl	80160700 <__RME_A7A_Read_Acquire>
80165e94:	e50b0010 	str	r0, [fp, #-16]
80165e98:	e51b3010 	ldr	r3, [fp, #-16]
80165e9c:	e1a03823 	lsr	r3, r3, #16
80165ea0:	e6ef3073 	uxtb	r3, r3
80165ea4:	e3530002 	cmp	r3, #2
80165ea8:	1a000001 	bne	80165eb4 <_RME_Prc_Cpt+0x108>
80165eac:	e3e03008 	mvn	r3, #8
80165eb0:	ea0000b8 	b	80166198 <_RME_Prc_Cpt+0x3ec>
80165eb4:	e51b3010 	ldr	r3, [fp, #-16]
80165eb8:	e1a03c23 	lsr	r3, r3, #24
80165ebc:	e3530003 	cmp	r3, #3
80165ec0:	0a000001 	beq	80165ecc <_RME_Prc_Cpt+0x120>
80165ec4:	e3e03001 	mvn	r3, #1
80165ec8:	ea0000b2 	b	80166198 <_RME_Prc_Cpt+0x3ec>
80165ecc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80165ed0:	e203207f 	and	r2, r3, #127	@ 0x7f
80165ed4:	e51b3008 	ldr	r3, [fp, #-8]
80165ed8:	e5933014 	ldr	r3, [r3, #20]
80165edc:	e1520003 	cmp	r2, r3
80165ee0:	3a000001 	bcc	80165eec <_RME_Prc_Cpt+0x140>
80165ee4:	e3e03002 	mvn	r3, #2
80165ee8:	ea0000aa 	b	80166198 <_RME_Prc_Cpt+0x3ec>
80165eec:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80165ef0:	e203307f 	and	r3, r3, #127	@ 0x7f
80165ef4:	e1a02283 	lsl	r2, r3, #5
80165ef8:	e51b3008 	ldr	r3, [fp, #-8]
80165efc:	e593300c 	ldr	r3, [r3, #12]
80165f00:	e0823003 	add	r3, r2, r3
80165f04:	e50b3008 	str	r3, [fp, #-8]
80165f08:	e51b3008 	ldr	r3, [fp, #-8]
80165f0c:	e1a00003 	mov	r0, r3
80165f10:	ebffe9fa 	bl	80160700 <__RME_A7A_Read_Acquire>
80165f14:	e50b0010 	str	r0, [fp, #-16]
80165f18:	e51b3010 	ldr	r3, [fp, #-16]
80165f1c:	e1a03823 	lsr	r3, r3, #16
80165f20:	e6ef3073 	uxtb	r3, r3
80165f24:	e3530002 	cmp	r3, #2
80165f28:	1a000001 	bne	80165f34 <_RME_Prc_Cpt+0x188>
80165f2c:	e3e03008 	mvn	r3, #8
80165f30:	ea000098 	b	80166198 <_RME_Prc_Cpt+0x3ec>
80165f34:	e51b3010 	ldr	r3, [fp, #-16]
80165f38:	e1a03c23 	lsr	r3, r3, #24
80165f3c:	e3530005 	cmp	r3, #5
80165f40:	0a000001 	beq	80165f4c <_RME_Prc_Cpt+0x1a0>
80165f44:	e3e03001 	mvn	r3, #1
80165f48:	ea000092 	b	80166198 <_RME_Prc_Cpt+0x3ec>
                   struct RME_Cap_Prc*,Prc_Op,Type_Stat); 
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
80165f4c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165f50:	e2033080 	and	r3, r3, #128	@ 0x80
80165f54:	e3530000 	cmp	r3, #0
80165f58:	1a00001d 	bne	80165fd4 <_RME_Prc_Cpt+0x228>
80165f5c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165f60:	e5932014 	ldr	r2, [r3, #20]
80165f64:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165f68:	e1520003 	cmp	r2, r3
80165f6c:	8a000001 	bhi	80165f78 <_RME_Prc_Cpt+0x1cc>
80165f70:	e3e03002 	mvn	r3, #2
80165f74:	ea000087 	b	80166198 <_RME_Prc_Cpt+0x3ec>
80165f78:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165f7c:	e1a02283 	lsl	r2, r3, #5
80165f80:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165f84:	e593300c 	ldr	r3, [r3, #12]
80165f88:	e0823003 	add	r3, r2, r3
80165f8c:	e50b300c 	str	r3, [fp, #-12]
80165f90:	e51b300c 	ldr	r3, [fp, #-12]
80165f94:	e1a00003 	mov	r0, r3
80165f98:	ebffe9d8 	bl	80160700 <__RME_A7A_Read_Acquire>
80165f9c:	e50b0010 	str	r0, [fp, #-16]
80165fa0:	e51b3010 	ldr	r3, [fp, #-16]
80165fa4:	e1a03823 	lsr	r3, r3, #16
80165fa8:	e6ef3073 	uxtb	r3, r3
80165fac:	e3530002 	cmp	r3, #2
80165fb0:	1a000001 	bne	80165fbc <_RME_Prc_Cpt+0x210>
80165fb4:	e3e03008 	mvn	r3, #8
80165fb8:	ea000076 	b	80166198 <_RME_Prc_Cpt+0x3ec>
80165fbc:	e51b3010 	ldr	r3, [fp, #-16]
80165fc0:	e1a03c23 	lsr	r3, r3, #24
80165fc4:	e3530003 	cmp	r3, #3
80165fc8:	0a000041 	beq	801660d4 <_RME_Prc_Cpt+0x328>
80165fcc:	e3e03001 	mvn	r3, #1
80165fd0:	ea000070 	b	80166198 <_RME_Prc_Cpt+0x3ec>
80165fd4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165fd8:	e1a02423 	lsr	r2, r3, #8
80165fdc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165fe0:	e5933014 	ldr	r3, [r3, #20]
80165fe4:	e1520003 	cmp	r2, r3
80165fe8:	3a000001 	bcc	80165ff4 <_RME_Prc_Cpt+0x248>
80165fec:	e3e03002 	mvn	r3, #2
80165ff0:	ea000068 	b	80166198 <_RME_Prc_Cpt+0x3ec>
80165ff4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165ff8:	e1a03423 	lsr	r3, r3, #8
80165ffc:	e1a02283 	lsl	r2, r3, #5
80166000:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166004:	e593300c 	ldr	r3, [r3, #12]
80166008:	e0823003 	add	r3, r2, r3
8016600c:	e50b300c 	str	r3, [fp, #-12]
80166010:	e51b300c 	ldr	r3, [fp, #-12]
80166014:	e1a00003 	mov	r0, r3
80166018:	ebffe9b8 	bl	80160700 <__RME_A7A_Read_Acquire>
8016601c:	e50b0010 	str	r0, [fp, #-16]
80166020:	e51b3010 	ldr	r3, [fp, #-16]
80166024:	e1a03823 	lsr	r3, r3, #16
80166028:	e6ef3073 	uxtb	r3, r3
8016602c:	e3530002 	cmp	r3, #2
80166030:	1a000001 	bne	8016603c <_RME_Prc_Cpt+0x290>
80166034:	e3e03008 	mvn	r3, #8
80166038:	ea000056 	b	80166198 <_RME_Prc_Cpt+0x3ec>
8016603c:	e51b3010 	ldr	r3, [fp, #-16]
80166040:	e1a03c23 	lsr	r3, r3, #24
80166044:	e3530003 	cmp	r3, #3
80166048:	0a000001 	beq	80166054 <_RME_Prc_Cpt+0x2a8>
8016604c:	e3e03001 	mvn	r3, #1
80166050:	ea000050 	b	80166198 <_RME_Prc_Cpt+0x3ec>
80166054:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166058:	e203207f 	and	r2, r3, #127	@ 0x7f
8016605c:	e51b300c 	ldr	r3, [fp, #-12]
80166060:	e5933014 	ldr	r3, [r3, #20]
80166064:	e1520003 	cmp	r2, r3
80166068:	3a000001 	bcc	80166074 <_RME_Prc_Cpt+0x2c8>
8016606c:	e3e03002 	mvn	r3, #2
80166070:	ea000048 	b	80166198 <_RME_Prc_Cpt+0x3ec>
80166074:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166078:	e203307f 	and	r3, r3, #127	@ 0x7f
8016607c:	e1a02283 	lsl	r2, r3, #5
80166080:	e51b300c 	ldr	r3, [fp, #-12]
80166084:	e593300c 	ldr	r3, [r3, #12]
80166088:	e0823003 	add	r3, r2, r3
8016608c:	e50b300c 	str	r3, [fp, #-12]
80166090:	e51b300c 	ldr	r3, [fp, #-12]
80166094:	e1a00003 	mov	r0, r3
80166098:	ebffe998 	bl	80160700 <__RME_A7A_Read_Acquire>
8016609c:	e50b0010 	str	r0, [fp, #-16]
801660a0:	e51b3010 	ldr	r3, [fp, #-16]
801660a4:	e1a03823 	lsr	r3, r3, #16
801660a8:	e6ef3073 	uxtb	r3, r3
801660ac:	e3530002 	cmp	r3, #2
801660b0:	1a000001 	bne	801660bc <_RME_Prc_Cpt+0x310>
801660b4:	e3e03008 	mvn	r3, #8
801660b8:	ea000036 	b	80166198 <_RME_Prc_Cpt+0x3ec>
801660bc:	e51b3010 	ldr	r3, [fp, #-16]
801660c0:	e1a03c23 	lsr	r3, r3, #24
801660c4:	e3530003 	cmp	r3, #3
801660c8:	0a000001 	beq	801660d4 <_RME_Prc_Cpt+0x328>
801660cc:	e3e03001 	mvn	r3, #1
801660d0:	ea000030 	b	80166198 <_RME_Prc_Cpt+0x3ec>
                   struct RME_Cap_Cpt*,Cpt_New,Type_Stat);     
    /* Check if the target caps is not frozen and allows such operations */
    RME_CAP_CHECK(Prc_Op,RME_PRC_FLAG_CPT);
801660d4:	e51b3008 	ldr	r3, [fp, #-8]
801660d8:	e5933008 	ldr	r3, [r3, #8]
801660dc:	e2033004 	and	r3, r3, #4
801660e0:	e3530000 	cmp	r3, #0
801660e4:	1a000001 	bne	801660f0 <_RME_Prc_Cpt+0x344>
801660e8:	e3e03006 	mvn	r3, #6
801660ec:	ea000029 	b	80166198 <_RME_Prc_Cpt+0x3ec>
    RME_CAP_CHECK(Cpt_New,RME_CPT_FLAG_PRC_CPT);
801660f0:	e51b300c 	ldr	r3, [fp, #-12]
801660f4:	e5933008 	ldr	r3, [r3, #8]
801660f8:	e2033080 	and	r3, r3, #128	@ 0x80
801660fc:	e3530000 	cmp	r3, #0
80166100:	1a000001 	bne	8016610c <_RME_Prc_Cpt+0x360>
80166104:	e3e03006 	mvn	r3, #6
80166108:	ea000022 	b	80166198 <_RME_Prc_Cpt+0x3ec>
    
    /* Convert to root */
    Cpt_New=RME_CAP_CONV_ROOT(Cpt_New,struct RME_Cap_Cpt*);
8016610c:	e51b300c 	ldr	r3, [fp, #-12]
80166110:	e5933000 	ldr	r3, [r3]
80166114:	e6ff3073 	uxth	r3, r3
80166118:	e3530000 	cmp	r3, #0
8016611c:	0a000002 	beq	8016612c <_RME_Prc_Cpt+0x380>
80166120:	e51b300c 	ldr	r3, [fp, #-12]
80166124:	e5933004 	ldr	r3, [r3, #4]
80166128:	ea000000 	b	80166130 <_RME_Prc_Cpt+0x384>
8016612c:	e51b300c 	ldr	r3, [fp, #-12]
80166130:	e50b300c 	str	r3, [fp, #-12]
    
    /* Commit the change */
    Cpt_Old=Prc_Op->Cpt;
80166134:	e51b3008 	ldr	r3, [fp, #-8]
80166138:	e5933014 	ldr	r3, [r3, #20]
8016613c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    if(RME_COMP_SWAP((rme_ptr_t*)(&(Prc_Op->Cpt)),
80166140:	e51b3008 	ldr	r3, [fp, #-8]
80166144:	e2833014 	add	r3, r3, #20
80166148:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
8016614c:	e51b200c 	ldr	r2, [fp, #-12]
80166150:	e1a00003 	mov	r0, r3
80166154:	ebffeaab 	bl	80160c08 <_RME_Comp_Swap_Single>
80166158:	e1a03000 	mov	r3, r0
8016615c:	e3530000 	cmp	r3, #0
80166160:	1a000001 	bne	8016616c <_RME_Prc_Cpt+0x3c0>
                     (rme_ptr_t)Cpt_Old,(rme_ptr_t)Cpt_New)==RME_CASFAIL)
    {
        RME_COV_MARKER();
        
        return RME_ERR_PTH_CONFLICT;
80166164:	e3e030c9 	mvn	r3, #201	@ 0xc9
80166168:	ea00000a 	b	80166198 <_RME_Prc_Cpt+0x3ec>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Reference new table and dereference the old table */
    RME_FETCH_ADD(&(Cpt_New->Head.Root_Ref),1);
8016616c:	e51b300c 	ldr	r3, [fp, #-12]
80166170:	e2833004 	add	r3, r3, #4
80166174:	e3a01001 	mov	r1, #1
80166178:	e1a00003 	mov	r0, r3
8016617c:	ebffeab6 	bl	80160c5c <_RME_Fetch_Add_Single>
    RME_FETCH_ADD(&(Cpt_Old->Head.Root_Ref),-1);
80166180:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80166184:	e2833004 	add	r3, r3, #4
80166188:	e3e01000 	mvn	r1, #0
8016618c:	e1a00003 	mov	r0, r3
80166190:	ebffeab1 	bl	80160c5c <_RME_Fetch_Add_Single>

    return 0;
80166194:	e3a03000 	mov	r3, #0
}
80166198:	e1a00003 	mov	r0, r3
8016619c:	e24bd004 	sub	sp, fp, #4
801661a0:	e8bd8800 	pop	{fp, pc}

801661a4 <_RME_Prc_Pgt>:
#else
static rme_ret_t _RME_Prc_Pgt(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Prc,
                              rme_ptr_t Raw_Pgt)
#endif
{
801661a4:	e92d4800 	push	{fp, lr}
801661a8:	e28db004 	add	fp, sp, #4
801661ac:	e24dd020 	sub	sp, sp, #32
801661b0:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
801661b4:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
801661b8:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    rme_ptr_t Pgt_Old;
#endif
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Prc,RME_CAP_TYPE_PRC,
801661bc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801661c0:	e2033080 	and	r3, r3, #128	@ 0x80
801661c4:	e3530000 	cmp	r3, #0
801661c8:	1a00001d 	bne	80166244 <_RME_Prc_Pgt+0xa0>
801661cc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801661d0:	e5932014 	ldr	r2, [r3, #20]
801661d4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801661d8:	e1520003 	cmp	r2, r3
801661dc:	8a000001 	bhi	801661e8 <_RME_Prc_Pgt+0x44>
801661e0:	e3e03002 	mvn	r3, #2
801661e4:	ea0000e9 	b	80166590 <_RME_Prc_Pgt+0x3ec>
801661e8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801661ec:	e1a02283 	lsl	r2, r3, #5
801661f0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801661f4:	e593300c 	ldr	r3, [r3, #12]
801661f8:	e0823003 	add	r3, r2, r3
801661fc:	e50b3008 	str	r3, [fp, #-8]
80166200:	e51b3008 	ldr	r3, [fp, #-8]
80166204:	e1a00003 	mov	r0, r3
80166208:	ebffe93c 	bl	80160700 <__RME_A7A_Read_Acquire>
8016620c:	e50b0010 	str	r0, [fp, #-16]
80166210:	e51b3010 	ldr	r3, [fp, #-16]
80166214:	e1a03823 	lsr	r3, r3, #16
80166218:	e6ef3073 	uxtb	r3, r3
8016621c:	e3530002 	cmp	r3, #2
80166220:	1a000001 	bne	8016622c <_RME_Prc_Pgt+0x88>
80166224:	e3e03008 	mvn	r3, #8
80166228:	ea0000d8 	b	80166590 <_RME_Prc_Pgt+0x3ec>
8016622c:	e51b3010 	ldr	r3, [fp, #-16]
80166230:	e1a03c23 	lsr	r3, r3, #24
80166234:	e3530005 	cmp	r3, #5
80166238:	0a000041 	beq	80166344 <_RME_Prc_Pgt+0x1a0>
8016623c:	e3e03001 	mvn	r3, #1
80166240:	ea0000d2 	b	80166590 <_RME_Prc_Pgt+0x3ec>
80166244:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80166248:	e1a02423 	lsr	r2, r3, #8
8016624c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166250:	e5933014 	ldr	r3, [r3, #20]
80166254:	e1520003 	cmp	r2, r3
80166258:	3a000001 	bcc	80166264 <_RME_Prc_Pgt+0xc0>
8016625c:	e3e03002 	mvn	r3, #2
80166260:	ea0000ca 	b	80166590 <_RME_Prc_Pgt+0x3ec>
80166264:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80166268:	e1a03423 	lsr	r3, r3, #8
8016626c:	e1a02283 	lsl	r2, r3, #5
80166270:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166274:	e593300c 	ldr	r3, [r3, #12]
80166278:	e0823003 	add	r3, r2, r3
8016627c:	e50b3008 	str	r3, [fp, #-8]
80166280:	e51b3008 	ldr	r3, [fp, #-8]
80166284:	e1a00003 	mov	r0, r3
80166288:	ebffe91c 	bl	80160700 <__RME_A7A_Read_Acquire>
8016628c:	e50b0010 	str	r0, [fp, #-16]
80166290:	e51b3010 	ldr	r3, [fp, #-16]
80166294:	e1a03823 	lsr	r3, r3, #16
80166298:	e6ef3073 	uxtb	r3, r3
8016629c:	e3530002 	cmp	r3, #2
801662a0:	1a000001 	bne	801662ac <_RME_Prc_Pgt+0x108>
801662a4:	e3e03008 	mvn	r3, #8
801662a8:	ea0000b8 	b	80166590 <_RME_Prc_Pgt+0x3ec>
801662ac:	e51b3010 	ldr	r3, [fp, #-16]
801662b0:	e1a03c23 	lsr	r3, r3, #24
801662b4:	e3530003 	cmp	r3, #3
801662b8:	0a000001 	beq	801662c4 <_RME_Prc_Pgt+0x120>
801662bc:	e3e03001 	mvn	r3, #1
801662c0:	ea0000b2 	b	80166590 <_RME_Prc_Pgt+0x3ec>
801662c4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801662c8:	e203207f 	and	r2, r3, #127	@ 0x7f
801662cc:	e51b3008 	ldr	r3, [fp, #-8]
801662d0:	e5933014 	ldr	r3, [r3, #20]
801662d4:	e1520003 	cmp	r2, r3
801662d8:	3a000001 	bcc	801662e4 <_RME_Prc_Pgt+0x140>
801662dc:	e3e03002 	mvn	r3, #2
801662e0:	ea0000aa 	b	80166590 <_RME_Prc_Pgt+0x3ec>
801662e4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801662e8:	e203307f 	and	r3, r3, #127	@ 0x7f
801662ec:	e1a02283 	lsl	r2, r3, #5
801662f0:	e51b3008 	ldr	r3, [fp, #-8]
801662f4:	e593300c 	ldr	r3, [r3, #12]
801662f8:	e0823003 	add	r3, r2, r3
801662fc:	e50b3008 	str	r3, [fp, #-8]
80166300:	e51b3008 	ldr	r3, [fp, #-8]
80166304:	e1a00003 	mov	r0, r3
80166308:	ebffe8fc 	bl	80160700 <__RME_A7A_Read_Acquire>
8016630c:	e50b0010 	str	r0, [fp, #-16]
80166310:	e51b3010 	ldr	r3, [fp, #-16]
80166314:	e1a03823 	lsr	r3, r3, #16
80166318:	e6ef3073 	uxtb	r3, r3
8016631c:	e3530002 	cmp	r3, #2
80166320:	1a000001 	bne	8016632c <_RME_Prc_Pgt+0x188>
80166324:	e3e03008 	mvn	r3, #8
80166328:	ea000098 	b	80166590 <_RME_Prc_Pgt+0x3ec>
8016632c:	e51b3010 	ldr	r3, [fp, #-16]
80166330:	e1a03c23 	lsr	r3, r3, #24
80166334:	e3530005 	cmp	r3, #5
80166338:	0a000001 	beq	80166344 <_RME_Prc_Pgt+0x1a0>
8016633c:	e3e03001 	mvn	r3, #1
80166340:	ea000092 	b	80166590 <_RME_Prc_Pgt+0x3ec>
                   struct RME_Cap_Prc*,Prc_Op,Type_Stat); 
#if(RME_PGT_RAW_ENABLE==0U)
    RME_CPT_GETCAP(Cpt,Cap_Pgt,RME_CAP_TYPE_PGT,
80166344:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166348:	e2033080 	and	r3, r3, #128	@ 0x80
8016634c:	e3530000 	cmp	r3, #0
80166350:	1a00001d 	bne	801663cc <_RME_Prc_Pgt+0x228>
80166354:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166358:	e5932014 	ldr	r2, [r3, #20]
8016635c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166360:	e1520003 	cmp	r2, r3
80166364:	8a000001 	bhi	80166370 <_RME_Prc_Pgt+0x1cc>
80166368:	e3e03002 	mvn	r3, #2
8016636c:	ea000087 	b	80166590 <_RME_Prc_Pgt+0x3ec>
80166370:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166374:	e1a02283 	lsl	r2, r3, #5
80166378:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016637c:	e593300c 	ldr	r3, [r3, #12]
80166380:	e0823003 	add	r3, r2, r3
80166384:	e50b300c 	str	r3, [fp, #-12]
80166388:	e51b300c 	ldr	r3, [fp, #-12]
8016638c:	e1a00003 	mov	r0, r3
80166390:	ebffe8da 	bl	80160700 <__RME_A7A_Read_Acquire>
80166394:	e50b0010 	str	r0, [fp, #-16]
80166398:	e51b3010 	ldr	r3, [fp, #-16]
8016639c:	e1a03823 	lsr	r3, r3, #16
801663a0:	e6ef3073 	uxtb	r3, r3
801663a4:	e3530002 	cmp	r3, #2
801663a8:	1a000001 	bne	801663b4 <_RME_Prc_Pgt+0x210>
801663ac:	e3e03008 	mvn	r3, #8
801663b0:	ea000076 	b	80166590 <_RME_Prc_Pgt+0x3ec>
801663b4:	e51b3010 	ldr	r3, [fp, #-16]
801663b8:	e1a03c23 	lsr	r3, r3, #24
801663bc:	e3530004 	cmp	r3, #4
801663c0:	0a000041 	beq	801664cc <_RME_Prc_Pgt+0x328>
801663c4:	e3e03001 	mvn	r3, #1
801663c8:	ea000070 	b	80166590 <_RME_Prc_Pgt+0x3ec>
801663cc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801663d0:	e1a02423 	lsr	r2, r3, #8
801663d4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801663d8:	e5933014 	ldr	r3, [r3, #20]
801663dc:	e1520003 	cmp	r2, r3
801663e0:	3a000001 	bcc	801663ec <_RME_Prc_Pgt+0x248>
801663e4:	e3e03002 	mvn	r3, #2
801663e8:	ea000068 	b	80166590 <_RME_Prc_Pgt+0x3ec>
801663ec:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801663f0:	e1a03423 	lsr	r3, r3, #8
801663f4:	e1a02283 	lsl	r2, r3, #5
801663f8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801663fc:	e593300c 	ldr	r3, [r3, #12]
80166400:	e0823003 	add	r3, r2, r3
80166404:	e50b300c 	str	r3, [fp, #-12]
80166408:	e51b300c 	ldr	r3, [fp, #-12]
8016640c:	e1a00003 	mov	r0, r3
80166410:	ebffe8ba 	bl	80160700 <__RME_A7A_Read_Acquire>
80166414:	e50b0010 	str	r0, [fp, #-16]
80166418:	e51b3010 	ldr	r3, [fp, #-16]
8016641c:	e1a03823 	lsr	r3, r3, #16
80166420:	e6ef3073 	uxtb	r3, r3
80166424:	e3530002 	cmp	r3, #2
80166428:	1a000001 	bne	80166434 <_RME_Prc_Pgt+0x290>
8016642c:	e3e03008 	mvn	r3, #8
80166430:	ea000056 	b	80166590 <_RME_Prc_Pgt+0x3ec>
80166434:	e51b3010 	ldr	r3, [fp, #-16]
80166438:	e1a03c23 	lsr	r3, r3, #24
8016643c:	e3530003 	cmp	r3, #3
80166440:	0a000001 	beq	8016644c <_RME_Prc_Pgt+0x2a8>
80166444:	e3e03001 	mvn	r3, #1
80166448:	ea000050 	b	80166590 <_RME_Prc_Pgt+0x3ec>
8016644c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166450:	e203207f 	and	r2, r3, #127	@ 0x7f
80166454:	e51b300c 	ldr	r3, [fp, #-12]
80166458:	e5933014 	ldr	r3, [r3, #20]
8016645c:	e1520003 	cmp	r2, r3
80166460:	3a000001 	bcc	8016646c <_RME_Prc_Pgt+0x2c8>
80166464:	e3e03002 	mvn	r3, #2
80166468:	ea000048 	b	80166590 <_RME_Prc_Pgt+0x3ec>
8016646c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166470:	e203307f 	and	r3, r3, #127	@ 0x7f
80166474:	e1a02283 	lsl	r2, r3, #5
80166478:	e51b300c 	ldr	r3, [fp, #-12]
8016647c:	e593300c 	ldr	r3, [r3, #12]
80166480:	e0823003 	add	r3, r2, r3
80166484:	e50b300c 	str	r3, [fp, #-12]
80166488:	e51b300c 	ldr	r3, [fp, #-12]
8016648c:	e1a00003 	mov	r0, r3
80166490:	ebffe89a 	bl	80160700 <__RME_A7A_Read_Acquire>
80166494:	e50b0010 	str	r0, [fp, #-16]
80166498:	e51b3010 	ldr	r3, [fp, #-16]
8016649c:	e1a03823 	lsr	r3, r3, #16
801664a0:	e6ef3073 	uxtb	r3, r3
801664a4:	e3530002 	cmp	r3, #2
801664a8:	1a000001 	bne	801664b4 <_RME_Prc_Pgt+0x310>
801664ac:	e3e03008 	mvn	r3, #8
801664b0:	ea000036 	b	80166590 <_RME_Prc_Pgt+0x3ec>
801664b4:	e51b3010 	ldr	r3, [fp, #-16]
801664b8:	e1a03c23 	lsr	r3, r3, #24
801664bc:	e3530004 	cmp	r3, #4
801664c0:	0a000001 	beq	801664cc <_RME_Prc_Pgt+0x328>
801664c4:	e3e03001 	mvn	r3, #1
801664c8:	ea000030 	b	80166590 <_RME_Prc_Pgt+0x3ec>
                   struct RME_Cap_Pgt*,Pgt_New,Type_Stat);
#endif
    /* Check if the target caps is not frozen and allows such operations */
    RME_CAP_CHECK(Prc_Op,RME_PRC_FLAG_PGT);
801664cc:	e51b3008 	ldr	r3, [fp, #-8]
801664d0:	e5933008 	ldr	r3, [r3, #8]
801664d4:	e2033008 	and	r3, r3, #8
801664d8:	e3530000 	cmp	r3, #0
801664dc:	1a000001 	bne	801664e8 <_RME_Prc_Pgt+0x344>
801664e0:	e3e03006 	mvn	r3, #6
801664e4:	ea000029 	b	80166590 <_RME_Prc_Pgt+0x3ec>
#if(RME_PGT_RAW_ENABLE==0U)
    RME_CAP_CHECK(Pgt_New,RME_PGT_FLAG_PRC_PGT);
801664e8:	e51b300c 	ldr	r3, [fp, #-12]
801664ec:	e5933008 	ldr	r3, [r3, #8]
801664f0:	e2033080 	and	r3, r3, #128	@ 0x80
801664f4:	e3530000 	cmp	r3, #0
801664f8:	1a000001 	bne	80166504 <_RME_Prc_Pgt+0x360>
801664fc:	e3e03006 	mvn	r3, #6
80166500:	ea000022 	b	80166590 <_RME_Prc_Pgt+0x3ec>
#endif
    
    Pgt_Old=Prc_Op->Pgt;
80166504:	e51b3008 	ldr	r3, [fp, #-8]
80166508:	e5933018 	ldr	r3, [r3, #24]
8016650c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    
#if(RME_PGT_RAW_ENABLE==0U)
    /* Convert to root */
    Pgt_New=RME_CAP_CONV_ROOT(Pgt_New,struct RME_Cap_Pgt*);
80166510:	e51b300c 	ldr	r3, [fp, #-12]
80166514:	e5933000 	ldr	r3, [r3]
80166518:	e6ff3073 	uxth	r3, r3
8016651c:	e3530000 	cmp	r3, #0
80166520:	0a000002 	beq	80166530 <_RME_Prc_Pgt+0x38c>
80166524:	e51b300c 	ldr	r3, [fp, #-12]
80166528:	e5933004 	ldr	r3, [r3, #4]
8016652c:	ea000000 	b	80166534 <_RME_Prc_Pgt+0x390>
80166530:	e51b300c 	ldr	r3, [fp, #-12]
80166534:	e50b300c 	str	r3, [fp, #-12]
    /* Actually commit the change */
    if(RME_COMP_SWAP((rme_ptr_t*)(&(Prc_Op->Pgt)),
80166538:	e51b3008 	ldr	r3, [fp, #-8]
8016653c:	e2833018 	add	r3, r3, #24
80166540:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
80166544:	e51b200c 	ldr	r2, [fp, #-12]
80166548:	e1a00003 	mov	r0, r3
8016654c:	ebffe9ad 	bl	80160c08 <_RME_Comp_Swap_Single>
80166550:	e1a03000 	mov	r3, r0
80166554:	e3530000 	cmp	r3, #0
80166558:	1a000001 	bne	80166564 <_RME_Prc_Pgt+0x3c0>
                     Raw_Pgt)==RME_CASFAIL)
#endif
    {
        RME_COV_MARKER();
        
        return RME_ERR_PTH_CONFLICT;
8016655c:	e3e030c9 	mvn	r3, #201	@ 0xc9
80166560:	ea00000a 	b	80166590 <_RME_Prc_Pgt+0x3ec>
        /* No action required */
    }
    
    /* Reference new table and dereference the old table */
#if(RME_PGT_RAW_ENABLE==0U)
    RME_FETCH_ADD(&(Pgt_New->Head.Root_Ref),1);
80166564:	e51b300c 	ldr	r3, [fp, #-12]
80166568:	e2833004 	add	r3, r3, #4
8016656c:	e3a01001 	mov	r1, #1
80166570:	e1a00003 	mov	r0, r3
80166574:	ebffe9b8 	bl	80160c5c <_RME_Fetch_Add_Single>
    RME_FETCH_ADD(&(Pgt_Old->Head.Root_Ref),-1);
80166578:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016657c:	e2833004 	add	r3, r3, #4
80166580:	e3e01000 	mvn	r1, #0
80166584:	e1a00003 	mov	r0, r3
80166588:	ebffe9b3 	bl	80160c5c <_RME_Fetch_Add_Single>
#endif
    
    return 0;
8016658c:	e3a03000 	mov	r3, #0
}
80166590:	e1a00003 	mov	r0, r3
80166594:	e24bd004 	sub	sp, fp, #4
80166598:	e8bd8800 	pop	{fp, pc}

8016659c <_RME_Thd_Crt>:
                              rme_cid_t Cap_Prc,
                              rme_ptr_t Prio_Max,
                              rme_ptr_t Raddr,
                              rme_ptr_t Attr,
                              rme_ptr_t Is_Hyp)
{
8016659c:	e92d4800 	push	{fp, lr}
801665a0:	e28db004 	add	fp, sp, #4
801665a4:	e24dd038 	sub	sp, sp, #56	@ 0x38
801665a8:	e50b0030 	str	r0, [fp, #-48]	@ 0xffffffd0
801665ac:	e50b1034 	str	r1, [fp, #-52]	@ 0xffffffcc
801665b0:	e50b2038 	str	r2, [fp, #-56]	@ 0xffffffc8
801665b4:	e50b303c 	str	r3, [fp, #-60]	@ 0xffffffc4
    rme_ptr_t Vaddr;
    rme_ptr_t Size;
    
    /* See if the maximum priority relationship is correct - a thread
     * can never create a thread with higher maximum priority */
    if((RME_CPU_LOCAL()->Thd_Cur)->Sched.Prio_Max<Prio_Max)
801665b8:	e30d3004 	movw	r3, #53252	@ 0xd004
801665bc:	e3483016 	movt	r3, #32790	@ 0x8016
801665c0:	e5933004 	ldr	r3, [r3, #4]
801665c4:	e5933024 	ldr	r3, [r3, #36]	@ 0x24
801665c8:	e59b2008 	ldr	r2, [fp, #8]
801665cc:	e1520003 	cmp	r2, r3
801665d0:	9a000001 	bls	801665dc <_RME_Thd_Crt+0x40>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_PRIO;
801665d4:	e3e030cc 	mvn	r3, #204	@ 0xcc
801665d8:	ea0001ea 	b	80166d88 <_RME_Thd_Crt+0x7ec>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
801665dc:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801665e0:	e2033080 	and	r3, r3, #128	@ 0x80
801665e4:	e3530000 	cmp	r3, #0
801665e8:	1a00001d 	bne	80166664 <_RME_Thd_Crt+0xc8>
801665ec:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801665f0:	e5932014 	ldr	r2, [r3, #20]
801665f4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801665f8:	e1520003 	cmp	r2, r3
801665fc:	8a000001 	bhi	80166608 <_RME_Thd_Crt+0x6c>
80166600:	e3e03002 	mvn	r3, #2
80166604:	ea0001df 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166608:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
8016660c:	e1a02283 	lsl	r2, r3, #5
80166610:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80166614:	e593300c 	ldr	r3, [r3, #12]
80166618:	e0823003 	add	r3, r2, r3
8016661c:	e50b3008 	str	r3, [fp, #-8]
80166620:	e51b3008 	ldr	r3, [fp, #-8]
80166624:	e1a00003 	mov	r0, r3
80166628:	ebffe834 	bl	80160700 <__RME_A7A_Read_Acquire>
8016662c:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80166630:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166634:	e1a03823 	lsr	r3, r3, #16
80166638:	e6ef3073 	uxtb	r3, r3
8016663c:	e3530002 	cmp	r3, #2
80166640:	1a000001 	bne	8016664c <_RME_Thd_Crt+0xb0>
80166644:	e3e03008 	mvn	r3, #8
80166648:	ea0001ce 	b	80166d88 <_RME_Thd_Crt+0x7ec>
8016664c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166650:	e1a03c23 	lsr	r3, r3, #24
80166654:	e3530003 	cmp	r3, #3
80166658:	0a000041 	beq	80166764 <_RME_Thd_Crt+0x1c8>
8016665c:	e3e03001 	mvn	r3, #1
80166660:	ea0001c8 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166664:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80166668:	e1a02423 	lsr	r2, r3, #8
8016666c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80166670:	e5933014 	ldr	r3, [r3, #20]
80166674:	e1520003 	cmp	r2, r3
80166678:	3a000001 	bcc	80166684 <_RME_Thd_Crt+0xe8>
8016667c:	e3e03002 	mvn	r3, #2
80166680:	ea0001c0 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166684:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80166688:	e1a03423 	lsr	r3, r3, #8
8016668c:	e1a02283 	lsl	r2, r3, #5
80166690:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80166694:	e593300c 	ldr	r3, [r3, #12]
80166698:	e0823003 	add	r3, r2, r3
8016669c:	e50b3008 	str	r3, [fp, #-8]
801666a0:	e51b3008 	ldr	r3, [fp, #-8]
801666a4:	e1a00003 	mov	r0, r3
801666a8:	ebffe814 	bl	80160700 <__RME_A7A_Read_Acquire>
801666ac:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
801666b0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801666b4:	e1a03823 	lsr	r3, r3, #16
801666b8:	e6ef3073 	uxtb	r3, r3
801666bc:	e3530002 	cmp	r3, #2
801666c0:	1a000001 	bne	801666cc <_RME_Thd_Crt+0x130>
801666c4:	e3e03008 	mvn	r3, #8
801666c8:	ea0001ae 	b	80166d88 <_RME_Thd_Crt+0x7ec>
801666cc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801666d0:	e1a03c23 	lsr	r3, r3, #24
801666d4:	e3530003 	cmp	r3, #3
801666d8:	0a000001 	beq	801666e4 <_RME_Thd_Crt+0x148>
801666dc:	e3e03001 	mvn	r3, #1
801666e0:	ea0001a8 	b	80166d88 <_RME_Thd_Crt+0x7ec>
801666e4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801666e8:	e203207f 	and	r2, r3, #127	@ 0x7f
801666ec:	e51b3008 	ldr	r3, [fp, #-8]
801666f0:	e5933014 	ldr	r3, [r3, #20]
801666f4:	e1520003 	cmp	r2, r3
801666f8:	3a000001 	bcc	80166704 <_RME_Thd_Crt+0x168>
801666fc:	e3e03002 	mvn	r3, #2
80166700:	ea0001a0 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166704:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80166708:	e203307f 	and	r3, r3, #127	@ 0x7f
8016670c:	e1a02283 	lsl	r2, r3, #5
80166710:	e51b3008 	ldr	r3, [fp, #-8]
80166714:	e593300c 	ldr	r3, [r3, #12]
80166718:	e0823003 	add	r3, r2, r3
8016671c:	e50b3008 	str	r3, [fp, #-8]
80166720:	e51b3008 	ldr	r3, [fp, #-8]
80166724:	e1a00003 	mov	r0, r3
80166728:	ebffe7f4 	bl	80160700 <__RME_A7A_Read_Acquire>
8016672c:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80166730:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166734:	e1a03823 	lsr	r3, r3, #16
80166738:	e6ef3073 	uxtb	r3, r3
8016673c:	e3530002 	cmp	r3, #2
80166740:	1a000001 	bne	8016674c <_RME_Thd_Crt+0x1b0>
80166744:	e3e03008 	mvn	r3, #8
80166748:	ea00018e 	b	80166d88 <_RME_Thd_Crt+0x7ec>
8016674c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166750:	e1a03c23 	lsr	r3, r3, #24
80166754:	e3530003 	cmp	r3, #3
80166758:	0a000001 	beq	80166764 <_RME_Thd_Crt+0x1c8>
8016675c:	e3e03001 	mvn	r3, #1
80166760:	ea000188 	b	80166d88 <_RME_Thd_Crt+0x7ec>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat); 
    RME_CPT_GETCAP(Cpt,Cap_Kom,RME_CAP_TYPE_KOM,
80166764:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80166768:	e2033080 	and	r3, r3, #128	@ 0x80
8016676c:	e3530000 	cmp	r3, #0
80166770:	1a00001d 	bne	801667ec <_RME_Thd_Crt+0x250>
80166774:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80166778:	e5932014 	ldr	r2, [r3, #20]
8016677c:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80166780:	e1520003 	cmp	r2, r3
80166784:	8a000001 	bhi	80166790 <_RME_Thd_Crt+0x1f4>
80166788:	e3e03002 	mvn	r3, #2
8016678c:	ea00017d 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166790:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80166794:	e1a02283 	lsl	r2, r3, #5
80166798:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016679c:	e593300c 	ldr	r3, [r3, #12]
801667a0:	e0823003 	add	r3, r2, r3
801667a4:	e50b3010 	str	r3, [fp, #-16]
801667a8:	e51b3010 	ldr	r3, [fp, #-16]
801667ac:	e1a00003 	mov	r0, r3
801667b0:	ebffe7d2 	bl	80160700 <__RME_A7A_Read_Acquire>
801667b4:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
801667b8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801667bc:	e1a03823 	lsr	r3, r3, #16
801667c0:	e6ef3073 	uxtb	r3, r3
801667c4:	e3530002 	cmp	r3, #2
801667c8:	1a000001 	bne	801667d4 <_RME_Thd_Crt+0x238>
801667cc:	e3e03008 	mvn	r3, #8
801667d0:	ea00016c 	b	80166d88 <_RME_Thd_Crt+0x7ec>
801667d4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801667d8:	e1a03c23 	lsr	r3, r3, #24
801667dc:	e3530002 	cmp	r3, #2
801667e0:	0a000041 	beq	801668ec <_RME_Thd_Crt+0x350>
801667e4:	e3e03001 	mvn	r3, #1
801667e8:	ea000166 	b	80166d88 <_RME_Thd_Crt+0x7ec>
801667ec:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
801667f0:	e1a02423 	lsr	r2, r3, #8
801667f4:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801667f8:	e5933014 	ldr	r3, [r3, #20]
801667fc:	e1520003 	cmp	r2, r3
80166800:	3a000001 	bcc	8016680c <_RME_Thd_Crt+0x270>
80166804:	e3e03002 	mvn	r3, #2
80166808:	ea00015e 	b	80166d88 <_RME_Thd_Crt+0x7ec>
8016680c:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80166810:	e1a03423 	lsr	r3, r3, #8
80166814:	e1a02283 	lsl	r2, r3, #5
80166818:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016681c:	e593300c 	ldr	r3, [r3, #12]
80166820:	e0823003 	add	r3, r2, r3
80166824:	e50b3010 	str	r3, [fp, #-16]
80166828:	e51b3010 	ldr	r3, [fp, #-16]
8016682c:	e1a00003 	mov	r0, r3
80166830:	ebffe7b2 	bl	80160700 <__RME_A7A_Read_Acquire>
80166834:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80166838:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016683c:	e1a03823 	lsr	r3, r3, #16
80166840:	e6ef3073 	uxtb	r3, r3
80166844:	e3530002 	cmp	r3, #2
80166848:	1a000001 	bne	80166854 <_RME_Thd_Crt+0x2b8>
8016684c:	e3e03008 	mvn	r3, #8
80166850:	ea00014c 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166854:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166858:	e1a03c23 	lsr	r3, r3, #24
8016685c:	e3530003 	cmp	r3, #3
80166860:	0a000001 	beq	8016686c <_RME_Thd_Crt+0x2d0>
80166864:	e3e03001 	mvn	r3, #1
80166868:	ea000146 	b	80166d88 <_RME_Thd_Crt+0x7ec>
8016686c:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80166870:	e203207f 	and	r2, r3, #127	@ 0x7f
80166874:	e51b3010 	ldr	r3, [fp, #-16]
80166878:	e5933014 	ldr	r3, [r3, #20]
8016687c:	e1520003 	cmp	r2, r3
80166880:	3a000001 	bcc	8016688c <_RME_Thd_Crt+0x2f0>
80166884:	e3e03002 	mvn	r3, #2
80166888:	ea00013e 	b	80166d88 <_RME_Thd_Crt+0x7ec>
8016688c:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80166890:	e203307f 	and	r3, r3, #127	@ 0x7f
80166894:	e1a02283 	lsl	r2, r3, #5
80166898:	e51b3010 	ldr	r3, [fp, #-16]
8016689c:	e593300c 	ldr	r3, [r3, #12]
801668a0:	e0823003 	add	r3, r2, r3
801668a4:	e50b3010 	str	r3, [fp, #-16]
801668a8:	e51b3010 	ldr	r3, [fp, #-16]
801668ac:	e1a00003 	mov	r0, r3
801668b0:	ebffe792 	bl	80160700 <__RME_A7A_Read_Acquire>
801668b4:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
801668b8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801668bc:	e1a03823 	lsr	r3, r3, #16
801668c0:	e6ef3073 	uxtb	r3, r3
801668c4:	e3530002 	cmp	r3, #2
801668c8:	1a000001 	bne	801668d4 <_RME_Thd_Crt+0x338>
801668cc:	e3e03008 	mvn	r3, #8
801668d0:	ea00012c 	b	80166d88 <_RME_Thd_Crt+0x7ec>
801668d4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801668d8:	e1a03c23 	lsr	r3, r3, #24
801668dc:	e3530002 	cmp	r3, #2
801668e0:	0a000001 	beq	801668ec <_RME_Thd_Crt+0x350>
801668e4:	e3e03001 	mvn	r3, #1
801668e8:	ea000126 	b	80166d88 <_RME_Thd_Crt+0x7ec>
                   struct RME_Cap_Kom*,Kom_Op,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Prc,RME_CAP_TYPE_PRC,
801668ec:	e59b3004 	ldr	r3, [fp, #4]
801668f0:	e2033080 	and	r3, r3, #128	@ 0x80
801668f4:	e3530000 	cmp	r3, #0
801668f8:	1a00001d 	bne	80166974 <_RME_Thd_Crt+0x3d8>
801668fc:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80166900:	e5932014 	ldr	r2, [r3, #20]
80166904:	e59b3004 	ldr	r3, [fp, #4]
80166908:	e1520003 	cmp	r2, r3
8016690c:	8a000001 	bhi	80166918 <_RME_Thd_Crt+0x37c>
80166910:	e3e03002 	mvn	r3, #2
80166914:	ea00011b 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166918:	e59b3004 	ldr	r3, [fp, #4]
8016691c:	e1a02283 	lsl	r2, r3, #5
80166920:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80166924:	e593300c 	ldr	r3, [r3, #12]
80166928:	e0823003 	add	r3, r2, r3
8016692c:	e50b300c 	str	r3, [fp, #-12]
80166930:	e51b300c 	ldr	r3, [fp, #-12]
80166934:	e1a00003 	mov	r0, r3
80166938:	ebffe770 	bl	80160700 <__RME_A7A_Read_Acquire>
8016693c:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80166940:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166944:	e1a03823 	lsr	r3, r3, #16
80166948:	e6ef3073 	uxtb	r3, r3
8016694c:	e3530002 	cmp	r3, #2
80166950:	1a000001 	bne	8016695c <_RME_Thd_Crt+0x3c0>
80166954:	e3e03008 	mvn	r3, #8
80166958:	ea00010a 	b	80166d88 <_RME_Thd_Crt+0x7ec>
8016695c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166960:	e1a03c23 	lsr	r3, r3, #24
80166964:	e3530005 	cmp	r3, #5
80166968:	0a000041 	beq	80166a74 <_RME_Thd_Crt+0x4d8>
8016696c:	e3e03001 	mvn	r3, #1
80166970:	ea000104 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166974:	e59b3004 	ldr	r3, [fp, #4]
80166978:	e1a02423 	lsr	r2, r3, #8
8016697c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80166980:	e5933014 	ldr	r3, [r3, #20]
80166984:	e1520003 	cmp	r2, r3
80166988:	3a000001 	bcc	80166994 <_RME_Thd_Crt+0x3f8>
8016698c:	e3e03002 	mvn	r3, #2
80166990:	ea0000fc 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166994:	e59b3004 	ldr	r3, [fp, #4]
80166998:	e1a03423 	lsr	r3, r3, #8
8016699c:	e1a02283 	lsl	r2, r3, #5
801669a0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801669a4:	e593300c 	ldr	r3, [r3, #12]
801669a8:	e0823003 	add	r3, r2, r3
801669ac:	e50b300c 	str	r3, [fp, #-12]
801669b0:	e51b300c 	ldr	r3, [fp, #-12]
801669b4:	e1a00003 	mov	r0, r3
801669b8:	ebffe750 	bl	80160700 <__RME_A7A_Read_Acquire>
801669bc:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
801669c0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801669c4:	e1a03823 	lsr	r3, r3, #16
801669c8:	e6ef3073 	uxtb	r3, r3
801669cc:	e3530002 	cmp	r3, #2
801669d0:	1a000001 	bne	801669dc <_RME_Thd_Crt+0x440>
801669d4:	e3e03008 	mvn	r3, #8
801669d8:	ea0000ea 	b	80166d88 <_RME_Thd_Crt+0x7ec>
801669dc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801669e0:	e1a03c23 	lsr	r3, r3, #24
801669e4:	e3530003 	cmp	r3, #3
801669e8:	0a000001 	beq	801669f4 <_RME_Thd_Crt+0x458>
801669ec:	e3e03001 	mvn	r3, #1
801669f0:	ea0000e4 	b	80166d88 <_RME_Thd_Crt+0x7ec>
801669f4:	e59b3004 	ldr	r3, [fp, #4]
801669f8:	e203207f 	and	r2, r3, #127	@ 0x7f
801669fc:	e51b300c 	ldr	r3, [fp, #-12]
80166a00:	e5933014 	ldr	r3, [r3, #20]
80166a04:	e1520003 	cmp	r2, r3
80166a08:	3a000001 	bcc	80166a14 <_RME_Thd_Crt+0x478>
80166a0c:	e3e03002 	mvn	r3, #2
80166a10:	ea0000dc 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166a14:	e59b3004 	ldr	r3, [fp, #4]
80166a18:	e203307f 	and	r3, r3, #127	@ 0x7f
80166a1c:	e1a02283 	lsl	r2, r3, #5
80166a20:	e51b300c 	ldr	r3, [fp, #-12]
80166a24:	e593300c 	ldr	r3, [r3, #12]
80166a28:	e0823003 	add	r3, r2, r3
80166a2c:	e50b300c 	str	r3, [fp, #-12]
80166a30:	e51b300c 	ldr	r3, [fp, #-12]
80166a34:	e1a00003 	mov	r0, r3
80166a38:	ebffe730 	bl	80160700 <__RME_A7A_Read_Acquire>
80166a3c:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80166a40:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166a44:	e1a03823 	lsr	r3, r3, #16
80166a48:	e6ef3073 	uxtb	r3, r3
80166a4c:	e3530002 	cmp	r3, #2
80166a50:	1a000001 	bne	80166a5c <_RME_Thd_Crt+0x4c0>
80166a54:	e3e03008 	mvn	r3, #8
80166a58:	ea0000ca 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166a5c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166a60:	e1a03c23 	lsr	r3, r3, #24
80166a64:	e3530005 	cmp	r3, #5
80166a68:	0a000001 	beq	80166a74 <_RME_Thd_Crt+0x4d8>
80166a6c:	e3e03001 	mvn	r3, #1
80166a70:	ea0000c4 	b	80166d88 <_RME_Thd_Crt+0x7ec>
                   struct RME_Cap_Prc*,Prc_Op,Type_Stat);
    /* Check if the target caps is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_CRT);
80166a74:	e51b3008 	ldr	r3, [fp, #-8]
80166a78:	e5933008 	ldr	r3, [r3, #8]
80166a7c:	e2033001 	and	r3, r3, #1
80166a80:	e3530000 	cmp	r3, #0
80166a84:	1a000001 	bne	80166a90 <_RME_Thd_Crt+0x4f4>
80166a88:	e3e03006 	mvn	r3, #6
80166a8c:	ea0000bd 	b	80166d88 <_RME_Thd_Crt+0x7ec>
    RME_CAP_CHECK(Prc_Op,RME_PRC_FLAG_THD);
80166a90:	e51b300c 	ldr	r3, [fp, #-12]
80166a94:	e5933008 	ldr	r3, [r3, #8]
80166a98:	e2033002 	and	r3, r3, #2
80166a9c:	e3530000 	cmp	r3, #0
80166aa0:	1a000001 	bne	80166aac <_RME_Thd_Crt+0x510>
80166aa4:	e3e03006 	mvn	r3, #6
80166aa8:	ea0000b6 	b	80166d88 <_RME_Thd_Crt+0x7ec>
    /* See if the creation is valid for this kmem range */
    if(Is_Hyp==0U)
80166aac:	e59b3014 	ldr	r3, [fp, #20]
80166ab0:	e3530000 	cmp	r3, #0
80166ab4:	1a000002 	bne	80166ac4 <_RME_Thd_Crt+0x528>
    {
        RME_COV_MARKER();
        
        Size=RME_THD_SIZE(Attr);
80166ab8:	e3a0309c 	mov	r3, #156	@ 0x9c
80166abc:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
80166ac0:	ea000001 	b	80166acc <_RME_Thd_Crt+0x530>
        RME_COV_MARKER();
        
#if(RME_HYP_VA_SIZE==0U)
        return RME_ERR_PTH_HADDR;
#else
        Size=RME_HYP_SIZE;
80166ac4:	e3a03058 	mov	r3, #88	@ 0x58
80166ac8:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
#endif
    }
    
    RME_KOM_CHECK(Kom_Op,RME_KOM_FLAG_THD,Raddr,Vaddr,Size);
80166acc:	e51b3010 	ldr	r3, [fp, #-16]
80166ad0:	e5933008 	ldr	r3, [r3, #8]
80166ad4:	e2033004 	and	r3, r3, #4
80166ad8:	e3530000 	cmp	r3, #0
80166adc:	1a000001 	bne	80166ae8 <_RME_Thd_Crt+0x54c>
80166ae0:	e3e03006 	mvn	r3, #6
80166ae4:	ea0000a7 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166ae8:	e51b3010 	ldr	r3, [fp, #-16]
80166aec:	e5933014 	ldr	r3, [r3, #20]
80166af0:	e59b200c 	ldr	r2, [fp, #12]
80166af4:	e0823003 	add	r3, r2, r3
80166af8:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
80166afc:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
80166b00:	e59b300c 	ldr	r3, [fp, #12]
80166b04:	e1520003 	cmp	r2, r3
80166b08:	2a000001 	bcs	80166b14 <_RME_Thd_Crt+0x578>
80166b0c:	e3e03006 	mvn	r3, #6
80166b10:	ea00009c 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166b14:	e51b3010 	ldr	r3, [fp, #-16]
80166b18:	e5933014 	ldr	r3, [r3, #20]
80166b1c:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
80166b20:	e1520003 	cmp	r2, r3
80166b24:	2a000001 	bcs	80166b30 <_RME_Thd_Crt+0x594>
80166b28:	e3e03006 	mvn	r3, #6
80166b2c:	ea000095 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166b30:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
80166b34:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80166b38:	e0823003 	add	r3, r2, r3
80166b3c:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
80166b40:	e1520003 	cmp	r2, r3
80166b44:	9a000001 	bls	80166b50 <_RME_Thd_Crt+0x5b4>
80166b48:	e3e03006 	mvn	r3, #6
80166b4c:	ea00008d 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166b50:	e51b3010 	ldr	r3, [fp, #-16]
80166b54:	e5932018 	ldr	r2, [r3, #24]
80166b58:	e51b101c 	ldr	r1, [fp, #-28]	@ 0xffffffe4
80166b5c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80166b60:	e0813003 	add	r3, r1, r3
80166b64:	e2433001 	sub	r3, r3, #1
80166b68:	e1520003 	cmp	r2, r3
80166b6c:	2a000001 	bcs	80166b78 <_RME_Thd_Crt+0x5dc>
80166b70:	e3e03006 	mvn	r3, #6
80166b74:	ea000083 	b	80166d88 <_RME_Thd_Crt+0x7ec>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Thd,struct RME_Cap_Thd*,Thd_Crt);
80166b78:	e51b3008 	ldr	r3, [fp, #-8]
80166b7c:	e5932014 	ldr	r2, [r3, #20]
80166b80:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80166b84:	e1520003 	cmp	r2, r3
80166b88:	8a000001 	bhi	80166b94 <_RME_Thd_Crt+0x5f8>
80166b8c:	e3e03002 	mvn	r3, #2
80166b90:	ea00007c 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166b94:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80166b98:	e1a02283 	lsl	r2, r3, #5
80166b9c:	e51b3008 	ldr	r3, [fp, #-8]
80166ba0:	e593300c 	ldr	r3, [r3, #12]
80166ba4:	e0823003 	add	r3, r2, r3
80166ba8:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Thd_Crt);
80166bac:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166bb0:	e3a02801 	mov	r2, #65536	@ 0x10000
80166bb4:	e3a01000 	mov	r1, #0
80166bb8:	e1a00003 	mov	r0, r3
80166bbc:	ebffe811 	bl	80160c08 <_RME_Comp_Swap_Single>
80166bc0:	e1a03000 	mov	r3, r0
80166bc4:	e3530000 	cmp	r3, #0
80166bc8:	1a000001 	bne	80166bd4 <_RME_Thd_Crt+0x638>
80166bcc:	e3e03004 	mvn	r3, #4
80166bd0:	ea00006c 	b	80166d88 <_RME_Thd_Crt+0x7ec>
80166bd4:	e30d3000 	movw	r3, #53248	@ 0xd000
80166bd8:	e3483016 	movt	r3, #32790	@ 0x8016
80166bdc:	e5932000 	ldr	r2, [r3]
80166be0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166be4:	e5832010 	str	r2, [r3, #16]
     
    /* Try to populate the area */
    if(_RME_Kot_Mark(Vaddr,Size)<0)
80166be8:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
80166bec:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80166bf0:	ebfff753 	bl	80164944 <_RME_Kot_Mark>
80166bf4:	e1a03000 	mov	r3, r0
80166bf8:	e3530000 	cmp	r3, #0
80166bfc:	aa000005 	bge	80166c18 <_RME_Thd_Crt+0x67c>
    {
        RME_COV_MARKER();

        RME_WRITE_RELEASE(&(Thd_Crt->Head.Type_Stat),0U);
80166c00:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166c04:	e3a01000 	mov	r1, #0
80166c08:	e1a00003 	mov	r0, r3
80166c0c:	ebffe6be 	bl	8016070c <__RME_A7A_Write_Release>
        return RME_ERR_CPT_KOT;
80166c10:	e3e03003 	mvn	r3, #3
80166c14:	ea00005b 	b	80166d88 <_RME_Thd_Crt+0x7ec>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Object init */
    Thread=(struct RME_Thd_Struct*)Vaddr;
80166c18:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80166c1c:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    /* These thread's TID default to 0, and have no timeslices assigned */
    Thread->Sched.TID=0U;
80166c20:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166c24:	e3a02000 	mov	r2, #0
80166c28:	e5832010 	str	r2, [r3, #16]
    Thread->Sched.Slice=0U;
80166c2c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166c30:	e3a02000 	mov	r2, #0
80166c34:	e5832018 	str	r2, [r3, #24]
    Thread->Sched.State=RME_THD_TIMEOUT;
80166c38:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166c3c:	e3a02002 	mov	r2, #2
80166c40:	e583201c 	str	r2, [r3, #28]
    Prc_Root=RME_CAP_CONV_ROOT(Prc_Op,struct RME_Cap_Prc*);
80166c44:	e51b300c 	ldr	r3, [fp, #-12]
80166c48:	e5933000 	ldr	r3, [r3]
80166c4c:	e6ff3073 	uxth	r3, r3
80166c50:	e3530000 	cmp	r3, #0
80166c54:	0a000002 	beq	80166c64 <_RME_Thd_Crt+0x6c8>
80166c58:	e51b300c 	ldr	r3, [fp, #-12]
80166c5c:	e5933004 	ldr	r3, [r3, #4]
80166c60:	ea000000 	b	80166c68 <_RME_Thd_Crt+0x6cc>
80166c64:	e51b300c 	ldr	r3, [fp, #-12]
80166c68:	e50b3028 	str	r3, [fp, #-40]	@ 0xffffffd8
    Thread->Sched.Prc=Prc_Root;
80166c6c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166c70:	e51b2028 	ldr	r2, [fp, #-40]	@ 0xffffffd8
80166c74:	e583202c 	str	r2, [r3, #44]	@ 0x2c
    Thread->Sched.Signal=0U;
80166c78:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166c7c:	e3a02000 	mov	r2, #0
80166c80:	e5832028 	str	r2, [r3, #40]	@ 0x28
    Thread->Sched.Prio_Max=Prio_Max;
80166c84:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166c88:	e59b2008 	ldr	r2, [fp, #8]
80166c8c:	e5832024 	str	r2, [r3, #36]	@ 0x24
    Thread->Sched.Sched_Ref=0U;
80166c90:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166c94:	e3a02000 	mov	r2, #0
80166c98:	e5832030 	str	r2, [r3, #48]	@ 0x30
    Thread->Sched.Sched_Sig=0U;
80166c9c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166ca0:	e3a02000 	mov	r2, #0
80166ca4:	e5832038 	str	r2, [r3, #56]	@ 0x38
    /* Currently the thread is not bound to any particular CPU */
    Thread->Sched.Local=RME_THD_FREE;
80166ca8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166cac:	e3e02000 	mvn	r2, #0
80166cb0:	e5832014 	str	r2, [r3, #20]
    /* This is a marking that this thread haven't sent any notifications */
    _RME_List_Crt(&(Thread->Sched.Notif));
80166cb4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166cb8:	e2833008 	add	r3, r3, #8
80166cbc:	e1a00003 	mov	r0, r3
80166cc0:	ebffe80a 	bl	80160cf0 <_RME_List_Crt>
    _RME_List_Crt(&(Thread->Sched.Event));
80166cc4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166cc8:	e283303c 	add	r3, r3, #60	@ 0x3c
80166ccc:	e1a00003 	mov	r0, r3
80166cd0:	ebffe806 	bl	80160cf0 <_RME_List_Crt>
    /* Point its pointer to itself - this is not a hypervisor thread yet */
    if(Is_Hyp==0U)
80166cd4:	e59b3014 	ldr	r3, [fp, #20]
80166cd8:	e3530000 	cmp	r3, #0
80166cdc:	1a000008 	bne	80166d04 <_RME_Thd_Crt+0x768>
    {
        RME_COV_MARKER();
        
        Thread->Ctx.Hyp_Attr=Attr;
80166ce0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166ce4:	e59b2010 	ldr	r2, [fp, #16]
80166ce8:	e5832044 	str	r2, [r3, #68]	@ 0x44
        Thread->Ctx.Reg=(struct RME_Thd_Reg*)(Vaddr+RME_HYP_SIZE);
80166cec:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80166cf0:	e2833058 	add	r3, r3, #88	@ 0x58
80166cf4:	e1a02003 	mov	r2, r3
80166cf8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166cfc:	e5832048 	str	r2, [r3, #72]	@ 0x48
80166d00:	ea000006 	b	80166d20 <_RME_Thd_Crt+0x784>
    /* Default to HYP_VA_BASE for all created hypervisor threads */
    else
    {
        RME_COV_MARKER();
        
        Thread->Ctx.Hyp_Attr=Attr|RME_THD_HYP_FLAG;
80166d04:	e59b3010 	ldr	r3, [fp, #16]
80166d08:	e3832102 	orr	r2, r3, #-2147483648	@ 0x80000000
80166d0c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166d10:	e5832044 	str	r2, [r3, #68]	@ 0x44
        Thread->Ctx.Reg=RME_HYP_VA_BASE;
80166d14:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166d18:	e3a02202 	mov	r2, #536870912	@ 0x20000000
80166d1c:	e5832048 	str	r2, [r3, #72]	@ 0x48
    }
    /* Initialize the invocation stack */
    _RME_List_Crt(&(Thread->Ctx.Invstk));
80166d20:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166d24:	e283304c 	add	r3, r3, #76	@ 0x4c
80166d28:	e1a00003 	mov	r0, r3
80166d2c:	ebffe7ef 	bl	80160cf0 <_RME_List_Crt>
    Thread->Ctx.Invstk_Depth=0U;
80166d30:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166d34:	e3a02000 	mov	r2, #0
80166d38:	e5832054 	str	r2, [r3, #84]	@ 0x54

    /* Header init */
    Thd_Crt->Head.Root_Ref=0U;
80166d3c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166d40:	e3a02000 	mov	r2, #0
80166d44:	e5832004 	str	r2, [r3, #4]
    Thd_Crt->Head.Object=Vaddr;
80166d48:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166d4c:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
80166d50:	e583200c 	str	r2, [r3, #12]
    Thd_Crt->Head.Flag=RME_THD_FLAG_ALL;
80166d54:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166d58:	e30021ff 	movw	r2, #511	@ 0x1ff
80166d5c:	e5832008 	str	r2, [r3, #8]

    /* Reference process */
    RME_FETCH_ADD(&(Prc_Root->Head.Root_Ref), 1U);
80166d60:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80166d64:	e2833004 	add	r3, r3, #4
80166d68:	e3a01001 	mov	r1, #1
80166d6c:	e1a00003 	mov	r0, r3
80166d70:	ebffe7b9 	bl	80160c5c <_RME_Fetch_Add_Single>
    
    /* Establish cap */
    RME_WRITE_RELEASE(&(Thd_Crt->Head.Type_Stat),
80166d74:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166d78:	e3a01406 	mov	r1, #100663296	@ 0x6000000
80166d7c:	e1a00003 	mov	r0, r3
80166d80:	ebffe661 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_THD,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
80166d84:	e3a03000 	mov	r3, #0
}
80166d88:	e1a00003 	mov	r0, r3
80166d8c:	e24bd004 	sub	sp, fp, #4
80166d90:	e8bd8800 	pop	{fp, pc}

80166d94 <_RME_Thd_Del>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Thd_Del(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt,
                              rme_cid_t Cap_Thd)
{
80166d94:	e92d4800 	push	{fp, lr}
80166d98:	e28db004 	add	fp, sp, #4
80166d9c:	e24dd028 	sub	sp, sp, #40	@ 0x28
80166da0:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
80166da4:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
80166da8:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
    /* These are for deletion */
    struct RME_Thd_Struct* Thread;
    struct RME_Inv_Struct* Invocation;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
80166dac:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166db0:	e2033080 	and	r3, r3, #128	@ 0x80
80166db4:	e3530000 	cmp	r3, #0
80166db8:	1a00001d 	bne	80166e34 <_RME_Thd_Del+0xa0>
80166dbc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166dc0:	e5932014 	ldr	r2, [r3, #20]
80166dc4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166dc8:	e1520003 	cmp	r2, r3
80166dcc:	8a000001 	bhi	80166dd8 <_RME_Thd_Del+0x44>
80166dd0:	e3e03002 	mvn	r3, #2
80166dd4:	ea000101 	b	801671e0 <_RME_Thd_Del+0x44c>
80166dd8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166ddc:	e1a02283 	lsl	r2, r3, #5
80166de0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166de4:	e593300c 	ldr	r3, [r3, #12]
80166de8:	e0823003 	add	r3, r2, r3
80166dec:	e50b3008 	str	r3, [fp, #-8]
80166df0:	e51b3008 	ldr	r3, [fp, #-8]
80166df4:	e1a00003 	mov	r0, r3
80166df8:	ebffe640 	bl	80160700 <__RME_A7A_Read_Acquire>
80166dfc:	e50b000c 	str	r0, [fp, #-12]
80166e00:	e51b300c 	ldr	r3, [fp, #-12]
80166e04:	e1a03823 	lsr	r3, r3, #16
80166e08:	e6ef3073 	uxtb	r3, r3
80166e0c:	e3530002 	cmp	r3, #2
80166e10:	1a000001 	bne	80166e1c <_RME_Thd_Del+0x88>
80166e14:	e3e03008 	mvn	r3, #8
80166e18:	ea0000f0 	b	801671e0 <_RME_Thd_Del+0x44c>
80166e1c:	e51b300c 	ldr	r3, [fp, #-12]
80166e20:	e1a03c23 	lsr	r3, r3, #24
80166e24:	e3530003 	cmp	r3, #3
80166e28:	0a000041 	beq	80166f34 <_RME_Thd_Del+0x1a0>
80166e2c:	e3e03001 	mvn	r3, #1
80166e30:	ea0000ea 	b	801671e0 <_RME_Thd_Del+0x44c>
80166e34:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166e38:	e1a02423 	lsr	r2, r3, #8
80166e3c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166e40:	e5933014 	ldr	r3, [r3, #20]
80166e44:	e1520003 	cmp	r2, r3
80166e48:	3a000001 	bcc	80166e54 <_RME_Thd_Del+0xc0>
80166e4c:	e3e03002 	mvn	r3, #2
80166e50:	ea0000e2 	b	801671e0 <_RME_Thd_Del+0x44c>
80166e54:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166e58:	e1a03423 	lsr	r3, r3, #8
80166e5c:	e1a02283 	lsl	r2, r3, #5
80166e60:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166e64:	e593300c 	ldr	r3, [r3, #12]
80166e68:	e0823003 	add	r3, r2, r3
80166e6c:	e50b3008 	str	r3, [fp, #-8]
80166e70:	e51b3008 	ldr	r3, [fp, #-8]
80166e74:	e1a00003 	mov	r0, r3
80166e78:	ebffe620 	bl	80160700 <__RME_A7A_Read_Acquire>
80166e7c:	e50b000c 	str	r0, [fp, #-12]
80166e80:	e51b300c 	ldr	r3, [fp, #-12]
80166e84:	e1a03823 	lsr	r3, r3, #16
80166e88:	e6ef3073 	uxtb	r3, r3
80166e8c:	e3530002 	cmp	r3, #2
80166e90:	1a000001 	bne	80166e9c <_RME_Thd_Del+0x108>
80166e94:	e3e03008 	mvn	r3, #8
80166e98:	ea0000d0 	b	801671e0 <_RME_Thd_Del+0x44c>
80166e9c:	e51b300c 	ldr	r3, [fp, #-12]
80166ea0:	e1a03c23 	lsr	r3, r3, #24
80166ea4:	e3530003 	cmp	r3, #3
80166ea8:	0a000001 	beq	80166eb4 <_RME_Thd_Del+0x120>
80166eac:	e3e03001 	mvn	r3, #1
80166eb0:	ea0000ca 	b	801671e0 <_RME_Thd_Del+0x44c>
80166eb4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166eb8:	e203207f 	and	r2, r3, #127	@ 0x7f
80166ebc:	e51b3008 	ldr	r3, [fp, #-8]
80166ec0:	e5933014 	ldr	r3, [r3, #20]
80166ec4:	e1520003 	cmp	r2, r3
80166ec8:	3a000001 	bcc	80166ed4 <_RME_Thd_Del+0x140>
80166ecc:	e3e03002 	mvn	r3, #2
80166ed0:	ea0000c2 	b	801671e0 <_RME_Thd_Del+0x44c>
80166ed4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166ed8:	e203307f 	and	r3, r3, #127	@ 0x7f
80166edc:	e1a02283 	lsl	r2, r3, #5
80166ee0:	e51b3008 	ldr	r3, [fp, #-8]
80166ee4:	e593300c 	ldr	r3, [r3, #12]
80166ee8:	e0823003 	add	r3, r2, r3
80166eec:	e50b3008 	str	r3, [fp, #-8]
80166ef0:	e51b3008 	ldr	r3, [fp, #-8]
80166ef4:	e1a00003 	mov	r0, r3
80166ef8:	ebffe600 	bl	80160700 <__RME_A7A_Read_Acquire>
80166efc:	e50b000c 	str	r0, [fp, #-12]
80166f00:	e51b300c 	ldr	r3, [fp, #-12]
80166f04:	e1a03823 	lsr	r3, r3, #16
80166f08:	e6ef3073 	uxtb	r3, r3
80166f0c:	e3530002 	cmp	r3, #2
80166f10:	1a000001 	bne	80166f1c <_RME_Thd_Del+0x188>
80166f14:	e3e03008 	mvn	r3, #8
80166f18:	ea0000b0 	b	801671e0 <_RME_Thd_Del+0x44c>
80166f1c:	e51b300c 	ldr	r3, [fp, #-12]
80166f20:	e1a03c23 	lsr	r3, r3, #24
80166f24:	e3530003 	cmp	r3, #3
80166f28:	0a000001 	beq	80166f34 <_RME_Thd_Del+0x1a0>
80166f2c:	e3e03001 	mvn	r3, #1
80166f30:	ea0000aa 	b	801671e0 <_RME_Thd_Del+0x44c>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_DEL);
80166f34:	e51b3008 	ldr	r3, [fp, #-8]
80166f38:	e5933008 	ldr	r3, [r3, #8]
80166f3c:	e2033002 	and	r3, r3, #2
80166f40:	e3530000 	cmp	r3, #0
80166f44:	1a000001 	bne	80166f50 <_RME_Thd_Del+0x1bc>
80166f48:	e3e03006 	mvn	r3, #6
80166f4c:	ea0000a3 	b	801671e0 <_RME_Thd_Del+0x44c>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Thd,struct RME_Cap_Thd*,Thd_Del);
80166f50:	e51b3008 	ldr	r3, [fp, #-8]
80166f54:	e5932014 	ldr	r2, [r3, #20]
80166f58:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80166f5c:	e1520003 	cmp	r2, r3
80166f60:	8a000001 	bhi	80166f6c <_RME_Thd_Del+0x1d8>
80166f64:	e3e03002 	mvn	r3, #2
80166f68:	ea00009c 	b	801671e0 <_RME_Thd_Del+0x44c>
80166f6c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80166f70:	e1a02283 	lsl	r2, r3, #5
80166f74:	e51b3008 	ldr	r3, [fp, #-8]
80166f78:	e593300c 	ldr	r3, [r3, #12]
80166f7c:	e0823003 	add	r3, r2, r3
80166f80:	e50b3010 	str	r3, [fp, #-16]
    /* Delete check */
    RME_CAP_DEL_CHECK(Thd_Del,Type_Stat,RME_CAP_TYPE_THD);
80166f84:	e51b3010 	ldr	r3, [fp, #-16]
80166f88:	e1a00003 	mov	r0, r3
80166f8c:	ebffe5db 	bl	80160700 <__RME_A7A_Read_Acquire>
80166f90:	e50b000c 	str	r0, [fp, #-12]
80166f94:	e51b300c 	ldr	r3, [fp, #-12]
80166f98:	e1a03823 	lsr	r3, r3, #16
80166f9c:	e6ef3073 	uxtb	r3, r3
80166fa0:	e3530002 	cmp	r3, #2
80166fa4:	0a000001 	beq	80166fb0 <_RME_Thd_Del+0x21c>
80166fa8:	e3e03008 	mvn	r3, #8
80166fac:	ea00008b 	b	801671e0 <_RME_Thd_Del+0x44c>
80166fb0:	e51b300c 	ldr	r3, [fp, #-12]
80166fb4:	e1a03c23 	lsr	r3, r3, #24
80166fb8:	e3530006 	cmp	r3, #6
80166fbc:	0a000001 	beq	80166fc8 <_RME_Thd_Del+0x234>
80166fc0:	e3e03001 	mvn	r3, #1
80166fc4:	ea000085 	b	801671e0 <_RME_Thd_Del+0x44c>
80166fc8:	e51b3010 	ldr	r3, [fp, #-16]
80166fcc:	e5933004 	ldr	r3, [r3, #4]
80166fd0:	e3530000 	cmp	r3, #0
80166fd4:	0a00000b 	beq	80167008 <_RME_Thd_Del+0x274>
80166fd8:	e51b300c 	ldr	r3, [fp, #-12]
80166fdc:	e6ff3073 	uxth	r3, r3
80166fe0:	e3530000 	cmp	r3, #0
80166fe4:	1a000005 	bne	80167000 <_RME_Thd_Del+0x26c>
80166fe8:	e51b0010 	ldr	r0, [fp, #-16]
80166fec:	e51b300c 	ldr	r3, [fp, #-12]
80166ff0:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
80166ff4:	e1a02003 	mov	r2, r3
80166ff8:	e51b100c 	ldr	r1, [fp, #-12]
80166ffc:	ebffe701 	bl	80160c08 <_RME_Comp_Swap_Single>
80167000:	e3e03005 	mvn	r3, #5
80167004:	ea000075 	b	801671e0 <_RME_Thd_Del+0x44c>
80167008:	e51b300c 	ldr	r3, [fp, #-12]
8016700c:	e6ff3073 	uxth	r3, r3
80167010:	e3530000 	cmp	r3, #0
80167014:	0a000008 	beq	8016703c <_RME_Thd_Del+0x2a8>
80167018:	e30c3318 	movw	r3, #49944	@ 0xc318
8016701c:	e3483016 	movt	r3, #32790	@ 0x8016
80167020:	e30c2324 	movw	r2, #49956	@ 0xc324
80167024:	e3482016 	movt	r2, #32790	@ 0x8016
80167028:	e30114f3 	movw	r1, #5363	@ 0x14f3
8016702c:	e30c0330 	movw	r0, #49968	@ 0xc330
80167030:	e3480016 	movt	r0, #32790	@ 0x8016
80167034:	ebffe6d2 	bl	80160b84 <RME_Log>
80167038:	eafffffe 	b	80167038 <_RME_Thd_Del+0x2a4>
    
    /* Get the thread */
    Thread=RME_CAP_GETOBJ(Thd_Del,struct RME_Thd_Struct*);
8016703c:	e51b3010 	ldr	r3, [fp, #-16]
80167040:	e593300c 	ldr	r3, [r3, #12]
80167044:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    
    /* See if the thread is free. If still bound, we cannot proceed to deletion */
    if(Thread->Sched.Local!=RME_THD_FREE)
80167048:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016704c:	e5933014 	ldr	r3, [r3, #20]
80167050:	e3730001 	cmn	r3, #1
80167054:	0a000007 	beq	80167078 <_RME_Thd_Del+0x2e4>
    {
        RME_COV_MARKER();

        RME_CAP_DEFROST(Thd_Del,Type_Stat);
80167058:	e51b0010 	ldr	r0, [fp, #-16]
8016705c:	e51b300c 	ldr	r3, [fp, #-12]
80167060:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
80167064:	e1a02003 	mov	r2, r3
80167068:	e51b100c 	ldr	r1, [fp, #-12]
8016706c:	ebffe6e5 	bl	80160c08 <_RME_Comp_Swap_Single>
        return RME_ERR_PTH_INVSTATE;
80167070:	e3e030cb 	mvn	r3, #203	@ 0xcb
80167074:	ea000059 	b	801671e0 <_RME_Thd_Del+0x44c>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Now we can safely delete the cap */
    RME_CAP_DELETE(Thd_Del,Type_Stat);
80167078:	e51b3010 	ldr	r3, [fp, #-16]
8016707c:	e3a02000 	mov	r2, #0
80167080:	e51b100c 	ldr	r1, [fp, #-12]
80167084:	e1a00003 	mov	r0, r3
80167088:	ebffe6de 	bl	80160c08 <_RME_Comp_Swap_Single>
8016708c:	e1a03000 	mov	r3, r0
80167090:	e3530000 	cmp	r3, #0
80167094:	1a000013 	bne	801670e8 <_RME_Thd_Del+0x354>
80167098:	e3e03000 	mvn	r3, #0
8016709c:	ea00004f 	b	801671e0 <_RME_Thd_Del+0x44c>
     * stack to empty, and free all the invocation stubs. This can be virtually
     * unbounded if the invocation stack is just too deep. This is left to the
     * user; if this is what he or she wants, be our guest. */
    while(Thread->Ctx.Invstk.Next!=&(Thread->Ctx.Invstk))
    {
        Invocation=(struct RME_Inv_Struct*)(Thread->Ctx.Invstk.Next);
801670a0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801670a4:	e593304c 	ldr	r3, [r3, #76]	@ 0x4c
801670a8:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
        _RME_List_Del(Invocation->Head.Prev,Invocation->Head.Next);
801670ac:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801670b0:	e5932004 	ldr	r2, [r3, #4]
801670b4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801670b8:	e5933000 	ldr	r3, [r3]
801670bc:	e1a01003 	mov	r1, r3
801670c0:	e1a00002 	mov	r0, r2
801670c4:	ebffe717 	bl	80160d28 <_RME_List_Del>
        Invocation->Thd_Act=0U;
801670c8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801670cc:	e3a02000 	mov	r2, #0
801670d0:	e583200c 	str	r2, [r3, #12]
        Thread->Ctx.Invstk_Depth--;
801670d4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801670d8:	e5933054 	ldr	r3, [r3, #84]	@ 0x54
801670dc:	e2432001 	sub	r2, r3, #1
801670e0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801670e4:	e5832054 	str	r2, [r3, #84]	@ 0x54
    while(Thread->Ctx.Invstk.Next!=&(Thread->Ctx.Invstk))
801670e8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801670ec:	e593204c 	ldr	r2, [r3, #76]	@ 0x4c
801670f0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801670f4:	e283304c 	add	r3, r3, #76	@ 0x4c
801670f8:	e1520003 	cmp	r2, r3
801670fc:	1affffe7 	bne	801670a0 <_RME_Thd_Del+0x30c>
    }
    RME_ASSERT(Thread->Ctx.Invstk_Depth==0U);
80167100:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167104:	e5933054 	ldr	r3, [r3, #84]	@ 0x54
80167108:	e3530000 	cmp	r3, #0
8016710c:	0a000008 	beq	80167134 <_RME_Thd_Del+0x3a0>
80167110:	e30c3318 	movw	r3, #49944	@ 0xc318
80167114:	e3483016 	movt	r3, #32790	@ 0x8016
80167118:	e30c2324 	movw	r2, #49956	@ 0xc324
8016711c:	e3482016 	movt	r2, #32790	@ 0x8016
80167120:	e3011514 	movw	r1, #5396	@ 0x1514
80167124:	e30c0330 	movw	r0, #49968	@ 0xc330
80167128:	e3480016 	movt	r0, #32790	@ 0x8016
8016712c:	ebffe694 	bl	80160b84 <RME_Log>
80167130:	eafffffe 	b	80167130 <_RME_Thd_Del+0x39c>
    
    /* Dereference the process */
    RME_FETCH_ADD(&(Thread->Sched.Prc->Head.Root_Ref), -1);
80167134:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167138:	e593302c 	ldr	r3, [r3, #44]	@ 0x2c
8016713c:	e2833004 	add	r3, r3, #4
80167140:	e3e01000 	mvn	r1, #0
80167144:	e1a00003 	mov	r0, r3
80167148:	ebffe6c3 	bl	80160c5c <_RME_Fetch_Add_Single>
    
    /* Try to depopulate the area - this must be successful */
    if((Thread->Ctx.Hyp_Attr&RME_THD_HYP_FLAG)==0U)
8016714c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167150:	e5933044 	ldr	r3, [r3, #68]	@ 0x44
80167154:	e3530000 	cmp	r3, #0
80167158:	ba00000f 	blt	8016719c <_RME_Thd_Del+0x408>
    {
        RME_COV_MARKER();

        RME_ASSERT(_RME_Kot_Erase((rme_ptr_t)Thread,
8016715c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167160:	e3a0109c 	mov	r1, #156	@ 0x9c
80167164:	e1a00003 	mov	r0, r3
80167168:	ebfff6c6 	bl	80164c88 <_RME_Kot_Erase>
8016716c:	e1a03000 	mov	r3, r0
80167170:	e3530000 	cmp	r3, #0
80167174:	0a000018 	beq	801671dc <_RME_Thd_Del+0x448>
80167178:	e30c3318 	movw	r3, #49944	@ 0xc318
8016717c:	e3483016 	movt	r3, #32790	@ 0x8016
80167180:	e30c2324 	movw	r2, #49956	@ 0xc324
80167184:	e3482016 	movt	r2, #32790	@ 0x8016
80167188:	e301151e 	movw	r1, #5406	@ 0x151e
8016718c:	e30c0330 	movw	r0, #49968	@ 0xc330
80167190:	e3480016 	movt	r0, #32790	@ 0x8016
80167194:	ebffe67a 	bl	80160b84 <RME_Log>
80167198:	eafffffe 	b	80167198 <_RME_Thd_Del+0x404>
    }
    else
    {
        RME_COV_MARKER();

        RME_ASSERT(_RME_Kot_Erase((rme_ptr_t)Thread,
8016719c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801671a0:	e3a01058 	mov	r1, #88	@ 0x58
801671a4:	e1a00003 	mov	r0, r3
801671a8:	ebfff6b6 	bl	80164c88 <_RME_Kot_Erase>
801671ac:	e1a03000 	mov	r3, r0
801671b0:	e3530000 	cmp	r3, #0
801671b4:	0a000008 	beq	801671dc <_RME_Thd_Del+0x448>
801671b8:	e30c3318 	movw	r3, #49944	@ 0xc318
801671bc:	e3483016 	movt	r3, #32790	@ 0x8016
801671c0:	e30c2324 	movw	r2, #49956	@ 0xc324
801671c4:	e3482016 	movt	r2, #32790	@ 0x8016
801671c8:	e3011525 	movw	r1, #5413	@ 0x1525
801671cc:	e30c0330 	movw	r0, #49968	@ 0xc330
801671d0:	e3480016 	movt	r0, #32790	@ 0x8016
801671d4:	ebffe66a 	bl	80160b84 <RME_Log>
801671d8:	eafffffe 	b	801671d8 <_RME_Thd_Del+0x444>
                   RME_HYP_SIZE)==0);
    }
    
    return 0;
801671dc:	e3a03000 	mov	r3, #0
}
801671e0:	e1a00003 	mov	r0, r3
801671e4:	e24bd004 	sub	sp, fp, #4
801671e8:	e8bd8800 	pop	{fp, pc}

801671ec <_RME_Thd_Sched_Bind>:
                                     rme_cid_t Cap_Thd_Sched,
                                     rme_cid_t Cap_Sig,
                                     rme_tid_t TID,
                                     rme_ptr_t Prio,
                                     rme_ptr_t Haddr)
{
801671ec:	e92d4800 	push	{fp, lr}
801671f0:	e28db004 	add	fp, sp, #4
801671f4:	e24dd038 	sub	sp, sp, #56	@ 0x38
801671f8:	e50b0030 	str	r0, [fp, #-48]	@ 0xffffffd0
801671fc:	e50b1034 	str	r1, [fp, #-52]	@ 0xffffffcc
80167200:	e50b2038 	str	r2, [fp, #-56]	@ 0xffffffc8
80167204:	e50b303c 	str	r3, [fp, #-60]	@ 0xffffffc4
    rme_ptr_t Type_Stat;
    rme_ptr_t Hyp_Attr;
    rme_ptr_t End;

    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Thd,RME_CAP_TYPE_THD,
80167208:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
8016720c:	e2033080 	and	r3, r3, #128	@ 0x80
80167210:	e3530000 	cmp	r3, #0
80167214:	1a00001d 	bne	80167290 <_RME_Thd_Sched_Bind+0xa4>
80167218:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016721c:	e5932014 	ldr	r2, [r3, #20]
80167220:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80167224:	e1520003 	cmp	r2, r3
80167228:	8a000001 	bhi	80167234 <_RME_Thd_Sched_Bind+0x48>
8016722c:	e3e03002 	mvn	r3, #2
80167230:	ea0001df 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167234:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80167238:	e1a02283 	lsl	r2, r3, #5
8016723c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167240:	e593300c 	ldr	r3, [r3, #12]
80167244:	e0823003 	add	r3, r2, r3
80167248:	e50b3008 	str	r3, [fp, #-8]
8016724c:	e51b3008 	ldr	r3, [fp, #-8]
80167250:	e1a00003 	mov	r0, r3
80167254:	ebffe529 	bl	80160700 <__RME_A7A_Read_Acquire>
80167258:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016725c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167260:	e1a03823 	lsr	r3, r3, #16
80167264:	e6ef3073 	uxtb	r3, r3
80167268:	e3530002 	cmp	r3, #2
8016726c:	1a000001 	bne	80167278 <_RME_Thd_Sched_Bind+0x8c>
80167270:	e3e03008 	mvn	r3, #8
80167274:	ea0001ce 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167278:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016727c:	e1a03c23 	lsr	r3, r3, #24
80167280:	e3530006 	cmp	r3, #6
80167284:	0a000041 	beq	80167390 <_RME_Thd_Sched_Bind+0x1a4>
80167288:	e3e03001 	mvn	r3, #1
8016728c:	ea0001c8 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167290:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80167294:	e1a02423 	lsr	r2, r3, #8
80167298:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016729c:	e5933014 	ldr	r3, [r3, #20]
801672a0:	e1520003 	cmp	r2, r3
801672a4:	3a000001 	bcc	801672b0 <_RME_Thd_Sched_Bind+0xc4>
801672a8:	e3e03002 	mvn	r3, #2
801672ac:	ea0001c0 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
801672b0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801672b4:	e1a03423 	lsr	r3, r3, #8
801672b8:	e1a02283 	lsl	r2, r3, #5
801672bc:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801672c0:	e593300c 	ldr	r3, [r3, #12]
801672c4:	e0823003 	add	r3, r2, r3
801672c8:	e50b3008 	str	r3, [fp, #-8]
801672cc:	e51b3008 	ldr	r3, [fp, #-8]
801672d0:	e1a00003 	mov	r0, r3
801672d4:	ebffe509 	bl	80160700 <__RME_A7A_Read_Acquire>
801672d8:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801672dc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801672e0:	e1a03823 	lsr	r3, r3, #16
801672e4:	e6ef3073 	uxtb	r3, r3
801672e8:	e3530002 	cmp	r3, #2
801672ec:	1a000001 	bne	801672f8 <_RME_Thd_Sched_Bind+0x10c>
801672f0:	e3e03008 	mvn	r3, #8
801672f4:	ea0001ae 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
801672f8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801672fc:	e1a03c23 	lsr	r3, r3, #24
80167300:	e3530003 	cmp	r3, #3
80167304:	0a000001 	beq	80167310 <_RME_Thd_Sched_Bind+0x124>
80167308:	e3e03001 	mvn	r3, #1
8016730c:	ea0001a8 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167310:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80167314:	e203207f 	and	r2, r3, #127	@ 0x7f
80167318:	e51b3008 	ldr	r3, [fp, #-8]
8016731c:	e5933014 	ldr	r3, [r3, #20]
80167320:	e1520003 	cmp	r2, r3
80167324:	3a000001 	bcc	80167330 <_RME_Thd_Sched_Bind+0x144>
80167328:	e3e03002 	mvn	r3, #2
8016732c:	ea0001a0 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167330:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80167334:	e203307f 	and	r3, r3, #127	@ 0x7f
80167338:	e1a02283 	lsl	r2, r3, #5
8016733c:	e51b3008 	ldr	r3, [fp, #-8]
80167340:	e593300c 	ldr	r3, [r3, #12]
80167344:	e0823003 	add	r3, r2, r3
80167348:	e50b3008 	str	r3, [fp, #-8]
8016734c:	e51b3008 	ldr	r3, [fp, #-8]
80167350:	e1a00003 	mov	r0, r3
80167354:	ebffe4e9 	bl	80160700 <__RME_A7A_Read_Acquire>
80167358:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016735c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167360:	e1a03823 	lsr	r3, r3, #16
80167364:	e6ef3073 	uxtb	r3, r3
80167368:	e3530002 	cmp	r3, #2
8016736c:	1a000001 	bne	80167378 <_RME_Thd_Sched_Bind+0x18c>
80167370:	e3e03008 	mvn	r3, #8
80167374:	ea00018e 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167378:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016737c:	e1a03c23 	lsr	r3, r3, #24
80167380:	e3530006 	cmp	r3, #6
80167384:	0a000001 	beq	80167390 <_RME_Thd_Sched_Bind+0x1a4>
80167388:	e3e03001 	mvn	r3, #1
8016738c:	ea000188 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
                   struct RME_Cap_Thd*,Thd_Op,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Thd_Sched,RME_CAP_TYPE_THD,
80167390:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80167394:	e2033080 	and	r3, r3, #128	@ 0x80
80167398:	e3530000 	cmp	r3, #0
8016739c:	1a00001d 	bne	80167418 <_RME_Thd_Sched_Bind+0x22c>
801673a0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801673a4:	e5932014 	ldr	r2, [r3, #20]
801673a8:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
801673ac:	e1520003 	cmp	r2, r3
801673b0:	8a000001 	bhi	801673bc <_RME_Thd_Sched_Bind+0x1d0>
801673b4:	e3e03002 	mvn	r3, #2
801673b8:	ea00017d 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
801673bc:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
801673c0:	e1a02283 	lsl	r2, r3, #5
801673c4:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801673c8:	e593300c 	ldr	r3, [r3, #12]
801673cc:	e0823003 	add	r3, r2, r3
801673d0:	e50b300c 	str	r3, [fp, #-12]
801673d4:	e51b300c 	ldr	r3, [fp, #-12]
801673d8:	e1a00003 	mov	r0, r3
801673dc:	ebffe4c7 	bl	80160700 <__RME_A7A_Read_Acquire>
801673e0:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801673e4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801673e8:	e1a03823 	lsr	r3, r3, #16
801673ec:	e6ef3073 	uxtb	r3, r3
801673f0:	e3530002 	cmp	r3, #2
801673f4:	1a000001 	bne	80167400 <_RME_Thd_Sched_Bind+0x214>
801673f8:	e3e03008 	mvn	r3, #8
801673fc:	ea00016c 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167400:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167404:	e1a03c23 	lsr	r3, r3, #24
80167408:	e3530006 	cmp	r3, #6
8016740c:	0a000041 	beq	80167518 <_RME_Thd_Sched_Bind+0x32c>
80167410:	e3e03001 	mvn	r3, #1
80167414:	ea000166 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167418:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
8016741c:	e1a02423 	lsr	r2, r3, #8
80167420:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167424:	e5933014 	ldr	r3, [r3, #20]
80167428:	e1520003 	cmp	r2, r3
8016742c:	3a000001 	bcc	80167438 <_RME_Thd_Sched_Bind+0x24c>
80167430:	e3e03002 	mvn	r3, #2
80167434:	ea00015e 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167438:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
8016743c:	e1a03423 	lsr	r3, r3, #8
80167440:	e1a02283 	lsl	r2, r3, #5
80167444:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167448:	e593300c 	ldr	r3, [r3, #12]
8016744c:	e0823003 	add	r3, r2, r3
80167450:	e50b300c 	str	r3, [fp, #-12]
80167454:	e51b300c 	ldr	r3, [fp, #-12]
80167458:	e1a00003 	mov	r0, r3
8016745c:	ebffe4a7 	bl	80160700 <__RME_A7A_Read_Acquire>
80167460:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80167464:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167468:	e1a03823 	lsr	r3, r3, #16
8016746c:	e6ef3073 	uxtb	r3, r3
80167470:	e3530002 	cmp	r3, #2
80167474:	1a000001 	bne	80167480 <_RME_Thd_Sched_Bind+0x294>
80167478:	e3e03008 	mvn	r3, #8
8016747c:	ea00014c 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167480:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167484:	e1a03c23 	lsr	r3, r3, #24
80167488:	e3530003 	cmp	r3, #3
8016748c:	0a000001 	beq	80167498 <_RME_Thd_Sched_Bind+0x2ac>
80167490:	e3e03001 	mvn	r3, #1
80167494:	ea000146 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167498:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
8016749c:	e203207f 	and	r2, r3, #127	@ 0x7f
801674a0:	e51b300c 	ldr	r3, [fp, #-12]
801674a4:	e5933014 	ldr	r3, [r3, #20]
801674a8:	e1520003 	cmp	r2, r3
801674ac:	3a000001 	bcc	801674b8 <_RME_Thd_Sched_Bind+0x2cc>
801674b0:	e3e03002 	mvn	r3, #2
801674b4:	ea00013e 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
801674b8:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
801674bc:	e203307f 	and	r3, r3, #127	@ 0x7f
801674c0:	e1a02283 	lsl	r2, r3, #5
801674c4:	e51b300c 	ldr	r3, [fp, #-12]
801674c8:	e593300c 	ldr	r3, [r3, #12]
801674cc:	e0823003 	add	r3, r2, r3
801674d0:	e50b300c 	str	r3, [fp, #-12]
801674d4:	e51b300c 	ldr	r3, [fp, #-12]
801674d8:	e1a00003 	mov	r0, r3
801674dc:	ebffe487 	bl	80160700 <__RME_A7A_Read_Acquire>
801674e0:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801674e4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801674e8:	e1a03823 	lsr	r3, r3, #16
801674ec:	e6ef3073 	uxtb	r3, r3
801674f0:	e3530002 	cmp	r3, #2
801674f4:	1a000001 	bne	80167500 <_RME_Thd_Sched_Bind+0x314>
801674f8:	e3e03008 	mvn	r3, #8
801674fc:	ea00012c 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167500:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167504:	e1a03c23 	lsr	r3, r3, #24
80167508:	e3530006 	cmp	r3, #6
8016750c:	0a000001 	beq	80167518 <_RME_Thd_Sched_Bind+0x32c>
80167510:	e3e03001 	mvn	r3, #1
80167514:	ea000126 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
                   struct RME_Cap_Thd*,Thd_Sched,Type_Stat);
    /* Check if the target cap is not frozen and allows such operations */
    RME_CAP_CHECK(Thd_Op,RME_THD_FLAG_SCHED_CHILD);
80167518:	e51b3008 	ldr	r3, [fp, #-8]
8016751c:	e5933008 	ldr	r3, [r3, #8]
80167520:	e2033002 	and	r3, r3, #2
80167524:	e3530000 	cmp	r3, #0
80167528:	1a000001 	bne	80167534 <_RME_Thd_Sched_Bind+0x348>
8016752c:	e3e03006 	mvn	r3, #6
80167530:	ea00011f 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
    RME_CAP_CHECK(Thd_Sched,RME_THD_FLAG_SCHED_PARENT);
80167534:	e51b300c 	ldr	r3, [fp, #-12]
80167538:	e5933008 	ldr	r3, [r3, #8]
8016753c:	e2033004 	and	r3, r3, #4
80167540:	e3530000 	cmp	r3, #0
80167544:	1a000001 	bne	80167550 <_RME_Thd_Sched_Bind+0x364>
80167548:	e3e03006 	mvn	r3, #6
8016754c:	ea000118 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
    
    /* Check if we need the signal endpoint for this operation */
    if(Cap_Sig!=RME_CID_NULL)
80167550:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80167554:	e3530902 	cmp	r3, #32768	@ 0x8000
80167558:	0a000068 	beq	80167700 <_RME_Thd_Sched_Bind+0x514>
    {
        RME_COV_MARKER();

        RME_CPT_GETCAP(Cpt,Cap_Sig,RME_CAP_TYPE_SIG,
8016755c:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80167560:	e2033080 	and	r3, r3, #128	@ 0x80
80167564:	e3530000 	cmp	r3, #0
80167568:	1a00001d 	bne	801675e4 <_RME_Thd_Sched_Bind+0x3f8>
8016756c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167570:	e5932014 	ldr	r2, [r3, #20]
80167574:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80167578:	e1520003 	cmp	r2, r3
8016757c:	8a000001 	bhi	80167588 <_RME_Thd_Sched_Bind+0x39c>
80167580:	e3e03002 	mvn	r3, #2
80167584:	ea00010a 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167588:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
8016758c:	e1a02283 	lsl	r2, r3, #5
80167590:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167594:	e593300c 	ldr	r3, [r3, #12]
80167598:	e0823003 	add	r3, r2, r3
8016759c:	e50b3010 	str	r3, [fp, #-16]
801675a0:	e51b3010 	ldr	r3, [fp, #-16]
801675a4:	e1a00003 	mov	r0, r3
801675a8:	ebffe454 	bl	80160700 <__RME_A7A_Read_Acquire>
801675ac:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801675b0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801675b4:	e1a03823 	lsr	r3, r3, #16
801675b8:	e6ef3073 	uxtb	r3, r3
801675bc:	e3530002 	cmp	r3, #2
801675c0:	1a000001 	bne	801675cc <_RME_Thd_Sched_Bind+0x3e0>
801675c4:	e3e03008 	mvn	r3, #8
801675c8:	ea0000f9 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
801675cc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801675d0:	e1a03c23 	lsr	r3, r3, #24
801675d4:	e3530008 	cmp	r3, #8
801675d8:	0a000041 	beq	801676e4 <_RME_Thd_Sched_Bind+0x4f8>
801675dc:	e3e03001 	mvn	r3, #1
801675e0:	ea0000f3 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
801675e4:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
801675e8:	e1a02423 	lsr	r2, r3, #8
801675ec:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801675f0:	e5933014 	ldr	r3, [r3, #20]
801675f4:	e1520003 	cmp	r2, r3
801675f8:	3a000001 	bcc	80167604 <_RME_Thd_Sched_Bind+0x418>
801675fc:	e3e03002 	mvn	r3, #2
80167600:	ea0000eb 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167604:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80167608:	e1a03423 	lsr	r3, r3, #8
8016760c:	e1a02283 	lsl	r2, r3, #5
80167610:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167614:	e593300c 	ldr	r3, [r3, #12]
80167618:	e0823003 	add	r3, r2, r3
8016761c:	e50b3010 	str	r3, [fp, #-16]
80167620:	e51b3010 	ldr	r3, [fp, #-16]
80167624:	e1a00003 	mov	r0, r3
80167628:	ebffe434 	bl	80160700 <__RME_A7A_Read_Acquire>
8016762c:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80167630:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167634:	e1a03823 	lsr	r3, r3, #16
80167638:	e6ef3073 	uxtb	r3, r3
8016763c:	e3530002 	cmp	r3, #2
80167640:	1a000001 	bne	8016764c <_RME_Thd_Sched_Bind+0x460>
80167644:	e3e03008 	mvn	r3, #8
80167648:	ea0000d9 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
8016764c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167650:	e1a03c23 	lsr	r3, r3, #24
80167654:	e3530003 	cmp	r3, #3
80167658:	0a000001 	beq	80167664 <_RME_Thd_Sched_Bind+0x478>
8016765c:	e3e03001 	mvn	r3, #1
80167660:	ea0000d3 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167664:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80167668:	e203207f 	and	r2, r3, #127	@ 0x7f
8016766c:	e51b3010 	ldr	r3, [fp, #-16]
80167670:	e5933014 	ldr	r3, [r3, #20]
80167674:	e1520003 	cmp	r2, r3
80167678:	3a000001 	bcc	80167684 <_RME_Thd_Sched_Bind+0x498>
8016767c:	e3e03002 	mvn	r3, #2
80167680:	ea0000cb 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
80167684:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80167688:	e203307f 	and	r3, r3, #127	@ 0x7f
8016768c:	e1a02283 	lsl	r2, r3, #5
80167690:	e51b3010 	ldr	r3, [fp, #-16]
80167694:	e593300c 	ldr	r3, [r3, #12]
80167698:	e0823003 	add	r3, r2, r3
8016769c:	e50b3010 	str	r3, [fp, #-16]
801676a0:	e51b3010 	ldr	r3, [fp, #-16]
801676a4:	e1a00003 	mov	r0, r3
801676a8:	ebffe414 	bl	80160700 <__RME_A7A_Read_Acquire>
801676ac:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801676b0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801676b4:	e1a03823 	lsr	r3, r3, #16
801676b8:	e6ef3073 	uxtb	r3, r3
801676bc:	e3530002 	cmp	r3, #2
801676c0:	1a000001 	bne	801676cc <_RME_Thd_Sched_Bind+0x4e0>
801676c4:	e3e03008 	mvn	r3, #8
801676c8:	ea0000b9 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
801676cc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801676d0:	e1a03c23 	lsr	r3, r3, #24
801676d4:	e3530008 	cmp	r3, #8
801676d8:	0a000001 	beq	801676e4 <_RME_Thd_Sched_Bind+0x4f8>
801676dc:	e3e03001 	mvn	r3, #1
801676e0:	ea0000b3 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
                       struct RME_Cap_Sig*,Sig_Op,Type_Stat);
        RME_CAP_CHECK(Sig_Op,RME_SIG_FLAG_SCHED);
801676e4:	e51b3010 	ldr	r3, [fp, #-16]
801676e8:	e5933008 	ldr	r3, [r3, #8]
801676ec:	e2033020 	and	r3, r3, #32
801676f0:	e3530000 	cmp	r3, #0
801676f4:	1a000003 	bne	80167708 <_RME_Thd_Sched_Bind+0x51c>
801676f8:	e3e03006 	mvn	r3, #6
801676fc:	ea0000ac 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
    }
    else
    {
        RME_COV_MARKER();

        Sig_Op=RME_NULL;
80167700:	e3a03000 	mov	r3, #0
80167704:	e50b3010 	str	r3, [fp, #-16]
    }

    /* Check if the target thread is already bound. If yes, we just quit */
    Thread=RME_CAP_GETOBJ(Thd_Op,struct RME_Thd_Struct*);
80167708:	e51b3008 	ldr	r3, [fp, #-8]
8016770c:	e593300c 	ldr	r3, [r3, #12]
80167710:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Local_Old=Thread->Sched.Local;
80167714:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167718:	e5933014 	ldr	r3, [r3, #20]
8016771c:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    if(Local_Old!=RME_THD_FREE)
80167720:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80167724:	e3730001 	cmn	r3, #1
80167728:	0a000001 	beq	80167734 <_RME_Thd_Sched_Bind+0x548>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
8016772c:	e3e030cb 	mvn	r3, #203	@ 0xcb
80167730:	ea00009f 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* See if the parent thread is on the same core with the current processor */
    Local_New=RME_CPU_LOCAL();
80167734:	e30d3004 	movw	r3, #53252	@ 0xd004
80167738:	e3483016 	movt	r3, #32790	@ 0x8016
8016773c:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
    Scheduler=RME_CAP_GETOBJ(Thd_Sched,struct RME_Thd_Struct*);
80167740:	e51b300c 	ldr	r3, [fp, #-12]
80167744:	e593300c 	ldr	r3, [r3, #12]
80167748:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    if(Scheduler->Sched.Local!=Local_New)
8016774c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80167750:	e5933014 	ldr	r3, [r3, #20]
80167754:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80167758:	e1520003 	cmp	r2, r3
8016775c:	0a000001 	beq	80167768 <_RME_Thd_Sched_Bind+0x57c>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
80167760:	e3e030cb 	mvn	r3, #203	@ 0xcb
80167764:	ea000092 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
        RME_COV_MARKER();
        /* No action required */
    }

    /* See if we are trying to bind to ourself - prohibited */
    if(Thread==Scheduler)
80167768:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016776c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80167770:	e1520003 	cmp	r2, r3
80167774:	1a000001 	bne	80167780 <_RME_Thd_Sched_Bind+0x594>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_NOTIF;
80167778:	e3e030ce 	mvn	r3, #206	@ 0xce
8016777c:	ea00008c 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* See if the priority relationship is correct */
    if(Scheduler->Sched.Prio_Max<Prio)
80167780:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80167784:	e5933024 	ldr	r3, [r3, #36]	@ 0x24
80167788:	e59b2008 	ldr	r2, [fp, #8]
8016778c:	e1520003 	cmp	r2, r3
80167790:	9a000001 	bls	8016779c <_RME_Thd_Sched_Bind+0x5b0>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_PRIO;
80167794:	e3e030cc 	mvn	r3, #204	@ 0xcc
80167798:	ea000085 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Check whether the coprocessor context attribute is compatible with this core */
    Hyp_Attr=Thread->Ctx.Hyp_Attr;
8016779c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801677a0:	e5933044 	ldr	r3, [r3, #68]	@ 0x44
801677a4:	e50b3028 	str	r3, [fp, #-40]	@ 0xffffffd8
        RME_COV_MARKER();

        return RME_ERR_CPT_FLAG;
    }
#else
    if(RME_THD_ATTR(Hyp_Attr)!=0U)
801677a8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801677ac:	e3c33102 	bic	r3, r3, #-2147483648	@ 0x80000000
801677b0:	e3530000 	cmp	r3, #0
801677b4:	0a000001 	beq	801677c0 <_RME_Thd_Sched_Bind+0x5d4>
    {
        RME_COV_MARKER();

        return RME_ERR_CPT_FLAG;
801677b8:	e3e03006 	mvn	r3, #6
801677bc:	ea00007c 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Check the hypervisor context buffer passed in to see whether it is good */
    if((Haddr!=RME_NULL)&&((Hyp_Attr&RME_THD_HYP_FLAG)!=0U))
801677c0:	e59b300c 	ldr	r3, [fp, #12]
801677c4:	e3530000 	cmp	r3, #0
801677c8:	0a000020 	beq	80167850 <_RME_Thd_Sched_Bind+0x664>
801677cc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801677d0:	e3530000 	cmp	r3, #0
801677d4:	aa00001d 	bge	80167850 <_RME_Thd_Sched_Bind+0x664>
    {
        RME_COV_MARKER();
        
        /* Register save area must be aligned to word boundary */
        if(RME_IS_ALIGNED(Haddr)!=0U)
801677d8:	e59b300c 	ldr	r3, [fp, #12]
801677dc:	e2033003 	and	r3, r3, #3
801677e0:	e3530000 	cmp	r3, #0
801677e4:	1a000001 	bne	801677f0 <_RME_Thd_Sched_Bind+0x604>
801677e8:	e3a03001 	mov	r3, #1
801677ec:	ea000000 	b	801677f4 <_RME_Thd_Sched_Bind+0x608>
801677f0:	e3a03000 	mov	r3, #0
801677f4:	e3530000 	cmp	r3, #0
801677f8:	0a000012 	beq	80167848 <_RME_Thd_Sched_Bind+0x65c>
        {
            RME_COV_MARKER();
            
            /* It needs to be safely accessible to the kernel as well */
#if(RME_HYP_VA_BASE!=0U)
            if(Haddr<RME_HYP_VA_BASE)
801677fc:	e59b300c 	ldr	r3, [fp, #12]
80167800:	e373021e 	cmn	r3, #-536870911	@ 0xe0000001
80167804:	8a000001 	bhi	80167810 <_RME_Thd_Sched_Bind+0x624>
            {
                RME_COV_MARKER();

                return RME_ERR_PTH_HADDR;
80167808:	e3e030ca 	mvn	r3, #202	@ 0xca
8016780c:	ea000068 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
            }
            else
            {
#endif
                End=Haddr+RME_REG_SIZE(RME_THD_ATTR(Thread->Ctx.Hyp_Attr));
80167810:	e59b300c 	ldr	r3, [fp, #12]
80167814:	e2833044 	add	r3, r3, #68	@ 0x44
80167818:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
                if((End<=Haddr)||(End>(RME_HYP_VA_BASE+RME_HYP_VA_SIZE)))
8016781c:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
80167820:	e59b300c 	ldr	r3, [fp, #12]
80167824:	e1520003 	cmp	r2, r3
80167828:	9a000004 	bls	80167840 <_RME_Thd_Sched_Bind+0x654>
8016782c:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
80167830:	e3a03000 	mov	r3, #0
80167834:	e3423002 	movt	r3, #8194	@ 0x2002
80167838:	e1520003 	cmp	r2, r3
8016783c:	9a000011 	bls	80167888 <_RME_Thd_Sched_Bind+0x69c>
                {
                    RME_COV_MARKER();

                    return RME_ERR_PTH_HADDR;
80167840:	e3e030ca 	mvn	r3, #202	@ 0xca
80167844:	ea00005a 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
        /* Not aligned, exiting */
        else
        {
            RME_COV_MARKER();

            return RME_ERR_PTH_HADDR;
80167848:	e3e030ca 	mvn	r3, #202	@ 0xca
8016784c:	ea000058 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
        }
    }
    /* We don't allow setting HYP addr for normal threads, nor do we allow
     * setting HYP addr to NULL for hypervisor-managed threads. */
    else if(((Haddr!=RME_NULL)&&((Hyp_Attr&RME_THD_HYP_FLAG)==0U))||
80167850:	e59b300c 	ldr	r3, [fp, #12]
80167854:	e3530000 	cmp	r3, #0
80167858:	0a000002 	beq	80167868 <_RME_Thd_Sched_Bind+0x67c>
8016785c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80167860:	e3530000 	cmp	r3, #0
80167864:	aa000005 	bge	80167880 <_RME_Thd_Sched_Bind+0x694>
80167868:	e59b300c 	ldr	r3, [fp, #12]
8016786c:	e3530000 	cmp	r3, #0
80167870:	1a000005 	bne	8016788c <_RME_Thd_Sched_Bind+0x6a0>
            ((Haddr==RME_NULL)&&((Hyp_Attr&RME_THD_HYP_FLAG)!=0U)))
80167874:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80167878:	e3530000 	cmp	r3, #0
8016787c:	aa000002 	bge	8016788c <_RME_Thd_Sched_Bind+0x6a0>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_HADDR;
80167880:	e3e030ca 	mvn	r3, #202	@ 0xca
80167884:	ea00004a 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
        if(RME_IS_ALIGNED(Haddr)!=0U)
80167888:	e320f000 	nop	{0}
        RME_COV_MARKER();
        /* No action required */
    }

    /* Try to bind the thread */
    if(RME_COMP_SWAP((rme_ptr_t*)&(Thread->Sched.Local),
8016788c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167890:	e2833014 	add	r3, r3, #20
80167894:	e51b101c 	ldr	r1, [fp, #-28]	@ 0xffffffe4
80167898:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
8016789c:	e1a00003 	mov	r0, r3
801678a0:	ebffe4d8 	bl	80160c08 <_RME_Comp_Swap_Single>
801678a4:	e1a03000 	mov	r3, r0
801678a8:	e3530000 	cmp	r3, #0
801678ac:	1a000001 	bne	801678b8 <_RME_Thd_Sched_Bind+0x6cc>
                     (rme_ptr_t)Local_Old,
                     (rme_ptr_t)Local_New)==RME_CASFAIL)
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_CONFLICT;
801678b0:	e3e030c9 	mvn	r3, #201	@ 0xc9
801678b4:	ea00003e 	b	801679b4 <_RME_Thd_Sched_Bind+0x7c8>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Increase the reference count of the scheduler thread struct - same core */
    Scheduler->Sched.Sched_Ref++;
801678b8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801678bc:	e5933030 	ldr	r3, [r3, #48]	@ 0x30
801678c0:	e2832001 	add	r2, r3, #1
801678c4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801678c8:	e5832030 	str	r2, [r3, #48]	@ 0x30
    
    /* Bind successful and finish the work off. No need to worry about other cores'
     * operations on this thread because this thread is already bound to this core.
     * TID is half-word parameter-wise, but is stored and returned as a full word. */
    Thread->Sched.Sched_Thd=Scheduler;
801678cc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801678d0:	e51b2024 	ldr	r2, [fp, #-36]	@ 0xffffffdc
801678d4:	e5832034 	str	r2, [r3, #52]	@ 0x34
    Thread->Sched.Prio=Prio;
801678d8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801678dc:	e59b2008 	ldr	r2, [fp, #8]
801678e0:	e5832020 	str	r2, [r3, #32]
    Thread->Sched.TID=(rme_ptr_t)TID;
801678e4:	e59b2004 	ldr	r2, [fp, #4]
801678e8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801678ec:	e5832010 	str	r2, [r3, #16]
    
    /* The state must be TIMEOUT or EXCPEND at this point */
    RME_ASSERT((Thread->Sched.State==RME_THD_TIMEOUT)||
801678f0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801678f4:	e593301c 	ldr	r3, [r3, #28]
801678f8:	e3530002 	cmp	r3, #2
801678fc:	0a00000c 	beq	80167934 <_RME_Thd_Sched_Bind+0x748>
80167900:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167904:	e593301c 	ldr	r3, [r3, #28]
80167908:	e3530003 	cmp	r3, #3
8016790c:	0a000008 	beq	80167934 <_RME_Thd_Sched_Bind+0x748>
80167910:	e30c3318 	movw	r3, #49944	@ 0xc318
80167914:	e3483016 	movt	r3, #32790	@ 0x8016
80167918:	e30c2324 	movw	r2, #49956	@ 0xc324
8016791c:	e3482016 	movt	r2, #32790	@ 0x8016
80167920:	e3011620 	movw	r1, #5664	@ 0x1620
80167924:	e30c0330 	movw	r0, #49968	@ 0xc330
80167928:	e3480016 	movt	r0, #32790	@ 0x8016
8016792c:	ebffe494 	bl	80160b84 <RME_Log>
80167930:	eafffffe 	b	80167930 <_RME_Thd_Sched_Bind+0x744>
               (Thread->Sched.State==RME_THD_EXCPEND));

    /* Tie the signal endpoint to it if not zero */
    if(Sig_Op==0U)
80167934:	e51b3010 	ldr	r3, [fp, #-16]
80167938:	e3530000 	cmp	r3, #0
8016793c:	1a000003 	bne	80167950 <_RME_Thd_Sched_Bind+0x764>
    {
        RME_COV_MARKER();

        Thread->Sched.Sched_Sig=0U;
80167940:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167944:	e3a02000 	mov	r2, #0
80167948:	e5832038 	str	r2, [r3, #56]	@ 0x38
8016794c:	ea000010 	b	80167994 <_RME_Thd_Sched_Bind+0x7a8>
    else
    {
        RME_COV_MARKER();

        /* Convert to root cap */
        Thread->Sched.Sched_Sig=RME_CAP_CONV_ROOT(Sig_Op,struct RME_Cap_Sig*);
80167950:	e51b3010 	ldr	r3, [fp, #-16]
80167954:	e5933000 	ldr	r3, [r3]
80167958:	e6ff3073 	uxth	r3, r3
8016795c:	e3530000 	cmp	r3, #0
80167960:	0a000002 	beq	80167970 <_RME_Thd_Sched_Bind+0x784>
80167964:	e51b3010 	ldr	r3, [fp, #-16]
80167968:	e5933004 	ldr	r3, [r3, #4]
8016796c:	ea000000 	b	80167974 <_RME_Thd_Sched_Bind+0x788>
80167970:	e51b3010 	ldr	r3, [fp, #-16]
80167974:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80167978:	e5823038 	str	r3, [r2, #56]	@ 0x38
        
        /* Increase refcnt */
        RME_FETCH_ADD(&(Thread->Sched.Sched_Sig->Head.Root_Ref),1U);
8016797c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167980:	e5933038 	ldr	r3, [r3, #56]	@ 0x38
80167984:	e2833004 	add	r3, r3, #4
80167988:	e3a01001 	mov	r1, #1
8016798c:	e1a00003 	mov	r0, r3
80167990:	ebffe4b1 	bl	80160c5c <_RME_Fetch_Add_Single>
    }
    
    /* Set hypervisor context address if we're hypervisor-managed */
    if((Thread->Ctx.Hyp_Attr&RME_THD_HYP_FLAG)!=0U)
80167994:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167998:	e5933044 	ldr	r3, [r3, #68]	@ 0x44
8016799c:	e3530000 	cmp	r3, #0
801679a0:	aa000002 	bge	801679b0 <_RME_Thd_Sched_Bind+0x7c4>
    {
        RME_COV_MARKER();
        Thread->Ctx.Reg=(struct RME_Thd_Reg*)Haddr;
801679a4:	e59b200c 	ldr	r2, [fp, #12]
801679a8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801679ac:	e5832048 	str	r2, [r3, #72]	@ 0x48
    {
        RME_COV_MARKER();
        /* No action required */
    }
    
    return 0;
801679b0:	e3a03000 	mov	r3, #0
}
801679b4:	e1a00003 	mov	r0, r3
801679b8:	e24bd004 	sub	sp, fp, #4
801679bc:	e8bd8800 	pop	{fp, pc}

801679c0 <_RME_Thd_Sched_Free>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Thd_Sched_Free(struct RME_Cap_Cpt* Cpt, 
                                     struct RME_Reg_Struct* Reg,
                                     rme_cid_t Cap_Thd)
{
801679c0:	e92d4800 	push	{fp, lr}
801679c4:	e28db004 	add	fp, sp, #4
801679c8:	e24dd020 	sub	sp, sp, #32
801679cc:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
801679d0:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
801679d4:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    /* These are used to free the thread */
    struct RME_CPU_Local* Local;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Thd,RME_CAP_TYPE_THD,
801679d8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801679dc:	e2033080 	and	r3, r3, #128	@ 0x80
801679e0:	e3530000 	cmp	r3, #0
801679e4:	1a00001d 	bne	80167a60 <_RME_Thd_Sched_Free+0xa0>
801679e8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801679ec:	e5932014 	ldr	r2, [r3, #20]
801679f0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801679f4:	e1520003 	cmp	r2, r3
801679f8:	8a000001 	bhi	80167a04 <_RME_Thd_Sched_Free+0x44>
801679fc:	e3e03002 	mvn	r3, #2
80167a00:	ea0000dc 	b	80167d78 <_RME_Thd_Sched_Free+0x3b8>
80167a04:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167a08:	e1a02283 	lsl	r2, r3, #5
80167a0c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167a10:	e593300c 	ldr	r3, [r3, #12]
80167a14:	e0823003 	add	r3, r2, r3
80167a18:	e50b3008 	str	r3, [fp, #-8]
80167a1c:	e51b3008 	ldr	r3, [fp, #-8]
80167a20:	e1a00003 	mov	r0, r3
80167a24:	ebffe335 	bl	80160700 <__RME_A7A_Read_Acquire>
80167a28:	e50b000c 	str	r0, [fp, #-12]
80167a2c:	e51b300c 	ldr	r3, [fp, #-12]
80167a30:	e1a03823 	lsr	r3, r3, #16
80167a34:	e6ef3073 	uxtb	r3, r3
80167a38:	e3530002 	cmp	r3, #2
80167a3c:	1a000001 	bne	80167a48 <_RME_Thd_Sched_Free+0x88>
80167a40:	e3e03008 	mvn	r3, #8
80167a44:	ea0000cb 	b	80167d78 <_RME_Thd_Sched_Free+0x3b8>
80167a48:	e51b300c 	ldr	r3, [fp, #-12]
80167a4c:	e1a03c23 	lsr	r3, r3, #24
80167a50:	e3530006 	cmp	r3, #6
80167a54:	0a000041 	beq	80167b60 <_RME_Thd_Sched_Free+0x1a0>
80167a58:	e3e03001 	mvn	r3, #1
80167a5c:	ea0000c5 	b	80167d78 <_RME_Thd_Sched_Free+0x3b8>
80167a60:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167a64:	e1a02423 	lsr	r2, r3, #8
80167a68:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167a6c:	e5933014 	ldr	r3, [r3, #20]
80167a70:	e1520003 	cmp	r2, r3
80167a74:	3a000001 	bcc	80167a80 <_RME_Thd_Sched_Free+0xc0>
80167a78:	e3e03002 	mvn	r3, #2
80167a7c:	ea0000bd 	b	80167d78 <_RME_Thd_Sched_Free+0x3b8>
80167a80:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167a84:	e1a03423 	lsr	r3, r3, #8
80167a88:	e1a02283 	lsl	r2, r3, #5
80167a8c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167a90:	e593300c 	ldr	r3, [r3, #12]
80167a94:	e0823003 	add	r3, r2, r3
80167a98:	e50b3008 	str	r3, [fp, #-8]
80167a9c:	e51b3008 	ldr	r3, [fp, #-8]
80167aa0:	e1a00003 	mov	r0, r3
80167aa4:	ebffe315 	bl	80160700 <__RME_A7A_Read_Acquire>
80167aa8:	e50b000c 	str	r0, [fp, #-12]
80167aac:	e51b300c 	ldr	r3, [fp, #-12]
80167ab0:	e1a03823 	lsr	r3, r3, #16
80167ab4:	e6ef3073 	uxtb	r3, r3
80167ab8:	e3530002 	cmp	r3, #2
80167abc:	1a000001 	bne	80167ac8 <_RME_Thd_Sched_Free+0x108>
80167ac0:	e3e03008 	mvn	r3, #8
80167ac4:	ea0000ab 	b	80167d78 <_RME_Thd_Sched_Free+0x3b8>
80167ac8:	e51b300c 	ldr	r3, [fp, #-12]
80167acc:	e1a03c23 	lsr	r3, r3, #24
80167ad0:	e3530003 	cmp	r3, #3
80167ad4:	0a000001 	beq	80167ae0 <_RME_Thd_Sched_Free+0x120>
80167ad8:	e3e03001 	mvn	r3, #1
80167adc:	ea0000a5 	b	80167d78 <_RME_Thd_Sched_Free+0x3b8>
80167ae0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167ae4:	e203207f 	and	r2, r3, #127	@ 0x7f
80167ae8:	e51b3008 	ldr	r3, [fp, #-8]
80167aec:	e5933014 	ldr	r3, [r3, #20]
80167af0:	e1520003 	cmp	r2, r3
80167af4:	3a000001 	bcc	80167b00 <_RME_Thd_Sched_Free+0x140>
80167af8:	e3e03002 	mvn	r3, #2
80167afc:	ea00009d 	b	80167d78 <_RME_Thd_Sched_Free+0x3b8>
80167b00:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167b04:	e203307f 	and	r3, r3, #127	@ 0x7f
80167b08:	e1a02283 	lsl	r2, r3, #5
80167b0c:	e51b3008 	ldr	r3, [fp, #-8]
80167b10:	e593300c 	ldr	r3, [r3, #12]
80167b14:	e0823003 	add	r3, r2, r3
80167b18:	e50b3008 	str	r3, [fp, #-8]
80167b1c:	e51b3008 	ldr	r3, [fp, #-8]
80167b20:	e1a00003 	mov	r0, r3
80167b24:	ebffe2f5 	bl	80160700 <__RME_A7A_Read_Acquire>
80167b28:	e50b000c 	str	r0, [fp, #-12]
80167b2c:	e51b300c 	ldr	r3, [fp, #-12]
80167b30:	e1a03823 	lsr	r3, r3, #16
80167b34:	e6ef3073 	uxtb	r3, r3
80167b38:	e3530002 	cmp	r3, #2
80167b3c:	1a000001 	bne	80167b48 <_RME_Thd_Sched_Free+0x188>
80167b40:	e3e03008 	mvn	r3, #8
80167b44:	ea00008b 	b	80167d78 <_RME_Thd_Sched_Free+0x3b8>
80167b48:	e51b300c 	ldr	r3, [fp, #-12]
80167b4c:	e1a03c23 	lsr	r3, r3, #24
80167b50:	e3530006 	cmp	r3, #6
80167b54:	0a000001 	beq	80167b60 <_RME_Thd_Sched_Free+0x1a0>
80167b58:	e3e03001 	mvn	r3, #1
80167b5c:	ea000085 	b	80167d78 <_RME_Thd_Sched_Free+0x3b8>
                   struct RME_Cap_Thd*,Thd_Op,Type_Stat);
    /* Check if the target cap is not frozen and allows such operations */
    RME_CAP_CHECK(Thd_Op,RME_THD_FLAG_SCHED_FREE);
80167b60:	e51b3008 	ldr	r3, [fp, #-8]
80167b64:	e5933008 	ldr	r3, [r3, #8]
80167b68:	e2033010 	and	r3, r3, #16
80167b6c:	e3530000 	cmp	r3, #0
80167b70:	1a000001 	bne	80167b7c <_RME_Thd_Sched_Free+0x1bc>
80167b74:	e3e03006 	mvn	r3, #6
80167b78:	ea00007e 	b	80167d78 <_RME_Thd_Sched_Free+0x3b8>
    
    /* Check if the target thread is already bound to this core */
    Local=RME_CPU_LOCAL();
80167b7c:	e30d3004 	movw	r3, #53252	@ 0xd004
80167b80:	e3483016 	movt	r3, #32790	@ 0x8016
80167b84:	e50b3010 	str	r3, [fp, #-16]
    Thread=(struct RME_Thd_Struct*)Thd_Op->Head.Object;
80167b88:	e51b3008 	ldr	r3, [fp, #-8]
80167b8c:	e593300c 	ldr	r3, [r3, #12]
80167b90:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    if(Thread->Sched.Local!=Local)
80167b94:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167b98:	e5933014 	ldr	r3, [r3, #20]
80167b9c:	e51b2010 	ldr	r2, [fp, #-16]
80167ba0:	e1520003 	cmp	r2, r3
80167ba4:	0a000001 	beq	80167bb0 <_RME_Thd_Sched_Free+0x1f0>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
80167ba8:	e3e030cb 	mvn	r3, #203	@ 0xcb
80167bac:	ea000071 	b	80167d78 <_RME_Thd_Sched_Free+0x3b8>
        /* No action required */
    }
    
    /* Am I referenced by someone as a scheduler? If yes, we cannot unbind. Because
     * boot-time thread's refcnt will never be 0, thus they will never pass this checking */
    if(Thread->Sched.Sched_Ref!=0U)
80167bb0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167bb4:	e5933030 	ldr	r3, [r3, #48]	@ 0x30
80167bb8:	e3530000 	cmp	r3, #0
80167bbc:	0a000001 	beq	80167bc8 <_RME_Thd_Sched_Free+0x208>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_REFCNT;
80167bc0:	e3e030cd 	mvn	r3, #205	@ 0xcd
80167bc4:	ea00006b 	b	80167d78 <_RME_Thd_Sched_Free+0x3b8>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Decrease the parent's reference count - on the same core */
    Thread->Sched.Sched_Thd->Sched.Sched_Ref--;
80167bc8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167bcc:	e5933034 	ldr	r3, [r3, #52]	@ 0x34
80167bd0:	e5932030 	ldr	r2, [r3, #48]	@ 0x30
80167bd4:	e2422001 	sub	r2, r2, #1
80167bd8:	e5832030 	str	r2, [r3, #48]	@ 0x30

    /* See if we have any events sent to the parent. If yes, remove that event */
    if(Thread->Sched.Notif.Next!=&(Thread->Sched.Notif))
80167bdc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167be0:	e5932008 	ldr	r2, [r3, #8]
80167be4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167be8:	e2833008 	add	r3, r3, #8
80167bec:	e1520003 	cmp	r2, r3
80167bf0:	0a00000a 	beq	80167c20 <_RME_Thd_Sched_Free+0x260>
    {
        RME_COV_MARKER();

        _RME_List_Del(Thread->Sched.Notif.Prev,Thread->Sched.Notif.Next);
80167bf4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167bf8:	e593200c 	ldr	r2, [r3, #12]
80167bfc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167c00:	e5933008 	ldr	r3, [r3, #8]
80167c04:	e1a01003 	mov	r1, r3
80167c08:	e1a00002 	mov	r0, r2
80167c0c:	ebffe445 	bl	80160d28 <_RME_List_Del>
        _RME_List_Crt(&(Thread->Sched.Notif));
80167c10:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167c14:	e2833008 	add	r3, r3, #8
80167c18:	e1a00003 	mov	r0, r3
80167c1c:	ebffe433 	bl	80160cf0 <_RME_List_Crt>
        RME_COV_MARKER();
        /* No action required */
    }

    /* If we have an scheduler event endpoint, release it */
    if(Thread->Sched.Sched_Sig!=RME_NULL)
80167c20:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167c24:	e5933038 	ldr	r3, [r3, #56]	@ 0x38
80167c28:	e3530000 	cmp	r3, #0
80167c2c:	0a000005 	beq	80167c48 <_RME_Thd_Sched_Free+0x288>
    {
        RME_COV_MARKER();

        RME_FETCH_ADD(&(Thread->Sched.Sched_Sig->Head.Root_Ref),-1);
80167c30:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167c34:	e5933038 	ldr	r3, [r3, #56]	@ 0x38
80167c38:	e2833004 	add	r3, r3, #4
80167c3c:	e3e01000 	mvn	r1, #0
80167c40:	e1a00003 	mov	r0, r3
80167c44:	ebffe404 	bl	80160c5c <_RME_Fetch_Add_Single>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Now save the system call return value to the caller stack */
    __RME_Svc_Retval_Set(Reg,0);  
80167c48:	e3a01000 	mov	r1, #0
80167c4c:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80167c50:	eb000f4f 	bl	8016b994 <__RME_Svc_Retval_Set>
    /* If the thread is ready, kick it out of the run queue. If it is blocked on
     * some endpoint, end the blocking and set the return value to RME_ERR_SIV_FREE.
     * If the thread is killed due to a fault, we will not clear the fault here, and
     * we will wait for the Exec_Set to clear it. No scheduler notifications are sent
     * because the thread is being freed and notifications at this point are useless. */
    if(Thread->Sched.State==RME_THD_READY)
80167c54:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167c58:	e593301c 	ldr	r3, [r3, #28]
80167c5c:	e3530000 	cmp	r3, #0
80167c60:	1a000005 	bne	80167c7c <_RME_Thd_Sched_Free+0x2bc>
    {
        RME_COV_MARKER();

        /* Remove from runqueue and timeout but don't notify parent */
        _RME_Run_Del(Thread);
80167c64:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80167c68:	ebfff502 	bl	80165078 <_RME_Run_Del>
        Thread->Sched.State=RME_THD_TIMEOUT;
80167c6c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167c70:	e3a02002 	mov	r2, #2
80167c74:	e583201c 	str	r2, [r3, #28]
80167c78:	ea000013 	b	80167ccc <_RME_Thd_Sched_Free+0x30c>
    }
    /* BLOCKED */
    else if(Thread->Sched.State==RME_THD_BLOCKED)
80167c7c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167c80:	e593301c 	ldr	r3, [r3, #28]
80167c84:	e3530001 	cmp	r3, #1
80167c88:	1a00000f 	bne	80167ccc <_RME_Thd_Sched_Free+0x30c>
    {
        RME_COV_MARKER();
        
        /* If it got here, the thread that is operated on cannot be the current 
         * thread, so we are not overwriting the return value of the caller. */
        __RME_Svc_Retval_Set(&(Thread->Ctx.Reg->Reg),RME_ERR_SIV_FREE);
80167c8c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167c90:	e5933048 	ldr	r3, [r3, #72]	@ 0x48
80167c94:	e30f1ece 	movw	r1, #65230	@ 0xfece
80167c98:	e34f1fff 	movt	r1, #65535	@ 0xffff
80167c9c:	e1a00003 	mov	r0, r3
80167ca0:	eb000f3b 	bl	8016b994 <__RME_Svc_Retval_Set>
        /* Release signal and thread from each other */
        Thread->Sched.Signal->Thd=RME_NULL;
80167ca4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167ca8:	e5933028 	ldr	r3, [r3, #40]	@ 0x28
80167cac:	e3a02000 	mov	r2, #0
80167cb0:	e5832018 	str	r2, [r3, #24]
        Thread->Sched.Signal=RME_NULL;
80167cb4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167cb8:	e3a02000 	mov	r2, #0
80167cbc:	e5832028 	str	r2, [r3, #40]	@ 0x28
        /* Timeout but don't notify parent */
        Thread->Sched.State=RME_THD_TIMEOUT;
80167cc0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167cc4:	e3a02002 	mov	r2, #2
80167cc8:	e583201c 	str	r2, [r3, #28]
        RME_COV_MARKER();
        /* No action required */
    }

    /* Cleanup all remaining timeslices on it */
    Thread->Sched.Slice=0U;
80167ccc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167cd0:	e3a02000 	mov	r2, #0
80167cd4:	e5832018 	str	r2, [r3, #24]
    
    /* Check if this thread is the current one and we may need to switch away */
    if(Local->Thd_Cur==Thread)
80167cd8:	e51b3010 	ldr	r3, [fp, #-16]
80167cdc:	e5933004 	ldr	r3, [r3, #4]
80167ce0:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80167ce4:	e1520003 	cmp	r2, r3
80167ce8:	1a00001c 	bne	80167d60 <_RME_Thd_Sched_Free+0x3a0>
    {
        RME_COV_MARKER();

        Local->Thd_Cur=_RME_Run_High(Local);
80167cec:	e51b0010 	ldr	r0, [fp, #-16]
80167cf0:	ebfff51e 	bl	80165170 <_RME_Run_High>
80167cf4:	e1a02000 	mov	r2, r0
80167cf8:	e51b3010 	ldr	r3, [fp, #-16]
80167cfc:	e5832004 	str	r2, [r3, #4]
        _RME_Run_Ins(Local->Thd_Cur);
80167d00:	e51b3010 	ldr	r3, [fp, #-16]
80167d04:	e5933004 	ldr	r3, [r3, #4]
80167d08:	e1a00003 	mov	r0, r3
80167d0c:	ebfff4a2 	bl	80164f9c <_RME_Run_Ins>
        RME_ASSERT(Local->Thd_Cur->Sched.State==RME_THD_READY);
80167d10:	e51b3010 	ldr	r3, [fp, #-16]
80167d14:	e5933004 	ldr	r3, [r3, #4]
80167d18:	e593301c 	ldr	r3, [r3, #28]
80167d1c:	e3530000 	cmp	r3, #0
80167d20:	0a000008 	beq	80167d48 <_RME_Thd_Sched_Free+0x388>
80167d24:	e30c3318 	movw	r3, #49944	@ 0xc318
80167d28:	e3483016 	movt	r3, #32790	@ 0x8016
80167d2c:	e30c2324 	movw	r2, #49956	@ 0xc324
80167d30:	e3482016 	movt	r2, #32790	@ 0x8016
80167d34:	e30116cd 	movw	r1, #5837	@ 0x16cd
80167d38:	e30c0330 	movw	r0, #49968	@ 0xc330
80167d3c:	e3480016 	movt	r0, #32790	@ 0x8016
80167d40:	ebffe38f 	bl	80160b84 <RME_Log>
80167d44:	eafffffe 	b	80167d44 <_RME_Thd_Sched_Free+0x384>
        _RME_Run_Swt(Reg,Thread,Local->Thd_Cur);
80167d48:	e51b3010 	ldr	r3, [fp, #-16]
80167d4c:	e5933004 	ldr	r3, [r3, #4]
80167d50:	e1a02003 	mov	r2, r3
80167d54:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
80167d58:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80167d5c:	ebfff576 	bl	8016533c <_RME_Run_Swt>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Set the state to free so other cores can bind */
    RME_WRITE_RELEASE((rme_ptr_t*)&(Thread->Sched.Local),
80167d60:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167d64:	e2833014 	add	r3, r3, #20
80167d68:	e3e01000 	mvn	r1, #0
80167d6c:	e1a00003 	mov	r0, r3
80167d70:	ebffe265 	bl	8016070c <__RME_A7A_Write_Release>
                      (rme_ptr_t)RME_THD_FREE);

    return 0;
80167d74:	e3a03000 	mov	r3, #0
}
80167d78:	e1a00003 	mov	r0, r3
80167d7c:	e24bd004 	sub	sp, fp, #4
80167d80:	e8bd8800 	pop	{fp, pc}

80167d84 <_RME_Thd_Exec_Set>:
                                   struct RME_Reg_Struct* Reg,
                                   rme_cid_t Cap_Thd,
                                   rme_ptr_t Entry,
                                   rme_ptr_t Stack,
                                   rme_ptr_t Param)
{
80167d84:	e92d4800 	push	{fp, lr}
80167d88:	e28db004 	add	fp, sp, #4
80167d8c:	e24dd028 	sub	sp, sp, #40	@ 0x28
80167d90:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80167d94:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
80167d98:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
80167d9c:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    struct RME_Thd_Struct* Thread;
    struct RME_CPU_Local* Local;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Thd,RME_CAP_TYPE_THD,
80167da0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167da4:	e2033080 	and	r3, r3, #128	@ 0x80
80167da8:	e3530000 	cmp	r3, #0
80167dac:	1a00001d 	bne	80167e28 <_RME_Thd_Exec_Set+0xa4>
80167db0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167db4:	e5932014 	ldr	r2, [r3, #20]
80167db8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167dbc:	e1520003 	cmp	r2, r3
80167dc0:	8a000001 	bhi	80167dcc <_RME_Thd_Exec_Set+0x48>
80167dc4:	e3e03002 	mvn	r3, #2
80167dc8:	ea000094 	b	80168020 <_RME_Thd_Exec_Set+0x29c>
80167dcc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167dd0:	e1a02283 	lsl	r2, r3, #5
80167dd4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167dd8:	e593300c 	ldr	r3, [r3, #12]
80167ddc:	e0823003 	add	r3, r2, r3
80167de0:	e50b3008 	str	r3, [fp, #-8]
80167de4:	e51b3008 	ldr	r3, [fp, #-8]
80167de8:	e1a00003 	mov	r0, r3
80167dec:	ebffe243 	bl	80160700 <__RME_A7A_Read_Acquire>
80167df0:	e50b000c 	str	r0, [fp, #-12]
80167df4:	e51b300c 	ldr	r3, [fp, #-12]
80167df8:	e1a03823 	lsr	r3, r3, #16
80167dfc:	e6ef3073 	uxtb	r3, r3
80167e00:	e3530002 	cmp	r3, #2
80167e04:	1a000001 	bne	80167e10 <_RME_Thd_Exec_Set+0x8c>
80167e08:	e3e03008 	mvn	r3, #8
80167e0c:	ea000083 	b	80168020 <_RME_Thd_Exec_Set+0x29c>
80167e10:	e51b300c 	ldr	r3, [fp, #-12]
80167e14:	e1a03c23 	lsr	r3, r3, #24
80167e18:	e3530006 	cmp	r3, #6
80167e1c:	0a000041 	beq	80167f28 <_RME_Thd_Exec_Set+0x1a4>
80167e20:	e3e03001 	mvn	r3, #1
80167e24:	ea00007d 	b	80168020 <_RME_Thd_Exec_Set+0x29c>
80167e28:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167e2c:	e1a02423 	lsr	r2, r3, #8
80167e30:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167e34:	e5933014 	ldr	r3, [r3, #20]
80167e38:	e1520003 	cmp	r2, r3
80167e3c:	3a000001 	bcc	80167e48 <_RME_Thd_Exec_Set+0xc4>
80167e40:	e3e03002 	mvn	r3, #2
80167e44:	ea000075 	b	80168020 <_RME_Thd_Exec_Set+0x29c>
80167e48:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167e4c:	e1a03423 	lsr	r3, r3, #8
80167e50:	e1a02283 	lsl	r2, r3, #5
80167e54:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167e58:	e593300c 	ldr	r3, [r3, #12]
80167e5c:	e0823003 	add	r3, r2, r3
80167e60:	e50b3008 	str	r3, [fp, #-8]
80167e64:	e51b3008 	ldr	r3, [fp, #-8]
80167e68:	e1a00003 	mov	r0, r3
80167e6c:	ebffe223 	bl	80160700 <__RME_A7A_Read_Acquire>
80167e70:	e50b000c 	str	r0, [fp, #-12]
80167e74:	e51b300c 	ldr	r3, [fp, #-12]
80167e78:	e1a03823 	lsr	r3, r3, #16
80167e7c:	e6ef3073 	uxtb	r3, r3
80167e80:	e3530002 	cmp	r3, #2
80167e84:	1a000001 	bne	80167e90 <_RME_Thd_Exec_Set+0x10c>
80167e88:	e3e03008 	mvn	r3, #8
80167e8c:	ea000063 	b	80168020 <_RME_Thd_Exec_Set+0x29c>
80167e90:	e51b300c 	ldr	r3, [fp, #-12]
80167e94:	e1a03c23 	lsr	r3, r3, #24
80167e98:	e3530003 	cmp	r3, #3
80167e9c:	0a000001 	beq	80167ea8 <_RME_Thd_Exec_Set+0x124>
80167ea0:	e3e03001 	mvn	r3, #1
80167ea4:	ea00005d 	b	80168020 <_RME_Thd_Exec_Set+0x29c>
80167ea8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167eac:	e203207f 	and	r2, r3, #127	@ 0x7f
80167eb0:	e51b3008 	ldr	r3, [fp, #-8]
80167eb4:	e5933014 	ldr	r3, [r3, #20]
80167eb8:	e1520003 	cmp	r2, r3
80167ebc:	3a000001 	bcc	80167ec8 <_RME_Thd_Exec_Set+0x144>
80167ec0:	e3e03002 	mvn	r3, #2
80167ec4:	ea000055 	b	80168020 <_RME_Thd_Exec_Set+0x29c>
80167ec8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167ecc:	e203307f 	and	r3, r3, #127	@ 0x7f
80167ed0:	e1a02283 	lsl	r2, r3, #5
80167ed4:	e51b3008 	ldr	r3, [fp, #-8]
80167ed8:	e593300c 	ldr	r3, [r3, #12]
80167edc:	e0823003 	add	r3, r2, r3
80167ee0:	e50b3008 	str	r3, [fp, #-8]
80167ee4:	e51b3008 	ldr	r3, [fp, #-8]
80167ee8:	e1a00003 	mov	r0, r3
80167eec:	ebffe203 	bl	80160700 <__RME_A7A_Read_Acquire>
80167ef0:	e50b000c 	str	r0, [fp, #-12]
80167ef4:	e51b300c 	ldr	r3, [fp, #-12]
80167ef8:	e1a03823 	lsr	r3, r3, #16
80167efc:	e6ef3073 	uxtb	r3, r3
80167f00:	e3530002 	cmp	r3, #2
80167f04:	1a000001 	bne	80167f10 <_RME_Thd_Exec_Set+0x18c>
80167f08:	e3e03008 	mvn	r3, #8
80167f0c:	ea000043 	b	80168020 <_RME_Thd_Exec_Set+0x29c>
80167f10:	e51b300c 	ldr	r3, [fp, #-12]
80167f14:	e1a03c23 	lsr	r3, r3, #24
80167f18:	e3530006 	cmp	r3, #6
80167f1c:	0a000001 	beq	80167f28 <_RME_Thd_Exec_Set+0x1a4>
80167f20:	e3e03001 	mvn	r3, #1
80167f24:	ea00003d 	b	80168020 <_RME_Thd_Exec_Set+0x29c>
                   struct RME_Cap_Thd*,Thd_Op,Type_Stat);
    /* Check if the target cap is not frozen and allows such operations */
    RME_CAP_CHECK(Thd_Op,RME_THD_FLAG_EXEC_SET);
80167f28:	e51b3008 	ldr	r3, [fp, #-8]
80167f2c:	e5933008 	ldr	r3, [r3, #8]
80167f30:	e2033001 	and	r3, r3, #1
80167f34:	e3530000 	cmp	r3, #0
80167f38:	1a000001 	bne	80167f44 <_RME_Thd_Exec_Set+0x1c0>
80167f3c:	e3e03006 	mvn	r3, #6
80167f40:	ea000036 	b	80168020 <_RME_Thd_Exec_Set+0x29c>
    
    /* Check if the target thread is already bound, and quit if it is not on our core */
    Thread=RME_CAP_GETOBJ(Thd_Op,struct RME_Thd_Struct*);
80167f44:	e51b3008 	ldr	r3, [fp, #-8]
80167f48:	e593300c 	ldr	r3, [r3, #12]
80167f4c:	e50b3010 	str	r3, [fp, #-16]
    Local=RME_CPU_LOCAL();
80167f50:	e30d3004 	movw	r3, #53252	@ 0xd004
80167f54:	e3483016 	movt	r3, #32790	@ 0x8016
80167f58:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    if(Thread->Sched.Local!=Local)
80167f5c:	e51b3010 	ldr	r3, [fp, #-16]
80167f60:	e5933014 	ldr	r3, [r3, #20]
80167f64:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80167f68:	e1520003 	cmp	r2, r3
80167f6c:	0a000001 	beq	80167f78 <_RME_Thd_Exec_Set+0x1f4>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
80167f70:	e3e030cb 	mvn	r3, #203	@ 0xcb
80167f74:	ea000029 	b	80168020 <_RME_Thd_Exec_Set+0x29c>
        /* No action required */
    }
    
    /* Commit the change if both values are non-zero. If both are zero we are just
     * clearing the error flag and continue from where the exception happened. */
    if((Entry!=RME_NULL)&&(Stack!=RME_NULL))
80167f78:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80167f7c:	e3530000 	cmp	r3, #0
80167f80:	0a00000c 	beq	80167fb8 <_RME_Thd_Exec_Set+0x234>
80167f84:	e59b3004 	ldr	r3, [fp, #4]
80167f88:	e3530000 	cmp	r3, #0
80167f8c:	0a000009 	beq	80167fb8 <_RME_Thd_Exec_Set+0x234>
    {
        RME_COV_MARKER();

        __RME_Thd_Reg_Init(RME_THD_ATTR(Thread->Ctx.Hyp_Attr),
80167f90:	e51b3010 	ldr	r3, [fp, #-16]
80167f94:	e5933044 	ldr	r3, [r3, #68]	@ 0x44
80167f98:	e3c30102 	bic	r0, r3, #-2147483648	@ 0x80000000
                           Entry,Stack,Param,&(Thread->Ctx.Reg->Reg));
80167f9c:	e51b3010 	ldr	r3, [fp, #-16]
80167fa0:	e5933048 	ldr	r3, [r3, #72]	@ 0x48
        __RME_Thd_Reg_Init(RME_THD_ATTR(Thread->Ctx.Hyp_Attr),
80167fa4:	e58d3000 	str	r3, [sp]
80167fa8:	e59b3008 	ldr	r3, [fp, #8]
80167fac:	e59b2004 	ldr	r2, [fp, #4]
80167fb0:	e51b1024 	ldr	r1, [fp, #-36]	@ 0xffffffdc
80167fb4:	eb000e82 	bl	8016b9c4 <__RME_Thd_Reg_Init>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Now save the system call return value to the caller stack */
    __RME_Svc_Retval_Set(Reg,0);  
80167fb8:	e3a01000 	mov	r1, #0
80167fbc:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80167fc0:	eb000e73 	bl	8016b994 <__RME_Svc_Retval_Set>
    
    /* Check if there is a exception pending and clear it if there is */
    if(Thread->Sched.State==RME_THD_EXCPEND)
80167fc4:	e51b3010 	ldr	r3, [fp, #-16]
80167fc8:	e593301c 	ldr	r3, [r3, #28]
80167fcc:	e3530003 	cmp	r3, #3
80167fd0:	1a000011 	bne	8016801c <_RME_Thd_Exec_Set+0x298>
    {
        RME_COV_MARKER();
        
        /* Check if the thread still have timeslices. If yes, put it into the runqueue;
         * if no, mark it as TIMEOUT and send scheduler notification to its parent. */
        if(Thread->Sched.Slice!=0U)
80167fd4:	e51b3010 	ldr	r3, [fp, #-16]
80167fd8:	e5933018 	ldr	r3, [r3, #24]
80167fdc:	e3530000 	cmp	r3, #0
80167fe0:	0a000005 	beq	80167ffc <_RME_Thd_Exec_Set+0x278>
        {
            RME_COV_MARKER();
            
            /* Ready and add to runqueue */
            Thread->Sched.State=RME_THD_READY;
80167fe4:	e51b3010 	ldr	r3, [fp, #-16]
80167fe8:	e3a02000 	mov	r2, #0
80167fec:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Ins(Thread);
80167ff0:	e51b0010 	ldr	r0, [fp, #-16]
80167ff4:	ebfff3e8 	bl	80164f9c <_RME_Run_Ins>
80167ff8:	ea000004 	b	80168010 <_RME_Thd_Exec_Set+0x28c>
        else
        {
            RME_COV_MARKER();
            
            /* Timeout and notify parent */
            Thread->Sched.State=RME_THD_TIMEOUT;
80167ffc:	e51b3010 	ldr	r3, [fp, #-16]
80168000:	e3a02002 	mov	r2, #2
80168004:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Notif(Thread);
80168008:	e51b0010 	ldr	r0, [fp, #-16]
8016800c:	ebfff48d 	bl	80165248 <_RME_Run_Notif>
        }
        
        /* Pick the highest priority thread because something unblocked */
        _RME_Kern_High(Reg,Local);
80168010:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
80168014:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80168018:	eb0005e1 	bl	801697a4 <_RME_Kern_High>
    {
        RME_COV_MARKER();
        /* No action required */
    }
    
    return 0;
8016801c:	e3a03000 	mov	r3, #0
}
80168020:	e1a00003 	mov	r0, r3
80168024:	e24bd004 	sub	sp, fp, #4
80168028:	e8bd8800 	pop	{fp, pc}

8016802c <_RME_Thd_Sched_Prio>:
                                     rme_ptr_t Prio0,
                                     rme_cid_t Cap_Thd1,
                                     rme_ptr_t Prio1,
                                     rme_cid_t Cap_Thd2,
                                     rme_ptr_t Prio2)
{
8016802c:	e92d4800 	push	{fp, lr}
80168030:	e28db004 	add	fp, sp, #4
80168034:	e24dd050 	sub	sp, sp, #80	@ 0x50
80168038:	e50b0048 	str	r0, [fp, #-72]	@ 0xffffffb8
8016803c:	e50b104c 	str	r1, [fp, #-76]	@ 0xffffffb4
80168040:	e50b2050 	str	r2, [fp, #-80]	@ 0xffffffb0
80168044:	e50b3054 	str	r3, [fp, #-84]	@ 0xffffffac
    struct RME_Thd_Struct* Thread[3];
    struct RME_CPU_Local* Local;
    rme_ptr_t Type_Stat;
    
    /* Check parameter validity */
    if((Number==0U)||(Number>3U))
80168048:	e51b3050 	ldr	r3, [fp, #-80]	@ 0xffffffb0
8016804c:	e3530000 	cmp	r3, #0
80168050:	0a000002 	beq	80168060 <_RME_Thd_Sched_Prio+0x34>
80168054:	e51b3050 	ldr	r3, [fp, #-80]	@ 0xffffffb0
80168058:	e3530003 	cmp	r3, #3
8016805c:	9a000001 	bls	80168068 <_RME_Thd_Sched_Prio+0x3c>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
80168060:	e3e030cb 	mvn	r3, #203	@ 0xcb
80168064:	ea000129 	b	80168510 <_RME_Thd_Sched_Prio+0x4e4>
    }
    
    /* We'll use arrays in the next */
    Cap_Thd[0]=Cap_Thd0;
80168068:	e51b3054 	ldr	r3, [fp, #-84]	@ 0xffffffac
8016806c:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    Cap_Thd[1]=Cap_Thd1;
80168070:	e59b3008 	ldr	r3, [fp, #8]
80168074:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Cap_Thd[2]=Cap_Thd2;
80168078:	e59b3010 	ldr	r3, [fp, #16]
8016807c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Prio[0]=Prio0;
80168080:	e59b3004 	ldr	r3, [fp, #4]
80168084:	e50b3028 	str	r3, [fp, #-40]	@ 0xffffffd8
    Prio[1]=Prio1;
80168088:	e59b300c 	ldr	r3, [fp, #12]
8016808c:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    Prio[2]=Prio2;
80168090:	e59b3014 	ldr	r3, [fp, #20]
80168094:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0

    Local=RME_CPU_LOCAL();
80168098:	e30d3004 	movw	r3, #53252	@ 0xd004
8016809c:	e3483016 	movt	r3, #32790	@ 0x8016
801680a0:	e50b300c 	str	r3, [fp, #-12]
    for(Count=0U;Count<Number;Count++)
801680a4:	e3a03000 	mov	r3, #0
801680a8:	e50b3008 	str	r3, [fp, #-8]
801680ac:	ea0000d5 	b	80168408 <_RME_Thd_Sched_Prio+0x3dc>
    {
        /* Get the capability slot */
        RME_CPT_GETCAP(Cpt,Cap_Thd[Count],RME_CAP_TYPE_THD,
801680b0:	e51b3008 	ldr	r3, [fp, #-8]
801680b4:	e1a03103 	lsl	r3, r3, #2
801680b8:	e2433004 	sub	r3, r3, #4
801680bc:	e083300b 	add	r3, r3, fp
801680c0:	e5133018 	ldr	r3, [r3, #-24]	@ 0xffffffe8
801680c4:	e2033080 	and	r3, r3, #128	@ 0x80
801680c8:	e3530000 	cmp	r3, #0
801680cc:	1a00002f 	bne	80168190 <_RME_Thd_Sched_Prio+0x164>
801680d0:	e51b3008 	ldr	r3, [fp, #-8]
801680d4:	e1a03103 	lsl	r3, r3, #2
801680d8:	e2433004 	sub	r3, r3, #4
801680dc:	e083300b 	add	r3, r3, fp
801680e0:	e5133018 	ldr	r3, [r3, #-24]	@ 0xffffffe8
801680e4:	e1a02003 	mov	r2, r3
801680e8:	e51b3048 	ldr	r3, [fp, #-72]	@ 0xffffffb8
801680ec:	e5933014 	ldr	r3, [r3, #20]
801680f0:	e1520003 	cmp	r2, r3
801680f4:	3a000001 	bcc	80168100 <_RME_Thd_Sched_Prio+0xd4>
801680f8:	e3e03002 	mvn	r3, #2
801680fc:	ea000103 	b	80168510 <_RME_Thd_Sched_Prio+0x4e4>
80168100:	e51b3008 	ldr	r3, [fp, #-8]
80168104:	e1a03103 	lsl	r3, r3, #2
80168108:	e2433004 	sub	r3, r3, #4
8016810c:	e083300b 	add	r3, r3, fp
80168110:	e5133018 	ldr	r3, [r3, #-24]	@ 0xffffffe8
80168114:	e1a02283 	lsl	r2, r3, #5
80168118:	e51b3048 	ldr	r3, [fp, #-72]	@ 0xffffffb8
8016811c:	e593300c 	ldr	r3, [r3, #12]
80168120:	e0823003 	add	r3, r2, r3
80168124:	e1a02003 	mov	r2, r3
80168128:	e51b3008 	ldr	r3, [fp, #-8]
8016812c:	e1a03103 	lsl	r3, r3, #2
80168130:	e2433004 	sub	r3, r3, #4
80168134:	e083300b 	add	r3, r3, fp
80168138:	e5032030 	str	r2, [r3, #-48]	@ 0xffffffd0
8016813c:	e51b3008 	ldr	r3, [fp, #-8]
80168140:	e1a03103 	lsl	r3, r3, #2
80168144:	e2433004 	sub	r3, r3, #4
80168148:	e083300b 	add	r3, r3, fp
8016814c:	e5133030 	ldr	r3, [r3, #-48]	@ 0xffffffd0
80168150:	e1a00003 	mov	r0, r3
80168154:	ebffe169 	bl	80160700 <__RME_A7A_Read_Acquire>
80168158:	e50b0010 	str	r0, [fp, #-16]
8016815c:	e51b3010 	ldr	r3, [fp, #-16]
80168160:	e1a03823 	lsr	r3, r3, #16
80168164:	e6ef3073 	uxtb	r3, r3
80168168:	e3530002 	cmp	r3, #2
8016816c:	1a000001 	bne	80168178 <_RME_Thd_Sched_Prio+0x14c>
80168170:	e3e03008 	mvn	r3, #8
80168174:	ea0000e5 	b	80168510 <_RME_Thd_Sched_Prio+0x4e4>
80168178:	e51b3010 	ldr	r3, [fp, #-16]
8016817c:	e1a03c23 	lsr	r3, r3, #24
80168180:	e3530006 	cmp	r3, #6
80168184:	0a00006b 	beq	80168338 <_RME_Thd_Sched_Prio+0x30c>
80168188:	e3e03001 	mvn	r3, #1
8016818c:	ea0000df 	b	80168510 <_RME_Thd_Sched_Prio+0x4e4>
80168190:	e51b3008 	ldr	r3, [fp, #-8]
80168194:	e1a03103 	lsl	r3, r3, #2
80168198:	e2433004 	sub	r3, r3, #4
8016819c:	e083300b 	add	r3, r3, fp
801681a0:	e5133018 	ldr	r3, [r3, #-24]	@ 0xffffffe8
801681a4:	e1a02423 	lsr	r2, r3, #8
801681a8:	e51b3048 	ldr	r3, [fp, #-72]	@ 0xffffffb8
801681ac:	e5933014 	ldr	r3, [r3, #20]
801681b0:	e1520003 	cmp	r2, r3
801681b4:	3a000001 	bcc	801681c0 <_RME_Thd_Sched_Prio+0x194>
801681b8:	e3e03002 	mvn	r3, #2
801681bc:	ea0000d3 	b	80168510 <_RME_Thd_Sched_Prio+0x4e4>
801681c0:	e51b3008 	ldr	r3, [fp, #-8]
801681c4:	e1a03103 	lsl	r3, r3, #2
801681c8:	e2433004 	sub	r3, r3, #4
801681cc:	e083300b 	add	r3, r3, fp
801681d0:	e5133018 	ldr	r3, [r3, #-24]	@ 0xffffffe8
801681d4:	e1a03423 	lsr	r3, r3, #8
801681d8:	e1a02283 	lsl	r2, r3, #5
801681dc:	e51b3048 	ldr	r3, [fp, #-72]	@ 0xffffffb8
801681e0:	e593300c 	ldr	r3, [r3, #12]
801681e4:	e0823003 	add	r3, r2, r3
801681e8:	e1a02003 	mov	r2, r3
801681ec:	e51b3008 	ldr	r3, [fp, #-8]
801681f0:	e1a03103 	lsl	r3, r3, #2
801681f4:	e2433004 	sub	r3, r3, #4
801681f8:	e083300b 	add	r3, r3, fp
801681fc:	e5032030 	str	r2, [r3, #-48]	@ 0xffffffd0
80168200:	e51b3008 	ldr	r3, [fp, #-8]
80168204:	e1a03103 	lsl	r3, r3, #2
80168208:	e2433004 	sub	r3, r3, #4
8016820c:	e083300b 	add	r3, r3, fp
80168210:	e5133030 	ldr	r3, [r3, #-48]	@ 0xffffffd0
80168214:	e1a00003 	mov	r0, r3
80168218:	ebffe138 	bl	80160700 <__RME_A7A_Read_Acquire>
8016821c:	e50b0010 	str	r0, [fp, #-16]
80168220:	e51b3010 	ldr	r3, [fp, #-16]
80168224:	e1a03823 	lsr	r3, r3, #16
80168228:	e6ef3073 	uxtb	r3, r3
8016822c:	e3530002 	cmp	r3, #2
80168230:	1a000001 	bne	8016823c <_RME_Thd_Sched_Prio+0x210>
80168234:	e3e03008 	mvn	r3, #8
80168238:	ea0000b4 	b	80168510 <_RME_Thd_Sched_Prio+0x4e4>
8016823c:	e51b3010 	ldr	r3, [fp, #-16]
80168240:	e1a03c23 	lsr	r3, r3, #24
80168244:	e3530003 	cmp	r3, #3
80168248:	0a000001 	beq	80168254 <_RME_Thd_Sched_Prio+0x228>
8016824c:	e3e03001 	mvn	r3, #1
80168250:	ea0000ae 	b	80168510 <_RME_Thd_Sched_Prio+0x4e4>
80168254:	e51b3008 	ldr	r3, [fp, #-8]
80168258:	e1a03103 	lsl	r3, r3, #2
8016825c:	e2433004 	sub	r3, r3, #4
80168260:	e083300b 	add	r3, r3, fp
80168264:	e5133018 	ldr	r3, [r3, #-24]	@ 0xffffffe8
80168268:	e203207f 	and	r2, r3, #127	@ 0x7f
8016826c:	e51b3008 	ldr	r3, [fp, #-8]
80168270:	e1a03103 	lsl	r3, r3, #2
80168274:	e2433004 	sub	r3, r3, #4
80168278:	e083300b 	add	r3, r3, fp
8016827c:	e5133030 	ldr	r3, [r3, #-48]	@ 0xffffffd0
80168280:	e5933014 	ldr	r3, [r3, #20]
80168284:	e1520003 	cmp	r2, r3
80168288:	3a000001 	bcc	80168294 <_RME_Thd_Sched_Prio+0x268>
8016828c:	e3e03002 	mvn	r3, #2
80168290:	ea00009e 	b	80168510 <_RME_Thd_Sched_Prio+0x4e4>
80168294:	e51b3008 	ldr	r3, [fp, #-8]
80168298:	e1a03103 	lsl	r3, r3, #2
8016829c:	e2433004 	sub	r3, r3, #4
801682a0:	e083300b 	add	r3, r3, fp
801682a4:	e5133018 	ldr	r3, [r3, #-24]	@ 0xffffffe8
801682a8:	e203307f 	and	r3, r3, #127	@ 0x7f
801682ac:	e1a02283 	lsl	r2, r3, #5
801682b0:	e51b3008 	ldr	r3, [fp, #-8]
801682b4:	e1a03103 	lsl	r3, r3, #2
801682b8:	e2433004 	sub	r3, r3, #4
801682bc:	e083300b 	add	r3, r3, fp
801682c0:	e5133030 	ldr	r3, [r3, #-48]	@ 0xffffffd0
801682c4:	e593300c 	ldr	r3, [r3, #12]
801682c8:	e0823003 	add	r3, r2, r3
801682cc:	e1a02003 	mov	r2, r3
801682d0:	e51b3008 	ldr	r3, [fp, #-8]
801682d4:	e1a03103 	lsl	r3, r3, #2
801682d8:	e2433004 	sub	r3, r3, #4
801682dc:	e083300b 	add	r3, r3, fp
801682e0:	e5032030 	str	r2, [r3, #-48]	@ 0xffffffd0
801682e4:	e51b3008 	ldr	r3, [fp, #-8]
801682e8:	e1a03103 	lsl	r3, r3, #2
801682ec:	e2433004 	sub	r3, r3, #4
801682f0:	e083300b 	add	r3, r3, fp
801682f4:	e5133030 	ldr	r3, [r3, #-48]	@ 0xffffffd0
801682f8:	e1a00003 	mov	r0, r3
801682fc:	ebffe0ff 	bl	80160700 <__RME_A7A_Read_Acquire>
80168300:	e50b0010 	str	r0, [fp, #-16]
80168304:	e51b3010 	ldr	r3, [fp, #-16]
80168308:	e1a03823 	lsr	r3, r3, #16
8016830c:	e6ef3073 	uxtb	r3, r3
80168310:	e3530002 	cmp	r3, #2
80168314:	1a000001 	bne	80168320 <_RME_Thd_Sched_Prio+0x2f4>
80168318:	e3e03008 	mvn	r3, #8
8016831c:	ea00007b 	b	80168510 <_RME_Thd_Sched_Prio+0x4e4>
80168320:	e51b3010 	ldr	r3, [fp, #-16]
80168324:	e1a03c23 	lsr	r3, r3, #24
80168328:	e3530006 	cmp	r3, #6
8016832c:	0a000001 	beq	80168338 <_RME_Thd_Sched_Prio+0x30c>
80168330:	e3e03001 	mvn	r3, #1
80168334:	ea000075 	b	80168510 <_RME_Thd_Sched_Prio+0x4e4>
                       struct RME_Cap_Thd*,Thd_Op[Count],Type_Stat);
        /* Check if the target cap is not frozen and allows such operations */
        RME_CAP_CHECK(Thd_Op[Count],RME_THD_FLAG_SCHED_PRIO);
80168338:	e51b3008 	ldr	r3, [fp, #-8]
8016833c:	e1a03103 	lsl	r3, r3, #2
80168340:	e2433004 	sub	r3, r3, #4
80168344:	e083300b 	add	r3, r3, fp
80168348:	e5133030 	ldr	r3, [r3, #-48]	@ 0xffffffd0
8016834c:	e5933008 	ldr	r3, [r3, #8]
80168350:	e2033008 	and	r3, r3, #8
80168354:	e3530000 	cmp	r3, #0
80168358:	1a000001 	bne	80168364 <_RME_Thd_Sched_Prio+0x338>
8016835c:	e3e03006 	mvn	r3, #6
80168360:	ea00006a 	b	80168510 <_RME_Thd_Sched_Prio+0x4e4>
        
        /* See if the target thread is already bound to this core. If no, we just quit */
        Thread[Count]=(struct RME_Thd_Struct*)(Thd_Op[Count]->Head.Object);
80168364:	e51b3008 	ldr	r3, [fp, #-8]
80168368:	e1a03103 	lsl	r3, r3, #2
8016836c:	e2433004 	sub	r3, r3, #4
80168370:	e083300b 	add	r3, r3, fp
80168374:	e5133030 	ldr	r3, [r3, #-48]	@ 0xffffffd0
80168378:	e593300c 	ldr	r3, [r3, #12]
8016837c:	e1a02003 	mov	r2, r3
80168380:	e51b3008 	ldr	r3, [fp, #-8]
80168384:	e1a03103 	lsl	r3, r3, #2
80168388:	e2433004 	sub	r3, r3, #4
8016838c:	e083300b 	add	r3, r3, fp
80168390:	e503203c 	str	r2, [r3, #-60]	@ 0xffffffc4
        if(Thread[Count]->Sched.Local!=Local)
80168394:	e51b3008 	ldr	r3, [fp, #-8]
80168398:	e1a03103 	lsl	r3, r3, #2
8016839c:	e2433004 	sub	r3, r3, #4
801683a0:	e083300b 	add	r3, r3, fp
801683a4:	e513303c 	ldr	r3, [r3, #-60]	@ 0xffffffc4
801683a8:	e5933014 	ldr	r3, [r3, #20]
801683ac:	e51b200c 	ldr	r2, [fp, #-12]
801683b0:	e1520003 	cmp	r2, r3
801683b4:	0a000001 	beq	801683c0 <_RME_Thd_Sched_Prio+0x394>
        {
            RME_COV_MARKER();

            return RME_ERR_PTH_INVSTATE;
801683b8:	e3e030cb 	mvn	r3, #203	@ 0xcb
801683bc:	ea000053 	b	80168510 <_RME_Thd_Sched_Prio+0x4e4>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* See if the priority relationship is correct */
        if(Thread[Count]->Sched.Prio_Max<Prio[Count])
801683c0:	e51b3008 	ldr	r3, [fp, #-8]
801683c4:	e1a03103 	lsl	r3, r3, #2
801683c8:	e2433004 	sub	r3, r3, #4
801683cc:	e083300b 	add	r3, r3, fp
801683d0:	e513303c 	ldr	r3, [r3, #-60]	@ 0xffffffc4
801683d4:	e5932024 	ldr	r2, [r3, #36]	@ 0x24
801683d8:	e51b3008 	ldr	r3, [fp, #-8]
801683dc:	e1a03103 	lsl	r3, r3, #2
801683e0:	e2433004 	sub	r3, r3, #4
801683e4:	e083300b 	add	r3, r3, fp
801683e8:	e5133024 	ldr	r3, [r3, #-36]	@ 0xffffffdc
801683ec:	e1520003 	cmp	r2, r3
801683f0:	2a000001 	bcs	801683fc <_RME_Thd_Sched_Prio+0x3d0>
        {
            RME_COV_MARKER();

            return RME_ERR_PTH_PRIO;
801683f4:	e3e030cc 	mvn	r3, #204	@ 0xcc
801683f8:	ea000044 	b	80168510 <_RME_Thd_Sched_Prio+0x4e4>
    for(Count=0U;Count<Number;Count++)
801683fc:	e51b3008 	ldr	r3, [fp, #-8]
80168400:	e2833001 	add	r3, r3, #1
80168404:	e50b3008 	str	r3, [fp, #-8]
80168408:	e51b2008 	ldr	r2, [fp, #-8]
8016840c:	e51b3050 	ldr	r3, [fp, #-80]	@ 0xffffffb0
80168410:	e1520003 	cmp	r2, r3
80168414:	3affff25 	bcc	801680b0 <_RME_Thd_Sched_Prio+0x84>
            /* No action required */
        }
    }
    
    /* Now save the system call return value to the caller stack */
    __RME_Svc_Retval_Set(Reg,0);
80168418:	e3a01000 	mov	r1, #0
8016841c:	e51b004c 	ldr	r0, [fp, #-76]	@ 0xffffffb4
80168420:	eb000d5b 	bl	8016b994 <__RME_Svc_Retval_Set>
    
    /* Change priority for each thread, and we'll switch to the real highest priority
     * thread after all these changes. This can help remove the excessive overhead. */
    for(Count=0U;Count<Number;Count++)
80168424:	e3a03000 	mov	r3, #0
80168428:	e50b3008 	str	r3, [fp, #-8]
8016842c:	ea00002f 	b	801684f0 <_RME_Thd_Sched_Prio+0x4c4>
    {
        /* See if this thread is currently in the runqueue */
        if(Thread[Count]->Sched.State==RME_THD_READY)
80168430:	e51b3008 	ldr	r3, [fp, #-8]
80168434:	e1a03103 	lsl	r3, r3, #2
80168438:	e2433004 	sub	r3, r3, #4
8016843c:	e083300b 	add	r3, r3, fp
80168440:	e513303c 	ldr	r3, [r3, #-60]	@ 0xffffffc4
80168444:	e593301c 	ldr	r3, [r3, #28]
80168448:	e3530000 	cmp	r3, #0
8016844c:	1a000019 	bne	801684b8 <_RME_Thd_Sched_Prio+0x48c>
        {
            RME_COV_MARKER();

            /* Remove from runqueue, change priority, and add it back */
            _RME_Run_Del(Thread[Count]);
80168450:	e51b3008 	ldr	r3, [fp, #-8]
80168454:	e1a03103 	lsl	r3, r3, #2
80168458:	e2433004 	sub	r3, r3, #4
8016845c:	e083300b 	add	r3, r3, fp
80168460:	e513303c 	ldr	r3, [r3, #-60]	@ 0xffffffc4
80168464:	e1a00003 	mov	r0, r3
80168468:	ebfff302 	bl	80165078 <_RME_Run_Del>
            Thread[Count]->Sched.Prio=Prio[Count];
8016846c:	e51b3008 	ldr	r3, [fp, #-8]
80168470:	e1a03103 	lsl	r3, r3, #2
80168474:	e2433004 	sub	r3, r3, #4
80168478:	e083300b 	add	r3, r3, fp
8016847c:	e513203c 	ldr	r2, [r3, #-60]	@ 0xffffffc4
80168480:	e51b3008 	ldr	r3, [fp, #-8]
80168484:	e1a03103 	lsl	r3, r3, #2
80168488:	e2433004 	sub	r3, r3, #4
8016848c:	e083300b 	add	r3, r3, fp
80168490:	e5133024 	ldr	r3, [r3, #-36]	@ 0xffffffdc
80168494:	e5823020 	str	r3, [r2, #32]
            _RME_Run_Ins(Thread[Count]);
80168498:	e51b3008 	ldr	r3, [fp, #-8]
8016849c:	e1a03103 	lsl	r3, r3, #2
801684a0:	e2433004 	sub	r3, r3, #4
801684a4:	e083300b 	add	r3, r3, fp
801684a8:	e513303c 	ldr	r3, [r3, #-60]	@ 0xffffffc4
801684ac:	e1a00003 	mov	r0, r3
801684b0:	ebfff2b9 	bl	80164f9c <_RME_Run_Ins>
801684b4:	ea00000a 	b	801684e4 <_RME_Thd_Sched_Prio+0x4b8>
        /* If it is BLOCKED, TIMEOUT or EXCPEND, changing the number will suffice */
        else
        {
            RME_COV_MARKER();

            Thread[Count]->Sched.Prio=Prio[Count];
801684b8:	e51b3008 	ldr	r3, [fp, #-8]
801684bc:	e1a03103 	lsl	r3, r3, #2
801684c0:	e2433004 	sub	r3, r3, #4
801684c4:	e083300b 	add	r3, r3, fp
801684c8:	e513203c 	ldr	r2, [r3, #-60]	@ 0xffffffc4
801684cc:	e51b3008 	ldr	r3, [fp, #-8]
801684d0:	e1a03103 	lsl	r3, r3, #2
801684d4:	e2433004 	sub	r3, r3, #4
801684d8:	e083300b 	add	r3, r3, fp
801684dc:	e5133024 	ldr	r3, [r3, #-36]	@ 0xffffffdc
801684e0:	e5823020 	str	r3, [r2, #32]
    for(Count=0U;Count<Number;Count++)
801684e4:	e51b3008 	ldr	r3, [fp, #-8]
801684e8:	e2833001 	add	r3, r3, #1
801684ec:	e50b3008 	str	r3, [fp, #-8]
801684f0:	e51b2008 	ldr	r2, [fp, #-8]
801684f4:	e51b3050 	ldr	r3, [fp, #-80]	@ 0xffffffb0
801684f8:	e1520003 	cmp	r2, r3
801684fc:	3affffcb 	bcc	80168430 <_RME_Thd_Sched_Prio+0x404>
        }
    }
    
    /* Pick the current highest priority thread to run */
    _RME_Kern_High(Reg,Local);
80168500:	e51b100c 	ldr	r1, [fp, #-12]
80168504:	e51b004c 	ldr	r0, [fp, #-76]	@ 0xffffffb4
80168508:	eb0004a5 	bl	801697a4 <_RME_Kern_High>

    return 0;
8016850c:	e3a03000 	mov	r3, #0
}
80168510:	e1a00003 	mov	r0, r3
80168514:	e24bd004 	sub	sp, fp, #4
80168518:	e8bd8800 	pop	{fp, pc}

8016851c <_RME_Thd_Sched_Rcv>:
Output      : None.
Return      : rme_ret_t - If successful, the thread ID; or an error code.
******************************************************************************/
static rme_ret_t _RME_Thd_Sched_Rcv(struct RME_Cap_Cpt* Cpt,
                                    rme_cid_t Cap_Thd)
{
8016851c:	e92d4800 	push	{fp, lr}
80168520:	e28db004 	add	fp, sp, #4
80168524:	e24dd020 	sub	sp, sp, #32
80168528:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
8016852c:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
    struct RME_Thd_Struct* Thread;
    rme_ptr_t Type_Stat;
    rme_ptr_t Flag;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Thd,RME_CAP_TYPE_THD,
80168530:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168534:	e2033080 	and	r3, r3, #128	@ 0x80
80168538:	e3530000 	cmp	r3, #0
8016853c:	1a00001d 	bne	801685b8 <_RME_Thd_Sched_Rcv+0x9c>
80168540:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168544:	e5932014 	ldr	r2, [r3, #20]
80168548:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016854c:	e1520003 	cmp	r2, r3
80168550:	8a000001 	bhi	8016855c <_RME_Thd_Sched_Rcv+0x40>
80168554:	e3e03002 	mvn	r3, #2
80168558:	ea00009a 	b	801687c8 <_RME_Thd_Sched_Rcv+0x2ac>
8016855c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168560:	e1a02283 	lsl	r2, r3, #5
80168564:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168568:	e593300c 	ldr	r3, [r3, #12]
8016856c:	e0823003 	add	r3, r2, r3
80168570:	e50b3008 	str	r3, [fp, #-8]
80168574:	e51b3008 	ldr	r3, [fp, #-8]
80168578:	e1a00003 	mov	r0, r3
8016857c:	ebffe05f 	bl	80160700 <__RME_A7A_Read_Acquire>
80168580:	e50b0010 	str	r0, [fp, #-16]
80168584:	e51b3010 	ldr	r3, [fp, #-16]
80168588:	e1a03823 	lsr	r3, r3, #16
8016858c:	e6ef3073 	uxtb	r3, r3
80168590:	e3530002 	cmp	r3, #2
80168594:	1a000001 	bne	801685a0 <_RME_Thd_Sched_Rcv+0x84>
80168598:	e3e03008 	mvn	r3, #8
8016859c:	ea000089 	b	801687c8 <_RME_Thd_Sched_Rcv+0x2ac>
801685a0:	e51b3010 	ldr	r3, [fp, #-16]
801685a4:	e1a03c23 	lsr	r3, r3, #24
801685a8:	e3530006 	cmp	r3, #6
801685ac:	0a000041 	beq	801686b8 <_RME_Thd_Sched_Rcv+0x19c>
801685b0:	e3e03001 	mvn	r3, #1
801685b4:	ea000083 	b	801687c8 <_RME_Thd_Sched_Rcv+0x2ac>
801685b8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801685bc:	e1a02423 	lsr	r2, r3, #8
801685c0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801685c4:	e5933014 	ldr	r3, [r3, #20]
801685c8:	e1520003 	cmp	r2, r3
801685cc:	3a000001 	bcc	801685d8 <_RME_Thd_Sched_Rcv+0xbc>
801685d0:	e3e03002 	mvn	r3, #2
801685d4:	ea00007b 	b	801687c8 <_RME_Thd_Sched_Rcv+0x2ac>
801685d8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801685dc:	e1a03423 	lsr	r3, r3, #8
801685e0:	e1a02283 	lsl	r2, r3, #5
801685e4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801685e8:	e593300c 	ldr	r3, [r3, #12]
801685ec:	e0823003 	add	r3, r2, r3
801685f0:	e50b3008 	str	r3, [fp, #-8]
801685f4:	e51b3008 	ldr	r3, [fp, #-8]
801685f8:	e1a00003 	mov	r0, r3
801685fc:	ebffe03f 	bl	80160700 <__RME_A7A_Read_Acquire>
80168600:	e50b0010 	str	r0, [fp, #-16]
80168604:	e51b3010 	ldr	r3, [fp, #-16]
80168608:	e1a03823 	lsr	r3, r3, #16
8016860c:	e6ef3073 	uxtb	r3, r3
80168610:	e3530002 	cmp	r3, #2
80168614:	1a000001 	bne	80168620 <_RME_Thd_Sched_Rcv+0x104>
80168618:	e3e03008 	mvn	r3, #8
8016861c:	ea000069 	b	801687c8 <_RME_Thd_Sched_Rcv+0x2ac>
80168620:	e51b3010 	ldr	r3, [fp, #-16]
80168624:	e1a03c23 	lsr	r3, r3, #24
80168628:	e3530003 	cmp	r3, #3
8016862c:	0a000001 	beq	80168638 <_RME_Thd_Sched_Rcv+0x11c>
80168630:	e3e03001 	mvn	r3, #1
80168634:	ea000063 	b	801687c8 <_RME_Thd_Sched_Rcv+0x2ac>
80168638:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016863c:	e203207f 	and	r2, r3, #127	@ 0x7f
80168640:	e51b3008 	ldr	r3, [fp, #-8]
80168644:	e5933014 	ldr	r3, [r3, #20]
80168648:	e1520003 	cmp	r2, r3
8016864c:	3a000001 	bcc	80168658 <_RME_Thd_Sched_Rcv+0x13c>
80168650:	e3e03002 	mvn	r3, #2
80168654:	ea00005b 	b	801687c8 <_RME_Thd_Sched_Rcv+0x2ac>
80168658:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016865c:	e203307f 	and	r3, r3, #127	@ 0x7f
80168660:	e1a02283 	lsl	r2, r3, #5
80168664:	e51b3008 	ldr	r3, [fp, #-8]
80168668:	e593300c 	ldr	r3, [r3, #12]
8016866c:	e0823003 	add	r3, r2, r3
80168670:	e50b3008 	str	r3, [fp, #-8]
80168674:	e51b3008 	ldr	r3, [fp, #-8]
80168678:	e1a00003 	mov	r0, r3
8016867c:	ebffe01f 	bl	80160700 <__RME_A7A_Read_Acquire>
80168680:	e50b0010 	str	r0, [fp, #-16]
80168684:	e51b3010 	ldr	r3, [fp, #-16]
80168688:	e1a03823 	lsr	r3, r3, #16
8016868c:	e6ef3073 	uxtb	r3, r3
80168690:	e3530002 	cmp	r3, #2
80168694:	1a000001 	bne	801686a0 <_RME_Thd_Sched_Rcv+0x184>
80168698:	e3e03008 	mvn	r3, #8
8016869c:	ea000049 	b	801687c8 <_RME_Thd_Sched_Rcv+0x2ac>
801686a0:	e51b3010 	ldr	r3, [fp, #-16]
801686a4:	e1a03c23 	lsr	r3, r3, #24
801686a8:	e3530006 	cmp	r3, #6
801686ac:	0a000001 	beq	801686b8 <_RME_Thd_Sched_Rcv+0x19c>
801686b0:	e3e03001 	mvn	r3, #1
801686b4:	ea000043 	b	801687c8 <_RME_Thd_Sched_Rcv+0x2ac>
                   struct RME_Cap_Thd*,Thd_Op,Type_Stat);
    /* Check if the target cap is not frozen and allows such operations */
    RME_CAP_CHECK(Thd_Op,RME_THD_FLAG_SCHED_RCV);
801686b8:	e51b3008 	ldr	r3, [fp, #-8]
801686bc:	e5933008 	ldr	r3, [r3, #8]
801686c0:	e2033020 	and	r3, r3, #32
801686c4:	e3530000 	cmp	r3, #0
801686c8:	1a000001 	bne	801686d4 <_RME_Thd_Sched_Rcv+0x1b8>
801686cc:	e3e03006 	mvn	r3, #6
801686d0:	ea00003c 	b	801687c8 <_RME_Thd_Sched_Rcv+0x2ac>
    
    /* Check if we are on the same core with the target thread */
    Scheduler=(struct RME_Thd_Struct*)Thd_Op->Head.Object;
801686d4:	e51b3008 	ldr	r3, [fp, #-8]
801686d8:	e593300c 	ldr	r3, [r3, #12]
801686dc:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    if(Scheduler->Sched.Local!=RME_CPU_LOCAL())
801686e0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801686e4:	e5932014 	ldr	r2, [r3, #20]
801686e8:	e30d3004 	movw	r3, #53252	@ 0xd004
801686ec:	e3483016 	movt	r3, #32790	@ 0x8016
801686f0:	e1520003 	cmp	r2, r3
801686f4:	0a000001 	beq	80168700 <_RME_Thd_Sched_Rcv+0x1e4>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
801686f8:	e3e030cb 	mvn	r3, #203	@ 0xcb
801686fc:	ea000031 	b	801687c8 <_RME_Thd_Sched_Rcv+0x2ac>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Check if there are any notifications */
    if(Scheduler->Sched.Event.Next==&(Scheduler->Sched.Event))
80168700:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168704:	e593203c 	ldr	r2, [r3, #60]	@ 0x3c
80168708:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016870c:	e283303c 	add	r3, r3, #60	@ 0x3c
80168710:	e1520003 	cmp	r2, r3
80168714:	1a000001 	bne	80168720 <_RME_Thd_Sched_Rcv+0x204>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_NOTIF;
80168718:	e3e030ce 	mvn	r3, #206	@ 0xce
8016871c:	ea000029 	b	801687c8 <_RME_Thd_Sched_Rcv+0x2ac>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Return one notification and delete it from the notification list */
    Thread=(struct RME_Thd_Struct*)(Scheduler->Sched.Event.Next-1U);
80168720:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168724:	e593303c 	ldr	r3, [r3, #60]	@ 0x3c
80168728:	e2433008 	sub	r3, r3, #8
8016872c:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    _RME_List_Del(Thread->Sched.Notif.Prev,Thread->Sched.Notif.Next);
80168730:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168734:	e593200c 	ldr	r2, [r3, #12]
80168738:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016873c:	e5933008 	ldr	r3, [r3, #8]
80168740:	e1a01003 	mov	r1, r3
80168744:	e1a00002 	mov	r0, r2
80168748:	ebffe176 	bl	80160d28 <_RME_List_Del>
    /* We need to do this because we are using this to detect whether the notification is sent */
    _RME_List_Crt(&(Thread->Sched.Notif));
8016874c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168750:	e2833008 	add	r3, r3, #8
80168754:	e1a00003 	mov	r0, r3
80168758:	ebffe164 	bl	80160cf0 <_RME_List_Crt>
    
    /* Exception pending */
    if(Thread->Sched.State==RME_THD_EXCPEND)
8016875c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168760:	e593301c 	ldr	r3, [r3, #28]
80168764:	e3530003 	cmp	r3, #3
80168768:	1a000009 	bne	80168794 <_RME_Thd_Sched_Rcv+0x278>
    {
        RME_COV_MARKER();
        
        Flag=RME_THD_EXCPEND_FLAG;
8016876c:	e3a03101 	mov	r3, #1073741824	@ 0x40000000
80168770:	e50b300c 	str	r3, [fp, #-12]
        
        /* Is it also out of timeslice? */
        if(Thread->Sched.Slice==0U)
80168774:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168778:	e5933018 	ldr	r3, [r3, #24]
8016877c:	e3530000 	cmp	r3, #0
80168780:	1a00000c 	bne	801687b8 <_RME_Thd_Sched_Rcv+0x29c>
        {
            RME_COV_MARKER();
            
            Flag|=RME_THD_TIMEOUT_FLAG;
80168784:	e51b300c 	ldr	r3, [fp, #-12]
80168788:	e3833202 	orr	r3, r3, #536870912	@ 0x20000000
8016878c:	e50b300c 	str	r3, [fp, #-12]
80168790:	ea000008 	b	801687b8 <_RME_Thd_Sched_Rcv+0x29c>
            RME_COV_MARKER();
            /* No action required */
        }
    }
    /* Timeout */
    else if(Thread->Sched.State==RME_THD_TIMEOUT)
80168794:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168798:	e593301c 	ldr	r3, [r3, #28]
8016879c:	e3530002 	cmp	r3, #2
801687a0:	1a000002 	bne	801687b0 <_RME_Thd_Sched_Rcv+0x294>
    {
        RME_COV_MARKER();
        
        Flag=RME_THD_TIMEOUT_FLAG;
801687a4:	e3a03202 	mov	r3, #536870912	@ 0x20000000
801687a8:	e50b300c 	str	r3, [fp, #-12]
801687ac:	ea000001 	b	801687b8 <_RME_Thd_Sched_Rcv+0x29c>
    /* Spurious notification, cause eliminated before this sched rcv */
    else
    {
        RME_COV_MARKER();
        
        Flag=0U;
801687b0:	e3a03000 	mov	r3, #0
801687b4:	e50b300c 	str	r3, [fp, #-12]
    }
    
    /* Return the notification TID with the flags */
    return (rme_ret_t)(Thread->Sched.TID|Flag);
801687b8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801687bc:	e5932010 	ldr	r2, [r3, #16]
801687c0:	e51b300c 	ldr	r3, [fp, #-12]
801687c4:	e1823003 	orr	r3, r2, r3
}
801687c8:	e1a00003 	mov	r0, r3
801687cc:	e24bd004 	sub	sp, fp, #4
801687d0:	e8bd8800 	pop	{fp, pc}

801687d4 <_RME_Thd_Time_Xfer>:
static rme_ret_t _RME_Thd_Time_Xfer(struct RME_Cap_Cpt* Cpt,
                                    struct RME_Reg_Struct* Reg,
                                    rme_cid_t Cap_Thd_Dst,
                                    rme_cid_t Cap_Thd_Src,
                                    rme_ptr_t Time)
{
801687d4:	e92d4800 	push	{fp, lr}
801687d8:	e28db004 	add	fp, sp, #4
801687dc:	e24dd030 	sub	sp, sp, #48	@ 0x30
801687e0:	e50b0028 	str	r0, [fp, #-40]	@ 0xffffffd8
801687e4:	e50b102c 	str	r1, [fp, #-44]	@ 0xffffffd4
801687e8:	e50b2030 	str	r2, [fp, #-48]	@ 0xffffffd0
801687ec:	e50b3034 	str	r3, [fp, #-52]	@ 0xffffffcc
    struct RME_CPU_Local* Local;
    rme_ptr_t Time_Xfer;
    rme_ptr_t Type_Stat;
    
    /* We may allow transferring infinite time here */
    if(Time==0U)
801687f0:	e59b3004 	ldr	r3, [fp, #4]
801687f4:	e3530000 	cmp	r3, #0
801687f8:	1a000001 	bne	80168804 <_RME_Thd_Time_Xfer+0x30>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
801687fc:	e3e030cb 	mvn	r3, #203	@ 0xcb
80168800:	ea00017d 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Thd_Dst,RME_CAP_TYPE_THD,
80168804:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80168808:	e2033080 	and	r3, r3, #128	@ 0x80
8016880c:	e3530000 	cmp	r3, #0
80168810:	1a00001d 	bne	8016888c <_RME_Thd_Time_Xfer+0xb8>
80168814:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168818:	e5932014 	ldr	r2, [r3, #20]
8016881c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80168820:	e1520003 	cmp	r2, r3
80168824:	8a000001 	bhi	80168830 <_RME_Thd_Time_Xfer+0x5c>
80168828:	e3e03002 	mvn	r3, #2
8016882c:	ea000172 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
80168830:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80168834:	e1a02283 	lsl	r2, r3, #5
80168838:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016883c:	e593300c 	ldr	r3, [r3, #12]
80168840:	e0823003 	add	r3, r2, r3
80168844:	e50b3008 	str	r3, [fp, #-8]
80168848:	e51b3008 	ldr	r3, [fp, #-8]
8016884c:	e1a00003 	mov	r0, r3
80168850:	ebffdfaa 	bl	80160700 <__RME_A7A_Read_Acquire>
80168854:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80168858:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016885c:	e1a03823 	lsr	r3, r3, #16
80168860:	e6ef3073 	uxtb	r3, r3
80168864:	e3530002 	cmp	r3, #2
80168868:	1a000001 	bne	80168874 <_RME_Thd_Time_Xfer+0xa0>
8016886c:	e3e03008 	mvn	r3, #8
80168870:	ea000161 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
80168874:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168878:	e1a03c23 	lsr	r3, r3, #24
8016887c:	e3530006 	cmp	r3, #6
80168880:	0a000041 	beq	8016898c <_RME_Thd_Time_Xfer+0x1b8>
80168884:	e3e03001 	mvn	r3, #1
80168888:	ea00015b 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
8016888c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80168890:	e1a02423 	lsr	r2, r3, #8
80168894:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168898:	e5933014 	ldr	r3, [r3, #20]
8016889c:	e1520003 	cmp	r2, r3
801688a0:	3a000001 	bcc	801688ac <_RME_Thd_Time_Xfer+0xd8>
801688a4:	e3e03002 	mvn	r3, #2
801688a8:	ea000153 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
801688ac:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801688b0:	e1a03423 	lsr	r3, r3, #8
801688b4:	e1a02283 	lsl	r2, r3, #5
801688b8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801688bc:	e593300c 	ldr	r3, [r3, #12]
801688c0:	e0823003 	add	r3, r2, r3
801688c4:	e50b3008 	str	r3, [fp, #-8]
801688c8:	e51b3008 	ldr	r3, [fp, #-8]
801688cc:	e1a00003 	mov	r0, r3
801688d0:	ebffdf8a 	bl	80160700 <__RME_A7A_Read_Acquire>
801688d4:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801688d8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801688dc:	e1a03823 	lsr	r3, r3, #16
801688e0:	e6ef3073 	uxtb	r3, r3
801688e4:	e3530002 	cmp	r3, #2
801688e8:	1a000001 	bne	801688f4 <_RME_Thd_Time_Xfer+0x120>
801688ec:	e3e03008 	mvn	r3, #8
801688f0:	ea000141 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
801688f4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801688f8:	e1a03c23 	lsr	r3, r3, #24
801688fc:	e3530003 	cmp	r3, #3
80168900:	0a000001 	beq	8016890c <_RME_Thd_Time_Xfer+0x138>
80168904:	e3e03001 	mvn	r3, #1
80168908:	ea00013b 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
8016890c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80168910:	e203207f 	and	r2, r3, #127	@ 0x7f
80168914:	e51b3008 	ldr	r3, [fp, #-8]
80168918:	e5933014 	ldr	r3, [r3, #20]
8016891c:	e1520003 	cmp	r2, r3
80168920:	3a000001 	bcc	8016892c <_RME_Thd_Time_Xfer+0x158>
80168924:	e3e03002 	mvn	r3, #2
80168928:	ea000133 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
8016892c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80168930:	e203307f 	and	r3, r3, #127	@ 0x7f
80168934:	e1a02283 	lsl	r2, r3, #5
80168938:	e51b3008 	ldr	r3, [fp, #-8]
8016893c:	e593300c 	ldr	r3, [r3, #12]
80168940:	e0823003 	add	r3, r2, r3
80168944:	e50b3008 	str	r3, [fp, #-8]
80168948:	e51b3008 	ldr	r3, [fp, #-8]
8016894c:	e1a00003 	mov	r0, r3
80168950:	ebffdf6a 	bl	80160700 <__RME_A7A_Read_Acquire>
80168954:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80168958:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016895c:	e1a03823 	lsr	r3, r3, #16
80168960:	e6ef3073 	uxtb	r3, r3
80168964:	e3530002 	cmp	r3, #2
80168968:	1a000001 	bne	80168974 <_RME_Thd_Time_Xfer+0x1a0>
8016896c:	e3e03008 	mvn	r3, #8
80168970:	ea000121 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
80168974:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168978:	e1a03c23 	lsr	r3, r3, #24
8016897c:	e3530006 	cmp	r3, #6
80168980:	0a000001 	beq	8016898c <_RME_Thd_Time_Xfer+0x1b8>
80168984:	e3e03001 	mvn	r3, #1
80168988:	ea00011b 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
                   struct RME_Cap_Thd*,Thd_Dst_Op,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Thd_Src,RME_CAP_TYPE_THD,
8016898c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80168990:	e2033080 	and	r3, r3, #128	@ 0x80
80168994:	e3530000 	cmp	r3, #0
80168998:	1a00001d 	bne	80168a14 <_RME_Thd_Time_Xfer+0x240>
8016899c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801689a0:	e5932014 	ldr	r2, [r3, #20]
801689a4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801689a8:	e1520003 	cmp	r2, r3
801689ac:	8a000001 	bhi	801689b8 <_RME_Thd_Time_Xfer+0x1e4>
801689b0:	e3e03002 	mvn	r3, #2
801689b4:	ea000110 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
801689b8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801689bc:	e1a02283 	lsl	r2, r3, #5
801689c0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801689c4:	e593300c 	ldr	r3, [r3, #12]
801689c8:	e0823003 	add	r3, r2, r3
801689cc:	e50b300c 	str	r3, [fp, #-12]
801689d0:	e51b300c 	ldr	r3, [fp, #-12]
801689d4:	e1a00003 	mov	r0, r3
801689d8:	ebffdf48 	bl	80160700 <__RME_A7A_Read_Acquire>
801689dc:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801689e0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801689e4:	e1a03823 	lsr	r3, r3, #16
801689e8:	e6ef3073 	uxtb	r3, r3
801689ec:	e3530002 	cmp	r3, #2
801689f0:	1a000001 	bne	801689fc <_RME_Thd_Time_Xfer+0x228>
801689f4:	e3e03008 	mvn	r3, #8
801689f8:	ea0000ff 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
801689fc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168a00:	e1a03c23 	lsr	r3, r3, #24
80168a04:	e3530006 	cmp	r3, #6
80168a08:	0a000041 	beq	80168b14 <_RME_Thd_Time_Xfer+0x340>
80168a0c:	e3e03001 	mvn	r3, #1
80168a10:	ea0000f9 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
80168a14:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80168a18:	e1a02423 	lsr	r2, r3, #8
80168a1c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168a20:	e5933014 	ldr	r3, [r3, #20]
80168a24:	e1520003 	cmp	r2, r3
80168a28:	3a000001 	bcc	80168a34 <_RME_Thd_Time_Xfer+0x260>
80168a2c:	e3e03002 	mvn	r3, #2
80168a30:	ea0000f1 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
80168a34:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80168a38:	e1a03423 	lsr	r3, r3, #8
80168a3c:	e1a02283 	lsl	r2, r3, #5
80168a40:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168a44:	e593300c 	ldr	r3, [r3, #12]
80168a48:	e0823003 	add	r3, r2, r3
80168a4c:	e50b300c 	str	r3, [fp, #-12]
80168a50:	e51b300c 	ldr	r3, [fp, #-12]
80168a54:	e1a00003 	mov	r0, r3
80168a58:	ebffdf28 	bl	80160700 <__RME_A7A_Read_Acquire>
80168a5c:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80168a60:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168a64:	e1a03823 	lsr	r3, r3, #16
80168a68:	e6ef3073 	uxtb	r3, r3
80168a6c:	e3530002 	cmp	r3, #2
80168a70:	1a000001 	bne	80168a7c <_RME_Thd_Time_Xfer+0x2a8>
80168a74:	e3e03008 	mvn	r3, #8
80168a78:	ea0000df 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
80168a7c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168a80:	e1a03c23 	lsr	r3, r3, #24
80168a84:	e3530003 	cmp	r3, #3
80168a88:	0a000001 	beq	80168a94 <_RME_Thd_Time_Xfer+0x2c0>
80168a8c:	e3e03001 	mvn	r3, #1
80168a90:	ea0000d9 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
80168a94:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80168a98:	e203207f 	and	r2, r3, #127	@ 0x7f
80168a9c:	e51b300c 	ldr	r3, [fp, #-12]
80168aa0:	e5933014 	ldr	r3, [r3, #20]
80168aa4:	e1520003 	cmp	r2, r3
80168aa8:	3a000001 	bcc	80168ab4 <_RME_Thd_Time_Xfer+0x2e0>
80168aac:	e3e03002 	mvn	r3, #2
80168ab0:	ea0000d1 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
80168ab4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80168ab8:	e203307f 	and	r3, r3, #127	@ 0x7f
80168abc:	e1a02283 	lsl	r2, r3, #5
80168ac0:	e51b300c 	ldr	r3, [fp, #-12]
80168ac4:	e593300c 	ldr	r3, [r3, #12]
80168ac8:	e0823003 	add	r3, r2, r3
80168acc:	e50b300c 	str	r3, [fp, #-12]
80168ad0:	e51b300c 	ldr	r3, [fp, #-12]
80168ad4:	e1a00003 	mov	r0, r3
80168ad8:	ebffdf08 	bl	80160700 <__RME_A7A_Read_Acquire>
80168adc:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80168ae0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168ae4:	e1a03823 	lsr	r3, r3, #16
80168ae8:	e6ef3073 	uxtb	r3, r3
80168aec:	e3530002 	cmp	r3, #2
80168af0:	1a000001 	bne	80168afc <_RME_Thd_Time_Xfer+0x328>
80168af4:	e3e03008 	mvn	r3, #8
80168af8:	ea0000bf 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
80168afc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168b00:	e1a03c23 	lsr	r3, r3, #24
80168b04:	e3530006 	cmp	r3, #6
80168b08:	0a000001 	beq	80168b14 <_RME_Thd_Time_Xfer+0x340>
80168b0c:	e3e03001 	mvn	r3, #1
80168b10:	ea0000b9 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
                   struct RME_Cap_Thd*,Thd_Src_Op,Type_Stat);
    /* Check if the target cap is not frozen and allows such operations */
    RME_CAP_CHECK(Thd_Dst_Op,RME_THD_FLAG_XFER_DST);
80168b14:	e51b3008 	ldr	r3, [fp, #-8]
80168b18:	e5933008 	ldr	r3, [r3, #8]
80168b1c:	e2033080 	and	r3, r3, #128	@ 0x80
80168b20:	e3530000 	cmp	r3, #0
80168b24:	1a000001 	bne	80168b30 <_RME_Thd_Time_Xfer+0x35c>
80168b28:	e3e03006 	mvn	r3, #6
80168b2c:	ea0000b2 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
    RME_CAP_CHECK(Thd_Src_Op,RME_THD_FLAG_XFER_SRC);
80168b30:	e51b300c 	ldr	r3, [fp, #-12]
80168b34:	e5933008 	ldr	r3, [r3, #8]
80168b38:	e2033040 	and	r3, r3, #64	@ 0x40
80168b3c:	e3530000 	cmp	r3, #0
80168b40:	1a000001 	bne	80168b4c <_RME_Thd_Time_Xfer+0x378>
80168b44:	e3e03006 	mvn	r3, #6
80168b48:	ea0000ab 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>

    /* Check if the two threads are on the core that is accordance with what we are on */
    Local=RME_CPU_LOCAL();
80168b4c:	e30d3004 	movw	r3, #53252	@ 0xd004
80168b50:	e3483016 	movt	r3, #32790	@ 0x8016
80168b54:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Thd_Src=RME_CAP_GETOBJ(Thd_Src_Op,struct RME_Thd_Struct*);
80168b58:	e51b300c 	ldr	r3, [fp, #-12]
80168b5c:	e593300c 	ldr	r3, [r3, #12]
80168b60:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    if(Thd_Src->Sched.Local!=Local)
80168b64:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168b68:	e5933014 	ldr	r3, [r3, #20]
80168b6c:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80168b70:	e1520003 	cmp	r2, r3
80168b74:	0a000001 	beq	80168b80 <_RME_Thd_Time_Xfer+0x3ac>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
80168b78:	e3e030cb 	mvn	r3, #203	@ 0xcb
80168b7c:	ea00009e 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Check if we have slices to transfer; 0 implies TIMEOUT, BLOCKED, or EXCPEND */
    if(Thd_Src->Sched.Slice==0U)
80168b80:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168b84:	e5933018 	ldr	r3, [r3, #24]
80168b88:	e3530000 	cmp	r3, #0
80168b8c:	1a000001 	bne	80168b98 <_RME_Thd_Time_Xfer+0x3c4>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
80168b90:	e3e030cb 	mvn	r3, #203	@ 0xcb
80168b94:	ea000098 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
    {
        RME_COV_MARKER();
        /* No action required */
    }
    
    Thd_Dst=RME_CAP_GETOBJ(Thd_Dst_Op,struct RME_Thd_Struct*);
80168b98:	e51b3008 	ldr	r3, [fp, #-8]
80168b9c:	e593300c 	ldr	r3, [r3, #12]
80168ba0:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
    
    if(Thd_Dst->Sched.Local!=Local)
80168ba4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168ba8:	e5933014 	ldr	r3, [r3, #20]
80168bac:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80168bb0:	e1520003 	cmp	r2, r3
80168bb4:	0a000001 	beq	80168bc0 <_RME_Thd_Time_Xfer+0x3ec>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
80168bb8:	e3e030cb 	mvn	r3, #203	@ 0xcb
80168bbc:	ea00008e 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
        /* No action required */
    }

    /* The destination must never have higher maximum priority than the source,
     * unless it is a init thread which could be used as a black hole */
    if((Thd_Src->Sched.Prio_Max<Thd_Dst->Sched.Prio_Max)&&
80168bc0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168bc4:	e5932024 	ldr	r2, [r3, #36]	@ 0x24
80168bc8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168bcc:	e5933024 	ldr	r3, [r3, #36]	@ 0x24
80168bd0:	e1520003 	cmp	r2, r3
80168bd4:	2a000005 	bcs	80168bf0 <_RME_Thd_Time_Xfer+0x41c>
       (Thd_Dst->Sched.Slice!=RME_THD_INIT_TIME))
80168bd8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168bdc:	e5933018 	ldr	r3, [r3, #24]
    if((Thd_Src->Sched.Prio_Max<Thd_Dst->Sched.Prio_Max)&&
80168be0:	e3730106 	cmn	r3, #-2147483647	@ 0x80000001
80168be4:	0a000001 	beq	80168bf0 <_RME_Thd_Time_Xfer+0x41c>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_PRIO;
80168be8:	e3e030cc 	mvn	r3, #204	@ 0xcc
80168bec:	ea000082 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Delegating from a normal thread */
    if(Thd_Src->Sched.Slice<RME_THD_INF_TIME)
80168bf0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168bf4:	e5933018 	ldr	r3, [r3, #24]
80168bf8:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
80168bfc:	8a000032 	bhi	80168ccc <_RME_Thd_Time_Xfer+0x4f8>
    {
        RME_COV_MARKER();

        /* Delegate all our time */
        if(Time>=RME_THD_INF_TIME)
80168c00:	e59b3004 	ldr	r3, [fp, #4]
80168c04:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
80168c08:	9a000003 	bls	80168c1c <_RME_Thd_Time_Xfer+0x448>
        {
            RME_COV_MARKER();

            Time_Xfer=Thd_Src->Sched.Slice;
80168c0c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168c10:	e5933018 	ldr	r3, [r3, #24]
80168c14:	e50b3010 	str	r3, [fp, #-16]
80168c18:	ea00000a 	b	80168c48 <_RME_Thd_Time_Xfer+0x474>
        /* Delegate some time, if not sufficient, clean up the source time */
        else
        {
            RME_COV_MARKER();
            
            if(Thd_Src->Sched.Slice>Time)
80168c1c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168c20:	e5933018 	ldr	r3, [r3, #24]
80168c24:	e59b2004 	ldr	r2, [fp, #4]
80168c28:	e1520003 	cmp	r2, r3
80168c2c:	2a000002 	bcs	80168c3c <_RME_Thd_Time_Xfer+0x468>
            {
                RME_COV_MARKER();

                Time_Xfer=Time;
80168c30:	e59b3004 	ldr	r3, [fp, #4]
80168c34:	e50b3010 	str	r3, [fp, #-16]
80168c38:	ea000002 	b	80168c48 <_RME_Thd_Time_Xfer+0x474>
            }
            else
            {
                RME_COV_MARKER();

                Time_Xfer=Thd_Src->Sched.Slice;
80168c3c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168c40:	e5933018 	ldr	r3, [r3, #24]
80168c44:	e50b3010 	str	r3, [fp, #-16]
            }
        }
        
        /* See if we are transferring to an infinite budget thread. If yes, we
         * are revoking timeslices; If not, this is a finite transfer */
        if(Thd_Dst->Sched.Slice<RME_THD_INF_TIME)
80168c48:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168c4c:	e5933018 	ldr	r3, [r3, #24]
80168c50:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
80168c54:	8a000015 	bhi	80168cb0 <_RME_Thd_Time_Xfer+0x4dc>
        {
            RME_COV_MARKER();
            
            RME_TIME_CHECK(Thd_Dst->Sched.Slice,Time_Xfer);
80168c58:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168c5c:	e5932018 	ldr	r2, [r3, #24]
80168c60:	e51b3010 	ldr	r3, [fp, #-16]
80168c64:	e0823003 	add	r3, r2, r3
80168c68:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
80168c6c:	8a000007 	bhi	80168c90 <_RME_Thd_Time_Xfer+0x4bc>
80168c70:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168c74:	e5932018 	ldr	r2, [r3, #24]
80168c78:	e51b3010 	ldr	r3, [fp, #-16]
80168c7c:	e0822003 	add	r2, r2, r3
80168c80:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168c84:	e5933018 	ldr	r3, [r3, #24]
80168c88:	e1520003 	cmp	r2, r3
80168c8c:	2a000001 	bcs	80168c98 <_RME_Thd_Time_Xfer+0x4c4>
80168c90:	e3e030cf 	mvn	r3, #207	@ 0xcf
80168c94:	ea000058 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
            Thd_Dst->Sched.Slice+=Time_Xfer;
80168c98:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168c9c:	e5932018 	ldr	r2, [r3, #24]
80168ca0:	e51b3010 	ldr	r3, [fp, #-16]
80168ca4:	e0822003 	add	r2, r2, r3
80168ca8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168cac:	e5832018 	str	r2, [r3, #24]
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        Thd_Src->Sched.Slice-=Time_Xfer;
80168cb0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168cb4:	e5932018 	ldr	r2, [r3, #24]
80168cb8:	e51b3010 	ldr	r3, [fp, #-16]
80168cbc:	e0422003 	sub	r2, r2, r3
80168cc0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168cc4:	e5832018 	str	r2, [r3, #24]
80168cc8:	ea00002a 	b	80168d78 <_RME_Thd_Time_Xfer+0x5a4>
    else
    {
        RME_COV_MARKER();

        /* Infinite transfer to the destination */
        if(Time>=RME_THD_INF_TIME)
80168ccc:	e59b3004 	ldr	r3, [fp, #4]
80168cd0:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
80168cd4:	9a000011 	bls	80168d20 <_RME_Thd_Time_Xfer+0x54c>
        {
            RME_COV_MARKER();

            /* This transfer will revoke the infinite budget */
            if(Time==RME_THD_INIT_TIME)
80168cd8:	e59b3004 	ldr	r3, [fp, #4]
80168cdc:	e3730106 	cmn	r3, #-2147483647	@ 0x80000001
80168ce0:	1a000006 	bne	80168d00 <_RME_Thd_Time_Xfer+0x52c>
            {
                RME_COV_MARKER();
                
                /* Will not revoke, source is an init thread */
                if(Thd_Src->Sched.Slice!=RME_THD_INIT_TIME)
80168ce4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168ce8:	e5933018 	ldr	r3, [r3, #24]
80168cec:	e3730106 	cmn	r3, #-2147483647	@ 0x80000001
80168cf0:	0a000002 	beq	80168d00 <_RME_Thd_Time_Xfer+0x52c>
                {
                    RME_COV_MARKER();
                    
                    Thd_Src->Sched.Slice=0U;
80168cf4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168cf8:	e3a02000 	mov	r2, #0
80168cfc:	e5832018 	str	r2, [r3, #24]
                RME_COV_MARKER();
                /* No action required */
            }
            
            /* Set destination to infinite if it is not an init thread */
            if(Thd_Dst->Sched.Slice<RME_THD_INF_TIME)
80168d00:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168d04:	e5933018 	ldr	r3, [r3, #24]
80168d08:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
80168d0c:	8a000019 	bhi	80168d78 <_RME_Thd_Time_Xfer+0x5a4>
            {
                RME_COV_MARKER();
                
                Thd_Dst->Sched.Slice=RME_THD_INF_TIME;
80168d10:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168d14:	e3e02106 	mvn	r2, #-2147483647	@ 0x80000001
80168d18:	e5832018 	str	r2, [r3, #24]
80168d1c:	ea000015 	b	80168d78 <_RME_Thd_Time_Xfer+0x5a4>
        else
        {
            RME_COV_MARKER();

            /* Just increase the budget of the other thread - check first */
            RME_TIME_CHECK(Thd_Dst->Sched.Slice,Time);
80168d20:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168d24:	e5932018 	ldr	r2, [r3, #24]
80168d28:	e59b3004 	ldr	r3, [fp, #4]
80168d2c:	e0823003 	add	r3, r2, r3
80168d30:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
80168d34:	8a000007 	bhi	80168d58 <_RME_Thd_Time_Xfer+0x584>
80168d38:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168d3c:	e5932018 	ldr	r2, [r3, #24]
80168d40:	e59b3004 	ldr	r3, [fp, #4]
80168d44:	e0822003 	add	r2, r2, r3
80168d48:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168d4c:	e5933018 	ldr	r3, [r3, #24]
80168d50:	e1520003 	cmp	r2, r3
80168d54:	2a000001 	bcs	80168d60 <_RME_Thd_Time_Xfer+0x58c>
80168d58:	e3e030cf 	mvn	r3, #207	@ 0xcf
80168d5c:	ea000026 	b	80168dfc <_RME_Thd_Time_Xfer+0x628>
            Thd_Dst->Sched.Slice+=Time;
80168d60:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168d64:	e5932018 	ldr	r2, [r3, #24]
80168d68:	e59b3004 	ldr	r3, [fp, #4]
80168d6c:	e0822003 	add	r2, r2, r3
80168d70:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168d74:	e5832018 	str	r2, [r3, #24]
        }
    }

    /* Is the source time used up? If yes, delete it from the run queue, and notify its 
     * parent. If it is not in the run queue, The state of the source must be BLOCKED. */
    if(Thd_Src->Sched.Slice==0U)
80168d78:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168d7c:	e5933018 	ldr	r3, [r3, #24]
80168d80:	e3530000 	cmp	r3, #0
80168d84:	1a00000a 	bne	80168db4 <_RME_Thd_Time_Xfer+0x5e0>
        
        /* If it is blocked or have an exception, we neither change its state nor send
         * the scheduler notification. It will be sent when the thread unblocks, or gets
         * its exception handled. The rule of the thumb is, we only send scheduler 
         * notifications when the thread really enter TIMEOUT or EXCPEND state. */
        if(Thd_Src->Sched.State==RME_THD_READY)
80168d88:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168d8c:	e593301c 	ldr	r3, [r3, #28]
80168d90:	e3530000 	cmp	r3, #0
80168d94:	1a000006 	bne	80168db4 <_RME_Thd_Time_Xfer+0x5e0>
        {
            RME_COV_MARKER();
            
            /* Remove from runqueue */
            _RME_Run_Del(Thd_Src);
80168d98:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80168d9c:	ebfff0b5 	bl	80165078 <_RME_Run_Del>
            
            /* Timeout and notify parent */
            Thd_Src->Sched.State=RME_THD_TIMEOUT;
80168da0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168da4:	e3a02002 	mov	r2, #2
80168da8:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Notif(Thd_Src);
80168dac:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80168db0:	ebfff124 	bl	80165248 <_RME_Run_Notif>
        /* No action required */
    }

    /* Now save the system call return value to the caller 
     * stack - how much time the destination have now */
    __RME_Svc_Retval_Set(Reg,(rme_ret_t)(Thd_Dst->Sched.Slice));
80168db4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168db8:	e5933018 	ldr	r3, [r3, #24]
80168dbc:	e1a01003 	mov	r1, r3
80168dc0:	e51b002c 	ldr	r0, [fp, #-44]	@ 0xffffffd4
80168dc4:	eb000af2 	bl	8016b994 <__RME_Svc_Retval_Set>

    /* See what was the state of the destination thread. If it is timeout, then activate
     * it. If it is BLOCKED or EXCPEND, then leave it alone, and it will be activated
     * when it unblocks or when the exception is handled. */
    if(Thd_Dst->Sched.State==RME_THD_TIMEOUT)
80168dc8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168dcc:	e593301c 	ldr	r3, [r3, #28]
80168dd0:	e3530002 	cmp	r3, #2
80168dd4:	1a000004 	bne	80168dec <_RME_Thd_Time_Xfer+0x618>
    {
        RME_COV_MARKER();

        /* Ready and add to runqueue */
        Thd_Dst->Sched.State=RME_THD_READY;
80168dd8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168ddc:	e3a02000 	mov	r2, #0
80168de0:	e583201c 	str	r2, [r3, #28]
        _RME_Run_Ins(Thd_Dst);
80168de4:	e51b0020 	ldr	r0, [fp, #-32]	@ 0xffffffe0
80168de8:	ebfff06b 	bl	80164f9c <_RME_Run_Ins>
        RME_COV_MARKER();
    }
    
    /* All possible kernel send (scheduler notifications) done,
     * now pick the highest priority thread to run */
    _RME_Kern_High(Reg,Local);
80168dec:	e51b1018 	ldr	r1, [fp, #-24]	@ 0xffffffe8
80168df0:	e51b002c 	ldr	r0, [fp, #-44]	@ 0xffffffd4
80168df4:	eb00026a 	bl	801697a4 <_RME_Kern_High>

    return 0;
80168df8:	e3a03000 	mov	r3, #0
}
80168dfc:	e1a00003 	mov	r0, r3
80168e00:	e24bd004 	sub	sp, fp, #4
80168e04:	e8bd8800 	pop	{fp, pc}

80168e08 <_RME_Thd_Swt>:
******************************************************************************/
static rme_ret_t _RME_Thd_Swt(struct RME_Cap_Cpt* Cpt,
                              struct RME_Reg_Struct* Reg,
                              rme_cid_t Cap_Thd,
                              rme_ptr_t Is_Yield)
{
80168e08:	e92d4800 	push	{fp, lr}
80168e0c:	e28db004 	add	fp, sp, #4
80168e10:	e24dd028 	sub	sp, sp, #40	@ 0x28
80168e14:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
80168e18:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
80168e1c:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
80168e20:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
    struct RME_Thd_Struct* Thd_High;
    struct RME_CPU_Local* Local;
    struct RME_Thd_Struct* Thd_Cur;
    rme_ptr_t Type_Stat;

    Local=RME_CPU_LOCAL();
80168e24:	e30d3004 	movw	r3, #53252	@ 0xd004
80168e28:	e3483016 	movt	r3, #32790	@ 0x8016
80168e2c:	e50b3010 	str	r3, [fp, #-16]
    Thd_Cur=Local->Thd_Cur;
80168e30:	e51b3010 	ldr	r3, [fp, #-16]
80168e34:	e5933004 	ldr	r3, [r3, #4]
80168e38:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    
    /* The caller have picked a thread to switch to */
    if(Cap_Thd<RME_CID_NULL)
80168e3c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168e40:	e3530902 	cmp	r3, #32768	@ 0x8000
80168e44:	aa0000a9 	bge	801690f0 <_RME_Thd_Swt+0x2e8>
    {
        RME_COV_MARKER();
        
        RME_CPT_GETCAP(Cpt,Cap_Thd,RME_CAP_TYPE_THD,
80168e48:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168e4c:	e2033080 	and	r3, r3, #128	@ 0x80
80168e50:	e3530000 	cmp	r3, #0
80168e54:	1a00001d 	bne	80168ed0 <_RME_Thd_Swt+0xc8>
80168e58:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168e5c:	e5932014 	ldr	r2, [r3, #20]
80168e60:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168e64:	e1520003 	cmp	r2, r3
80168e68:	8a000001 	bhi	80168e74 <_RME_Thd_Swt+0x6c>
80168e6c:	e3e03002 	mvn	r3, #2
80168e70:	ea0000e2 	b	80169200 <_RME_Thd_Swt+0x3f8>
80168e74:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168e78:	e1a02283 	lsl	r2, r3, #5
80168e7c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168e80:	e593300c 	ldr	r3, [r3, #12]
80168e84:	e0823003 	add	r3, r2, r3
80168e88:	e50b3008 	str	r3, [fp, #-8]
80168e8c:	e51b3008 	ldr	r3, [fp, #-8]
80168e90:	e1a00003 	mov	r0, r3
80168e94:	ebffde19 	bl	80160700 <__RME_A7A_Read_Acquire>
80168e98:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80168e9c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168ea0:	e1a03823 	lsr	r3, r3, #16
80168ea4:	e6ef3073 	uxtb	r3, r3
80168ea8:	e3530002 	cmp	r3, #2
80168eac:	1a000001 	bne	80168eb8 <_RME_Thd_Swt+0xb0>
80168eb0:	e3e03008 	mvn	r3, #8
80168eb4:	ea0000d1 	b	80169200 <_RME_Thd_Swt+0x3f8>
80168eb8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168ebc:	e1a03c23 	lsr	r3, r3, #24
80168ec0:	e3530006 	cmp	r3, #6
80168ec4:	0a000041 	beq	80168fd0 <_RME_Thd_Swt+0x1c8>
80168ec8:	e3e03001 	mvn	r3, #1
80168ecc:	ea0000cb 	b	80169200 <_RME_Thd_Swt+0x3f8>
80168ed0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168ed4:	e1a02423 	lsr	r2, r3, #8
80168ed8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168edc:	e5933014 	ldr	r3, [r3, #20]
80168ee0:	e1520003 	cmp	r2, r3
80168ee4:	3a000001 	bcc	80168ef0 <_RME_Thd_Swt+0xe8>
80168ee8:	e3e03002 	mvn	r3, #2
80168eec:	ea0000c3 	b	80169200 <_RME_Thd_Swt+0x3f8>
80168ef0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168ef4:	e1a03423 	lsr	r3, r3, #8
80168ef8:	e1a02283 	lsl	r2, r3, #5
80168efc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168f00:	e593300c 	ldr	r3, [r3, #12]
80168f04:	e0823003 	add	r3, r2, r3
80168f08:	e50b3008 	str	r3, [fp, #-8]
80168f0c:	e51b3008 	ldr	r3, [fp, #-8]
80168f10:	e1a00003 	mov	r0, r3
80168f14:	ebffddf9 	bl	80160700 <__RME_A7A_Read_Acquire>
80168f18:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80168f1c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168f20:	e1a03823 	lsr	r3, r3, #16
80168f24:	e6ef3073 	uxtb	r3, r3
80168f28:	e3530002 	cmp	r3, #2
80168f2c:	1a000001 	bne	80168f38 <_RME_Thd_Swt+0x130>
80168f30:	e3e03008 	mvn	r3, #8
80168f34:	ea0000b1 	b	80169200 <_RME_Thd_Swt+0x3f8>
80168f38:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168f3c:	e1a03c23 	lsr	r3, r3, #24
80168f40:	e3530003 	cmp	r3, #3
80168f44:	0a000001 	beq	80168f50 <_RME_Thd_Swt+0x148>
80168f48:	e3e03001 	mvn	r3, #1
80168f4c:	ea0000ab 	b	80169200 <_RME_Thd_Swt+0x3f8>
80168f50:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168f54:	e203207f 	and	r2, r3, #127	@ 0x7f
80168f58:	e51b3008 	ldr	r3, [fp, #-8]
80168f5c:	e5933014 	ldr	r3, [r3, #20]
80168f60:	e1520003 	cmp	r2, r3
80168f64:	3a000001 	bcc	80168f70 <_RME_Thd_Swt+0x168>
80168f68:	e3e03002 	mvn	r3, #2
80168f6c:	ea0000a3 	b	80169200 <_RME_Thd_Swt+0x3f8>
80168f70:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168f74:	e203307f 	and	r3, r3, #127	@ 0x7f
80168f78:	e1a02283 	lsl	r2, r3, #5
80168f7c:	e51b3008 	ldr	r3, [fp, #-8]
80168f80:	e593300c 	ldr	r3, [r3, #12]
80168f84:	e0823003 	add	r3, r2, r3
80168f88:	e50b3008 	str	r3, [fp, #-8]
80168f8c:	e51b3008 	ldr	r3, [fp, #-8]
80168f90:	e1a00003 	mov	r0, r3
80168f94:	ebffddd9 	bl	80160700 <__RME_A7A_Read_Acquire>
80168f98:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80168f9c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168fa0:	e1a03823 	lsr	r3, r3, #16
80168fa4:	e6ef3073 	uxtb	r3, r3
80168fa8:	e3530002 	cmp	r3, #2
80168fac:	1a000001 	bne	80168fb8 <_RME_Thd_Swt+0x1b0>
80168fb0:	e3e03008 	mvn	r3, #8
80168fb4:	ea000091 	b	80169200 <_RME_Thd_Swt+0x3f8>
80168fb8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168fbc:	e1a03c23 	lsr	r3, r3, #24
80168fc0:	e3530006 	cmp	r3, #6
80168fc4:	0a000001 	beq	80168fd0 <_RME_Thd_Swt+0x1c8>
80168fc8:	e3e03001 	mvn	r3, #1
80168fcc:	ea00008b 	b	80169200 <_RME_Thd_Swt+0x3f8>
                       struct RME_Cap_Thd*,Thd_Cap_New,Type_Stat);
        /* Check if the target cap is not frozen and allows such operations */
        RME_CAP_CHECK(Thd_Cap_New,RME_THD_FLAG_SWT);
80168fd0:	e51b3008 	ldr	r3, [fp, #-8]
80168fd4:	e5933008 	ldr	r3, [r3, #8]
80168fd8:	e2033c01 	and	r3, r3, #256	@ 0x100
80168fdc:	e3530000 	cmp	r3, #0
80168fe0:	1a000001 	bne	80168fec <_RME_Thd_Swt+0x1e4>
80168fe4:	e3e03006 	mvn	r3, #6
80168fe8:	ea000084 	b	80169200 <_RME_Thd_Swt+0x3f8>
        /* See if we can do operation on this core */
        Thd_New=RME_CAP_GETOBJ(Thd_Cap_New,struct RME_Thd_Struct*);
80168fec:	e51b3008 	ldr	r3, [fp, #-8]
80168ff0:	e593300c 	ldr	r3, [r3, #12]
80168ff4:	e50b300c 	str	r3, [fp, #-12]
        if(Thd_New->Sched.Local!=Local)
80168ff8:	e51b300c 	ldr	r3, [fp, #-12]
80168ffc:	e5933014 	ldr	r3, [r3, #20]
80169000:	e51b2010 	ldr	r2, [fp, #-16]
80169004:	e1520003 	cmp	r2, r3
80169008:	0a000001 	beq	80169014 <_RME_Thd_Swt+0x20c>
        {
            RME_COV_MARKER();

            return RME_ERR_PTH_INVSTATE;
8016900c:	e3e030cb 	mvn	r3, #203	@ 0xcb
80169010:	ea00007a 	b	80169200 <_RME_Thd_Swt+0x3f8>
            RME_COV_MARKER();
            /* No action required */
        }
            
        /* See if we can yield to the thread */
        if(Thd_Cur->Sched.Prio!=Thd_New->Sched.Prio)
80169014:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169018:	e5932020 	ldr	r2, [r3, #32]
8016901c:	e51b300c 	ldr	r3, [fp, #-12]
80169020:	e5933020 	ldr	r3, [r3, #32]
80169024:	e1520003 	cmp	r2, r3
80169028:	0a000001 	beq	80169034 <_RME_Thd_Swt+0x22c>
        {
            RME_COV_MARKER();

            return RME_ERR_PTH_PRIO;
8016902c:	e3e030cc 	mvn	r3, #204	@ 0xcc
80169030:	ea000072 	b	80169200 <_RME_Thd_Swt+0x3f8>
            RME_COV_MARKER();
            /* No action required */
        }
            
        /* Check if the target thread state is valid */
        if((Thd_New->Sched.State==RME_THD_BLOCKED)||
80169034:	e51b300c 	ldr	r3, [fp, #-12]
80169038:	e593301c 	ldr	r3, [r3, #28]
8016903c:	e3530001 	cmp	r3, #1
80169040:	0a000007 	beq	80169064 <_RME_Thd_Swt+0x25c>
           (Thd_New->Sched.State==RME_THD_TIMEOUT)||
80169044:	e51b300c 	ldr	r3, [fp, #-12]
80169048:	e593301c 	ldr	r3, [r3, #28]
        if((Thd_New->Sched.State==RME_THD_BLOCKED)||
8016904c:	e3530002 	cmp	r3, #2
80169050:	0a000003 	beq	80169064 <_RME_Thd_Swt+0x25c>
           (Thd_New->Sched.State==RME_THD_EXCPEND))
80169054:	e51b300c 	ldr	r3, [fp, #-12]
80169058:	e593301c 	ldr	r3, [r3, #28]
           (Thd_New->Sched.State==RME_THD_TIMEOUT)||
8016905c:	e3530003 	cmp	r3, #3
80169060:	1a000001 	bne	8016906c <_RME_Thd_Swt+0x264>
        {
            RME_COV_MARKER();

            return RME_ERR_PTH_INVSTATE;
80169064:	e3e030cb 	mvn	r3, #203	@ 0xcb
80169068:	ea000064 	b	80169200 <_RME_Thd_Swt+0x3f8>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* See if we need to give up all our timeslices in this yield */
        if((Is_Yield!=0U)&&(Thd_Cur->Sched.Slice<RME_THD_INF_TIME))
8016906c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80169070:	e3530000 	cmp	r3, #0
80169074:	0a000043 	beq	80169188 <_RME_Thd_Swt+0x380>
80169078:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016907c:	e5933018 	ldr	r3, [r3, #24]
80169080:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
80169084:	8a00003f 	bhi	80169188 <_RME_Thd_Swt+0x380>
        {
            RME_COV_MARKER();
            
            /* Deprive all timeslices and remove from runqueue */
            Thd_Cur->Sched.Slice=0U;
80169088:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016908c:	e3a02000 	mov	r2, #0
80169090:	e5832018 	str	r2, [r3, #24]
            _RME_Run_Del(Thd_Cur);
80169094:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80169098:	ebffeff6 	bl	80165078 <_RME_Run_Del>
            
            /* Timeout and notify parent */
            Thd_Cur->Sched.State=RME_THD_TIMEOUT;
8016909c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801690a0:	e3a02002 	mov	r2, #2
801690a4:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Notif(Thd_Cur);
801690a8:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801690ac:	ebfff065 	bl	80165248 <_RME_Run_Notif>
            
            /* Because we have sent a notification, we could have unblocked a
             * thread at higher priority. Additionally, if the new thread is
             * the current thread, we are forced to switch to someone else,
             * because the current thread's timeslice must be exhausted. */
            Thd_High=_RME_Run_High(Local);
801690b0:	e51b0010 	ldr	r0, [fp, #-16]
801690b4:	ebfff02d 	bl	80165170 <_RME_Run_High>
801690b8:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
            if((Thd_High->Sched.Prio>Thd_New->Sched.Prio)||(Thd_Cur==Thd_New))
801690bc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801690c0:	e5932020 	ldr	r2, [r3, #32]
801690c4:	e51b300c 	ldr	r3, [fp, #-12]
801690c8:	e5933020 	ldr	r3, [r3, #32]
801690cc:	e1520003 	cmp	r2, r3
801690d0:	8a000003 	bhi	801690e4 <_RME_Thd_Swt+0x2dc>
801690d4:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
801690d8:	e51b300c 	ldr	r3, [fp, #-12]
801690dc:	e1520003 	cmp	r2, r3
801690e0:	1a000028 	bne	80169188 <_RME_Thd_Swt+0x380>
            {
                RME_COV_MARKER();

                Thd_New=Thd_High;
801690e4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801690e8:	e50b300c 	str	r3, [fp, #-12]
801690ec:	ea000025 	b	80169188 <_RME_Thd_Swt+0x380>
    else
    {
        RME_COV_MARKER();
        
        /* See if we need to give up all our timeslices in this yield */
        if((Is_Yield!=0U)&&(Thd_Cur->Sched.Slice<RME_THD_INF_TIME))
801690f0:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801690f4:	e3530000 	cmp	r3, #0
801690f8:	0a00000e 	beq	80169138 <_RME_Thd_Swt+0x330>
801690fc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169100:	e5933018 	ldr	r3, [r3, #24]
80169104:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
80169108:	8a00000a 	bhi	80169138 <_RME_Thd_Swt+0x330>
        {
            RME_COV_MARKER();
            
            /* Deprive all timeslices and remove from runqueue */
            Thd_Cur->Sched.Slice=0U;
8016910c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169110:	e3a02000 	mov	r2, #0
80169114:	e5832018 	str	r2, [r3, #24]
            _RME_Run_Del(Thd_Cur);
80169118:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016911c:	ebffefd5 	bl	80165078 <_RME_Run_Del>
            
            /* Timeout and notify parent */
            Thd_Cur->Sched.State=RME_THD_TIMEOUT;
80169120:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169124:	e3a02002 	mov	r2, #2
80169128:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Notif(Thd_Cur);
8016912c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80169130:	ebfff044 	bl	80165248 <_RME_Run_Notif>
80169134:	ea000010 	b	8016917c <_RME_Thd_Swt+0x374>
        {
            RME_COV_MARKER();
            
            /* This operation is just to make sure that if there are any other
             * thread at the same priority level, we're not switching to ourself */
            RME_ASSERT(Thd_Cur->Sched.State==RME_THD_READY);
80169138:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016913c:	e593301c 	ldr	r3, [r3, #28]
80169140:	e3530000 	cmp	r3, #0
80169144:	0a000008 	beq	8016916c <_RME_Thd_Swt+0x364>
80169148:	e30c3318 	movw	r3, #49944	@ 0xc318
8016914c:	e3483016 	movt	r3, #32790	@ 0x8016
80169150:	e30c2324 	movw	r2, #49956	@ 0xc324
80169154:	e3482016 	movt	r2, #32790	@ 0x8016
80169158:	e3011a15 	movw	r1, #6677	@ 0x1a15
8016915c:	e30c0330 	movw	r0, #49968	@ 0xc330
80169160:	e3480016 	movt	r0, #32790	@ 0x8016
80169164:	ebffde86 	bl	80160b84 <RME_Log>
80169168:	eafffffe 	b	80169168 <_RME_Thd_Swt+0x360>
            _RME_Run_Del(Thd_Cur);
8016916c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80169170:	ebffefc0 	bl	80165078 <_RME_Run_Del>
            _RME_Run_Ins(Thd_Cur);
80169174:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80169178:	ebffef87 	bl	80164f9c <_RME_Run_Ins>
        }
        
        Thd_New=_RME_Run_High(Local);
8016917c:	e51b0010 	ldr	r0, [fp, #-16]
80169180:	ebffeffa 	bl	80165170 <_RME_Run_High>
80169184:	e50b000c 	str	r0, [fp, #-12]
    }
    
    /* Now that we are successful, save the return value to the caller stack */
    __RME_Svc_Retval_Set(Reg,0);
80169188:	e3a01000 	mov	r1, #0
8016918c:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
80169190:	eb0009ff 	bl	8016b994 <__RME_Svc_Retval_Set>

    RME_ASSERT(Thd_New->Sched.State==RME_THD_READY);
80169194:	e51b300c 	ldr	r3, [fp, #-12]
80169198:	e593301c 	ldr	r3, [r3, #28]
8016919c:	e3530000 	cmp	r3, #0
801691a0:	0a000008 	beq	801691c8 <_RME_Thd_Swt+0x3c0>
801691a4:	e30c3318 	movw	r3, #49944	@ 0xc318
801691a8:	e3483016 	movt	r3, #32790	@ 0x8016
801691ac:	e30c2324 	movw	r2, #49956	@ 0xc324
801691b0:	e3482016 	movt	r2, #32790	@ 0x8016
801691b4:	e3011a20 	movw	r1, #6688	@ 0x1a20
801691b8:	e30c0330 	movw	r0, #49968	@ 0xc330
801691bc:	e3480016 	movt	r0, #32790	@ 0x8016
801691c0:	ebffde6f 	bl	80160b84 <RME_Log>
801691c4:	eafffffe 	b	801691c4 <_RME_Thd_Swt+0x3bc>
    /* We cannot call _RME_Kern_High because it picks some random thread. Instead,
     * we use a manual implementation that is faster than the _RME_Kern_High. */
    if(Thd_Cur==Thd_New)
801691c8:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
801691cc:	e51b300c 	ldr	r3, [fp, #-12]
801691d0:	e1520003 	cmp	r2, r3
801691d4:	1a000001 	bne	801691e0 <_RME_Thd_Swt+0x3d8>
    {
        RME_COV_MARKER();
        
        return 0;
801691d8:	e3a03000 	mov	r3, #0
801691dc:	ea000007 	b	80169200 <_RME_Thd_Swt+0x3f8>
        RME_COV_MARKER();
        /* No action required */
    }
            
    /* We have a solid context switch at this point */
    _RME_Run_Swt(Reg,Thd_Cur,Thd_New);
801691e0:	e51b200c 	ldr	r2, [fp, #-12]
801691e4:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
801691e8:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
801691ec:	ebfff052 	bl	8016533c <_RME_Run_Swt>
    Local->Thd_Cur=Thd_New;
801691f0:	e51b3010 	ldr	r3, [fp, #-16]
801691f4:	e51b200c 	ldr	r2, [fp, #-12]
801691f8:	e5832004 	str	r2, [r3, #4]

    return 0;
801691fc:	e3a03000 	mov	r3, #0
}
80169200:	e1a00003 	mov	r0, r3
80169204:	e24bd004 	sub	sp, fp, #4
80169208:	e8bd8800 	pop	{fp, pc}

8016920c <_RME_Sig_Crt>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Sig_Crt(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt,
                              rme_cid_t Cap_Sig)
{
8016920c:	e92d4800 	push	{fp, lr}
80169210:	e28db004 	add	fp, sp, #4
80169214:	e24dd020 	sub	sp, sp, #32
80169218:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
8016921c:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
80169220:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    struct RME_Cap_Cpt* Cpt_Op;
    volatile struct RME_Cap_Sig* Sig_Crt;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
80169224:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169228:	e2033080 	and	r3, r3, #128	@ 0x80
8016922c:	e3530000 	cmp	r3, #0
80169230:	1a00001d 	bne	801692ac <_RME_Sig_Crt+0xa0>
80169234:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169238:	e5932014 	ldr	r2, [r3, #20]
8016923c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169240:	e1520003 	cmp	r2, r3
80169244:	8a000001 	bhi	80169250 <_RME_Sig_Crt+0x44>
80169248:	e3e03002 	mvn	r3, #2
8016924c:	ea00008d 	b	80169488 <_RME_Sig_Crt+0x27c>
80169250:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169254:	e1a02283 	lsl	r2, r3, #5
80169258:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016925c:	e593300c 	ldr	r3, [r3, #12]
80169260:	e0823003 	add	r3, r2, r3
80169264:	e50b3008 	str	r3, [fp, #-8]
80169268:	e51b3008 	ldr	r3, [fp, #-8]
8016926c:	e1a00003 	mov	r0, r3
80169270:	ebffdd22 	bl	80160700 <__RME_A7A_Read_Acquire>
80169274:	e50b000c 	str	r0, [fp, #-12]
80169278:	e51b300c 	ldr	r3, [fp, #-12]
8016927c:	e1a03823 	lsr	r3, r3, #16
80169280:	e6ef3073 	uxtb	r3, r3
80169284:	e3530002 	cmp	r3, #2
80169288:	1a000001 	bne	80169294 <_RME_Sig_Crt+0x88>
8016928c:	e3e03008 	mvn	r3, #8
80169290:	ea00007c 	b	80169488 <_RME_Sig_Crt+0x27c>
80169294:	e51b300c 	ldr	r3, [fp, #-12]
80169298:	e1a03c23 	lsr	r3, r3, #24
8016929c:	e3530003 	cmp	r3, #3
801692a0:	0a000041 	beq	801693ac <_RME_Sig_Crt+0x1a0>
801692a4:	e3e03001 	mvn	r3, #1
801692a8:	ea000076 	b	80169488 <_RME_Sig_Crt+0x27c>
801692ac:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801692b0:	e1a02423 	lsr	r2, r3, #8
801692b4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801692b8:	e5933014 	ldr	r3, [r3, #20]
801692bc:	e1520003 	cmp	r2, r3
801692c0:	3a000001 	bcc	801692cc <_RME_Sig_Crt+0xc0>
801692c4:	e3e03002 	mvn	r3, #2
801692c8:	ea00006e 	b	80169488 <_RME_Sig_Crt+0x27c>
801692cc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801692d0:	e1a03423 	lsr	r3, r3, #8
801692d4:	e1a02283 	lsl	r2, r3, #5
801692d8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801692dc:	e593300c 	ldr	r3, [r3, #12]
801692e0:	e0823003 	add	r3, r2, r3
801692e4:	e50b3008 	str	r3, [fp, #-8]
801692e8:	e51b3008 	ldr	r3, [fp, #-8]
801692ec:	e1a00003 	mov	r0, r3
801692f0:	ebffdd02 	bl	80160700 <__RME_A7A_Read_Acquire>
801692f4:	e50b000c 	str	r0, [fp, #-12]
801692f8:	e51b300c 	ldr	r3, [fp, #-12]
801692fc:	e1a03823 	lsr	r3, r3, #16
80169300:	e6ef3073 	uxtb	r3, r3
80169304:	e3530002 	cmp	r3, #2
80169308:	1a000001 	bne	80169314 <_RME_Sig_Crt+0x108>
8016930c:	e3e03008 	mvn	r3, #8
80169310:	ea00005c 	b	80169488 <_RME_Sig_Crt+0x27c>
80169314:	e51b300c 	ldr	r3, [fp, #-12]
80169318:	e1a03c23 	lsr	r3, r3, #24
8016931c:	e3530003 	cmp	r3, #3
80169320:	0a000001 	beq	8016932c <_RME_Sig_Crt+0x120>
80169324:	e3e03001 	mvn	r3, #1
80169328:	ea000056 	b	80169488 <_RME_Sig_Crt+0x27c>
8016932c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169330:	e203207f 	and	r2, r3, #127	@ 0x7f
80169334:	e51b3008 	ldr	r3, [fp, #-8]
80169338:	e5933014 	ldr	r3, [r3, #20]
8016933c:	e1520003 	cmp	r2, r3
80169340:	3a000001 	bcc	8016934c <_RME_Sig_Crt+0x140>
80169344:	e3e03002 	mvn	r3, #2
80169348:	ea00004e 	b	80169488 <_RME_Sig_Crt+0x27c>
8016934c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169350:	e203307f 	and	r3, r3, #127	@ 0x7f
80169354:	e1a02283 	lsl	r2, r3, #5
80169358:	e51b3008 	ldr	r3, [fp, #-8]
8016935c:	e593300c 	ldr	r3, [r3, #12]
80169360:	e0823003 	add	r3, r2, r3
80169364:	e50b3008 	str	r3, [fp, #-8]
80169368:	e51b3008 	ldr	r3, [fp, #-8]
8016936c:	e1a00003 	mov	r0, r3
80169370:	ebffdce2 	bl	80160700 <__RME_A7A_Read_Acquire>
80169374:	e50b000c 	str	r0, [fp, #-12]
80169378:	e51b300c 	ldr	r3, [fp, #-12]
8016937c:	e1a03823 	lsr	r3, r3, #16
80169380:	e6ef3073 	uxtb	r3, r3
80169384:	e3530002 	cmp	r3, #2
80169388:	1a000001 	bne	80169394 <_RME_Sig_Crt+0x188>
8016938c:	e3e03008 	mvn	r3, #8
80169390:	ea00003c 	b	80169488 <_RME_Sig_Crt+0x27c>
80169394:	e51b300c 	ldr	r3, [fp, #-12]
80169398:	e1a03c23 	lsr	r3, r3, #24
8016939c:	e3530003 	cmp	r3, #3
801693a0:	0a000001 	beq	801693ac <_RME_Sig_Crt+0x1a0>
801693a4:	e3e03001 	mvn	r3, #1
801693a8:	ea000036 	b	80169488 <_RME_Sig_Crt+0x27c>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
    /* Check if the captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_CRT);
801693ac:	e51b3008 	ldr	r3, [fp, #-8]
801693b0:	e5933008 	ldr	r3, [r3, #8]
801693b4:	e2033001 	and	r3, r3, #1
801693b8:	e3530000 	cmp	r3, #0
801693bc:	1a000001 	bne	801693c8 <_RME_Sig_Crt+0x1bc>
801693c0:	e3e03006 	mvn	r3, #6
801693c4:	ea00002f 	b	80169488 <_RME_Sig_Crt+0x27c>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Sig,struct RME_Cap_Sig*,Sig_Crt);
801693c8:	e51b3008 	ldr	r3, [fp, #-8]
801693cc:	e5932014 	ldr	r2, [r3, #20]
801693d0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801693d4:	e1520003 	cmp	r2, r3
801693d8:	8a000001 	bhi	801693e4 <_RME_Sig_Crt+0x1d8>
801693dc:	e3e03002 	mvn	r3, #2
801693e0:	ea000028 	b	80169488 <_RME_Sig_Crt+0x27c>
801693e4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801693e8:	e1a02283 	lsl	r2, r3, #5
801693ec:	e51b3008 	ldr	r3, [fp, #-8]
801693f0:	e593300c 	ldr	r3, [r3, #12]
801693f4:	e0823003 	add	r3, r2, r3
801693f8:	e50b3010 	str	r3, [fp, #-16]
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Sig_Crt);
801693fc:	e51b3010 	ldr	r3, [fp, #-16]
80169400:	e3a02801 	mov	r2, #65536	@ 0x10000
80169404:	e3a01000 	mov	r1, #0
80169408:	e1a00003 	mov	r0, r3
8016940c:	ebffddfd 	bl	80160c08 <_RME_Comp_Swap_Single>
80169410:	e1a03000 	mov	r3, r0
80169414:	e3530000 	cmp	r3, #0
80169418:	1a000001 	bne	80169424 <_RME_Sig_Crt+0x218>
8016941c:	e3e03004 	mvn	r3, #4
80169420:	ea000018 	b	80169488 <_RME_Sig_Crt+0x27c>
80169424:	e30d3000 	movw	r3, #53248	@ 0xd000
80169428:	e3483016 	movt	r3, #32790	@ 0x8016
8016942c:	e5932000 	ldr	r2, [r3]
80169430:	e51b3010 	ldr	r3, [fp, #-16]
80169434:	e5832010 	str	r2, [r3, #16]

    /* Header init */
    Sig_Crt->Head.Root_Ref=0U;
80169438:	e51b3010 	ldr	r3, [fp, #-16]
8016943c:	e3a02000 	mov	r2, #0
80169440:	e5832004 	str	r2, [r3, #4]
    Sig_Crt->Head.Object=0U;
80169444:	e51b3010 	ldr	r3, [fp, #-16]
80169448:	e3a02000 	mov	r2, #0
8016944c:	e583200c 	str	r2, [r3, #12]
    Sig_Crt->Head.Flag=RME_SIG_FLAG_ALL;
80169450:	e51b3010 	ldr	r3, [fp, #-16]
80169454:	e3a0203f 	mov	r2, #63	@ 0x3f
80169458:	e5832008 	str	r2, [r3, #8]
    
    /* Info init */
    Sig_Crt->Sig_Num=0U;
8016945c:	e51b3010 	ldr	r3, [fp, #-16]
80169460:	e3a02000 	mov	r2, #0
80169464:	e5832014 	str	r2, [r3, #20]
    Sig_Crt->Thd=0U;
80169468:	e51b3010 	ldr	r3, [fp, #-16]
8016946c:	e3a02000 	mov	r2, #0
80169470:	e5832018 	str	r2, [r3, #24]
    
    /* Establish cap */
    RME_WRITE_RELEASE(&(Sig_Crt->Head.Type_Stat),
80169474:	e51b3010 	ldr	r3, [fp, #-16]
80169478:	e3a01302 	mov	r1, #134217728	@ 0x8000000
8016947c:	e1a00003 	mov	r0, r3
80169480:	ebffdca1 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_SIG,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
80169484:	e3a03000 	mov	r3, #0
}
80169488:	e1a00003 	mov	r0, r3
8016948c:	e24bd004 	sub	sp, fp, #4
80169490:	e8bd8800 	pop	{fp, pc}

80169494 <_RME_Sig_Del>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Sig_Del(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt,
                              rme_cid_t Cap_Sig)
{
80169494:	e92d4800 	push	{fp, lr}
80169498:	e28db004 	add	fp, sp, #4
8016949c:	e24dd020 	sub	sp, sp, #32
801694a0:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
801694a4:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
801694a8:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    struct RME_Cap_Cpt* Cpt_Op;
    volatile struct RME_Cap_Sig* Sig_Del;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
801694ac:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801694b0:	e2033080 	and	r3, r3, #128	@ 0x80
801694b4:	e3530000 	cmp	r3, #0
801694b8:	1a00001d 	bne	80169534 <_RME_Sig_Del+0xa0>
801694bc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801694c0:	e5932014 	ldr	r2, [r3, #20]
801694c4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801694c8:	e1520003 	cmp	r2, r3
801694cc:	8a000001 	bhi	801694d8 <_RME_Sig_Del+0x44>
801694d0:	e3e03002 	mvn	r3, #2
801694d4:	ea0000af 	b	80169798 <_RME_Sig_Del+0x304>
801694d8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801694dc:	e1a02283 	lsl	r2, r3, #5
801694e0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801694e4:	e593300c 	ldr	r3, [r3, #12]
801694e8:	e0823003 	add	r3, r2, r3
801694ec:	e50b3008 	str	r3, [fp, #-8]
801694f0:	e51b3008 	ldr	r3, [fp, #-8]
801694f4:	e1a00003 	mov	r0, r3
801694f8:	ebffdc80 	bl	80160700 <__RME_A7A_Read_Acquire>
801694fc:	e50b000c 	str	r0, [fp, #-12]
80169500:	e51b300c 	ldr	r3, [fp, #-12]
80169504:	e1a03823 	lsr	r3, r3, #16
80169508:	e6ef3073 	uxtb	r3, r3
8016950c:	e3530002 	cmp	r3, #2
80169510:	1a000001 	bne	8016951c <_RME_Sig_Del+0x88>
80169514:	e3e03008 	mvn	r3, #8
80169518:	ea00009e 	b	80169798 <_RME_Sig_Del+0x304>
8016951c:	e51b300c 	ldr	r3, [fp, #-12]
80169520:	e1a03c23 	lsr	r3, r3, #24
80169524:	e3530003 	cmp	r3, #3
80169528:	0a000041 	beq	80169634 <_RME_Sig_Del+0x1a0>
8016952c:	e3e03001 	mvn	r3, #1
80169530:	ea000098 	b	80169798 <_RME_Sig_Del+0x304>
80169534:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169538:	e1a02423 	lsr	r2, r3, #8
8016953c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169540:	e5933014 	ldr	r3, [r3, #20]
80169544:	e1520003 	cmp	r2, r3
80169548:	3a000001 	bcc	80169554 <_RME_Sig_Del+0xc0>
8016954c:	e3e03002 	mvn	r3, #2
80169550:	ea000090 	b	80169798 <_RME_Sig_Del+0x304>
80169554:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169558:	e1a03423 	lsr	r3, r3, #8
8016955c:	e1a02283 	lsl	r2, r3, #5
80169560:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169564:	e593300c 	ldr	r3, [r3, #12]
80169568:	e0823003 	add	r3, r2, r3
8016956c:	e50b3008 	str	r3, [fp, #-8]
80169570:	e51b3008 	ldr	r3, [fp, #-8]
80169574:	e1a00003 	mov	r0, r3
80169578:	ebffdc60 	bl	80160700 <__RME_A7A_Read_Acquire>
8016957c:	e50b000c 	str	r0, [fp, #-12]
80169580:	e51b300c 	ldr	r3, [fp, #-12]
80169584:	e1a03823 	lsr	r3, r3, #16
80169588:	e6ef3073 	uxtb	r3, r3
8016958c:	e3530002 	cmp	r3, #2
80169590:	1a000001 	bne	8016959c <_RME_Sig_Del+0x108>
80169594:	e3e03008 	mvn	r3, #8
80169598:	ea00007e 	b	80169798 <_RME_Sig_Del+0x304>
8016959c:	e51b300c 	ldr	r3, [fp, #-12]
801695a0:	e1a03c23 	lsr	r3, r3, #24
801695a4:	e3530003 	cmp	r3, #3
801695a8:	0a000001 	beq	801695b4 <_RME_Sig_Del+0x120>
801695ac:	e3e03001 	mvn	r3, #1
801695b0:	ea000078 	b	80169798 <_RME_Sig_Del+0x304>
801695b4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801695b8:	e203207f 	and	r2, r3, #127	@ 0x7f
801695bc:	e51b3008 	ldr	r3, [fp, #-8]
801695c0:	e5933014 	ldr	r3, [r3, #20]
801695c4:	e1520003 	cmp	r2, r3
801695c8:	3a000001 	bcc	801695d4 <_RME_Sig_Del+0x140>
801695cc:	e3e03002 	mvn	r3, #2
801695d0:	ea000070 	b	80169798 <_RME_Sig_Del+0x304>
801695d4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801695d8:	e203307f 	and	r3, r3, #127	@ 0x7f
801695dc:	e1a02283 	lsl	r2, r3, #5
801695e0:	e51b3008 	ldr	r3, [fp, #-8]
801695e4:	e593300c 	ldr	r3, [r3, #12]
801695e8:	e0823003 	add	r3, r2, r3
801695ec:	e50b3008 	str	r3, [fp, #-8]
801695f0:	e51b3008 	ldr	r3, [fp, #-8]
801695f4:	e1a00003 	mov	r0, r3
801695f8:	ebffdc40 	bl	80160700 <__RME_A7A_Read_Acquire>
801695fc:	e50b000c 	str	r0, [fp, #-12]
80169600:	e51b300c 	ldr	r3, [fp, #-12]
80169604:	e1a03823 	lsr	r3, r3, #16
80169608:	e6ef3073 	uxtb	r3, r3
8016960c:	e3530002 	cmp	r3, #2
80169610:	1a000001 	bne	8016961c <_RME_Sig_Del+0x188>
80169614:	e3e03008 	mvn	r3, #8
80169618:	ea00005e 	b	80169798 <_RME_Sig_Del+0x304>
8016961c:	e51b300c 	ldr	r3, [fp, #-12]
80169620:	e1a03c23 	lsr	r3, r3, #24
80169624:	e3530003 	cmp	r3, #3
80169628:	0a000001 	beq	80169634 <_RME_Sig_Del+0x1a0>
8016962c:	e3e03001 	mvn	r3, #1
80169630:	ea000058 	b	80169798 <_RME_Sig_Del+0x304>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_DEL);
80169634:	e51b3008 	ldr	r3, [fp, #-8]
80169638:	e5933008 	ldr	r3, [r3, #8]
8016963c:	e2033002 	and	r3, r3, #2
80169640:	e3530000 	cmp	r3, #0
80169644:	1a000001 	bne	80169650 <_RME_Sig_Del+0x1bc>
80169648:	e3e03006 	mvn	r3, #6
8016964c:	ea000051 	b	80169798 <_RME_Sig_Del+0x304>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Sig,struct RME_Cap_Sig*,Sig_Del);
80169650:	e51b3008 	ldr	r3, [fp, #-8]
80169654:	e5932014 	ldr	r2, [r3, #20]
80169658:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016965c:	e1520003 	cmp	r2, r3
80169660:	8a000001 	bhi	8016966c <_RME_Sig_Del+0x1d8>
80169664:	e3e03002 	mvn	r3, #2
80169668:	ea00004a 	b	80169798 <_RME_Sig_Del+0x304>
8016966c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169670:	e1a02283 	lsl	r2, r3, #5
80169674:	e51b3008 	ldr	r3, [fp, #-8]
80169678:	e593300c 	ldr	r3, [r3, #12]
8016967c:	e0823003 	add	r3, r2, r3
80169680:	e50b3010 	str	r3, [fp, #-16]
    /* Delete check */
    RME_CAP_DEL_CHECK(Sig_Del,Type_Stat,RME_CAP_TYPE_SIG);
80169684:	e51b3010 	ldr	r3, [fp, #-16]
80169688:	e1a00003 	mov	r0, r3
8016968c:	ebffdc1b 	bl	80160700 <__RME_A7A_Read_Acquire>
80169690:	e50b000c 	str	r0, [fp, #-12]
80169694:	e51b300c 	ldr	r3, [fp, #-12]
80169698:	e1a03823 	lsr	r3, r3, #16
8016969c:	e6ef3073 	uxtb	r3, r3
801696a0:	e3530002 	cmp	r3, #2
801696a4:	0a000001 	beq	801696b0 <_RME_Sig_Del+0x21c>
801696a8:	e3e03008 	mvn	r3, #8
801696ac:	ea000039 	b	80169798 <_RME_Sig_Del+0x304>
801696b0:	e51b300c 	ldr	r3, [fp, #-12]
801696b4:	e1a03c23 	lsr	r3, r3, #24
801696b8:	e3530008 	cmp	r3, #8
801696bc:	0a000001 	beq	801696c8 <_RME_Sig_Del+0x234>
801696c0:	e3e03001 	mvn	r3, #1
801696c4:	ea000033 	b	80169798 <_RME_Sig_Del+0x304>
801696c8:	e51b3010 	ldr	r3, [fp, #-16]
801696cc:	e5933004 	ldr	r3, [r3, #4]
801696d0:	e3530000 	cmp	r3, #0
801696d4:	0a00000b 	beq	80169708 <_RME_Sig_Del+0x274>
801696d8:	e51b300c 	ldr	r3, [fp, #-12]
801696dc:	e6ff3073 	uxth	r3, r3
801696e0:	e3530000 	cmp	r3, #0
801696e4:	1a000005 	bne	80169700 <_RME_Sig_Del+0x26c>
801696e8:	e51b0010 	ldr	r0, [fp, #-16]
801696ec:	e51b300c 	ldr	r3, [fp, #-12]
801696f0:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
801696f4:	e1a02003 	mov	r2, r3
801696f8:	e51b100c 	ldr	r1, [fp, #-12]
801696fc:	ebffdd41 	bl	80160c08 <_RME_Comp_Swap_Single>
80169700:	e3e03005 	mvn	r3, #5
80169704:	ea000023 	b	80169798 <_RME_Sig_Del+0x304>
80169708:	e51b300c 	ldr	r3, [fp, #-12]
8016970c:	e6ff3073 	uxth	r3, r3
80169710:	e3530000 	cmp	r3, #0
80169714:	0a000008 	beq	8016973c <_RME_Sig_Del+0x2a8>
80169718:	e30c3318 	movw	r3, #49944	@ 0xc318
8016971c:	e3483016 	movt	r3, #32790	@ 0x8016
80169720:	e30c2324 	movw	r2, #49956	@ 0xc324
80169724:	e3482016 	movt	r2, #32790	@ 0x8016
80169728:	e3011aba 	movw	r1, #6842	@ 0x1aba
8016972c:	e30c0330 	movw	r0, #49968	@ 0xc330
80169730:	e3480016 	movt	r0, #32790	@ 0x8016
80169734:	ebffdd12 	bl	80160b84 <RME_Log>
80169738:	eafffffe 	b	80169738 <_RME_Sig_Del+0x2a4>

    /* Check if the signal endpoint is currently used and cannot be deleted */
    if(Sig_Del->Thd!=0U)
8016973c:	e51b3010 	ldr	r3, [fp, #-16]
80169740:	e5933018 	ldr	r3, [r3, #24]
80169744:	e3530000 	cmp	r3, #0
80169748:	0a000007 	beq	8016976c <_RME_Sig_Del+0x2d8>
    {
        RME_COV_MARKER();

        RME_CAP_DEFROST(Sig_Del,Type_Stat);
8016974c:	e51b0010 	ldr	r0, [fp, #-16]
80169750:	e51b300c 	ldr	r3, [fp, #-12]
80169754:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
80169758:	e1a02003 	mov	r2, r3
8016975c:	e51b100c 	ldr	r1, [fp, #-12]
80169760:	ebffdd28 	bl	80160c08 <_RME_Comp_Swap_Single>
        return RME_ERR_SIV_ACT;
80169764:	e3e03f4b 	mvn	r3, #300	@ 0x12c
80169768:	ea00000a 	b	80169798 <_RME_Sig_Del+0x304>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Now we can safely delete the cap */
    RME_CAP_DELETE(Sig_Del,Type_Stat);
8016976c:	e51b3010 	ldr	r3, [fp, #-16]
80169770:	e3a02000 	mov	r2, #0
80169774:	e51b100c 	ldr	r1, [fp, #-12]
80169778:	e1a00003 	mov	r0, r3
8016977c:	ebffdd21 	bl	80160c08 <_RME_Comp_Swap_Single>
80169780:	e1a03000 	mov	r3, r0
80169784:	e3530000 	cmp	r3, #0
80169788:	1a000001 	bne	80169794 <_RME_Sig_Del+0x300>
8016978c:	e3e03000 	mvn	r3, #0
80169790:	ea000000 	b	80169798 <_RME_Sig_Del+0x304>
    
    return 0;
80169794:	e3a03000 	mov	r3, #0
}
80169798:	e1a00003 	mov	r0, r3
8016979c:	e24bd004 	sub	sp, fp, #4
801697a0:	e8bd8800 	pop	{fp, pc}

801697a4 <_RME_Kern_High>:
Output      : volatile struct RME_Reg_Struct* Reg - The updated register set.
Return      : None.
******************************************************************************/
void _RME_Kern_High(struct RME_Reg_Struct* Reg,
                    struct RME_CPU_Local* Local)
{
801697a4:	e92d4800 	push	{fp, lr}
801697a8:	e28db004 	add	fp, sp, #4
801697ac:	e24dd010 	sub	sp, sp, #16
801697b0:	e50b0010 	str	r0, [fp, #-16]
801697b4:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
    struct RME_Thd_Struct* Thd_New;
    struct RME_Thd_Struct* Thd_Cur;

    Thd_New=_RME_Run_High(Local);
801697b8:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801697bc:	ebffee6b 	bl	80165170 <_RME_Run_High>
801697c0:	e50b0008 	str	r0, [fp, #-8]
    RME_ASSERT(Thd_New!=RME_NULL);
801697c4:	e51b3008 	ldr	r3, [fp, #-8]
801697c8:	e3530000 	cmp	r3, #0
801697cc:	1a000008 	bne	801697f4 <_RME_Kern_High+0x50>
801697d0:	e30c3318 	movw	r3, #49944	@ 0xc318
801697d4:	e3483016 	movt	r3, #32790	@ 0x8016
801697d8:	e30c2324 	movw	r2, #49956	@ 0xc324
801697dc:	e3482016 	movt	r2, #32790	@ 0x8016
801697e0:	e3011ae3 	movw	r1, #6883	@ 0x1ae3
801697e4:	e30c0330 	movw	r0, #49968	@ 0xc330
801697e8:	e3480016 	movt	r0, #32790	@ 0x8016
801697ec:	ebffdce4 	bl	80160b84 <RME_Log>
801697f0:	eafffffe 	b	801697f0 <_RME_Kern_High+0x4c>
    Thd_Cur=Local->Thd_Cur;
801697f4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801697f8:	e5933004 	ldr	r3, [r3, #4]
801697fc:	e50b300c 	str	r3, [fp, #-12]

    /* Are these two threads the same? */
    if(Thd_New==Thd_Cur)
80169800:	e51b2008 	ldr	r2, [fp, #-8]
80169804:	e51b300c 	ldr	r3, [fp, #-12]
80169808:	e1520003 	cmp	r2, r3
8016980c:	0a00001e 	beq	8016988c <_RME_Kern_High+0xe8>
        /* No action required */
    }

    /* Check if we need to do the context switch regardless of priority
     * because the current thread is not ready yet. */
    if(Thd_Cur->Sched.State==RME_THD_READY)
80169810:	e51b300c 	ldr	r3, [fp, #-12]
80169814:	e593301c 	ldr	r3, [r3, #28]
80169818:	e3530000 	cmp	r3, #0
8016981c:	1a000005 	bne	80169838 <_RME_Kern_High+0x94>
    {
        RME_COV_MARKER();

        /* Check priority to see if the switch is necessary */
        if(Thd_New->Sched.Prio<=Thd_Cur->Sched.Prio)
80169820:	e51b3008 	ldr	r3, [fp, #-8]
80169824:	e5932020 	ldr	r2, [r3, #32]
80169828:	e51b300c 	ldr	r3, [fp, #-12]
8016982c:	e5933020 	ldr	r3, [r3, #32]
80169830:	e1520003 	cmp	r2, r3
80169834:	9a000016 	bls	80169894 <_RME_Kern_High+0xf0>
        /* No action required */
    }

    /* We will have a solid context switch on this point. The current 
     * thread is not necessarily READY, it could be EXCPEND as well. */
    RME_ASSERT(Thd_New->Sched.State==RME_THD_READY);
80169838:	e51b3008 	ldr	r3, [fp, #-8]
8016983c:	e593301c 	ldr	r3, [r3, #28]
80169840:	e3530000 	cmp	r3, #0
80169844:	0a000008 	beq	8016986c <_RME_Kern_High+0xc8>
80169848:	e30c3318 	movw	r3, #49944	@ 0xc318
8016984c:	e3483016 	movt	r3, #32790	@ 0x8016
80169850:	e30c2324 	movw	r2, #49956	@ 0xc324
80169854:	e3482016 	movt	r2, #32790	@ 0x8016
80169858:	e3011b0e 	movw	r1, #6926	@ 0x1b0e
8016985c:	e30c0330 	movw	r0, #49968	@ 0xc330
80169860:	e3480016 	movt	r0, #32790	@ 0x8016
80169864:	ebffdcc6 	bl	80160b84 <RME_Log>
80169868:	eafffffe 	b	80169868 <_RME_Kern_High+0xc4>
    _RME_Run_Swt(Reg,Thd_Cur,Thd_New);
8016986c:	e51b2008 	ldr	r2, [fp, #-8]
80169870:	e51b100c 	ldr	r1, [fp, #-12]
80169874:	e51b0010 	ldr	r0, [fp, #-16]
80169878:	ebffeeaf 	bl	8016533c <_RME_Run_Swt>
    Local->Thd_Cur=Thd_New;
8016987c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169880:	e51b2008 	ldr	r2, [fp, #-8]
80169884:	e5832004 	str	r2, [r3, #4]
80169888:	ea000002 	b	80169898 <_RME_Kern_High+0xf4>
        return;
8016988c:	e320f000 	nop	{0}
80169890:	ea000000 	b	80169898 <_RME_Kern_High+0xf4>
            return;
80169894:	e320f000 	nop	{0}
}
80169898:	e24bd004 	sub	sp, fp, #4
8016989c:	e8bd8800 	pop	{fp, pc}

801698a0 <_RME_Kern_Snd>:
Input       : struct RME_Cap_Sig* Cap_Sig - The signal root capability.
Output      : None.
Return      : rme_ret_t - If successful, 0, or an error code.
******************************************************************************/
rme_ret_t _RME_Kern_Snd(struct RME_Cap_Sig* Cap_Sig)
{
801698a0:	e92d4800 	push	{fp, lr}
801698a4:	e28db004 	add	fp, sp, #4
801698a8:	e24dd010 	sub	sp, sp, #16
801698ac:	e50b0010 	str	r0, [fp, #-16]
    rme_ptr_t Unblock;
    struct RME_Thd_Struct* Thd_Sig;
    
    Thd_Sig=Cap_Sig->Thd;
801698b0:	e51b3010 	ldr	r3, [fp, #-16]
801698b4:	e5933018 	ldr	r3, [r3, #24]
801698b8:	e50b300c 	str	r3, [fp, #-12]
    
    /* If and only if we are calling from the same core do we unblock */
    if(Thd_Sig!=RME_NULL)
801698bc:	e51b300c 	ldr	r3, [fp, #-12]
801698c0:	e3530000 	cmp	r3, #0
801698c4:	0a00000b 	beq	801698f8 <_RME_Kern_Snd+0x58>
    {
        RME_COV_MARKER();

        if(Thd_Sig->Sched.Local==RME_CPU_LOCAL())
801698c8:	e51b300c 	ldr	r3, [fp, #-12]
801698cc:	e5932014 	ldr	r2, [r3, #20]
801698d0:	e30d3004 	movw	r3, #53252	@ 0xd004
801698d4:	e3483016 	movt	r3, #32790	@ 0x8016
801698d8:	e1520003 	cmp	r2, r3
801698dc:	1a000002 	bne	801698ec <_RME_Kern_Snd+0x4c>
        {
            RME_COV_MARKER();

            Unblock=1U;
801698e0:	e3a03001 	mov	r3, #1
801698e4:	e50b3008 	str	r3, [fp, #-8]
801698e8:	ea000004 	b	80169900 <_RME_Kern_Snd+0x60>
        }
        else
        {
            RME_COV_MARKER();

            Unblock=0U;
801698ec:	e3a03000 	mov	r3, #0
801698f0:	e50b3008 	str	r3, [fp, #-8]
801698f4:	ea000001 	b	80169900 <_RME_Kern_Snd+0x60>
    }
    else
    {
        RME_COV_MARKER();

        Unblock=0U;
801698f8:	e3a03000 	mov	r3, #0
801698fc:	e50b3008 	str	r3, [fp, #-8]
    }

    if(Unblock!=0U)
80169900:	e51b3008 	ldr	r3, [fp, #-8]
80169904:	e3530000 	cmp	r3, #0
80169908:	0a000017 	beq	8016996c <_RME_Kern_Snd+0xcc>

        /* The thread is blocked, and it is on our core. Unblock it, and
         * set the return value to one as always, Even if we were specifying
         * multi-receive. This is because other cores may reduce the count
         * to zero while we are doing this. */
        __RME_Svc_Retval_Set(&(Thd_Sig->Ctx.Reg->Reg),1);
8016990c:	e51b300c 	ldr	r3, [fp, #-12]
80169910:	e5933048 	ldr	r3, [r3, #72]	@ 0x48
80169914:	e3a01001 	mov	r1, #1
80169918:	e1a00003 	mov	r0, r3
8016991c:	eb00081c 	bl	8016b994 <__RME_Svc_Retval_Set>
        
        /* See if the thread still have time left */
        if(Thd_Sig->Sched.Slice!=0U)
80169920:	e51b300c 	ldr	r3, [fp, #-12]
80169924:	e5933018 	ldr	r3, [r3, #24]
80169928:	e3530000 	cmp	r3, #0
8016992c:	0a000005 	beq	80169948 <_RME_Kern_Snd+0xa8>
        {
            RME_COV_MARKER();

            /* Ready and add to runqueue */
            Thd_Sig->Sched.State=RME_THD_READY;
80169930:	e51b300c 	ldr	r3, [fp, #-12]
80169934:	e3a02000 	mov	r2, #0
80169938:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Ins(Thd_Sig);
8016993c:	e51b000c 	ldr	r0, [fp, #-12]
80169940:	ebffed95 	bl	80164f9c <_RME_Run_Ins>
80169944:	ea000004 	b	8016995c <_RME_Kern_Snd+0xbc>
        else
        {
            RME_COV_MARKER();

            /* Timeout and notify parent */
            Thd_Sig->Sched.State=RME_THD_TIMEOUT;
80169948:	e51b300c 	ldr	r3, [fp, #-12]
8016994c:	e3a02002 	mov	r2, #2
80169950:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Notif(Thd_Sig);
80169954:	e51b000c 	ldr	r0, [fp, #-12]
80169958:	ebffee3a 	bl	80165248 <_RME_Run_Notif>
         * we hope to perform the context switch only once when exiting that
         * handler. Also note that the current thread could be EXCPEND as well;
         * this is different from the normal signal sending system call. */
        
        /* Clear endpoint blocking status - no write release required */
        Cap_Sig->Thd=RME_NULL;
8016995c:	e51b3010 	ldr	r3, [fp, #-16]
80169960:	e3a02000 	mov	r2, #0
80169964:	e5832018 	str	r2, [r3, #24]
80169968:	ea00000f 	b	801699ac <_RME_Kern_Snd+0x10c>
    {
        RME_COV_MARKER();

        /* The guy who blocked on it is not on our core, or nobody blocked.
         * We just faa the counter value and return. */
        if(RME_FETCH_ADD(&(Cap_Sig->Sig_Num),1U)>=RME_MAX_SIG_NUM)
8016996c:	e51b3010 	ldr	r3, [fp, #-16]
80169970:	e2833014 	add	r3, r3, #20
80169974:	e3a01001 	mov	r1, #1
80169978:	e1a00003 	mov	r0, r3
8016997c:	ebffdcb6 	bl	80160c5c <_RME_Fetch_Add_Single>
80169980:	e1a03000 	mov	r3, r0
80169984:	e373010a 	cmn	r3, #-2147483646	@ 0x80000002
80169988:	9a000007 	bls	801699ac <_RME_Kern_Snd+0x10c>
        {
            RME_COV_MARKER();

            RME_FETCH_ADD(&(Cap_Sig->Sig_Num),-1);
8016998c:	e51b3010 	ldr	r3, [fp, #-16]
80169990:	e2833014 	add	r3, r3, #20
80169994:	e3e01000 	mvn	r1, #0
80169998:	e1a00003 	mov	r0, r3
8016999c:	ebffdcae 	bl	80160c5c <_RME_Fetch_Add_Single>
            return RME_ERR_SIV_FULL;
801699a0:	e30f3ed1 	movw	r3, #65233	@ 0xfed1
801699a4:	e34f3fff 	movt	r3, #65535	@ 0xffff
801699a8:	ea000000 	b	801699b0 <_RME_Kern_Snd+0x110>
            RME_COV_MARKER();
            /* No action required */
        }
    }

    return 0;
801699ac:	e3a03000 	mov	r3, #0
}
801699b0:	e1a00003 	mov	r0, r3
801699b4:	e24bd004 	sub	sp, fp, #4
801699b8:	e8bd8800 	pop	{fp, pc}

801699bc <_RME_Sig_Snd>:
Return      : rme_ret_t - If successful, 0, or an error code.
******************************************************************************/
static rme_ret_t _RME_Sig_Snd(struct RME_Cap_Cpt* Cpt, 
                              struct RME_Reg_Struct* Reg,
                              rme_cid_t Cap_Sig)
{
801699bc:	e92d4800 	push	{fp, lr}
801699c0:	e28db004 	add	fp, sp, #4
801699c4:	e24dd028 	sub	sp, sp, #40	@ 0x28
801699c8:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
801699cc:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
801699d0:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
    struct RME_CPU_Local* Local;
    rme_ptr_t Unblock;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Sig,RME_CAP_TYPE_SIG,
801699d4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801699d8:	e2033080 	and	r3, r3, #128	@ 0x80
801699dc:	e3530000 	cmp	r3, #0
801699e0:	1a00001d 	bne	80169a5c <_RME_Sig_Snd+0xa0>
801699e4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801699e8:	e5932014 	ldr	r2, [r3, #20]
801699ec:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801699f0:	e1520003 	cmp	r2, r3
801699f4:	8a000001 	bhi	80169a00 <_RME_Sig_Snd+0x44>
801699f8:	e3e03002 	mvn	r3, #2
801699fc:	ea0000b2 	b	80169ccc <_RME_Sig_Snd+0x310>
80169a00:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169a04:	e1a02283 	lsl	r2, r3, #5
80169a08:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169a0c:	e593300c 	ldr	r3, [r3, #12]
80169a10:	e0823003 	add	r3, r2, r3
80169a14:	e50b3008 	str	r3, [fp, #-8]
80169a18:	e51b3008 	ldr	r3, [fp, #-8]
80169a1c:	e1a00003 	mov	r0, r3
80169a20:	ebffdb36 	bl	80160700 <__RME_A7A_Read_Acquire>
80169a24:	e50b0010 	str	r0, [fp, #-16]
80169a28:	e51b3010 	ldr	r3, [fp, #-16]
80169a2c:	e1a03823 	lsr	r3, r3, #16
80169a30:	e6ef3073 	uxtb	r3, r3
80169a34:	e3530002 	cmp	r3, #2
80169a38:	1a000001 	bne	80169a44 <_RME_Sig_Snd+0x88>
80169a3c:	e3e03008 	mvn	r3, #8
80169a40:	ea0000a1 	b	80169ccc <_RME_Sig_Snd+0x310>
80169a44:	e51b3010 	ldr	r3, [fp, #-16]
80169a48:	e1a03c23 	lsr	r3, r3, #24
80169a4c:	e3530008 	cmp	r3, #8
80169a50:	0a000041 	beq	80169b5c <_RME_Sig_Snd+0x1a0>
80169a54:	e3e03001 	mvn	r3, #1
80169a58:	ea00009b 	b	80169ccc <_RME_Sig_Snd+0x310>
80169a5c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169a60:	e1a02423 	lsr	r2, r3, #8
80169a64:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169a68:	e5933014 	ldr	r3, [r3, #20]
80169a6c:	e1520003 	cmp	r2, r3
80169a70:	3a000001 	bcc	80169a7c <_RME_Sig_Snd+0xc0>
80169a74:	e3e03002 	mvn	r3, #2
80169a78:	ea000093 	b	80169ccc <_RME_Sig_Snd+0x310>
80169a7c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169a80:	e1a03423 	lsr	r3, r3, #8
80169a84:	e1a02283 	lsl	r2, r3, #5
80169a88:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169a8c:	e593300c 	ldr	r3, [r3, #12]
80169a90:	e0823003 	add	r3, r2, r3
80169a94:	e50b3008 	str	r3, [fp, #-8]
80169a98:	e51b3008 	ldr	r3, [fp, #-8]
80169a9c:	e1a00003 	mov	r0, r3
80169aa0:	ebffdb16 	bl	80160700 <__RME_A7A_Read_Acquire>
80169aa4:	e50b0010 	str	r0, [fp, #-16]
80169aa8:	e51b3010 	ldr	r3, [fp, #-16]
80169aac:	e1a03823 	lsr	r3, r3, #16
80169ab0:	e6ef3073 	uxtb	r3, r3
80169ab4:	e3530002 	cmp	r3, #2
80169ab8:	1a000001 	bne	80169ac4 <_RME_Sig_Snd+0x108>
80169abc:	e3e03008 	mvn	r3, #8
80169ac0:	ea000081 	b	80169ccc <_RME_Sig_Snd+0x310>
80169ac4:	e51b3010 	ldr	r3, [fp, #-16]
80169ac8:	e1a03c23 	lsr	r3, r3, #24
80169acc:	e3530003 	cmp	r3, #3
80169ad0:	0a000001 	beq	80169adc <_RME_Sig_Snd+0x120>
80169ad4:	e3e03001 	mvn	r3, #1
80169ad8:	ea00007b 	b	80169ccc <_RME_Sig_Snd+0x310>
80169adc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169ae0:	e203207f 	and	r2, r3, #127	@ 0x7f
80169ae4:	e51b3008 	ldr	r3, [fp, #-8]
80169ae8:	e5933014 	ldr	r3, [r3, #20]
80169aec:	e1520003 	cmp	r2, r3
80169af0:	3a000001 	bcc	80169afc <_RME_Sig_Snd+0x140>
80169af4:	e3e03002 	mvn	r3, #2
80169af8:	ea000073 	b	80169ccc <_RME_Sig_Snd+0x310>
80169afc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169b00:	e203307f 	and	r3, r3, #127	@ 0x7f
80169b04:	e1a02283 	lsl	r2, r3, #5
80169b08:	e51b3008 	ldr	r3, [fp, #-8]
80169b0c:	e593300c 	ldr	r3, [r3, #12]
80169b10:	e0823003 	add	r3, r2, r3
80169b14:	e50b3008 	str	r3, [fp, #-8]
80169b18:	e51b3008 	ldr	r3, [fp, #-8]
80169b1c:	e1a00003 	mov	r0, r3
80169b20:	ebffdaf6 	bl	80160700 <__RME_A7A_Read_Acquire>
80169b24:	e50b0010 	str	r0, [fp, #-16]
80169b28:	e51b3010 	ldr	r3, [fp, #-16]
80169b2c:	e1a03823 	lsr	r3, r3, #16
80169b30:	e6ef3073 	uxtb	r3, r3
80169b34:	e3530002 	cmp	r3, #2
80169b38:	1a000001 	bne	80169b44 <_RME_Sig_Snd+0x188>
80169b3c:	e3e03008 	mvn	r3, #8
80169b40:	ea000061 	b	80169ccc <_RME_Sig_Snd+0x310>
80169b44:	e51b3010 	ldr	r3, [fp, #-16]
80169b48:	e1a03c23 	lsr	r3, r3, #24
80169b4c:	e3530008 	cmp	r3, #8
80169b50:	0a000001 	beq	80169b5c <_RME_Sig_Snd+0x1a0>
80169b54:	e3e03001 	mvn	r3, #1
80169b58:	ea00005b 	b	80169ccc <_RME_Sig_Snd+0x310>
                   struct RME_Cap_Sig*,Sig_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Sig_Op,RME_SIG_FLAG_SND);
80169b5c:	e51b3008 	ldr	r3, [fp, #-8]
80169b60:	e5933008 	ldr	r3, [r3, #8]
80169b64:	e2033001 	and	r3, r3, #1
80169b68:	e3530000 	cmp	r3, #0
80169b6c:	1a000001 	bne	80169b78 <_RME_Sig_Snd+0x1bc>
80169b70:	e3e03006 	mvn	r3, #6
80169b74:	ea000054 	b	80169ccc <_RME_Sig_Snd+0x310>
    
    Local=RME_CPU_LOCAL();
80169b78:	e30d3004 	movw	r3, #53252	@ 0xd004
80169b7c:	e3483016 	movt	r3, #32790	@ 0x8016
80169b80:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Sig_Root=RME_CAP_CONV_ROOT(Sig_Op,struct RME_Cap_Sig*);
80169b84:	e51b3008 	ldr	r3, [fp, #-8]
80169b88:	e5933000 	ldr	r3, [r3]
80169b8c:	e6ff3073 	uxth	r3, r3
80169b90:	e3530000 	cmp	r3, #0
80169b94:	0a000002 	beq	80169ba4 <_RME_Sig_Snd+0x1e8>
80169b98:	e51b3008 	ldr	r3, [fp, #-8]
80169b9c:	e5933004 	ldr	r3, [r3, #4]
80169ba0:	ea000000 	b	80169ba8 <_RME_Sig_Snd+0x1ec>
80169ba4:	e51b3008 	ldr	r3, [fp, #-8]
80169ba8:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Thd_Rcv=Sig_Root->Thd;
80169bac:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169bb0:	e5933018 	ldr	r3, [r3, #24]
80169bb4:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4

    /* If and only if we are calling from the same core do we unblock */
    if(Thd_Rcv!=RME_NULL)
80169bb8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169bbc:	e3530000 	cmp	r3, #0
80169bc0:	0a00000a 	beq	80169bf0 <_RME_Sig_Snd+0x234>
    {
        RME_COV_MARKER();

        if(Thd_Rcv->Sched.Local==Local)
80169bc4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169bc8:	e5933014 	ldr	r3, [r3, #20]
80169bcc:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80169bd0:	e1520003 	cmp	r2, r3
80169bd4:	1a000002 	bne	80169be4 <_RME_Sig_Snd+0x228>
        {
            RME_COV_MARKER();

            Unblock=1U;
80169bd8:	e3a03001 	mov	r3, #1
80169bdc:	e50b300c 	str	r3, [fp, #-12]
80169be0:	ea000004 	b	80169bf8 <_RME_Sig_Snd+0x23c>
        }
        else
        {
            RME_COV_MARKER();

            Unblock=0U;
80169be4:	e3a03000 	mov	r3, #0
80169be8:	e50b300c 	str	r3, [fp, #-12]
80169bec:	ea000001 	b	80169bf8 <_RME_Sig_Snd+0x23c>
    }
    else
    {
        RME_COV_MARKER();

        Unblock=0U;
80169bf0:	e3a03000 	mov	r3, #0
80169bf4:	e50b300c 	str	r3, [fp, #-12]
    }
    
    if(Unblock!=0U)
80169bf8:	e51b300c 	ldr	r3, [fp, #-12]
80169bfc:	e3530000 	cmp	r3, #0
80169c00:	0a00001d 	beq	80169c7c <_RME_Sig_Snd+0x2c0>
    {
        RME_COV_MARKER();

        /* Now save the system call return value to the caller stack */
        __RME_Svc_Retval_Set(Reg,0);
80169c04:	e3a01000 	mov	r1, #0
80169c08:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
80169c0c:	eb000760 	bl	8016b994 <__RME_Svc_Retval_Set>
        
        /* The thread is blocked, and it is on our core. Unblock it, and
         * set the return value to one as always, Even if we were specifying
         * multi-receive. This is because other cores may reduce the count
         * to zero while we are doing this. */
        __RME_Svc_Retval_Set(&(Thd_Rcv->Ctx.Reg->Reg),1);
80169c10:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169c14:	e5933048 	ldr	r3, [r3, #72]	@ 0x48
80169c18:	e3a01001 	mov	r1, #1
80169c1c:	e1a00003 	mov	r0, r3
80169c20:	eb00075b 	bl	8016b994 <__RME_Svc_Retval_Set>
        
        /* See if the thread still have time left */
        if(Thd_Rcv->Sched.Slice!=0U)
80169c24:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169c28:	e5933018 	ldr	r3, [r3, #24]
80169c2c:	e3530000 	cmp	r3, #0
80169c30:	0a000005 	beq	80169c4c <_RME_Sig_Snd+0x290>
        {
            RME_COV_MARKER();

            /* Ready and add to runqueue */
            Thd_Rcv->Sched.State=RME_THD_READY;
80169c34:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169c38:	e3a02000 	mov	r2, #0
80169c3c:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Ins(Thd_Rcv);
80169c40:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80169c44:	ebffecd4 	bl	80164f9c <_RME_Run_Ins>
80169c48:	ea000004 	b	80169c60 <_RME_Sig_Snd+0x2a4>
        else
        {
            RME_COV_MARKER();

            /* Timeout and notify parent */
            Thd_Rcv->Sched.State=RME_THD_TIMEOUT;
80169c4c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169c50:	e3a02002 	mov	r2, #2
80169c54:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Notif(Thd_Rcv);
80169c58:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80169c5c:	ebffed79 	bl	80165248 <_RME_Run_Notif>
        }
        
        /* Pick the highest priority thread to run */
        _RME_Kern_High(Reg,Local);
80169c60:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
80169c64:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
80169c68:	ebfffecd 	bl	801697a4 <_RME_Kern_High>
        
        /* Clear endpoint blocking status - no write release required */
        Sig_Root->Thd=RME_NULL;
80169c6c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169c70:	e3a02000 	mov	r2, #0
80169c74:	e5832018 	str	r2, [r3, #24]
80169c78:	ea000012 	b	80169cc8 <_RME_Sig_Snd+0x30c>
    else
    {
        RME_COV_MARKER();

        /* The guy who blocked on it is not on our core, we just faa and return */
        if(RME_FETCH_ADD(&(Sig_Root->Sig_Num),1U)>=RME_MAX_SIG_NUM)
80169c7c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169c80:	e2833014 	add	r3, r3, #20
80169c84:	e3a01001 	mov	r1, #1
80169c88:	e1a00003 	mov	r0, r3
80169c8c:	ebffdbf2 	bl	80160c5c <_RME_Fetch_Add_Single>
80169c90:	e1a03000 	mov	r3, r0
80169c94:	e373010a 	cmn	r3, #-2147483646	@ 0x80000002
80169c98:	9a000007 	bls	80169cbc <_RME_Sig_Snd+0x300>
        {
            RME_COV_MARKER();

            RME_FETCH_ADD(&(Sig_Root->Sig_Num),-1);
80169c9c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169ca0:	e2833014 	add	r3, r3, #20
80169ca4:	e3e01000 	mvn	r1, #0
80169ca8:	e1a00003 	mov	r0, r3
80169cac:	ebffdbea 	bl	80160c5c <_RME_Fetch_Add_Single>
            return RME_ERR_SIV_FULL;
80169cb0:	e30f3ed1 	movw	r3, #65233	@ 0xfed1
80169cb4:	e34f3fff 	movt	r3, #65535	@ 0xffff
80169cb8:	ea000003 	b	80169ccc <_RME_Sig_Snd+0x310>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Now save the system call return value to the caller stack */
        __RME_Svc_Retval_Set(Reg,0);
80169cbc:	e3a01000 	mov	r1, #0
80169cc0:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
80169cc4:	eb000732 	bl	8016b994 <__RME_Svc_Retval_Set>
    }

    return 0;
80169cc8:	e3a03000 	mov	r3, #0
}
80169ccc:	e1a00003 	mov	r0, r3
80169cd0:	e24bd004 	sub	sp, fp, #4
80169cd4:	e8bd8800 	pop	{fp, pc}

80169cd8 <_RME_Sig_Rcv>:
******************************************************************************/
static rme_ret_t _RME_Sig_Rcv(struct RME_Cap_Cpt* Cpt,
                              struct RME_Reg_Struct* Reg,
                              rme_cid_t Cap_Sig,
                              rme_ptr_t Option)
{
80169cd8:	e92d4800 	push	{fp, lr}
80169cdc:	e28db004 	add	fp, sp, #4
80169ce0:	e24dd028 	sub	sp, sp, #40	@ 0x28
80169ce4:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
80169ce8:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
80169cec:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
80169cf0:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
    struct RME_Thd_Struct* Thd_Cur;
    rme_ptr_t Old_Value;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Sig,RME_CAP_TYPE_SIG,
80169cf4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169cf8:	e2033080 	and	r3, r3, #128	@ 0x80
80169cfc:	e3530000 	cmp	r3, #0
80169d00:	1a00001d 	bne	80169d7c <_RME_Sig_Rcv+0xa4>
80169d04:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169d08:	e5932014 	ldr	r2, [r3, #20]
80169d0c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169d10:	e1520003 	cmp	r2, r3
80169d14:	8a000001 	bhi	80169d20 <_RME_Sig_Rcv+0x48>
80169d18:	e3e03002 	mvn	r3, #2
80169d1c:	ea0000fb 	b	8016a110 <_RME_Sig_Rcv+0x438>
80169d20:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169d24:	e1a02283 	lsl	r2, r3, #5
80169d28:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169d2c:	e593300c 	ldr	r3, [r3, #12]
80169d30:	e0823003 	add	r3, r2, r3
80169d34:	e50b3008 	str	r3, [fp, #-8]
80169d38:	e51b3008 	ldr	r3, [fp, #-8]
80169d3c:	e1a00003 	mov	r0, r3
80169d40:	ebffda6e 	bl	80160700 <__RME_A7A_Read_Acquire>
80169d44:	e50b000c 	str	r0, [fp, #-12]
80169d48:	e51b300c 	ldr	r3, [fp, #-12]
80169d4c:	e1a03823 	lsr	r3, r3, #16
80169d50:	e6ef3073 	uxtb	r3, r3
80169d54:	e3530002 	cmp	r3, #2
80169d58:	1a000001 	bne	80169d64 <_RME_Sig_Rcv+0x8c>
80169d5c:	e3e03008 	mvn	r3, #8
80169d60:	ea0000ea 	b	8016a110 <_RME_Sig_Rcv+0x438>
80169d64:	e51b300c 	ldr	r3, [fp, #-12]
80169d68:	e1a03c23 	lsr	r3, r3, #24
80169d6c:	e3530008 	cmp	r3, #8
80169d70:	0a000041 	beq	80169e7c <_RME_Sig_Rcv+0x1a4>
80169d74:	e3e03001 	mvn	r3, #1
80169d78:	ea0000e4 	b	8016a110 <_RME_Sig_Rcv+0x438>
80169d7c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169d80:	e1a02423 	lsr	r2, r3, #8
80169d84:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169d88:	e5933014 	ldr	r3, [r3, #20]
80169d8c:	e1520003 	cmp	r2, r3
80169d90:	3a000001 	bcc	80169d9c <_RME_Sig_Rcv+0xc4>
80169d94:	e3e03002 	mvn	r3, #2
80169d98:	ea0000dc 	b	8016a110 <_RME_Sig_Rcv+0x438>
80169d9c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169da0:	e1a03423 	lsr	r3, r3, #8
80169da4:	e1a02283 	lsl	r2, r3, #5
80169da8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169dac:	e593300c 	ldr	r3, [r3, #12]
80169db0:	e0823003 	add	r3, r2, r3
80169db4:	e50b3008 	str	r3, [fp, #-8]
80169db8:	e51b3008 	ldr	r3, [fp, #-8]
80169dbc:	e1a00003 	mov	r0, r3
80169dc0:	ebffda4e 	bl	80160700 <__RME_A7A_Read_Acquire>
80169dc4:	e50b000c 	str	r0, [fp, #-12]
80169dc8:	e51b300c 	ldr	r3, [fp, #-12]
80169dcc:	e1a03823 	lsr	r3, r3, #16
80169dd0:	e6ef3073 	uxtb	r3, r3
80169dd4:	e3530002 	cmp	r3, #2
80169dd8:	1a000001 	bne	80169de4 <_RME_Sig_Rcv+0x10c>
80169ddc:	e3e03008 	mvn	r3, #8
80169de0:	ea0000ca 	b	8016a110 <_RME_Sig_Rcv+0x438>
80169de4:	e51b300c 	ldr	r3, [fp, #-12]
80169de8:	e1a03c23 	lsr	r3, r3, #24
80169dec:	e3530003 	cmp	r3, #3
80169df0:	0a000001 	beq	80169dfc <_RME_Sig_Rcv+0x124>
80169df4:	e3e03001 	mvn	r3, #1
80169df8:	ea0000c4 	b	8016a110 <_RME_Sig_Rcv+0x438>
80169dfc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169e00:	e203207f 	and	r2, r3, #127	@ 0x7f
80169e04:	e51b3008 	ldr	r3, [fp, #-8]
80169e08:	e5933014 	ldr	r3, [r3, #20]
80169e0c:	e1520003 	cmp	r2, r3
80169e10:	3a000001 	bcc	80169e1c <_RME_Sig_Rcv+0x144>
80169e14:	e3e03002 	mvn	r3, #2
80169e18:	ea0000bc 	b	8016a110 <_RME_Sig_Rcv+0x438>
80169e1c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169e20:	e203307f 	and	r3, r3, #127	@ 0x7f
80169e24:	e1a02283 	lsl	r2, r3, #5
80169e28:	e51b3008 	ldr	r3, [fp, #-8]
80169e2c:	e593300c 	ldr	r3, [r3, #12]
80169e30:	e0823003 	add	r3, r2, r3
80169e34:	e50b3008 	str	r3, [fp, #-8]
80169e38:	e51b3008 	ldr	r3, [fp, #-8]
80169e3c:	e1a00003 	mov	r0, r3
80169e40:	ebffda2e 	bl	80160700 <__RME_A7A_Read_Acquire>
80169e44:	e50b000c 	str	r0, [fp, #-12]
80169e48:	e51b300c 	ldr	r3, [fp, #-12]
80169e4c:	e1a03823 	lsr	r3, r3, #16
80169e50:	e6ef3073 	uxtb	r3, r3
80169e54:	e3530002 	cmp	r3, #2
80169e58:	1a000001 	bne	80169e64 <_RME_Sig_Rcv+0x18c>
80169e5c:	e3e03008 	mvn	r3, #8
80169e60:	ea0000aa 	b	8016a110 <_RME_Sig_Rcv+0x438>
80169e64:	e51b300c 	ldr	r3, [fp, #-12]
80169e68:	e1a03c23 	lsr	r3, r3, #24
80169e6c:	e3530008 	cmp	r3, #8
80169e70:	0a000001 	beq	80169e7c <_RME_Sig_Rcv+0x1a4>
80169e74:	e3e03001 	mvn	r3, #1
80169e78:	ea0000a4 	b	8016a110 <_RME_Sig_Rcv+0x438>
                   struct RME_Cap_Sig*,Sig_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    switch(Option)
80169e7c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80169e80:	e3530003 	cmp	r3, #3
80169e84:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
80169e88:	ea00001f 	b	80169f0c <_RME_Sig_Rcv+0x234>
80169e8c:	80169e9c 	.word	0x80169e9c
80169e90:	80169eb8 	.word	0x80169eb8
80169e94:	80169ed4 	.word	0x80169ed4
80169e98:	80169ef0 	.word	0x80169ef0
    {
        case RME_RCV_BS:
        {
            RME_COV_MARKER();

            RME_CAP_CHECK(Sig_Op,RME_SIG_FLAG_RCV_BS);
80169e9c:	e51b3008 	ldr	r3, [fp, #-8]
80169ea0:	e5933008 	ldr	r3, [r3, #8]
80169ea4:	e2033002 	and	r3, r3, #2
80169ea8:	e3530000 	cmp	r3, #0
80169eac:	1a000018 	bne	80169f14 <_RME_Sig_Rcv+0x23c>
80169eb0:	e3e03006 	mvn	r3, #6
80169eb4:	ea000095 	b	8016a110 <_RME_Sig_Rcv+0x438>
        }
        case RME_RCV_BM:
        {
            RME_COV_MARKER();
            
            RME_CAP_CHECK(Sig_Op,RME_SIG_FLAG_RCV_BM);
80169eb8:	e51b3008 	ldr	r3, [fp, #-8]
80169ebc:	e5933008 	ldr	r3, [r3, #8]
80169ec0:	e2033004 	and	r3, r3, #4
80169ec4:	e3530000 	cmp	r3, #0
80169ec8:	1a000013 	bne	80169f1c <_RME_Sig_Rcv+0x244>
80169ecc:	e3e03006 	mvn	r3, #6
80169ed0:	ea00008e 	b	8016a110 <_RME_Sig_Rcv+0x438>
        }
        case RME_RCV_NS:
        {
            RME_COV_MARKER();
            
            RME_CAP_CHECK(Sig_Op,RME_SIG_FLAG_RCV_NS);
80169ed4:	e51b3008 	ldr	r3, [fp, #-8]
80169ed8:	e5933008 	ldr	r3, [r3, #8]
80169edc:	e2033008 	and	r3, r3, #8
80169ee0:	e3530000 	cmp	r3, #0
80169ee4:	1a00000e 	bne	80169f24 <_RME_Sig_Rcv+0x24c>
80169ee8:	e3e03006 	mvn	r3, #6
80169eec:	ea000087 	b	8016a110 <_RME_Sig_Rcv+0x438>
        }
        case RME_RCV_NM:
        {
            RME_COV_MARKER();
            
            RME_CAP_CHECK(Sig_Op,RME_SIG_FLAG_RCV_NM);
80169ef0:	e51b3008 	ldr	r3, [fp, #-8]
80169ef4:	e5933008 	ldr	r3, [r3, #8]
80169ef8:	e2033010 	and	r3, r3, #16
80169efc:	e3530000 	cmp	r3, #0
80169f00:	1a000009 	bne	80169f2c <_RME_Sig_Rcv+0x254>
80169f04:	e3e03006 	mvn	r3, #6
80169f08:	ea000080 	b	8016a110 <_RME_Sig_Rcv+0x438>
        }
        default:
        {
            RME_COV_MARKER();
            
            return RME_ERR_SIV_ACT;
80169f0c:	e3e03f4b 	mvn	r3, #300	@ 0x12c
80169f10:	ea00007e 	b	8016a110 <_RME_Sig_Rcv+0x438>
            break;
80169f14:	e320f000 	nop	{0}
80169f18:	ea000004 	b	80169f30 <_RME_Sig_Rcv+0x258>
            break;
80169f1c:	e320f000 	nop	{0}
80169f20:	ea000002 	b	80169f30 <_RME_Sig_Rcv+0x258>
            break;
80169f24:	e320f000 	nop	{0}
80169f28:	ea000000 	b	80169f30 <_RME_Sig_Rcv+0x258>
            break;
80169f2c:	e320f000 	nop	{0}
        }
    }
    
    /* Convert to root cap */
    Sig_Root=RME_CAP_CONV_ROOT(Sig_Op,struct RME_Cap_Sig*);
80169f30:	e51b3008 	ldr	r3, [fp, #-8]
80169f34:	e5933000 	ldr	r3, [r3]
80169f38:	e6ff3073 	uxth	r3, r3
80169f3c:	e3530000 	cmp	r3, #0
80169f40:	0a000002 	beq	80169f50 <_RME_Sig_Rcv+0x278>
80169f44:	e51b3008 	ldr	r3, [fp, #-8]
80169f48:	e5933004 	ldr	r3, [r3, #4]
80169f4c:	ea000000 	b	80169f54 <_RME_Sig_Rcv+0x27c>
80169f50:	e51b3008 	ldr	r3, [fp, #-8]
80169f54:	e50b3010 	str	r3, [fp, #-16]
    
    /* See if we can receive on that endpoint - if someone blocks on it, we 
     * must wait for it to unblock before we can proceed. */
    if(Sig_Root->Thd!=RME_NULL)
80169f58:	e51b3010 	ldr	r3, [fp, #-16]
80169f5c:	e5933018 	ldr	r3, [r3, #24]
80169f60:	e3530000 	cmp	r3, #0
80169f64:	0a000001 	beq	80169f70 <_RME_Sig_Rcv+0x298>
    {
        RME_COV_MARKER();

        return RME_ERR_SIV_ACT;
80169f68:	e3e03f4b 	mvn	r3, #300	@ 0x12c
80169f6c:	ea000067 	b	8016a110 <_RME_Sig_Rcv+0x438>
    {
        RME_COV_MARKER();
        /* No action required */
    }
    
    Local=RME_CPU_LOCAL();
80169f70:	e30d3004 	movw	r3, #53252	@ 0xd004
80169f74:	e3483016 	movt	r3, #32790	@ 0x8016
80169f78:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Thd_Cur=Local->Thd_Cur;
80169f7c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169f80:	e5933004 	ldr	r3, [r3, #4]
80169f84:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    
    /* Check if we trying to let a boot-time thread block on a signal, which is
     * disallowed. Additionally, if the current thread have no timeslice left
     * (which shouldn't happen under any circumstances), we assert and die. */
    RME_ASSERT(Thd_Cur->Sched.Slice!=0U);
80169f88:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169f8c:	e5933018 	ldr	r3, [r3, #24]
80169f90:	e3530000 	cmp	r3, #0
80169f94:	1a000008 	bne	80169fbc <_RME_Sig_Rcv+0x2e4>
80169f98:	e30c3318 	movw	r3, #49944	@ 0xc318
80169f9c:	e3483016 	movt	r3, #32790	@ 0x8016
80169fa0:	e30c2324 	movw	r2, #49956	@ 0xc324
80169fa4:	e3482016 	movt	r2, #32790	@ 0x8016
80169fa8:	e3011c51 	movw	r1, #7249	@ 0x1c51
80169fac:	e30c0330 	movw	r0, #49968	@ 0xc330
80169fb0:	e3480016 	movt	r0, #32790	@ 0x8016
80169fb4:	ebffdaf2 	bl	80160b84 <RME_Log>
80169fb8:	eafffffe 	b	80169fb8 <_RME_Sig_Rcv+0x2e0>
    if(Thd_Cur->Sched.Slice==RME_THD_INIT_TIME)
80169fbc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169fc0:	e5933018 	ldr	r3, [r3, #24]
80169fc4:	e3730106 	cmn	r3, #-2147483647	@ 0x80000001
80169fc8:	1a000002 	bne	80169fd8 <_RME_Sig_Rcv+0x300>
    {
        RME_COV_MARKER();

        return RME_ERR_SIV_BOOT;
80169fcc:	e30f3ecd 	movw	r3, #65229	@ 0xfecd
80169fd0:	e34f3fff 	movt	r3, #65535	@ 0xffff
80169fd4:	ea00004d 	b	8016a110 <_RME_Sig_Rcv+0x438>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Check if there are signals available */
    Old_Value=Sig_Root->Sig_Num;
80169fd8:	e51b3010 	ldr	r3, [fp, #-16]
80169fdc:	e5933014 	ldr	r3, [r3, #20]
80169fe0:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    if(Old_Value>0U)
80169fe4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169fe8:	e3530000 	cmp	r3, #0
80169fec:	0a000026 	beq	8016a08c <_RME_Sig_Rcv+0x3b4>
    {
        RME_COV_MARKER();

        /* Can't use faa, other cores may reduce count to zero in the meantime */
        if((Option==RME_RCV_BS)||(Option==RME_RCV_NS))
80169ff0:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80169ff4:	e3530000 	cmp	r3, #0
80169ff8:	0a000002 	beq	8016a008 <_RME_Sig_Rcv+0x330>
80169ffc:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016a000:	e3530002 	cmp	r3, #2
8016a004:	1a00000f 	bne	8016a048 <_RME_Sig_Rcv+0x370>
        {
            RME_COV_MARKER();

            /* Try to take one */
            if(RME_COMP_SWAP(&(Sig_Root->Sig_Num),
8016a008:	e51b3010 	ldr	r3, [fp, #-16]
8016a00c:	e2830014 	add	r0, r3, #20
8016a010:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a014:	e2433001 	sub	r3, r3, #1
8016a018:	e1a02003 	mov	r2, r3
8016a01c:	e51b101c 	ldr	r1, [fp, #-28]	@ 0xffffffe4
8016a020:	ebffdaf8 	bl	80160c08 <_RME_Comp_Swap_Single>
8016a024:	e1a03000 	mov	r3, r0
8016a028:	e3530000 	cmp	r3, #0
8016a02c:	1a000001 	bne	8016a038 <_RME_Sig_Rcv+0x360>
                             Old_Value,
                             Old_Value-1U)==RME_CASFAIL)
            {
                RME_COV_MARKER();

                return RME_ERR_SIV_CONFLICT;
8016a030:	e3e03e13 	mvn	r3, #304	@ 0x130
8016a034:	ea000035 	b	8016a110 <_RME_Sig_Rcv+0x438>
                RME_COV_MARKER();
                /* No action required */
            }
            
            /* We have taken it, now return what we have taken */
            __RME_Svc_Retval_Set(Reg,1);
8016a038:	e3a01001 	mov	r1, #1
8016a03c:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
8016a040:	eb000653 	bl	8016b994 <__RME_Svc_Retval_Set>
8016a044:	ea00000e 	b	8016a084 <_RME_Sig_Rcv+0x3ac>
        else
        {
            RME_COV_MARKER();

            /* Try to take all */
            if(RME_COMP_SWAP(&(Sig_Root->Sig_Num),
8016a048:	e51b3010 	ldr	r3, [fp, #-16]
8016a04c:	e2833014 	add	r3, r3, #20
8016a050:	e3a02000 	mov	r2, #0
8016a054:	e51b101c 	ldr	r1, [fp, #-28]	@ 0xffffffe4
8016a058:	e1a00003 	mov	r0, r3
8016a05c:	ebffdae9 	bl	80160c08 <_RME_Comp_Swap_Single>
8016a060:	e1a03000 	mov	r3, r0
8016a064:	e3530000 	cmp	r3, #0
8016a068:	1a000001 	bne	8016a074 <_RME_Sig_Rcv+0x39c>
                             Old_Value,
                             0U)==RME_CASFAIL)
            {
                RME_COV_MARKER();

                return RME_ERR_SIV_CONFLICT;
8016a06c:	e3e03e13 	mvn	r3, #304	@ 0x130
8016a070:	ea000026 	b	8016a110 <_RME_Sig_Rcv+0x438>
                RME_COV_MARKER();
                /* No action required */
            }
            
            /* We have taken all, now return what we have taken */
            __RME_Svc_Retval_Set(Reg,(rme_ret_t)Old_Value);
8016a074:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a078:	e1a01003 	mov	r1, r3
8016a07c:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
8016a080:	eb000643 	bl	8016b994 <__RME_Svc_Retval_Set>
        }
        
        return 0;
8016a084:	e3a03000 	mov	r3, #0
8016a088:	ea000020 	b	8016a110 <_RME_Sig_Rcv+0x438>
    else
    {
        RME_COV_MARKER();

        /* There's no value, try to block */
        if((Option==RME_RCV_BS)||(Option==RME_RCV_BM))
8016a08c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016a090:	e3530000 	cmp	r3, #0
8016a094:	0a000002 	beq	8016a0a4 <_RME_Sig_Rcv+0x3cc>
8016a098:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016a09c:	e3530001 	cmp	r3, #1
8016a0a0:	1a000016 	bne	8016a100 <_RME_Sig_Rcv+0x428>
        {
            RME_COV_MARKER();

            if(RME_COMP_SWAP((rme_ptr_t*)&(Sig_Root->Thd),
8016a0a4:	e51b3010 	ldr	r3, [fp, #-16]
8016a0a8:	e2833018 	add	r3, r3, #24
8016a0ac:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016a0b0:	e3a01000 	mov	r1, #0
8016a0b4:	e1a00003 	mov	r0, r3
8016a0b8:	ebffdad2 	bl	80160c08 <_RME_Comp_Swap_Single>
8016a0bc:	e1a03000 	mov	r3, r0
8016a0c0:	e3530000 	cmp	r3, #0
8016a0c4:	1a000001 	bne	8016a0d0 <_RME_Sig_Rcv+0x3f8>
                             RME_NULL,
                             (rme_ptr_t)Thd_Cur)==RME_CASFAIL)
            {
                RME_COV_MARKER();

                return RME_ERR_SIV_CONFLICT;
8016a0c8:	e3e03e13 	mvn	r3, #304	@ 0x130
8016a0cc:	ea00000f 	b	8016a110 <_RME_Sig_Rcv+0x438>
            /* Now we block our current thread. No need to set any return value
             * to the register set here, because we do not yet know how many
             * signals will be there when the thread unblocks. The unblocking
             * does not need an option so we don't keep that; we always treat
             * it as single receive when we unblock anyway. */
            Thd_Cur->Sched.Signal=Sig_Root;
8016a0d0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a0d4:	e51b2010 	ldr	r2, [fp, #-16]
8016a0d8:	e5832028 	str	r2, [r3, #40]	@ 0x28
            Thd_Cur->Sched.State=RME_THD_BLOCKED;
8016a0dc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a0e0:	e3a02001 	mov	r2, #1
8016a0e4:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Del(Thd_Cur);
8016a0e8:	e51b0018 	ldr	r0, [fp, #-24]	@ 0xffffffe8
8016a0ec:	ebffebe1 	bl	80165078 <_RME_Run_Del>
            
            /* Pick the highest priority thread to run */
            _RME_Kern_High(Reg,Local);
8016a0f0:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
8016a0f4:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
8016a0f8:	ebfffda9 	bl	801697a4 <_RME_Kern_High>
8016a0fc:	ea000002 	b	8016a10c <_RME_Sig_Rcv+0x434>
        else
        {
            RME_COV_MARKER();

            /* We have taken nothing but the system call is successful anyway */
            __RME_Svc_Retval_Set(Reg,0);
8016a100:	e3a01000 	mov	r1, #0
8016a104:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
8016a108:	eb000621 	bl	8016b994 <__RME_Svc_Retval_Set>
        }
    }
    
    return 0;
8016a10c:	e3a03000 	mov	r3, #0
}
8016a110:	e1a00003 	mov	r0, r3
8016a114:	e24bd004 	sub	sp, fp, #4
8016a118:	e8bd8800 	pop	{fp, pc}

8016a11c <_RME_Inv_Crt>:
                              rme_cid_t Cap_Cpt,
                              rme_cid_t Cap_Kom,
                              rme_cid_t Cap_Inv,
                              rme_cid_t Cap_Prc,
                              rme_ptr_t Raddr)
{
8016a11c:	e92d4800 	push	{fp, lr}
8016a120:	e28db004 	add	fp, sp, #4
8016a124:	e24dd030 	sub	sp, sp, #48	@ 0x30
8016a128:	e50b0028 	str	r0, [fp, #-40]	@ 0xffffffd8
8016a12c:	e50b102c 	str	r1, [fp, #-44]	@ 0xffffffd4
8016a130:	e50b2030 	str	r2, [fp, #-48]	@ 0xffffffd0
8016a134:	e50b3034 	str	r3, [fp, #-52]	@ 0xffffffcc
    struct RME_Inv_Struct* Invocation;
    rme_ptr_t Type_Stat;
    rme_ptr_t Vaddr;
    
    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
8016a138:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016a13c:	e2033080 	and	r3, r3, #128	@ 0x80
8016a140:	e3530000 	cmp	r3, #0
8016a144:	1a00001d 	bne	8016a1c0 <_RME_Inv_Crt+0xa4>
8016a148:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a14c:	e5932014 	ldr	r2, [r3, #20]
8016a150:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016a154:	e1520003 	cmp	r2, r3
8016a158:	8a000001 	bhi	8016a164 <_RME_Inv_Crt+0x48>
8016a15c:	e3e03002 	mvn	r3, #2
8016a160:	ea00019e 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a164:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016a168:	e1a02283 	lsl	r2, r3, #5
8016a16c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a170:	e593300c 	ldr	r3, [r3, #12]
8016a174:	e0823003 	add	r3, r2, r3
8016a178:	e50b3008 	str	r3, [fp, #-8]
8016a17c:	e51b3008 	ldr	r3, [fp, #-8]
8016a180:	e1a00003 	mov	r0, r3
8016a184:	ebffd95d 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a188:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016a18c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a190:	e1a03823 	lsr	r3, r3, #16
8016a194:	e6ef3073 	uxtb	r3, r3
8016a198:	e3530002 	cmp	r3, #2
8016a19c:	1a000001 	bne	8016a1a8 <_RME_Inv_Crt+0x8c>
8016a1a0:	e3e03008 	mvn	r3, #8
8016a1a4:	ea00018d 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a1a8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a1ac:	e1a03c23 	lsr	r3, r3, #24
8016a1b0:	e3530003 	cmp	r3, #3
8016a1b4:	0a000041 	beq	8016a2c0 <_RME_Inv_Crt+0x1a4>
8016a1b8:	e3e03001 	mvn	r3, #1
8016a1bc:	ea000187 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a1c0:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016a1c4:	e1a02423 	lsr	r2, r3, #8
8016a1c8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a1cc:	e5933014 	ldr	r3, [r3, #20]
8016a1d0:	e1520003 	cmp	r2, r3
8016a1d4:	3a000001 	bcc	8016a1e0 <_RME_Inv_Crt+0xc4>
8016a1d8:	e3e03002 	mvn	r3, #2
8016a1dc:	ea00017f 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a1e0:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016a1e4:	e1a03423 	lsr	r3, r3, #8
8016a1e8:	e1a02283 	lsl	r2, r3, #5
8016a1ec:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a1f0:	e593300c 	ldr	r3, [r3, #12]
8016a1f4:	e0823003 	add	r3, r2, r3
8016a1f8:	e50b3008 	str	r3, [fp, #-8]
8016a1fc:	e51b3008 	ldr	r3, [fp, #-8]
8016a200:	e1a00003 	mov	r0, r3
8016a204:	ebffd93d 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a208:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016a20c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a210:	e1a03823 	lsr	r3, r3, #16
8016a214:	e6ef3073 	uxtb	r3, r3
8016a218:	e3530002 	cmp	r3, #2
8016a21c:	1a000001 	bne	8016a228 <_RME_Inv_Crt+0x10c>
8016a220:	e3e03008 	mvn	r3, #8
8016a224:	ea00016d 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a228:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a22c:	e1a03c23 	lsr	r3, r3, #24
8016a230:	e3530003 	cmp	r3, #3
8016a234:	0a000001 	beq	8016a240 <_RME_Inv_Crt+0x124>
8016a238:	e3e03001 	mvn	r3, #1
8016a23c:	ea000167 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a240:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016a244:	e203207f 	and	r2, r3, #127	@ 0x7f
8016a248:	e51b3008 	ldr	r3, [fp, #-8]
8016a24c:	e5933014 	ldr	r3, [r3, #20]
8016a250:	e1520003 	cmp	r2, r3
8016a254:	3a000001 	bcc	8016a260 <_RME_Inv_Crt+0x144>
8016a258:	e3e03002 	mvn	r3, #2
8016a25c:	ea00015f 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a260:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016a264:	e203307f 	and	r3, r3, #127	@ 0x7f
8016a268:	e1a02283 	lsl	r2, r3, #5
8016a26c:	e51b3008 	ldr	r3, [fp, #-8]
8016a270:	e593300c 	ldr	r3, [r3, #12]
8016a274:	e0823003 	add	r3, r2, r3
8016a278:	e50b3008 	str	r3, [fp, #-8]
8016a27c:	e51b3008 	ldr	r3, [fp, #-8]
8016a280:	e1a00003 	mov	r0, r3
8016a284:	ebffd91d 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a288:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016a28c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a290:	e1a03823 	lsr	r3, r3, #16
8016a294:	e6ef3073 	uxtb	r3, r3
8016a298:	e3530002 	cmp	r3, #2
8016a29c:	1a000001 	bne	8016a2a8 <_RME_Inv_Crt+0x18c>
8016a2a0:	e3e03008 	mvn	r3, #8
8016a2a4:	ea00014d 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a2a8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a2ac:	e1a03c23 	lsr	r3, r3, #24
8016a2b0:	e3530003 	cmp	r3, #3
8016a2b4:	0a000001 	beq	8016a2c0 <_RME_Inv_Crt+0x1a4>
8016a2b8:	e3e03001 	mvn	r3, #1
8016a2bc:	ea000147 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Prc,RME_CAP_TYPE_PRC,
8016a2c0:	e59b3004 	ldr	r3, [fp, #4]
8016a2c4:	e2033080 	and	r3, r3, #128	@ 0x80
8016a2c8:	e3530000 	cmp	r3, #0
8016a2cc:	1a00001d 	bne	8016a348 <_RME_Inv_Crt+0x22c>
8016a2d0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a2d4:	e5932014 	ldr	r2, [r3, #20]
8016a2d8:	e59b3004 	ldr	r3, [fp, #4]
8016a2dc:	e1520003 	cmp	r2, r3
8016a2e0:	8a000001 	bhi	8016a2ec <_RME_Inv_Crt+0x1d0>
8016a2e4:	e3e03002 	mvn	r3, #2
8016a2e8:	ea00013c 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a2ec:	e59b3004 	ldr	r3, [fp, #4]
8016a2f0:	e1a02283 	lsl	r2, r3, #5
8016a2f4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a2f8:	e593300c 	ldr	r3, [r3, #12]
8016a2fc:	e0823003 	add	r3, r2, r3
8016a300:	e50b300c 	str	r3, [fp, #-12]
8016a304:	e51b300c 	ldr	r3, [fp, #-12]
8016a308:	e1a00003 	mov	r0, r3
8016a30c:	ebffd8fb 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a310:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016a314:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a318:	e1a03823 	lsr	r3, r3, #16
8016a31c:	e6ef3073 	uxtb	r3, r3
8016a320:	e3530002 	cmp	r3, #2
8016a324:	1a000001 	bne	8016a330 <_RME_Inv_Crt+0x214>
8016a328:	e3e03008 	mvn	r3, #8
8016a32c:	ea00012b 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a330:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a334:	e1a03c23 	lsr	r3, r3, #24
8016a338:	e3530005 	cmp	r3, #5
8016a33c:	0a000041 	beq	8016a448 <_RME_Inv_Crt+0x32c>
8016a340:	e3e03001 	mvn	r3, #1
8016a344:	ea000125 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a348:	e59b3004 	ldr	r3, [fp, #4]
8016a34c:	e1a02423 	lsr	r2, r3, #8
8016a350:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a354:	e5933014 	ldr	r3, [r3, #20]
8016a358:	e1520003 	cmp	r2, r3
8016a35c:	3a000001 	bcc	8016a368 <_RME_Inv_Crt+0x24c>
8016a360:	e3e03002 	mvn	r3, #2
8016a364:	ea00011d 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a368:	e59b3004 	ldr	r3, [fp, #4]
8016a36c:	e1a03423 	lsr	r3, r3, #8
8016a370:	e1a02283 	lsl	r2, r3, #5
8016a374:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a378:	e593300c 	ldr	r3, [r3, #12]
8016a37c:	e0823003 	add	r3, r2, r3
8016a380:	e50b300c 	str	r3, [fp, #-12]
8016a384:	e51b300c 	ldr	r3, [fp, #-12]
8016a388:	e1a00003 	mov	r0, r3
8016a38c:	ebffd8db 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a390:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016a394:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a398:	e1a03823 	lsr	r3, r3, #16
8016a39c:	e6ef3073 	uxtb	r3, r3
8016a3a0:	e3530002 	cmp	r3, #2
8016a3a4:	1a000001 	bne	8016a3b0 <_RME_Inv_Crt+0x294>
8016a3a8:	e3e03008 	mvn	r3, #8
8016a3ac:	ea00010b 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a3b0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a3b4:	e1a03c23 	lsr	r3, r3, #24
8016a3b8:	e3530003 	cmp	r3, #3
8016a3bc:	0a000001 	beq	8016a3c8 <_RME_Inv_Crt+0x2ac>
8016a3c0:	e3e03001 	mvn	r3, #1
8016a3c4:	ea000105 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a3c8:	e59b3004 	ldr	r3, [fp, #4]
8016a3cc:	e203207f 	and	r2, r3, #127	@ 0x7f
8016a3d0:	e51b300c 	ldr	r3, [fp, #-12]
8016a3d4:	e5933014 	ldr	r3, [r3, #20]
8016a3d8:	e1520003 	cmp	r2, r3
8016a3dc:	3a000001 	bcc	8016a3e8 <_RME_Inv_Crt+0x2cc>
8016a3e0:	e3e03002 	mvn	r3, #2
8016a3e4:	ea0000fd 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a3e8:	e59b3004 	ldr	r3, [fp, #4]
8016a3ec:	e203307f 	and	r3, r3, #127	@ 0x7f
8016a3f0:	e1a02283 	lsl	r2, r3, #5
8016a3f4:	e51b300c 	ldr	r3, [fp, #-12]
8016a3f8:	e593300c 	ldr	r3, [r3, #12]
8016a3fc:	e0823003 	add	r3, r2, r3
8016a400:	e50b300c 	str	r3, [fp, #-12]
8016a404:	e51b300c 	ldr	r3, [fp, #-12]
8016a408:	e1a00003 	mov	r0, r3
8016a40c:	ebffd8bb 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a410:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016a414:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a418:	e1a03823 	lsr	r3, r3, #16
8016a41c:	e6ef3073 	uxtb	r3, r3
8016a420:	e3530002 	cmp	r3, #2
8016a424:	1a000001 	bne	8016a430 <_RME_Inv_Crt+0x314>
8016a428:	e3e03008 	mvn	r3, #8
8016a42c:	ea0000eb 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a430:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a434:	e1a03c23 	lsr	r3, r3, #24
8016a438:	e3530005 	cmp	r3, #5
8016a43c:	0a000001 	beq	8016a448 <_RME_Inv_Crt+0x32c>
8016a440:	e3e03001 	mvn	r3, #1
8016a444:	ea0000e5 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
                   struct RME_Cap_Prc*,Prc_Op,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Kom,RME_CAP_TYPE_KOM,
8016a448:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016a44c:	e2033080 	and	r3, r3, #128	@ 0x80
8016a450:	e3530000 	cmp	r3, #0
8016a454:	1a00001d 	bne	8016a4d0 <_RME_Inv_Crt+0x3b4>
8016a458:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a45c:	e5932014 	ldr	r2, [r3, #20]
8016a460:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016a464:	e1520003 	cmp	r2, r3
8016a468:	8a000001 	bhi	8016a474 <_RME_Inv_Crt+0x358>
8016a46c:	e3e03002 	mvn	r3, #2
8016a470:	ea0000da 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a474:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016a478:	e1a02283 	lsl	r2, r3, #5
8016a47c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a480:	e593300c 	ldr	r3, [r3, #12]
8016a484:	e0823003 	add	r3, r2, r3
8016a488:	e50b3010 	str	r3, [fp, #-16]
8016a48c:	e51b3010 	ldr	r3, [fp, #-16]
8016a490:	e1a00003 	mov	r0, r3
8016a494:	ebffd899 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a498:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016a49c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a4a0:	e1a03823 	lsr	r3, r3, #16
8016a4a4:	e6ef3073 	uxtb	r3, r3
8016a4a8:	e3530002 	cmp	r3, #2
8016a4ac:	1a000001 	bne	8016a4b8 <_RME_Inv_Crt+0x39c>
8016a4b0:	e3e03008 	mvn	r3, #8
8016a4b4:	ea0000c9 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a4b8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a4bc:	e1a03c23 	lsr	r3, r3, #24
8016a4c0:	e3530002 	cmp	r3, #2
8016a4c4:	0a000041 	beq	8016a5d0 <_RME_Inv_Crt+0x4b4>
8016a4c8:	e3e03001 	mvn	r3, #1
8016a4cc:	ea0000c3 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a4d0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016a4d4:	e1a02423 	lsr	r2, r3, #8
8016a4d8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a4dc:	e5933014 	ldr	r3, [r3, #20]
8016a4e0:	e1520003 	cmp	r2, r3
8016a4e4:	3a000001 	bcc	8016a4f0 <_RME_Inv_Crt+0x3d4>
8016a4e8:	e3e03002 	mvn	r3, #2
8016a4ec:	ea0000bb 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a4f0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016a4f4:	e1a03423 	lsr	r3, r3, #8
8016a4f8:	e1a02283 	lsl	r2, r3, #5
8016a4fc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a500:	e593300c 	ldr	r3, [r3, #12]
8016a504:	e0823003 	add	r3, r2, r3
8016a508:	e50b3010 	str	r3, [fp, #-16]
8016a50c:	e51b3010 	ldr	r3, [fp, #-16]
8016a510:	e1a00003 	mov	r0, r3
8016a514:	ebffd879 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a518:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016a51c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a520:	e1a03823 	lsr	r3, r3, #16
8016a524:	e6ef3073 	uxtb	r3, r3
8016a528:	e3530002 	cmp	r3, #2
8016a52c:	1a000001 	bne	8016a538 <_RME_Inv_Crt+0x41c>
8016a530:	e3e03008 	mvn	r3, #8
8016a534:	ea0000a9 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a538:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a53c:	e1a03c23 	lsr	r3, r3, #24
8016a540:	e3530003 	cmp	r3, #3
8016a544:	0a000001 	beq	8016a550 <_RME_Inv_Crt+0x434>
8016a548:	e3e03001 	mvn	r3, #1
8016a54c:	ea0000a3 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a550:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016a554:	e203207f 	and	r2, r3, #127	@ 0x7f
8016a558:	e51b3010 	ldr	r3, [fp, #-16]
8016a55c:	e5933014 	ldr	r3, [r3, #20]
8016a560:	e1520003 	cmp	r2, r3
8016a564:	3a000001 	bcc	8016a570 <_RME_Inv_Crt+0x454>
8016a568:	e3e03002 	mvn	r3, #2
8016a56c:	ea00009b 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a570:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016a574:	e203307f 	and	r3, r3, #127	@ 0x7f
8016a578:	e1a02283 	lsl	r2, r3, #5
8016a57c:	e51b3010 	ldr	r3, [fp, #-16]
8016a580:	e593300c 	ldr	r3, [r3, #12]
8016a584:	e0823003 	add	r3, r2, r3
8016a588:	e50b3010 	str	r3, [fp, #-16]
8016a58c:	e51b3010 	ldr	r3, [fp, #-16]
8016a590:	e1a00003 	mov	r0, r3
8016a594:	ebffd859 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a598:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016a59c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a5a0:	e1a03823 	lsr	r3, r3, #16
8016a5a4:	e6ef3073 	uxtb	r3, r3
8016a5a8:	e3530002 	cmp	r3, #2
8016a5ac:	1a000001 	bne	8016a5b8 <_RME_Inv_Crt+0x49c>
8016a5b0:	e3e03008 	mvn	r3, #8
8016a5b4:	ea000089 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a5b8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a5bc:	e1a03c23 	lsr	r3, r3, #24
8016a5c0:	e3530002 	cmp	r3, #2
8016a5c4:	0a000001 	beq	8016a5d0 <_RME_Inv_Crt+0x4b4>
8016a5c8:	e3e03001 	mvn	r3, #1
8016a5cc:	ea000083 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
                   struct RME_Cap_Kom*,Kom_Op,Type_Stat);
    /* Check if the captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_CRT);
8016a5d0:	e51b3008 	ldr	r3, [fp, #-8]
8016a5d4:	e5933008 	ldr	r3, [r3, #8]
8016a5d8:	e2033001 	and	r3, r3, #1
8016a5dc:	e3530000 	cmp	r3, #0
8016a5e0:	1a000001 	bne	8016a5ec <_RME_Inv_Crt+0x4d0>
8016a5e4:	e3e03006 	mvn	r3, #6
8016a5e8:	ea00007c 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
    RME_CAP_CHECK(Prc_Op,RME_PRC_FLAG_INV);
8016a5ec:	e51b300c 	ldr	r3, [fp, #-12]
8016a5f0:	e5933008 	ldr	r3, [r3, #8]
8016a5f4:	e2033001 	and	r3, r3, #1
8016a5f8:	e3530000 	cmp	r3, #0
8016a5fc:	1a000001 	bne	8016a608 <_RME_Inv_Crt+0x4ec>
8016a600:	e3e03006 	mvn	r3, #6
8016a604:	ea000075 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
    /* See if the creation is valid for this kmem range */
    RME_KOM_CHECK(Kom_Op,RME_KOM_FLAG_INV,Raddr,Vaddr,RME_INV_SIZE);
8016a608:	e51b3010 	ldr	r3, [fp, #-16]
8016a60c:	e5933008 	ldr	r3, [r3, #8]
8016a610:	e2033008 	and	r3, r3, #8
8016a614:	e3530000 	cmp	r3, #0
8016a618:	1a000001 	bne	8016a624 <_RME_Inv_Crt+0x508>
8016a61c:	e3e03006 	mvn	r3, #6
8016a620:	ea00006e 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a624:	e51b3010 	ldr	r3, [fp, #-16]
8016a628:	e5933014 	ldr	r3, [r3, #20]
8016a62c:	e59b2008 	ldr	r2, [fp, #8]
8016a630:	e0823003 	add	r3, r2, r3
8016a634:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
8016a638:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016a63c:	e59b3008 	ldr	r3, [fp, #8]
8016a640:	e1520003 	cmp	r2, r3
8016a644:	2a000001 	bcs	8016a650 <_RME_Inv_Crt+0x534>
8016a648:	e3e03006 	mvn	r3, #6
8016a64c:	ea000063 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a650:	e51b3010 	ldr	r3, [fp, #-16]
8016a654:	e5933014 	ldr	r3, [r3, #20]
8016a658:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016a65c:	e1520003 	cmp	r2, r3
8016a660:	2a000001 	bcs	8016a66c <_RME_Inv_Crt+0x550>
8016a664:	e3e03006 	mvn	r3, #6
8016a668:	ea00005c 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a66c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a670:	e3730025 	cmn	r3, #37	@ 0x25
8016a674:	9a000001 	bls	8016a680 <_RME_Inv_Crt+0x564>
8016a678:	e3e03006 	mvn	r3, #6
8016a67c:	ea000057 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a680:	e51b3010 	ldr	r3, [fp, #-16]
8016a684:	e5932018 	ldr	r2, [r3, #24]
8016a688:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a68c:	e2833023 	add	r3, r3, #35	@ 0x23
8016a690:	e1520003 	cmp	r2, r3
8016a694:	2a000001 	bcs	8016a6a0 <_RME_Inv_Crt+0x584>
8016a698:	e3e03006 	mvn	r3, #6
8016a69c:	ea00004f 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Inv,struct RME_Cap_Inv*,Inv_Crt);
8016a6a0:	e51b3008 	ldr	r3, [fp, #-8]
8016a6a4:	e5932014 	ldr	r2, [r3, #20]
8016a6a8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
8016a6ac:	e1520003 	cmp	r2, r3
8016a6b0:	8a000001 	bhi	8016a6bc <_RME_Inv_Crt+0x5a0>
8016a6b4:	e3e03002 	mvn	r3, #2
8016a6b8:	ea000048 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a6bc:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
8016a6c0:	e1a02283 	lsl	r2, r3, #5
8016a6c4:	e51b3008 	ldr	r3, [fp, #-8]
8016a6c8:	e593300c 	ldr	r3, [r3, #12]
8016a6cc:	e0823003 	add	r3, r2, r3
8016a6d0:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Inv_Crt);
8016a6d4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a6d8:	e3a02801 	mov	r2, #65536	@ 0x10000
8016a6dc:	e3a01000 	mov	r1, #0
8016a6e0:	e1a00003 	mov	r0, r3
8016a6e4:	ebffd947 	bl	80160c08 <_RME_Comp_Swap_Single>
8016a6e8:	e1a03000 	mov	r3, r0
8016a6ec:	e3530000 	cmp	r3, #0
8016a6f0:	1a000001 	bne	8016a6fc <_RME_Inv_Crt+0x5e0>
8016a6f4:	e3e03004 	mvn	r3, #4
8016a6f8:	ea000038 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
8016a6fc:	e30d3000 	movw	r3, #53248	@ 0xd000
8016a700:	e3483016 	movt	r3, #32790	@ 0x8016
8016a704:	e5932000 	ldr	r2, [r3]
8016a708:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a70c:	e5832010 	str	r2, [r3, #16]
    
    /* Try to populate the area */
    if(_RME_Kot_Mark(Vaddr,RME_INV_SIZE)!=0)
8016a710:	e3a01024 	mov	r1, #36	@ 0x24
8016a714:	e51b0018 	ldr	r0, [fp, #-24]	@ 0xffffffe8
8016a718:	ebffe889 	bl	80164944 <_RME_Kot_Mark>
8016a71c:	e1a03000 	mov	r3, r0
8016a720:	e3530000 	cmp	r3, #0
8016a724:	0a000005 	beq	8016a740 <_RME_Inv_Crt+0x624>
    {
        RME_COV_MARKER();

        RME_WRITE_RELEASE(&(Inv_Crt->Head.Type_Stat),0U);
8016a728:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a72c:	e3a01000 	mov	r1, #0
8016a730:	e1a00003 	mov	r0, r3
8016a734:	ebffd7f4 	bl	8016070c <__RME_A7A_Write_Release>
        return RME_ERR_CPT_KOT;
8016a738:	e3e03003 	mvn	r3, #3
8016a73c:	ea000027 	b	8016a7e0 <_RME_Inv_Crt+0x6c4>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Object init */
    Invocation=(struct RME_Inv_Struct*)Vaddr;
8016a740:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a744:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
    Prc_Root=RME_CAP_CONV_ROOT(Prc_Op,struct RME_Cap_Prc*);
8016a748:	e51b300c 	ldr	r3, [fp, #-12]
8016a74c:	e5933000 	ldr	r3, [r3]
8016a750:	e6ff3073 	uxth	r3, r3
8016a754:	e3530000 	cmp	r3, #0
8016a758:	0a000002 	beq	8016a768 <_RME_Inv_Crt+0x64c>
8016a75c:	e51b300c 	ldr	r3, [fp, #-12]
8016a760:	e5933004 	ldr	r3, [r3, #4]
8016a764:	ea000000 	b	8016a76c <_RME_Inv_Crt+0x650>
8016a768:	e51b300c 	ldr	r3, [fp, #-12]
8016a76c:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    Invocation->Prc=Prc_Root;
8016a770:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a774:	e51b2024 	ldr	r2, [fp, #-36]	@ 0xffffffdc
8016a778:	e5832008 	str	r2, [r3, #8]
    Invocation->Thd_Act=RME_NULL;
8016a77c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a780:	e3a02000 	mov	r2, #0
8016a784:	e583200c 	str	r2, [r3, #12]
    /* By default we do not return on exception */
    Invocation->Is_Exc_Ret=0U;
8016a788:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a78c:	e3a02000 	mov	r2, #0
8016a790:	e5832018 	str	r2, [r3, #24]
    
    /* Header init */
    Inv_Crt->Head.Root_Ref=0U;
8016a794:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a798:	e3a02000 	mov	r2, #0
8016a79c:	e5832004 	str	r2, [r3, #4]
    Inv_Crt->Head.Object=Vaddr;
8016a7a0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a7a4:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016a7a8:	e583200c 	str	r2, [r3, #12]
    Inv_Crt->Head.Flag=RME_INV_FLAG_ALL;
8016a7ac:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a7b0:	e3a02003 	mov	r2, #3
8016a7b4:	e5832008 	str	r2, [r3, #8]
    
    /* Reference object */
    RME_FETCH_ADD(&(Prc_Root->Head.Root_Ref),1U);
8016a7b8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016a7bc:	e2833004 	add	r3, r3, #4
8016a7c0:	e3a01001 	mov	r1, #1
8016a7c4:	e1a00003 	mov	r0, r3
8016a7c8:	ebffd923 	bl	80160c5c <_RME_Fetch_Add_Single>
    
    /* Establish cap */
    RME_WRITE_RELEASE(&(Inv_Crt->Head.Type_Stat),
8016a7cc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a7d0:	e3a01407 	mov	r1, #117440512	@ 0x7000000
8016a7d4:	e1a00003 	mov	r0, r3
8016a7d8:	ebffd7cb 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_INV,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
8016a7dc:	e3a03000 	mov	r3, #0
}
8016a7e0:	e1a00003 	mov	r0, r3
8016a7e4:	e24bd004 	sub	sp, fp, #4
8016a7e8:	e8bd8800 	pop	{fp, pc}

8016a7ec <_RME_Inv_Del>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Inv_Del(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt,
                              rme_cid_t Cap_Inv)
{
8016a7ec:	e92d4800 	push	{fp, lr}
8016a7f0:	e28db004 	add	fp, sp, #4
8016a7f4:	e24dd020 	sub	sp, sp, #32
8016a7f8:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
8016a7fc:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
8016a800:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    rme_ptr_t Type_Stat;
    /* These are for deletion */
    struct RME_Inv_Struct* Invocation;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
8016a804:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a808:	e2033080 	and	r3, r3, #128	@ 0x80
8016a80c:	e3530000 	cmp	r3, #0
8016a810:	1a00001d 	bne	8016a88c <_RME_Inv_Del+0xa0>
8016a814:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a818:	e5932014 	ldr	r2, [r3, #20]
8016a81c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a820:	e1520003 	cmp	r2, r3
8016a824:	8a000001 	bhi	8016a830 <_RME_Inv_Del+0x44>
8016a828:	e3e03002 	mvn	r3, #2
8016a82c:	ea0000c8 	b	8016ab54 <_RME_Inv_Del+0x368>
8016a830:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a834:	e1a02283 	lsl	r2, r3, #5
8016a838:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a83c:	e593300c 	ldr	r3, [r3, #12]
8016a840:	e0823003 	add	r3, r2, r3
8016a844:	e50b3008 	str	r3, [fp, #-8]
8016a848:	e51b3008 	ldr	r3, [fp, #-8]
8016a84c:	e1a00003 	mov	r0, r3
8016a850:	ebffd7aa 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a854:	e50b000c 	str	r0, [fp, #-12]
8016a858:	e51b300c 	ldr	r3, [fp, #-12]
8016a85c:	e1a03823 	lsr	r3, r3, #16
8016a860:	e6ef3073 	uxtb	r3, r3
8016a864:	e3530002 	cmp	r3, #2
8016a868:	1a000001 	bne	8016a874 <_RME_Inv_Del+0x88>
8016a86c:	e3e03008 	mvn	r3, #8
8016a870:	ea0000b7 	b	8016ab54 <_RME_Inv_Del+0x368>
8016a874:	e51b300c 	ldr	r3, [fp, #-12]
8016a878:	e1a03c23 	lsr	r3, r3, #24
8016a87c:	e3530003 	cmp	r3, #3
8016a880:	0a000041 	beq	8016a98c <_RME_Inv_Del+0x1a0>
8016a884:	e3e03001 	mvn	r3, #1
8016a888:	ea0000b1 	b	8016ab54 <_RME_Inv_Del+0x368>
8016a88c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a890:	e1a02423 	lsr	r2, r3, #8
8016a894:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a898:	e5933014 	ldr	r3, [r3, #20]
8016a89c:	e1520003 	cmp	r2, r3
8016a8a0:	3a000001 	bcc	8016a8ac <_RME_Inv_Del+0xc0>
8016a8a4:	e3e03002 	mvn	r3, #2
8016a8a8:	ea0000a9 	b	8016ab54 <_RME_Inv_Del+0x368>
8016a8ac:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a8b0:	e1a03423 	lsr	r3, r3, #8
8016a8b4:	e1a02283 	lsl	r2, r3, #5
8016a8b8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a8bc:	e593300c 	ldr	r3, [r3, #12]
8016a8c0:	e0823003 	add	r3, r2, r3
8016a8c4:	e50b3008 	str	r3, [fp, #-8]
8016a8c8:	e51b3008 	ldr	r3, [fp, #-8]
8016a8cc:	e1a00003 	mov	r0, r3
8016a8d0:	ebffd78a 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a8d4:	e50b000c 	str	r0, [fp, #-12]
8016a8d8:	e51b300c 	ldr	r3, [fp, #-12]
8016a8dc:	e1a03823 	lsr	r3, r3, #16
8016a8e0:	e6ef3073 	uxtb	r3, r3
8016a8e4:	e3530002 	cmp	r3, #2
8016a8e8:	1a000001 	bne	8016a8f4 <_RME_Inv_Del+0x108>
8016a8ec:	e3e03008 	mvn	r3, #8
8016a8f0:	ea000097 	b	8016ab54 <_RME_Inv_Del+0x368>
8016a8f4:	e51b300c 	ldr	r3, [fp, #-12]
8016a8f8:	e1a03c23 	lsr	r3, r3, #24
8016a8fc:	e3530003 	cmp	r3, #3
8016a900:	0a000001 	beq	8016a90c <_RME_Inv_Del+0x120>
8016a904:	e3e03001 	mvn	r3, #1
8016a908:	ea000091 	b	8016ab54 <_RME_Inv_Del+0x368>
8016a90c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a910:	e203207f 	and	r2, r3, #127	@ 0x7f
8016a914:	e51b3008 	ldr	r3, [fp, #-8]
8016a918:	e5933014 	ldr	r3, [r3, #20]
8016a91c:	e1520003 	cmp	r2, r3
8016a920:	3a000001 	bcc	8016a92c <_RME_Inv_Del+0x140>
8016a924:	e3e03002 	mvn	r3, #2
8016a928:	ea000089 	b	8016ab54 <_RME_Inv_Del+0x368>
8016a92c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a930:	e203307f 	and	r3, r3, #127	@ 0x7f
8016a934:	e1a02283 	lsl	r2, r3, #5
8016a938:	e51b3008 	ldr	r3, [fp, #-8]
8016a93c:	e593300c 	ldr	r3, [r3, #12]
8016a940:	e0823003 	add	r3, r2, r3
8016a944:	e50b3008 	str	r3, [fp, #-8]
8016a948:	e51b3008 	ldr	r3, [fp, #-8]
8016a94c:	e1a00003 	mov	r0, r3
8016a950:	ebffd76a 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a954:	e50b000c 	str	r0, [fp, #-12]
8016a958:	e51b300c 	ldr	r3, [fp, #-12]
8016a95c:	e1a03823 	lsr	r3, r3, #16
8016a960:	e6ef3073 	uxtb	r3, r3
8016a964:	e3530002 	cmp	r3, #2
8016a968:	1a000001 	bne	8016a974 <_RME_Inv_Del+0x188>
8016a96c:	e3e03008 	mvn	r3, #8
8016a970:	ea000077 	b	8016ab54 <_RME_Inv_Del+0x368>
8016a974:	e51b300c 	ldr	r3, [fp, #-12]
8016a978:	e1a03c23 	lsr	r3, r3, #24
8016a97c:	e3530003 	cmp	r3, #3
8016a980:	0a000001 	beq	8016a98c <_RME_Inv_Del+0x1a0>
8016a984:	e3e03001 	mvn	r3, #1
8016a988:	ea000071 	b	8016ab54 <_RME_Inv_Del+0x368>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_DEL);
8016a98c:	e51b3008 	ldr	r3, [fp, #-8]
8016a990:	e5933008 	ldr	r3, [r3, #8]
8016a994:	e2033002 	and	r3, r3, #2
8016a998:	e3530000 	cmp	r3, #0
8016a99c:	1a000001 	bne	8016a9a8 <_RME_Inv_Del+0x1bc>
8016a9a0:	e3e03006 	mvn	r3, #6
8016a9a4:	ea00006a 	b	8016ab54 <_RME_Inv_Del+0x368>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Inv,struct RME_Cap_Inv*,Inv_Del);
8016a9a8:	e51b3008 	ldr	r3, [fp, #-8]
8016a9ac:	e5932014 	ldr	r2, [r3, #20]
8016a9b0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a9b4:	e1520003 	cmp	r2, r3
8016a9b8:	8a000001 	bhi	8016a9c4 <_RME_Inv_Del+0x1d8>
8016a9bc:	e3e03002 	mvn	r3, #2
8016a9c0:	ea000063 	b	8016ab54 <_RME_Inv_Del+0x368>
8016a9c4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a9c8:	e1a02283 	lsl	r2, r3, #5
8016a9cc:	e51b3008 	ldr	r3, [fp, #-8]
8016a9d0:	e593300c 	ldr	r3, [r3, #12]
8016a9d4:	e0823003 	add	r3, r2, r3
8016a9d8:	e50b3010 	str	r3, [fp, #-16]
    /* Delete check */
    RME_CAP_DEL_CHECK(Inv_Del,Type_Stat,RME_CAP_TYPE_INV);
8016a9dc:	e51b3010 	ldr	r3, [fp, #-16]
8016a9e0:	e1a00003 	mov	r0, r3
8016a9e4:	ebffd745 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a9e8:	e50b000c 	str	r0, [fp, #-12]
8016a9ec:	e51b300c 	ldr	r3, [fp, #-12]
8016a9f0:	e1a03823 	lsr	r3, r3, #16
8016a9f4:	e6ef3073 	uxtb	r3, r3
8016a9f8:	e3530002 	cmp	r3, #2
8016a9fc:	0a000001 	beq	8016aa08 <_RME_Inv_Del+0x21c>
8016aa00:	e3e03008 	mvn	r3, #8
8016aa04:	ea000052 	b	8016ab54 <_RME_Inv_Del+0x368>
8016aa08:	e51b300c 	ldr	r3, [fp, #-12]
8016aa0c:	e1a03c23 	lsr	r3, r3, #24
8016aa10:	e3530007 	cmp	r3, #7
8016aa14:	0a000001 	beq	8016aa20 <_RME_Inv_Del+0x234>
8016aa18:	e3e03001 	mvn	r3, #1
8016aa1c:	ea00004c 	b	8016ab54 <_RME_Inv_Del+0x368>
8016aa20:	e51b3010 	ldr	r3, [fp, #-16]
8016aa24:	e5933004 	ldr	r3, [r3, #4]
8016aa28:	e3530000 	cmp	r3, #0
8016aa2c:	0a00000b 	beq	8016aa60 <_RME_Inv_Del+0x274>
8016aa30:	e51b300c 	ldr	r3, [fp, #-12]
8016aa34:	e6ff3073 	uxth	r3, r3
8016aa38:	e3530000 	cmp	r3, #0
8016aa3c:	1a000005 	bne	8016aa58 <_RME_Inv_Del+0x26c>
8016aa40:	e51b0010 	ldr	r0, [fp, #-16]
8016aa44:	e51b300c 	ldr	r3, [fp, #-12]
8016aa48:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
8016aa4c:	e1a02003 	mov	r2, r3
8016aa50:	e51b100c 	ldr	r1, [fp, #-12]
8016aa54:	ebffd86b 	bl	80160c08 <_RME_Comp_Swap_Single>
8016aa58:	e3e03005 	mvn	r3, #5
8016aa5c:	ea00003c 	b	8016ab54 <_RME_Inv_Del+0x368>
8016aa60:	e51b300c 	ldr	r3, [fp, #-12]
8016aa64:	e6ff3073 	uxth	r3, r3
8016aa68:	e3530000 	cmp	r3, #0
8016aa6c:	0a000008 	beq	8016aa94 <_RME_Inv_Del+0x2a8>
8016aa70:	e30c3318 	movw	r3, #49944	@ 0xc318
8016aa74:	e3483016 	movt	r3, #32790	@ 0x8016
8016aa78:	e30c2324 	movw	r2, #49956	@ 0xc324
8016aa7c:	e3482016 	movt	r2, #32790	@ 0x8016
8016aa80:	e3011d3c 	movw	r1, #7484	@ 0x1d3c
8016aa84:	e30c0330 	movw	r0, #49968	@ 0xc330
8016aa88:	e3480016 	movt	r0, #32790	@ 0x8016
8016aa8c:	ebffd83c 	bl	80160b84 <RME_Log>
8016aa90:	eafffffe 	b	8016aa90 <_RME_Inv_Del+0x2a4>
    
    /* Get the invocation */
    Invocation=RME_CAP_GETOBJ(Inv_Del,struct RME_Inv_Struct*);
8016aa94:	e51b3010 	ldr	r3, [fp, #-16]
8016aa98:	e593300c 	ldr	r3, [r3, #12]
8016aa9c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    
    /* See if the invocation is currently being used. If yes, we cannot delete it */
    if(Invocation->Thd_Act!=RME_NULL)
8016aaa0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016aaa4:	e593300c 	ldr	r3, [r3, #12]
8016aaa8:	e3530000 	cmp	r3, #0
8016aaac:	0a000007 	beq	8016aad0 <_RME_Inv_Del+0x2e4>
    {
        RME_COV_MARKER();

        RME_CAP_DEFROST(Inv_Del,Type_Stat);
8016aab0:	e51b0010 	ldr	r0, [fp, #-16]
8016aab4:	e51b300c 	ldr	r3, [fp, #-12]
8016aab8:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
8016aabc:	e1a02003 	mov	r2, r3
8016aac0:	e51b100c 	ldr	r1, [fp, #-12]
8016aac4:	ebffd84f 	bl	80160c08 <_RME_Comp_Swap_Single>
        return RME_ERR_SIV_ACT;
8016aac8:	e3e03f4b 	mvn	r3, #300	@ 0x12c
8016aacc:	ea000020 	b	8016ab54 <_RME_Inv_Del+0x368>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Now we can safely delete the cap */
    RME_CAP_DELETE(Inv_Del,Type_Stat);
8016aad0:	e51b3010 	ldr	r3, [fp, #-16]
8016aad4:	e3a02000 	mov	r2, #0
8016aad8:	e51b100c 	ldr	r1, [fp, #-12]
8016aadc:	e1a00003 	mov	r0, r3
8016aae0:	ebffd848 	bl	80160c08 <_RME_Comp_Swap_Single>
8016aae4:	e1a03000 	mov	r3, r0
8016aae8:	e3530000 	cmp	r3, #0
8016aaec:	1a000001 	bne	8016aaf8 <_RME_Inv_Del+0x30c>
8016aaf0:	e3e03000 	mvn	r3, #0
8016aaf4:	ea000016 	b	8016ab54 <_RME_Inv_Del+0x368>
    
    /* Dereference the process */
    RME_FETCH_ADD(&(Invocation->Prc->Head.Root_Ref), -1);
8016aaf8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016aafc:	e5933008 	ldr	r3, [r3, #8]
8016ab00:	e2833004 	add	r3, r3, #4
8016ab04:	e3e01000 	mvn	r1, #0
8016ab08:	e1a00003 	mov	r0, r3
8016ab0c:	ebffd852 	bl	80160c5c <_RME_Fetch_Add_Single>
    
    /* Try to clear the area - this must be successful */
    RME_ASSERT(_RME_Kot_Erase((rme_ptr_t)Invocation,RME_INV_SIZE)==0);
8016ab10:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016ab14:	e3a01024 	mov	r1, #36	@ 0x24
8016ab18:	e1a00003 	mov	r0, r3
8016ab1c:	ebffe859 	bl	80164c88 <_RME_Kot_Erase>
8016ab20:	e1a03000 	mov	r3, r0
8016ab24:	e3530000 	cmp	r3, #0
8016ab28:	0a000008 	beq	8016ab50 <_RME_Inv_Del+0x364>
8016ab2c:	e30c3318 	movw	r3, #49944	@ 0xc318
8016ab30:	e3483016 	movt	r3, #32790	@ 0x8016
8016ab34:	e30c2324 	movw	r2, #49956	@ 0xc324
8016ab38:	e3482016 	movt	r2, #32790	@ 0x8016
8016ab3c:	e3011d56 	movw	r1, #7510	@ 0x1d56
8016ab40:	e30c0330 	movw	r0, #49968	@ 0xc330
8016ab44:	e3480016 	movt	r0, #32790	@ 0x8016
8016ab48:	ebffd80d 	bl	80160b84 <RME_Log>
8016ab4c:	eafffffe 	b	8016ab4c <_RME_Inv_Del+0x360>
    
    return 0;
8016ab50:	e3a03000 	mov	r3, #0
}
8016ab54:	e1a00003 	mov	r0, r3
8016ab58:	e24bd004 	sub	sp, fp, #4
8016ab5c:	e8bd8800 	pop	{fp, pc}

8016ab60 <_RME_Inv_Set>:
static rme_ret_t _RME_Inv_Set(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Inv,
                              rme_ptr_t Entry,
                              rme_ptr_t Stack,
                              rme_ptr_t Is_Exc_Ret)
{
8016ab60:	e92d4800 	push	{fp, lr}
8016ab64:	e28db004 	add	fp, sp, #4
8016ab68:	e24dd020 	sub	sp, sp, #32
8016ab6c:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
8016ab70:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
8016ab74:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
8016ab78:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    struct RME_Cap_Inv* Inv_Op;
    volatile struct RME_Inv_Struct* Invocation;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Inv,RME_CAP_TYPE_INV,
8016ab7c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016ab80:	e2033080 	and	r3, r3, #128	@ 0x80
8016ab84:	e3530000 	cmp	r3, #0
8016ab88:	1a00001d 	bne	8016ac04 <_RME_Inv_Set+0xa4>
8016ab8c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016ab90:	e5932014 	ldr	r2, [r3, #20]
8016ab94:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016ab98:	e1520003 	cmp	r2, r3
8016ab9c:	8a000001 	bhi	8016aba8 <_RME_Inv_Set+0x48>
8016aba0:	e3e03002 	mvn	r3, #2
8016aba4:	ea00006a 	b	8016ad54 <_RME_Inv_Set+0x1f4>
8016aba8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016abac:	e1a02283 	lsl	r2, r3, #5
8016abb0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016abb4:	e593300c 	ldr	r3, [r3, #12]
8016abb8:	e0823003 	add	r3, r2, r3
8016abbc:	e50b3008 	str	r3, [fp, #-8]
8016abc0:	e51b3008 	ldr	r3, [fp, #-8]
8016abc4:	e1a00003 	mov	r0, r3
8016abc8:	ebffd6cc 	bl	80160700 <__RME_A7A_Read_Acquire>
8016abcc:	e50b000c 	str	r0, [fp, #-12]
8016abd0:	e51b300c 	ldr	r3, [fp, #-12]
8016abd4:	e1a03823 	lsr	r3, r3, #16
8016abd8:	e6ef3073 	uxtb	r3, r3
8016abdc:	e3530002 	cmp	r3, #2
8016abe0:	1a000001 	bne	8016abec <_RME_Inv_Set+0x8c>
8016abe4:	e3e03008 	mvn	r3, #8
8016abe8:	ea000059 	b	8016ad54 <_RME_Inv_Set+0x1f4>
8016abec:	e51b300c 	ldr	r3, [fp, #-12]
8016abf0:	e1a03c23 	lsr	r3, r3, #24
8016abf4:	e3530007 	cmp	r3, #7
8016abf8:	0a000041 	beq	8016ad04 <_RME_Inv_Set+0x1a4>
8016abfc:	e3e03001 	mvn	r3, #1
8016ac00:	ea000053 	b	8016ad54 <_RME_Inv_Set+0x1f4>
8016ac04:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016ac08:	e1a02423 	lsr	r2, r3, #8
8016ac0c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016ac10:	e5933014 	ldr	r3, [r3, #20]
8016ac14:	e1520003 	cmp	r2, r3
8016ac18:	3a000001 	bcc	8016ac24 <_RME_Inv_Set+0xc4>
8016ac1c:	e3e03002 	mvn	r3, #2
8016ac20:	ea00004b 	b	8016ad54 <_RME_Inv_Set+0x1f4>
8016ac24:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016ac28:	e1a03423 	lsr	r3, r3, #8
8016ac2c:	e1a02283 	lsl	r2, r3, #5
8016ac30:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016ac34:	e593300c 	ldr	r3, [r3, #12]
8016ac38:	e0823003 	add	r3, r2, r3
8016ac3c:	e50b3008 	str	r3, [fp, #-8]
8016ac40:	e51b3008 	ldr	r3, [fp, #-8]
8016ac44:	e1a00003 	mov	r0, r3
8016ac48:	ebffd6ac 	bl	80160700 <__RME_A7A_Read_Acquire>
8016ac4c:	e50b000c 	str	r0, [fp, #-12]
8016ac50:	e51b300c 	ldr	r3, [fp, #-12]
8016ac54:	e1a03823 	lsr	r3, r3, #16
8016ac58:	e6ef3073 	uxtb	r3, r3
8016ac5c:	e3530002 	cmp	r3, #2
8016ac60:	1a000001 	bne	8016ac6c <_RME_Inv_Set+0x10c>
8016ac64:	e3e03008 	mvn	r3, #8
8016ac68:	ea000039 	b	8016ad54 <_RME_Inv_Set+0x1f4>
8016ac6c:	e51b300c 	ldr	r3, [fp, #-12]
8016ac70:	e1a03c23 	lsr	r3, r3, #24
8016ac74:	e3530003 	cmp	r3, #3
8016ac78:	0a000001 	beq	8016ac84 <_RME_Inv_Set+0x124>
8016ac7c:	e3e03001 	mvn	r3, #1
8016ac80:	ea000033 	b	8016ad54 <_RME_Inv_Set+0x1f4>
8016ac84:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016ac88:	e203207f 	and	r2, r3, #127	@ 0x7f
8016ac8c:	e51b3008 	ldr	r3, [fp, #-8]
8016ac90:	e5933014 	ldr	r3, [r3, #20]
8016ac94:	e1520003 	cmp	r2, r3
8016ac98:	3a000001 	bcc	8016aca4 <_RME_Inv_Set+0x144>
8016ac9c:	e3e03002 	mvn	r3, #2
8016aca0:	ea00002b 	b	8016ad54 <_RME_Inv_Set+0x1f4>
8016aca4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016aca8:	e203307f 	and	r3, r3, #127	@ 0x7f
8016acac:	e1a02283 	lsl	r2, r3, #5
8016acb0:	e51b3008 	ldr	r3, [fp, #-8]
8016acb4:	e593300c 	ldr	r3, [r3, #12]
8016acb8:	e0823003 	add	r3, r2, r3
8016acbc:	e50b3008 	str	r3, [fp, #-8]
8016acc0:	e51b3008 	ldr	r3, [fp, #-8]
8016acc4:	e1a00003 	mov	r0, r3
8016acc8:	ebffd68c 	bl	80160700 <__RME_A7A_Read_Acquire>
8016accc:	e50b000c 	str	r0, [fp, #-12]
8016acd0:	e51b300c 	ldr	r3, [fp, #-12]
8016acd4:	e1a03823 	lsr	r3, r3, #16
8016acd8:	e6ef3073 	uxtb	r3, r3
8016acdc:	e3530002 	cmp	r3, #2
8016ace0:	1a000001 	bne	8016acec <_RME_Inv_Set+0x18c>
8016ace4:	e3e03008 	mvn	r3, #8
8016ace8:	ea000019 	b	8016ad54 <_RME_Inv_Set+0x1f4>
8016acec:	e51b300c 	ldr	r3, [fp, #-12]
8016acf0:	e1a03c23 	lsr	r3, r3, #24
8016acf4:	e3530007 	cmp	r3, #7
8016acf8:	0a000001 	beq	8016ad04 <_RME_Inv_Set+0x1a4>
8016acfc:	e3e03001 	mvn	r3, #1
8016ad00:	ea000013 	b	8016ad54 <_RME_Inv_Set+0x1f4>
                   struct RME_Cap_Inv*,Inv_Op,Type_Stat);
    /* Check if the target cap is not frozen and allows such operations */
    RME_CAP_CHECK(Inv_Op,RME_INV_FLAG_SET);
8016ad04:	e51b3008 	ldr	r3, [fp, #-8]
8016ad08:	e5933008 	ldr	r3, [r3, #8]
8016ad0c:	e2033001 	and	r3, r3, #1
8016ad10:	e3530000 	cmp	r3, #0
8016ad14:	1a000001 	bne	8016ad20 <_RME_Inv_Set+0x1c0>
8016ad18:	e3e03006 	mvn	r3, #6
8016ad1c:	ea00000c 	b	8016ad54 <_RME_Inv_Set+0x1f4>
    
    /* Commit the change - we do not care if the invocation is in use, it is
     * the user's responsibility to guarantee the integrity of applications */
    Invocation=RME_CAP_GETOBJ(Inv_Op,struct RME_Inv_Struct*);
8016ad20:	e51b3008 	ldr	r3, [fp, #-8]
8016ad24:	e593300c 	ldr	r3, [r3, #12]
8016ad28:	e50b3010 	str	r3, [fp, #-16]
    Invocation->Entry=Entry;
8016ad2c:	e51b3010 	ldr	r3, [fp, #-16]
8016ad30:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
8016ad34:	e5832010 	str	r2, [r3, #16]
    Invocation->Stack=Stack;
8016ad38:	e51b3010 	ldr	r3, [fp, #-16]
8016ad3c:	e51b2024 	ldr	r2, [fp, #-36]	@ 0xffffffdc
8016ad40:	e5832014 	str	r2, [r3, #20]
    Invocation->Is_Exc_Ret=Is_Exc_Ret;
8016ad44:	e51b3010 	ldr	r3, [fp, #-16]
8016ad48:	e59b2004 	ldr	r2, [fp, #4]
8016ad4c:	e5832018 	str	r2, [r3, #24]
    
    return 0;
8016ad50:	e3a03000 	mov	r3, #0
}
8016ad54:	e1a00003 	mov	r0, r3
8016ad58:	e24bd004 	sub	sp, fp, #4
8016ad5c:	e8bd8800 	pop	{fp, pc}

8016ad60 <_RME_Inv_Act>:
******************************************************************************/
static rme_ret_t _RME_Inv_Act(struct RME_Cap_Cpt* Cpt, 
                              struct RME_Reg_Struct* Reg,
                              rme_cid_t Cap_Inv,
                              rme_ptr_t Param)
{
8016ad60:	e92d4800 	push	{fp, lr}
8016ad64:	e28db004 	add	fp, sp, #4
8016ad68:	e24dd030 	sub	sp, sp, #48	@ 0x30
8016ad6c:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
8016ad70:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
8016ad74:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
8016ad78:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
        /* No action required */
    }
#endif

    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Inv,RME_CAP_TYPE_INV,
8016ad7c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016ad80:	e2033080 	and	r3, r3, #128	@ 0x80
8016ad84:	e3530000 	cmp	r3, #0
8016ad88:	1a00001d 	bne	8016ae04 <_RME_Inv_Act+0xa4>
8016ad8c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016ad90:	e5932014 	ldr	r2, [r3, #20]
8016ad94:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016ad98:	e1520003 	cmp	r2, r3
8016ad9c:	8a000001 	bhi	8016ada8 <_RME_Inv_Act+0x48>
8016ada0:	e3e03002 	mvn	r3, #2
8016ada4:	ea0000a9 	b	8016b050 <_RME_Inv_Act+0x2f0>
8016ada8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016adac:	e1a02283 	lsl	r2, r3, #5
8016adb0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016adb4:	e593300c 	ldr	r3, [r3, #12]
8016adb8:	e0823003 	add	r3, r2, r3
8016adbc:	e50b3008 	str	r3, [fp, #-8]
8016adc0:	e51b3008 	ldr	r3, [fp, #-8]
8016adc4:	e1a00003 	mov	r0, r3
8016adc8:	ebffd64c 	bl	80160700 <__RME_A7A_Read_Acquire>
8016adcc:	e50b000c 	str	r0, [fp, #-12]
8016add0:	e51b300c 	ldr	r3, [fp, #-12]
8016add4:	e1a03823 	lsr	r3, r3, #16
8016add8:	e6ef3073 	uxtb	r3, r3
8016addc:	e3530002 	cmp	r3, #2
8016ade0:	1a000001 	bne	8016adec <_RME_Inv_Act+0x8c>
8016ade4:	e3e03008 	mvn	r3, #8
8016ade8:	ea000098 	b	8016b050 <_RME_Inv_Act+0x2f0>
8016adec:	e51b300c 	ldr	r3, [fp, #-12]
8016adf0:	e1a03c23 	lsr	r3, r3, #24
8016adf4:	e3530007 	cmp	r3, #7
8016adf8:	0a000041 	beq	8016af04 <_RME_Inv_Act+0x1a4>
8016adfc:	e3e03001 	mvn	r3, #1
8016ae00:	ea000092 	b	8016b050 <_RME_Inv_Act+0x2f0>
8016ae04:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016ae08:	e1a02423 	lsr	r2, r3, #8
8016ae0c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016ae10:	e5933014 	ldr	r3, [r3, #20]
8016ae14:	e1520003 	cmp	r2, r3
8016ae18:	3a000001 	bcc	8016ae24 <_RME_Inv_Act+0xc4>
8016ae1c:	e3e03002 	mvn	r3, #2
8016ae20:	ea00008a 	b	8016b050 <_RME_Inv_Act+0x2f0>
8016ae24:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016ae28:	e1a03423 	lsr	r3, r3, #8
8016ae2c:	e1a02283 	lsl	r2, r3, #5
8016ae30:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016ae34:	e593300c 	ldr	r3, [r3, #12]
8016ae38:	e0823003 	add	r3, r2, r3
8016ae3c:	e50b3008 	str	r3, [fp, #-8]
8016ae40:	e51b3008 	ldr	r3, [fp, #-8]
8016ae44:	e1a00003 	mov	r0, r3
8016ae48:	ebffd62c 	bl	80160700 <__RME_A7A_Read_Acquire>
8016ae4c:	e50b000c 	str	r0, [fp, #-12]
8016ae50:	e51b300c 	ldr	r3, [fp, #-12]
8016ae54:	e1a03823 	lsr	r3, r3, #16
8016ae58:	e6ef3073 	uxtb	r3, r3
8016ae5c:	e3530002 	cmp	r3, #2
8016ae60:	1a000001 	bne	8016ae6c <_RME_Inv_Act+0x10c>
8016ae64:	e3e03008 	mvn	r3, #8
8016ae68:	ea000078 	b	8016b050 <_RME_Inv_Act+0x2f0>
8016ae6c:	e51b300c 	ldr	r3, [fp, #-12]
8016ae70:	e1a03c23 	lsr	r3, r3, #24
8016ae74:	e3530003 	cmp	r3, #3
8016ae78:	0a000001 	beq	8016ae84 <_RME_Inv_Act+0x124>
8016ae7c:	e3e03001 	mvn	r3, #1
8016ae80:	ea000072 	b	8016b050 <_RME_Inv_Act+0x2f0>
8016ae84:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016ae88:	e203207f 	and	r2, r3, #127	@ 0x7f
8016ae8c:	e51b3008 	ldr	r3, [fp, #-8]
8016ae90:	e5933014 	ldr	r3, [r3, #20]
8016ae94:	e1520003 	cmp	r2, r3
8016ae98:	3a000001 	bcc	8016aea4 <_RME_Inv_Act+0x144>
8016ae9c:	e3e03002 	mvn	r3, #2
8016aea0:	ea00006a 	b	8016b050 <_RME_Inv_Act+0x2f0>
8016aea4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016aea8:	e203307f 	and	r3, r3, #127	@ 0x7f
8016aeac:	e1a02283 	lsl	r2, r3, #5
8016aeb0:	e51b3008 	ldr	r3, [fp, #-8]
8016aeb4:	e593300c 	ldr	r3, [r3, #12]
8016aeb8:	e0823003 	add	r3, r2, r3
8016aebc:	e50b3008 	str	r3, [fp, #-8]
8016aec0:	e51b3008 	ldr	r3, [fp, #-8]
8016aec4:	e1a00003 	mov	r0, r3
8016aec8:	ebffd60c 	bl	80160700 <__RME_A7A_Read_Acquire>
8016aecc:	e50b000c 	str	r0, [fp, #-12]
8016aed0:	e51b300c 	ldr	r3, [fp, #-12]
8016aed4:	e1a03823 	lsr	r3, r3, #16
8016aed8:	e6ef3073 	uxtb	r3, r3
8016aedc:	e3530002 	cmp	r3, #2
8016aee0:	1a000001 	bne	8016aeec <_RME_Inv_Act+0x18c>
8016aee4:	e3e03008 	mvn	r3, #8
8016aee8:	ea000058 	b	8016b050 <_RME_Inv_Act+0x2f0>
8016aeec:	e51b300c 	ldr	r3, [fp, #-12]
8016aef0:	e1a03c23 	lsr	r3, r3, #24
8016aef4:	e3530007 	cmp	r3, #7
8016aef8:	0a000001 	beq	8016af04 <_RME_Inv_Act+0x1a4>
8016aefc:	e3e03001 	mvn	r3, #1
8016af00:	ea000052 	b	8016b050 <_RME_Inv_Act+0x2f0>
                   struct RME_Cap_Inv*,Inv_Op,Type_Stat);
    /* Check if the target cap is not frozen and allows such operations */
    RME_CAP_CHECK(Inv_Op,RME_INV_FLAG_ACT);
8016af04:	e51b3008 	ldr	r3, [fp, #-8]
8016af08:	e5933008 	ldr	r3, [r3, #8]
8016af0c:	e2033002 	and	r3, r3, #2
8016af10:	e3530000 	cmp	r3, #0
8016af14:	1a000001 	bne	8016af20 <_RME_Inv_Act+0x1c0>
8016af18:	e3e03006 	mvn	r3, #6
8016af1c:	ea00004b 	b	8016b050 <_RME_Inv_Act+0x2f0>

    /* Get the invocation struct */
    Invocation=RME_CAP_GETOBJ(Inv_Op,struct RME_Inv_Struct*);
8016af20:	e51b3008 	ldr	r3, [fp, #-8]
8016af24:	e593300c 	ldr	r3, [r3, #12]
8016af28:	e50b3010 	str	r3, [fp, #-16]
    /* Check if this invocation port is already active */
    Thd_Act=Invocation->Thd_Act;
8016af2c:	e51b3010 	ldr	r3, [fp, #-16]
8016af30:	e593300c 	ldr	r3, [r3, #12]
8016af34:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    if(RME_UNLIKELY(Thd_Act!=0U))
8016af38:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016af3c:	e3530000 	cmp	r3, #0
8016af40:	0a000001 	beq	8016af4c <_RME_Inv_Act+0x1ec>
    {
        RME_COV_MARKER();

        return RME_ERR_SIV_ACT;
8016af44:	e3e03f4b 	mvn	r3, #300	@ 0x12c
8016af48:	ea000040 	b	8016b050 <_RME_Inv_Act+0x2f0>
        RME_COV_MARKER();
        /* No action required */
    }

#if(RME_CPT_ENTRY_MAX==0U)
    Thd_Cur=RME_CPU_LOCAL()->Thd_Cur;
8016af4c:	e30d3004 	movw	r3, #53252	@ 0xd004
8016af50:	e3483016 	movt	r3, #32790	@ 0x8016
8016af54:	e5933004 	ldr	r3, [r3, #4]
8016af58:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
#endif
    
    /* Try to do CAS and activate this port */
    if(RME_UNLIKELY(RME_COMP_SWAP((volatile rme_ptr_t*)&(Invocation->Thd_Act),
8016af5c:	e51b3010 	ldr	r3, [fp, #-16]
8016af60:	e283300c 	add	r3, r3, #12
8016af64:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
8016af68:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016af6c:	e1a00003 	mov	r0, r3
8016af70:	ebffd724 	bl	80160c08 <_RME_Comp_Swap_Single>
8016af74:	e1a03000 	mov	r3, r0
8016af78:	e3530000 	cmp	r3, #0
8016af7c:	1a000001 	bne	8016af88 <_RME_Inv_Act+0x228>
                                  (rme_ptr_t)Thd_Act,
                                  (rme_ptr_t)Thd_Cur)==RME_CASFAIL))
    {
        RME_COV_MARKER();

        return RME_ERR_SIV_ACT;
8016af80:	e3e03f4b 	mvn	r3, #300	@ 0x12c
8016af84:	ea000031 	b	8016b050 <_RME_Inv_Act+0x2f0>

    /* Save whatever is needed to return to the point - normally only SP and IP needed
     * because all other registers, including the coprocessor registers, are saved at
     * user-level. We do not set the return value because it will be set by Inv_Ret.
     * The coprocessor state will be consistent across the call */
    __RME_Inv_Reg_Save(&(Invocation->Ret),Reg);
8016af88:	e51b3010 	ldr	r3, [fp, #-16]
8016af8c:	e283301c 	add	r3, r3, #28
8016af90:	e51b1024 	ldr	r1, [fp, #-36]	@ 0xffffffdc
8016af94:	e1a00003 	mov	r0, r3
8016af98:	eb0002e6 	bl	8016bb38 <__RME_Inv_Reg_Save>
    /* Push this into the stack: insert after the thread list header */
    _RME_List_Ins(&(Invocation->Head),
8016af9c:	e51b0010 	ldr	r0, [fp, #-16]
8016afa0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016afa4:	e283104c 	add	r1, r3, #76	@ 0x4c
8016afa8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016afac:	e593304c 	ldr	r3, [r3, #76]	@ 0x4c
8016afb0:	e1a02003 	mov	r2, r3
8016afb4:	ebffd76a 	bl	80160d64 <_RME_List_Ins>
                  &(Thd_Cur->Ctx.Invstk),
                  Thd_Cur->Ctx.Invstk.Next);
    /* Increase invocation depth - no atomic operation needed */
    Thd_Cur->Ctx.Invstk_Depth++;
8016afb8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016afbc:	e5933054 	ldr	r3, [r3, #84]	@ 0x54
8016afc0:	e2832001 	add	r2, r3, #1
8016afc4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016afc8:	e5832054 	str	r2, [r3, #84]	@ 0x54
    /* Setup the register contents, and do the invocation */
    __RME_Thd_Reg_Init(RME_THD_ATTR(Thd_Cur->Ctx.Hyp_Attr),
8016afcc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016afd0:	e5933044 	ldr	r3, [r3, #68]	@ 0x44
8016afd4:	e3c30102 	bic	r0, r3, #-2147483648	@ 0x80000000
8016afd8:	e51b3010 	ldr	r3, [fp, #-16]
8016afdc:	e5931010 	ldr	r1, [r3, #16]
8016afe0:	e51b3010 	ldr	r3, [fp, #-16]
8016afe4:	e5932014 	ldr	r2, [r3, #20]
8016afe8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016afec:	e58d3000 	str	r3, [sp]
8016aff0:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016aff4:	eb000272 	bl	8016b9c4 <__RME_Thd_Reg_Init>
    
    
    /* We are assuming that we are always invoking into a new process (why use synchronous
     * invocation if you don't do so?). So we always switch page tables regardless. */
#if(RME_PGT_RAW_ENABLE==0U)
    RME_ASSERT(RME_CAP_IS_ROOT(Invocation->Prc->Pgt)!=0U);
8016aff8:	e51b3010 	ldr	r3, [fp, #-16]
8016affc:	e5933008 	ldr	r3, [r3, #8]
8016b000:	e5933018 	ldr	r3, [r3, #24]
8016b004:	e5933000 	ldr	r3, [r3]
8016b008:	e6ff3073 	uxth	r3, r3
8016b00c:	e3530000 	cmp	r3, #0
8016b010:	0a000008 	beq	8016b038 <_RME_Inv_Act+0x2d8>
8016b014:	e30c3318 	movw	r3, #49944	@ 0xc318
8016b018:	e3483016 	movt	r3, #32790	@ 0x8016
8016b01c:	e30c2324 	movw	r2, #49956	@ 0xc324
8016b020:	e3482016 	movt	r2, #32790	@ 0x8016
8016b024:	e3011de9 	movw	r1, #7657	@ 0x1de9
8016b028:	e30c0330 	movw	r0, #49968	@ 0xc330
8016b02c:	e3480016 	movt	r0, #32790	@ 0x8016
8016b030:	ebffd6d3 	bl	80160b84 <RME_Log>
8016b034:	eafffffe 	b	8016b034 <_RME_Inv_Act+0x2d4>
#endif
    __RME_Pgt_Set(Invocation->Prc->Pgt);
8016b038:	e51b3010 	ldr	r3, [fp, #-16]
8016b03c:	e5933008 	ldr	r3, [r3, #8]
8016b040:	e5933018 	ldr	r3, [r3, #24]
8016b044:	e1a00003 	mov	r0, r3
8016b048:	eb000373 	bl	8016be1c <__RME_Pgt_Set>
    
    return 0;
8016b04c:	e3a03000 	mov	r3, #0
}
8016b050:	e1a00003 	mov	r0, r3
8016b054:	e24bd004 	sub	sp, fp, #4
8016b058:	e8bd8800 	pop	{fp, pc}

8016b05c <_RME_Inv_Ret>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Inv_Ret(struct RME_Reg_Struct* Reg,
                              rme_ptr_t Retval,
                              rme_ptr_t Is_Exc)
{
8016b05c:	e92d4800 	push	{fp, lr}
8016b060:	e28db004 	add	fp, sp, #4
8016b064:	e24dd018 	sub	sp, sp, #24
8016b068:	e50b0010 	str	r0, [fp, #-16]
8016b06c:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
8016b070:	e50b2018 	str	r2, [fp, #-24]	@ 0xffffffe8
    struct RME_Thd_Struct* Thread;
    struct RME_Inv_Struct* Invocation;

    /* See if we can return; If we can, get the structure */
    Thread=RME_CPU_LOCAL()->Thd_Cur;
8016b074:	e30d3004 	movw	r3, #53252	@ 0xd004
8016b078:	e3483016 	movt	r3, #32790	@ 0x8016
8016b07c:	e5933004 	ldr	r3, [r3, #4]
8016b080:	e50b3008 	str	r3, [fp, #-8]
    Invocation=RME_INVSTK_TOP(Thread);
8016b084:	e51b3008 	ldr	r3, [fp, #-8]
8016b088:	e593204c 	ldr	r2, [r3, #76]	@ 0x4c
8016b08c:	e51b3008 	ldr	r3, [fp, #-8]
8016b090:	e283304c 	add	r3, r3, #76	@ 0x4c
8016b094:	e1520003 	cmp	r2, r3
8016b098:	0a000002 	beq	8016b0a8 <_RME_Inv_Ret+0x4c>
8016b09c:	e51b3008 	ldr	r3, [fp, #-8]
8016b0a0:	e593304c 	ldr	r3, [r3, #76]	@ 0x4c
8016b0a4:	ea000000 	b	8016b0ac <_RME_Inv_Ret+0x50>
8016b0a8:	e3a03000 	mov	r3, #0
8016b0ac:	e50b300c 	str	r3, [fp, #-12]
    if(RME_UNLIKELY(Invocation==RME_NULL))
8016b0b0:	e51b300c 	ldr	r3, [fp, #-12]
8016b0b4:	e3530000 	cmp	r3, #0
8016b0b8:	1a000002 	bne	8016b0c8 <_RME_Inv_Ret+0x6c>
    {
        RME_COV_MARKER();

        return RME_ERR_SIV_EMPTY;
8016b0bc:	e30f3ed0 	movw	r3, #65232	@ 0xfed0
8016b0c0:	e34f3fff 	movt	r3, #65535	@ 0xffff
8016b0c4:	ea000068 	b	8016b26c <_RME_Inv_Ret+0x210>
        RME_COV_MARKER();
        /* No action required */
    }

    /* See if this port allows return-on-fault */
    if(RME_UNLIKELY((Is_Exc!=0U)&&(Invocation->Is_Exc_Ret==0U)))
8016b0c8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b0cc:	e3530000 	cmp	r3, #0
8016b0d0:	0a000006 	beq	8016b0f0 <_RME_Inv_Ret+0x94>
8016b0d4:	e51b300c 	ldr	r3, [fp, #-12]
8016b0d8:	e5933018 	ldr	r3, [r3, #24]
8016b0dc:	e3530000 	cmp	r3, #0
8016b0e0:	1a000002 	bne	8016b0f0 <_RME_Inv_Ret+0x94>
    {
        RME_COV_MARKER();

        return RME_ERR_SIV_FAULT;
8016b0e4:	e30f3ed2 	movw	r3, #65234	@ 0xfed2
8016b0e8:	e34f3fff 	movt	r3, #65535	@ 0xffff
8016b0ec:	ea00005e 	b	8016b26c <_RME_Inv_Ret+0x210>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Pop it from the stack */
    _RME_List_Del(Invocation->Head.Prev,Invocation->Head.Next);
8016b0f0:	e51b300c 	ldr	r3, [fp, #-12]
8016b0f4:	e5932004 	ldr	r2, [r3, #4]
8016b0f8:	e51b300c 	ldr	r3, [fp, #-12]
8016b0fc:	e5933000 	ldr	r3, [r3]
8016b100:	e1a01003 	mov	r1, r3
8016b104:	e1a00002 	mov	r0, r2
8016b108:	ebffd706 	bl	80160d28 <_RME_List_Del>
    /* Decrease invocation depth - no atomic operation needed */
    Thread->Ctx.Invstk_Depth--;
8016b10c:	e51b3008 	ldr	r3, [fp, #-8]
8016b110:	e5933054 	ldr	r3, [r3, #84]	@ 0x54
8016b114:	e2432001 	sub	r2, r3, #1
8016b118:	e51b3008 	ldr	r3, [fp, #-8]
8016b11c:	e5832054 	str	r2, [r3, #84]	@ 0x54

    /* Restore the register contents, and set return value. We need to set
     * the return value of the invocation system call itself as well. */
    __RME_Inv_Reg_Restore(Reg,&(Invocation->Ret));
8016b120:	e51b300c 	ldr	r3, [fp, #-12]
8016b124:	e283301c 	add	r3, r3, #28
8016b128:	e1a01003 	mov	r1, r3
8016b12c:	e51b0010 	ldr	r0, [fp, #-16]
8016b130:	eb000291 	bl	8016bb7c <__RME_Inv_Reg_Restore>
    __RME_Inv_Retval_Set(Reg,(rme_ret_t)Retval);
8016b134:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016b138:	e1a01003 	mov	r1, r3
8016b13c:	e51b0010 	ldr	r0, [fp, #-16]
8016b140:	eb00029e 	bl	8016bbc0 <__RME_Inv_Retval_Set>

    /* We have successfully returned, set the invocation as inactive. We need
     * a barrier here to avoid potential destruction of the return value. */
    RME_WRITE_RELEASE(&(Invocation->Thd_Act),0U);
8016b144:	e51b300c 	ldr	r3, [fp, #-12]
8016b148:	e283300c 	add	r3, r3, #12
8016b14c:	e3a01000 	mov	r1, #0
8016b150:	e1a00003 	mov	r0, r3
8016b154:	ebffd56c 	bl	8016070c <__RME_A7A_Write_Release>

    /* Decide the system call's return value */
    if(RME_UNLIKELY(Is_Exc!=0U))
8016b158:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b15c:	e3530000 	cmp	r3, #0
8016b160:	0a000004 	beq	8016b178 <_RME_Inv_Ret+0x11c>
    {
        RME_COV_MARKER();

        __RME_Svc_Retval_Set(Reg, RME_ERR_SIV_FAULT);
8016b164:	e30f1ed2 	movw	r1, #65234	@ 0xfed2
8016b168:	e34f1fff 	movt	r1, #65535	@ 0xffff
8016b16c:	e51b0010 	ldr	r0, [fp, #-16]
8016b170:	eb000207 	bl	8016b994 <__RME_Svc_Retval_Set>
8016b174:	ea000002 	b	8016b184 <_RME_Inv_Ret+0x128>
    }
    else
    {
        RME_COV_MARKER();

        __RME_Svc_Retval_Set(Reg,0);
8016b178:	e3a01000 	mov	r1, #0
8016b17c:	e51b0010 	ldr	r0, [fp, #-16]
8016b180:	eb000203 	bl	8016b994 <__RME_Svc_Retval_Set>
    }

    /* Same assumptions as in invocation activation */
    Invocation=RME_INVSTK_TOP(Thread);
8016b184:	e51b3008 	ldr	r3, [fp, #-8]
8016b188:	e593204c 	ldr	r2, [r3, #76]	@ 0x4c
8016b18c:	e51b3008 	ldr	r3, [fp, #-8]
8016b190:	e283304c 	add	r3, r3, #76	@ 0x4c
8016b194:	e1520003 	cmp	r2, r3
8016b198:	0a000002 	beq	8016b1a8 <_RME_Inv_Ret+0x14c>
8016b19c:	e51b3008 	ldr	r3, [fp, #-8]
8016b1a0:	e593304c 	ldr	r3, [r3, #76]	@ 0x4c
8016b1a4:	ea000000 	b	8016b1ac <_RME_Inv_Ret+0x150>
8016b1a8:	e3a03000 	mov	r3, #0
8016b1ac:	e50b300c 	str	r3, [fp, #-12]
    if(Invocation!=RME_NULL)
8016b1b0:	e51b300c 	ldr	r3, [fp, #-12]
8016b1b4:	e3530000 	cmp	r3, #0
8016b1b8:	0a000015 	beq	8016b214 <_RME_Inv_Ret+0x1b8>
    {
        RME_COV_MARKER();
        
#if(RME_PGT_RAW_ENABLE==0U)
        RME_ASSERT(RME_CAP_IS_ROOT(Invocation->Prc->Pgt)!=0U);
8016b1bc:	e51b300c 	ldr	r3, [fp, #-12]
8016b1c0:	e5933008 	ldr	r3, [r3, #8]
8016b1c4:	e5933018 	ldr	r3, [r3, #24]
8016b1c8:	e5933000 	ldr	r3, [r3]
8016b1cc:	e6ff3073 	uxth	r3, r3
8016b1d0:	e3530000 	cmp	r3, #0
8016b1d4:	0a000008 	beq	8016b1fc <_RME_Inv_Ret+0x1a0>
8016b1d8:	e30c3318 	movw	r3, #49944	@ 0xc318
8016b1dc:	e3483016 	movt	r3, #32790	@ 0x8016
8016b1e0:	e30c2324 	movw	r2, #49956	@ 0xc324
8016b1e4:	e3482016 	movt	r2, #32790	@ 0x8016
8016b1e8:	e3011e41 	movw	r1, #7745	@ 0x1e41
8016b1ec:	e30c0330 	movw	r0, #49968	@ 0xc330
8016b1f0:	e3480016 	movt	r0, #32790	@ 0x8016
8016b1f4:	ebffd662 	bl	80160b84 <RME_Log>
8016b1f8:	eafffffe 	b	8016b1f8 <_RME_Inv_Ret+0x19c>
#endif
        __RME_Pgt_Set(Invocation->Prc->Pgt);
8016b1fc:	e51b300c 	ldr	r3, [fp, #-12]
8016b200:	e5933008 	ldr	r3, [r3, #8]
8016b204:	e5933018 	ldr	r3, [r3, #24]
8016b208:	e1a00003 	mov	r0, r3
8016b20c:	eb000302 	bl	8016be1c <__RME_Pgt_Set>
8016b210:	ea000014 	b	8016b268 <_RME_Inv_Ret+0x20c>
    else
    {
        RME_COV_MARKER();
        
#if(RME_PGT_RAW_ENABLE==0U)
        RME_ASSERT(RME_CAP_IS_ROOT(Thread->Sched.Prc->Pgt)!=0U);
8016b214:	e51b3008 	ldr	r3, [fp, #-8]
8016b218:	e593302c 	ldr	r3, [r3, #44]	@ 0x2c
8016b21c:	e5933018 	ldr	r3, [r3, #24]
8016b220:	e5933000 	ldr	r3, [r3]
8016b224:	e6ff3073 	uxth	r3, r3
8016b228:	e3530000 	cmp	r3, #0
8016b22c:	0a000008 	beq	8016b254 <_RME_Inv_Ret+0x1f8>
8016b230:	e30c3318 	movw	r3, #49944	@ 0xc318
8016b234:	e3483016 	movt	r3, #32790	@ 0x8016
8016b238:	e30c2324 	movw	r2, #49956	@ 0xc324
8016b23c:	e3482016 	movt	r2, #32790	@ 0x8016
8016b240:	e3011e4a 	movw	r1, #7754	@ 0x1e4a
8016b244:	e30c0330 	movw	r0, #49968	@ 0xc330
8016b248:	e3480016 	movt	r0, #32790	@ 0x8016
8016b24c:	ebffd64c 	bl	80160b84 <RME_Log>
8016b250:	eafffffe 	b	8016b250 <_RME_Inv_Ret+0x1f4>
#endif
        __RME_Pgt_Set(Thread->Sched.Prc->Pgt);
8016b254:	e51b3008 	ldr	r3, [fp, #-8]
8016b258:	e593302c 	ldr	r3, [r3, #44]	@ 0x2c
8016b25c:	e5933018 	ldr	r3, [r3, #24]
8016b260:	e1a00003 	mov	r0, r3
8016b264:	eb0002ec 	bl	8016be1c <__RME_Pgt_Set>
    }
    
    return 0;
8016b268:	e3a03000 	mov	r3, #0
}
8016b26c:	e1a00003 	mov	r0, r3
8016b270:	e24bd004 	sub	sp, fp, #4
8016b274:	e8bd8800 	pop	{fp, pc}

8016b278 <_RME_Kfn_Act>:
                              rme_cid_t Cap_Kfn,
                              rme_ptr_t Func_ID,
                              rme_ptr_t Sub_ID,
                              rme_ptr_t Param1,
                              rme_ptr_t Param2)
{
8016b278:	e92d4800 	push	{fp, lr}
8016b27c:	e28db004 	add	fp, sp, #4
8016b280:	e24dd020 	sub	sp, sp, #32
8016b284:	e50b0010 	str	r0, [fp, #-16]
8016b288:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
8016b28c:	e50b2018 	str	r2, [fp, #-24]	@ 0xffffffe8
8016b290:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    struct RME_Cap_Kfn* Kfn_Op;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Kfn,RME_CAP_TYPE_KFN,
8016b294:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b298:	e2033080 	and	r3, r3, #128	@ 0x80
8016b29c:	e3530000 	cmp	r3, #0
8016b2a0:	1a00001d 	bne	8016b31c <_RME_Kfn_Act+0xa4>
8016b2a4:	e51b3010 	ldr	r3, [fp, #-16]
8016b2a8:	e5932014 	ldr	r2, [r3, #20]
8016b2ac:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b2b0:	e1520003 	cmp	r2, r3
8016b2b4:	8a000001 	bhi	8016b2c0 <_RME_Kfn_Act+0x48>
8016b2b8:	e3e03002 	mvn	r3, #2
8016b2bc:	ea00006e 	b	8016b47c <_RME_Kfn_Act+0x204>
8016b2c0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b2c4:	e1a02283 	lsl	r2, r3, #5
8016b2c8:	e51b3010 	ldr	r3, [fp, #-16]
8016b2cc:	e593300c 	ldr	r3, [r3, #12]
8016b2d0:	e0823003 	add	r3, r2, r3
8016b2d4:	e50b3008 	str	r3, [fp, #-8]
8016b2d8:	e51b3008 	ldr	r3, [fp, #-8]
8016b2dc:	e1a00003 	mov	r0, r3
8016b2e0:	ebffd506 	bl	80160700 <__RME_A7A_Read_Acquire>
8016b2e4:	e50b000c 	str	r0, [fp, #-12]
8016b2e8:	e51b300c 	ldr	r3, [fp, #-12]
8016b2ec:	e1a03823 	lsr	r3, r3, #16
8016b2f0:	e6ef3073 	uxtb	r3, r3
8016b2f4:	e3530002 	cmp	r3, #2
8016b2f8:	1a000001 	bne	8016b304 <_RME_Kfn_Act+0x8c>
8016b2fc:	e3e03008 	mvn	r3, #8
8016b300:	ea00005d 	b	8016b47c <_RME_Kfn_Act+0x204>
8016b304:	e51b300c 	ldr	r3, [fp, #-12]
8016b308:	e1a03c23 	lsr	r3, r3, #24
8016b30c:	e3530001 	cmp	r3, #1
8016b310:	0a000041 	beq	8016b41c <_RME_Kfn_Act+0x1a4>
8016b314:	e3e03001 	mvn	r3, #1
8016b318:	ea000057 	b	8016b47c <_RME_Kfn_Act+0x204>
8016b31c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b320:	e1a02423 	lsr	r2, r3, #8
8016b324:	e51b3010 	ldr	r3, [fp, #-16]
8016b328:	e5933014 	ldr	r3, [r3, #20]
8016b32c:	e1520003 	cmp	r2, r3
8016b330:	3a000001 	bcc	8016b33c <_RME_Kfn_Act+0xc4>
8016b334:	e3e03002 	mvn	r3, #2
8016b338:	ea00004f 	b	8016b47c <_RME_Kfn_Act+0x204>
8016b33c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b340:	e1a03423 	lsr	r3, r3, #8
8016b344:	e1a02283 	lsl	r2, r3, #5
8016b348:	e51b3010 	ldr	r3, [fp, #-16]
8016b34c:	e593300c 	ldr	r3, [r3, #12]
8016b350:	e0823003 	add	r3, r2, r3
8016b354:	e50b3008 	str	r3, [fp, #-8]
8016b358:	e51b3008 	ldr	r3, [fp, #-8]
8016b35c:	e1a00003 	mov	r0, r3
8016b360:	ebffd4e6 	bl	80160700 <__RME_A7A_Read_Acquire>
8016b364:	e50b000c 	str	r0, [fp, #-12]
8016b368:	e51b300c 	ldr	r3, [fp, #-12]
8016b36c:	e1a03823 	lsr	r3, r3, #16
8016b370:	e6ef3073 	uxtb	r3, r3
8016b374:	e3530002 	cmp	r3, #2
8016b378:	1a000001 	bne	8016b384 <_RME_Kfn_Act+0x10c>
8016b37c:	e3e03008 	mvn	r3, #8
8016b380:	ea00003d 	b	8016b47c <_RME_Kfn_Act+0x204>
8016b384:	e51b300c 	ldr	r3, [fp, #-12]
8016b388:	e1a03c23 	lsr	r3, r3, #24
8016b38c:	e3530003 	cmp	r3, #3
8016b390:	0a000001 	beq	8016b39c <_RME_Kfn_Act+0x124>
8016b394:	e3e03001 	mvn	r3, #1
8016b398:	ea000037 	b	8016b47c <_RME_Kfn_Act+0x204>
8016b39c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b3a0:	e203207f 	and	r2, r3, #127	@ 0x7f
8016b3a4:	e51b3008 	ldr	r3, [fp, #-8]
8016b3a8:	e5933014 	ldr	r3, [r3, #20]
8016b3ac:	e1520003 	cmp	r2, r3
8016b3b0:	3a000001 	bcc	8016b3bc <_RME_Kfn_Act+0x144>
8016b3b4:	e3e03002 	mvn	r3, #2
8016b3b8:	ea00002f 	b	8016b47c <_RME_Kfn_Act+0x204>
8016b3bc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b3c0:	e203307f 	and	r3, r3, #127	@ 0x7f
8016b3c4:	e1a02283 	lsl	r2, r3, #5
8016b3c8:	e51b3008 	ldr	r3, [fp, #-8]
8016b3cc:	e593300c 	ldr	r3, [r3, #12]
8016b3d0:	e0823003 	add	r3, r2, r3
8016b3d4:	e50b3008 	str	r3, [fp, #-8]
8016b3d8:	e51b3008 	ldr	r3, [fp, #-8]
8016b3dc:	e1a00003 	mov	r0, r3
8016b3e0:	ebffd4c6 	bl	80160700 <__RME_A7A_Read_Acquire>
8016b3e4:	e50b000c 	str	r0, [fp, #-12]
8016b3e8:	e51b300c 	ldr	r3, [fp, #-12]
8016b3ec:	e1a03823 	lsr	r3, r3, #16
8016b3f0:	e6ef3073 	uxtb	r3, r3
8016b3f4:	e3530002 	cmp	r3, #2
8016b3f8:	1a000001 	bne	8016b404 <_RME_Kfn_Act+0x18c>
8016b3fc:	e3e03008 	mvn	r3, #8
8016b400:	ea00001d 	b	8016b47c <_RME_Kfn_Act+0x204>
8016b404:	e51b300c 	ldr	r3, [fp, #-12]
8016b408:	e1a03c23 	lsr	r3, r3, #24
8016b40c:	e3530001 	cmp	r3, #1
8016b410:	0a000001 	beq	8016b41c <_RME_Kfn_Act+0x1a4>
8016b414:	e3e03001 	mvn	r3, #1
8016b418:	ea000017 	b	8016b47c <_RME_Kfn_Act+0x204>
                   struct RME_Cap_Kfn*,Kfn_Op,Type_Stat);    

    /* Check if the range of calling is allowed - kernel function specific */
    if((Func_ID>RME_KFN_FLAG_HIGH(Kfn_Op->Head.Flag))||
8016b41c:	e51b3008 	ldr	r3, [fp, #-8]
8016b420:	e5933008 	ldr	r3, [r3, #8]
8016b424:	e1a03823 	lsr	r3, r3, #16
8016b428:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
8016b42c:	e1520003 	cmp	r2, r3
8016b430:	8a000005 	bhi	8016b44c <_RME_Kfn_Act+0x1d4>
       (Func_ID<RME_KFN_FLAG_LOW(Kfn_Op->Head.Flag)))
8016b434:	e51b3008 	ldr	r3, [fp, #-8]
8016b438:	e5933008 	ldr	r3, [r3, #8]
8016b43c:	e6ff3073 	uxth	r3, r3
    if((Func_ID>RME_KFN_FLAG_HIGH(Kfn_Op->Head.Flag))||
8016b440:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
8016b444:	e1520003 	cmp	r2, r3
8016b448:	2a000001 	bcs	8016b454 <_RME_Kfn_Act+0x1dc>
    {
        RME_COV_MARKER();

        return RME_ERR_CPT_FLAG;
8016b44c:	e3e03006 	mvn	r3, #6
8016b450:	ea000009 	b	8016b47c <_RME_Kfn_Act+0x204>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Return whatever the function returns */
    return __RME_Kfn_Handler(Cpt,Reg,Func_ID,Sub_ID,Param1,Param2);
8016b454:	e59b300c 	ldr	r3, [fp, #12]
8016b458:	e58d3004 	str	r3, [sp, #4]
8016b45c:	e59b3008 	ldr	r3, [fp, #8]
8016b460:	e58d3000 	str	r3, [sp]
8016b464:	e59b3004 	ldr	r3, [fp, #4]
8016b468:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
8016b46c:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
8016b470:	e51b0010 	ldr	r0, [fp, #-16]
8016b474:	eb0001dd 	bl	8016bbf0 <__RME_Kfn_Handler>
8016b478:	e1a03000 	mov	r3, r0
}
8016b47c:	e1a00003 	mov	r0, r3
8016b480:	e24bd004 	sub	sp, fp, #4
8016b484:	e8bd8800 	pop	{fp, pc}

8016b488 <main>:
Input       : None.
Output      : None.
Return      : int - This function never returns.
******************************************************************************/
int main(void)
{
8016b488:	e92d4800 	push	{fp, lr}
8016b48c:	e28db004 	add	fp, sp, #4
    /*__RME_Putchar('w');
    __RME_Putchar('o');
    __RME_Putchar('r');
    __RME_Putchar('l');
    __RME_Putchar('d');*/
    RME_Kmain();
8016b490:	ebffd649 	bl	80160dbc <RME_Kmain>
    
    //test
    /* The main function of the kernel - we will start our kernel boot here */
    //_RME_Kmain(RME_KOM_STACK_ADDR);

    return 0;
8016b494:	e3a03000 	mov	r3, #0
}
8016b498:	e1a00003 	mov	r0, r3
8016b49c:	e8bd8800 	pop	{fp, pc}

8016b4a0 <__RME_Putchar>:
Input       : char Char - The character to print.
Output      : None.
Return      : rme_ptr_t - Always 0.
******************************************************************************/
rme_ptr_t __RME_Putchar(char Char)
{
8016b4a0:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016b4a4:	e28db000 	add	fp, sp, #0
8016b4a8:	e24dd00c 	sub	sp, sp, #12
8016b4ac:	e1a03000 	mov	r3, r0
8016b4b0:	e54b3005 	strb	r3, [fp, #-5]
    RME_A7A_PUTCHAR(Char);
8016b4b4:	e320f000 	nop	{0}
8016b4b8:	e301302c 	movw	r3, #4140	@ 0x102c
8016b4bc:	e34e3000 	movt	r3, #57344	@ 0xe000
8016b4c0:	e5933000 	ldr	r3, [r3]
8016b4c4:	e2033008 	and	r3, r3, #8
8016b4c8:	e3530000 	cmp	r3, #0
8016b4cc:	0afffff9 	beq	8016b4b8 <__RME_Putchar+0x18>
8016b4d0:	e3013030 	movw	r3, #4144	@ 0x1030
8016b4d4:	e34e3000 	movt	r3, #57344	@ 0xe000
8016b4d8:	e15b20d5 	ldrsb	r2, [fp, #-5]
8016b4dc:	e5832000 	str	r2, [r3]
    return 0;
8016b4e0:	e3a03000 	mov	r3, #0
}
8016b4e4:	e1a00003 	mov	r0, r3
8016b4e8:	e28bd000 	add	sp, fp, #0
8016b4ec:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016b4f0:	e12fff1e 	bx	lr

8016b4f4 <__RME_A7A_Int_Init>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
void __RME_A7A_Int_Init(void)
{
8016b4f4:	e92d4800 	push	{fp, lr}
8016b4f8:	e28db004 	add	fp, sp, #4
8016b4fc:	e24dd008 	sub	sp, sp, #8
    rme_ptr_t Temp;
    rme_ptr_t Lines;

    /* Who implemented the GIC, what variant, how many interrupts? */
    Temp=RME_A7A_GICD_IIDR;
8016b500:	e3013008 	movw	r3, #4104	@ 0x1008
8016b504:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016b508:	e5933000 	ldr	r3, [r3]
8016b50c:	e50b3008 	str	r3, [fp, #-8]
    RME_DBG_S("\r\nA7A-GIC: ProductID: ");
8016b510:	e30c03d8 	movw	r0, #50136	@ 0xc3d8
8016b514:	e3480016 	movt	r0, #32790	@ 0x8016
8016b518:	ebffd57a 	bl	80160b08 <RME_Str_Print>
    RME_DBG_I(Temp>>24);
8016b51c:	e51b3008 	ldr	r3, [fp, #-8]
8016b520:	e1a03c23 	lsr	r3, r3, #24
8016b524:	e1a00003 	mov	r0, r3
8016b528:	ebffd4d7 	bl	8016088c <RME_Int_Print>
    RME_DBG_S("\r\nA7A-GIC: Variant: ");
8016b52c:	e30c03f0 	movw	r0, #50160	@ 0xc3f0
8016b530:	e3480016 	movt	r0, #32790	@ 0x8016
8016b534:	ebffd573 	bl	80160b08 <RME_Str_Print>
    RME_DBG_I((Temp>>20)&0xF);
8016b538:	e51b3008 	ldr	r3, [fp, #-8]
8016b53c:	e1a03a23 	lsr	r3, r3, #20
8016b540:	e203300f 	and	r3, r3, #15
8016b544:	e1a00003 	mov	r0, r3
8016b548:	ebffd4cf 	bl	8016088c <RME_Int_Print>
    RME_DBG_S("\r\nA7A-GIC: Revision: ");
8016b54c:	e30c0408 	movw	r0, #50184	@ 0xc408
8016b550:	e3480016 	movt	r0, #32790	@ 0x8016
8016b554:	ebffd56b 	bl	80160b08 <RME_Str_Print>
    RME_DBG_I((Temp>>12)&0xF);
8016b558:	e51b3008 	ldr	r3, [fp, #-8]
8016b55c:	e1a03623 	lsr	r3, r3, #12
8016b560:	e203300f 	and	r3, r3, #15
8016b564:	e1a00003 	mov	r0, r3
8016b568:	ebffd4c7 	bl	8016088c <RME_Int_Print>
    RME_DBG_S("\r\nA7A-GIC: Implementer: 0x");
8016b56c:	e30c0420 	movw	r0, #50208	@ 0xc420
8016b570:	e3480016 	movt	r0, #32790	@ 0x8016
8016b574:	ebffd563 	bl	80160b08 <RME_Str_Print>
    RME_DBG_H(Temp&0xFFF);
8016b578:	e51b3008 	ldr	r3, [fp, #-8]
8016b57c:	e7eb3053 	ubfx	r3, r3, #0, #12
8016b580:	e1a00003 	mov	r0, r3
8016b584:	ebffd51d 	bl	80160a00 <RME_Hex_Print>

    /* How many locked SPIs, security extension enabled or not, number of
     * actual CPUs and interrupt lines */
    Temp=RME_A7A_GICD_TYPER;
8016b588:	e3013004 	movw	r3, #4100	@ 0x1004
8016b58c:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016b590:	e5933000 	ldr	r3, [r3]
8016b594:	e50b3008 	str	r3, [fp, #-8]
    RME_DBG_S("\r\nA7A-GIC: SPI number: ");
8016b598:	e30c043c 	movw	r0, #50236	@ 0xc43c
8016b59c:	e3480016 	movt	r0, #32790	@ 0x8016
8016b5a0:	ebffd558 	bl	80160b08 <RME_Str_Print>
    RME_DBG_I(Temp>>16);
8016b5a4:	e51b3008 	ldr	r3, [fp, #-8]
8016b5a8:	e1a03823 	lsr	r3, r3, #16
8016b5ac:	e1a00003 	mov	r0, r3
8016b5b0:	ebffd4b5 	bl	8016088c <RME_Int_Print>
    RME_DBG_S("\r\nA7A-GIC: Security extension: ");
8016b5b4:	e30c0454 	movw	r0, #50260	@ 0xc454
8016b5b8:	e3480016 	movt	r0, #32790	@ 0x8016
8016b5bc:	ebffd551 	bl	80160b08 <RME_Str_Print>
    RME_DBG_I((Temp>>10)&0x1);
8016b5c0:	e51b3008 	ldr	r3, [fp, #-8]
8016b5c4:	e1a03523 	lsr	r3, r3, #10
8016b5c8:	e2033001 	and	r3, r3, #1
8016b5cc:	e1a00003 	mov	r0, r3
8016b5d0:	ebffd4ad 	bl	8016088c <RME_Int_Print>
    RME_DBG_S("\r\nA7A-GIC: CPU number: ");
8016b5d4:	e30c0474 	movw	r0, #50292	@ 0xc474
8016b5d8:	e3480016 	movt	r0, #32790	@ 0x8016
8016b5dc:	ebffd549 	bl	80160b08 <RME_Str_Print>
    RME_DBG_I(((Temp>>5)&0x7)+1);
8016b5e0:	e51b3008 	ldr	r3, [fp, #-8]
8016b5e4:	e1a032a3 	lsr	r3, r3, #5
8016b5e8:	e2033007 	and	r3, r3, #7
8016b5ec:	e2833001 	add	r3, r3, #1
8016b5f0:	e1a00003 	mov	r0, r3
8016b5f4:	ebffd4a4 	bl	8016088c <RME_Int_Print>
    RME_DBG_S("\r\nA7A-GIC: Interrupt line number: ");
8016b5f8:	e30c048c 	movw	r0, #50316	@ 0xc48c
8016b5fc:	e3480016 	movt	r0, #32790	@ 0x8016
8016b600:	ebffd540 	bl	80160b08 <RME_Str_Print>
    Lines=((Temp&0x1F)+1)*32;
8016b604:	e51b3008 	ldr	r3, [fp, #-8]
8016b608:	e203301f 	and	r3, r3, #31
8016b60c:	e2833001 	add	r3, r3, #1
8016b610:	e1a03283 	lsl	r3, r3, #5
8016b614:	e50b300c 	str	r3, [fp, #-12]
    RME_DBG_H(Lines);
8016b618:	e51b000c 	ldr	r0, [fp, #-12]
8016b61c:	ebffd4f7 	bl	80160a00 <RME_Hex_Print>


#if(RME_A7A_GIC_TYPE==RME_A7A_GIC_V1)
    /* Initialize all vectors to group 0, and disable all */
	for(Temp=0;Temp<Lines/32;Temp++)
8016b620:	e3a03000 	mov	r3, #0
8016b624:	e50b3008 	str	r3, [fp, #-8]
8016b628:	ea00001a 	b	8016b698 <__RME_A7A_Int_Init+0x1a4>
	{
		RME_A7A_GICD_ICPENDR(Temp)=0xFFFFFFFFU;
8016b62c:	e51b2008 	ldr	r2, [fp, #-8]
8016b630:	e3a03e4a 	mov	r3, #1184	@ 0x4a0
8016b634:	e3433e3c 	movt	r3, #15932	@ 0x3e3c
8016b638:	e0823003 	add	r3, r2, r3
8016b63c:	e1a03103 	lsl	r3, r3, #2
8016b640:	e1a02003 	mov	r2, r3
8016b644:	e3e03000 	mvn	r3, #0
8016b648:	e5823000 	str	r3, [r2]
		RME_A7A_GICD_IGROUPR(Temp)=0x00000000U;
8016b64c:	e51b2008 	ldr	r2, [fp, #-8]
8016b650:	e3a03e42 	mov	r3, #1056	@ 0x420
8016b654:	e3433e3c 	movt	r3, #15932	@ 0x3e3c
8016b658:	e0823003 	add	r3, r2, r3
8016b65c:	e1a03103 	lsl	r3, r3, #2
8016b660:	e1a02003 	mov	r2, r3
8016b664:	e3a03000 	mov	r3, #0
8016b668:	e5823000 	str	r3, [r2]
		RME_A7A_GICD_ICENABLER(Temp)=0xFFFFFFFFU;
8016b66c:	e51b2008 	ldr	r2, [fp, #-8]
8016b670:	e3a03e46 	mov	r3, #1120	@ 0x460
8016b674:	e3433e3c 	movt	r3, #15932	@ 0x3e3c
8016b678:	e0823003 	add	r3, r2, r3
8016b67c:	e1a03103 	lsl	r3, r3, #2
8016b680:	e1a02003 	mov	r2, r3
8016b684:	e3e03000 	mvn	r3, #0
8016b688:	e5823000 	str	r3, [r2]
	for(Temp=0;Temp<Lines/32;Temp++)
8016b68c:	e51b3008 	ldr	r3, [fp, #-8]
8016b690:	e2833001 	add	r3, r3, #1
8016b694:	e50b3008 	str	r3, [fp, #-8]
8016b698:	e51b300c 	ldr	r3, [fp, #-12]
8016b69c:	e1a032a3 	lsr	r3, r3, #5
8016b6a0:	e51b2008 	ldr	r2, [fp, #-8]
8016b6a4:	e1520003 	cmp	r2, r3
8016b6a8:	3affffdf 	bcc	8016b62c <__RME_A7A_Int_Init+0x138>
	}

	/* Set the priority of all such interrupts to the lowest level */
	for(Temp=0;Temp<Lines/4;Temp++)
8016b6ac:	e3a03000 	mov	r3, #0
8016b6b0:	e50b3008 	str	r3, [fp, #-8]
8016b6b4:	ea00000b 	b	8016b6e8 <__RME_A7A_Int_Init+0x1f4>
		RME_A7A_GICD_IPRIORITYR(Temp)=0xA0A0A0A0U;
8016b6b8:	e51b2008 	ldr	r2, [fp, #-8]
8016b6bc:	e3a03c05 	mov	r3, #1280	@ 0x500
8016b6c0:	e3433e3c 	movt	r3, #15932	@ 0x3e3c
8016b6c4:	e0823003 	add	r3, r2, r3
8016b6c8:	e1a03103 	lsl	r3, r3, #2
8016b6cc:	e1a02003 	mov	r2, r3
8016b6d0:	e30a30a0 	movw	r3, #41120	@ 0xa0a0
8016b6d4:	e34a30a0 	movt	r3, #41120	@ 0xa0a0
8016b6d8:	e5823000 	str	r3, [r2]
	for(Temp=0;Temp<Lines/4;Temp++)
8016b6dc:	e51b3008 	ldr	r3, [fp, #-8]
8016b6e0:	e2833001 	add	r3, r3, #1
8016b6e4:	e50b3008 	str	r3, [fp, #-8]
8016b6e8:	e51b300c 	ldr	r3, [fp, #-12]
8016b6ec:	e1a03123 	lsr	r3, r3, #2
8016b6f0:	e51b2008 	ldr	r2, [fp, #-8]
8016b6f4:	e1520003 	cmp	r2, r3
8016b6f8:	3affffee 	bcc	8016b6b8 <__RME_A7A_Int_Init+0x1c4>

	/* All interrupts target CPU0 */
	for(Temp=8;Temp<Lines/4;Temp++)
8016b6fc:	e3a03008 	mov	r3, #8
8016b700:	e50b3008 	str	r3, [fp, #-8]
8016b704:	ea00000b 	b	8016b738 <__RME_A7A_Int_Init+0x244>
		RME_A7A_GICD_ITARGETSR(Temp)=0x01010101U;
8016b708:	e51b2008 	ldr	r2, [fp, #-8]
8016b70c:	e3a03c06 	mov	r3, #1536	@ 0x600
8016b710:	e3433e3c 	movt	r3, #15932	@ 0x3e3c
8016b714:	e0823003 	add	r3, r2, r3
8016b718:	e1a03103 	lsl	r3, r3, #2
8016b71c:	e1a02003 	mov	r2, r3
8016b720:	e3003101 	movw	r3, #257	@ 0x101
8016b724:	e3403101 	movt	r3, #257	@ 0x101
8016b728:	e5823000 	str	r3, [r2]
	for(Temp=8;Temp<Lines/4;Temp++)
8016b72c:	e51b3008 	ldr	r3, [fp, #-8]
8016b730:	e2833001 	add	r3, r3, #1
8016b734:	e50b3008 	str	r3, [fp, #-8]
8016b738:	e51b300c 	ldr	r3, [fp, #-12]
8016b73c:	e1a03123 	lsr	r3, r3, #2
8016b740:	e51b2008 	ldr	r2, [fp, #-8]
8016b744:	e1520003 	cmp	r2, r3
8016b748:	3affffee 	bcc	8016b708 <__RME_A7A_Int_Init+0x214>

	/* All interrupts are edge triggered, and use 1-N model */
	for(Temp=0;Temp<Lines/16;Temp++)
8016b74c:	e3a03000 	mov	r3, #0
8016b750:	e50b3008 	str	r3, [fp, #-8]
8016b754:	ea00000b 	b	8016b788 <__RME_A7A_Int_Init+0x294>
		RME_A7A_GICD_ICFGR(Temp)=0x55555555U;
8016b758:	e51b2008 	ldr	r2, [fp, #-8]
8016b75c:	e3a03c07 	mov	r3, #1792	@ 0x700
8016b760:	e3433e3c 	movt	r3, #15932	@ 0x3e3c
8016b764:	e0823003 	add	r3, r2, r3
8016b768:	e1a03103 	lsl	r3, r3, #2
8016b76c:	e1a02003 	mov	r2, r3
8016b770:	e3053555 	movw	r3, #21845	@ 0x5555
8016b774:	e3453555 	movt	r3, #21845	@ 0x5555
8016b778:	e5823000 	str	r3, [r2]
	for(Temp=0;Temp<Lines/16;Temp++)
8016b77c:	e51b3008 	ldr	r3, [fp, #-8]
8016b780:	e2833001 	add	r3, r3, #1
8016b784:	e50b3008 	str	r3, [fp, #-8]
8016b788:	e51b300c 	ldr	r3, [fp, #-12]
8016b78c:	e1a03223 	lsr	r3, r3, #4
8016b790:	e51b2008 	ldr	r2, [fp, #-8]
8016b794:	e1520003 	cmp	r2, r3
8016b798:	3affffee 	bcc	8016b758 <__RME_A7A_Int_Init+0x264>

	/* Enable the interrupt controller */
	RME_A7A_GICD_CTLR=RME_A7A_GICD_CTLR_GRP1EN|RME_A7A_GICD_CTLR_GRP0EN;
8016b79c:	e3a03a01 	mov	r3, #4096	@ 0x1000
8016b7a0:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016b7a4:	e3a02003 	mov	r2, #3
8016b7a8:	e5832000 	str	r2, [r3]
    	RME_A7A_GICD_ICFGR(Temp)=0xFFFFFFFFU;

    /* Enable the interrupt controller */
    RME_A7A_GICD_CTLR=RME_A7A_GICD_CTLR_GRP1EN|RME_A7A_GICD_CTLR_GRP0EN;
#endif
}
8016b7ac:	e320f000 	nop	{0}
8016b7b0:	e24bd004 	sub	sp, fp, #4
8016b7b4:	e8bd8800 	pop	{fp, pc}

8016b7b8 <__RME_A7A_Int_Local_Init>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
void __RME_A7A_Int_Local_Init(void)
{
8016b7b8:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016b7bc:	e28db000 	add	fp, sp, #0
	/* Priority grouping */
	RME_A7A_GICC_BPR=RME_A7A_GIC_GROUPING;
8016b7c0:	e3a03f41 	mov	r3, #260	@ 0x104
8016b7c4:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016b7c8:	e3a02000 	mov	r2, #0
8016b7cc:	e5832000 	str	r2, [r3]

#if(RME_A7A_GIC_TYPE==RME_A7A_GIC_V1)
	/* Enable all interrupts to this interface - FIQ is bypassed, and all
	 * interrupts go through the IRQ. The FIQ feature is only available on
	 * the stabdalone FIQ interrupt line */
	RME_A7A_GICC_CTLR=RME_A7A_GICC_ENABLEGRP0;
8016b7d0:	e3a03c01 	mov	r3, #256	@ 0x100
8016b7d4:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016b7d8:	e3a02001 	mov	r2, #1
8016b7dc:	e5832000 	str	r2, [r3]

	/* No interrupts are masked - This must be set at last because enabling
	 * will trash the contents of this register if previously set. To maintain
	 * compatibility across all possible implementations, no priority level
	 * lower than 0xF0 will be considered valid */
	RME_A7A_GICC_PMR=0xF0U;
8016b7e0:	e3a03f41 	mov	r3, #260	@ 0x104
8016b7e4:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016b7e8:	e3a020f0 	mov	r2, #240	@ 0xf0
8016b7ec:	e5832000 	str	r2, [r3]
}
8016b7f0:	e320f000 	nop	{0}
8016b7f4:	e28bd000 	add	sp, fp, #0
8016b7f8:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016b7fc:	e12fff1e 	bx	lr

8016b800 <__RME_A7A_Timer_Init>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
void __RME_A7A_Timer_Init(void)
{
8016b800:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016b804:	e28db000 	add	fp, sp, #0
#if((RME_A7A_CPU_TYPE==RME_A7A_CPU_CORTEX_A5)|| \
	(RME_A7A_CPU_TYPE==RME_A7A_CPU_CORTEX_A9))
    /* Writing this will also write the counter register as well */
    RME_A7A_PTWD_PTLR=RME_A7A_SYSTICK_VAL;
8016b808:	e3a03c06 	mov	r3, #1536	@ 0x600
8016b80c:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016b810:	e3082478 	movw	r2, #33912	@ 0x8478
8016b814:	e340203a 	movt	r2, #58	@ 0x3a
8016b818:	e5832000 	str	r2, [r3]
    /* Clear the interrupt flag */
    RME_A7A_PTWD_PTISR=0;
8016b81c:	e300360c 	movw	r3, #1548	@ 0x60c
8016b820:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016b824:	e3a02000 	mov	r2, #0
8016b828:	e5832000 	str	r2, [r3]
    /* Start the timer */
    RME_A7A_PTWD_PTCTLR=RME_A7A_PTWD_PTCTLR_PRESC(0)|
8016b82c:	e3003608 	movw	r3, #1544	@ 0x608
8016b830:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016b834:	e3a02007 	mov	r2, #7
8016b838:	e5832000 	str	r2, [r3]
                         RME_A7A_PTWD_PTCTLR_IRQEN|
						 RME_A7A_PTWD_PTCTLR_AUTOREL|
						 RME_A7A_PTWD_PTCTLR_TIMEN;

    /* Enable the timer interrupt in the GIC */
    RME_A7A_GICD_ISENABLER(0)|=1<<29;
8016b83c:	e3a03c11 	mov	r3, #4352	@ 0x1100
8016b840:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016b844:	e5932000 	ldr	r2, [r3]
8016b848:	e3a03c11 	mov	r3, #4352	@ 0x1100
8016b84c:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016b850:	e3822202 	orr	r2, r2, #536870912	@ 0x20000000
8016b854:	e5832000 	str	r2, [r3]
#else
	#error Cortex-A7/8/15/17 is not supported at the moment.
    Cortex-A7/15/17 use the new generic timer, and Cortex-A8 does not
	have a processor timer due to very early release dates.
#endif
}
8016b858:	e320f000 	nop	{0}
8016b85c:	e28bd000 	add	sp, fp, #0
8016b860:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016b864:	e12fff1e 	bx	lr

8016b868 <__RME_Lowlvl_Init>:
Input       : None.
Output      : None.
Return      : rme_ptr_t - Always 0.
******************************************************************************/
void __RME_Lowlvl_Init(void)
{
8016b868:	e92d4800 	push	{fp, lr}
8016b86c:	e28db004 	add	fp, sp, #4
    /* Initialize hardware */
    RME_A7A_LOW_LEVEL_INIT();

    /* Initialize our own CPU-local data structure */
    _RME_CPU_Local_Init(&RME_A7A_Local,0);
8016b870:	e3a01000 	mov	r1, #0
8016b874:	e30d0004 	movw	r0, #53252	@ 0xd004
8016b878:	e3480016 	movt	r0, #32790	@ 0x8016
8016b87c:	ebffe59a 	bl	80164eec <_RME_CPU_Local_Init>

    /* Initialize the interrupt controller */
    __RME_A7A_Int_Init();
8016b880:	ebffff1b 	bl	8016b4f4 <__RME_A7A_Int_Init>

    /* Initialize CPU-local interrupt resources */
	__RME_A7A_Int_Local_Init();
8016b884:	ebffffcb 	bl	8016b7b8 <__RME_A7A_Int_Local_Init>

    /* Initialize the vector table */
    RME_DBG_S("\r\nA7A-Vector: 0x");
8016b888:	e30c04b0 	movw	r0, #50352	@ 0xc4b0
8016b88c:	e3480016 	movt	r0, #32790	@ 0x8016
8016b890:	ebffd49c 	bl	80160b08 <RME_Str_Print>
    RME_DBG_H((rme_ptr_t)&__RME_A7A_Vector_Table);
8016b894:	e3003000 	movw	r3, #0
8016b898:	e3483016 	movt	r3, #32790	@ 0x8016
8016b89c:	e1a00003 	mov	r0, r3
8016b8a0:	ebffd456 	bl	80160a00 <RME_Hex_Print>
    __RME_A7A_VBAR_Set((rme_ptr_t)&__RME_A7A_Vector_Table);
8016b8a4:	e3003000 	movw	r3, #0
8016b8a8:	e3483016 	movt	r3, #32790	@ 0x8016
8016b8ac:	e1a00003 	mov	r0, r3
8016b8b0:	ebffd35a 	bl	80160620 <__RME_A7A_VBAR_Set>

    RME_DBG_S("\r\nA7A-Non-Secure: ");
8016b8b4:	e30c04c4 	movw	r0, #50372	@ 0xc4c4
8016b8b8:	e3480016 	movt	r0, #32790	@ 0x8016
8016b8bc:	ebffd491 	bl	80160b08 <RME_Str_Print>
    RME_DBG_H(__RME_A7A_SCR_Get());
8016b8c0:	ebffd214 	bl	80160118 <__RME_A7A_SCR_Get>
8016b8c4:	e1a03000 	mov	r3, r0
8016b8c8:	e1a00003 	mov	r0, r3
8016b8cc:	ebffd44b 	bl	80160a00 <RME_Hex_Print>
}
8016b8d0:	e320f000 	nop	{0}
8016b8d4:	e8bd8800 	pop	{fp, pc}

8016b8d8 <__RME_Pgt_Kom_Init>:
Input       : None.
Output      : None.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Kom_Init(void)
{
8016b8d8:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016b8dc:	e28db000 	add	fp, sp, #0

    return 0;
8016b8e0:	e3a03000 	mov	r3, #0
}
8016b8e4:	e1a00003 	mov	r0, r3
8016b8e8:	e28bd000 	add	sp, fp, #0
8016b8ec:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016b8f0:	e12fff1e 	bx	lr

8016b8f4 <__RME_Boot>:
Input       : None.
Output      : None.
Return      : rme_ptr_t - Always 0.
******************************************************************************/
void __RME_Boot(void)
{
8016b8f4:	e92d4800 	push	{fp, lr}
8016b8f8:	e28db004 	add	fp, sp, #4
    /* Initialize timer */
	__RME_A7A_Timer_Init();
8016b8fc:	ebffffbf 	bl	8016b800 <__RME_A7A_Timer_Init>
    __RME_Int_Enable();
8016b900:	ebffd386 	bl	80160720 <__RME_Int_Enable>
	while(1);
8016b904:	eafffffe 	b	8016b904 <__RME_Boot+0x10>

8016b908 <__RME_Svc_Param_Get>:
              rme_ptr_t* Capid - The capability ID number.
              rme_ptr_t* Param - The parameters.
Return      : None.
******************************************************************************/
void __RME_Svc_Param_Get(struct RME_Reg_Struct* Reg,rme_ptr_t* Svc,rme_ptr_t* Capid,rme_ptr_t* Param)
{
8016b908:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016b90c:	e28db000 	add	fp, sp, #0
8016b910:	e24dd014 	sub	sp, sp, #20
8016b914:	e50b0008 	str	r0, [fp, #-8]
8016b918:	e50b100c 	str	r1, [fp, #-12]
8016b91c:	e50b2010 	str	r2, [fp, #-16]
8016b920:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    *Svc=(Reg->R0)>>16;
8016b924:	e51b3008 	ldr	r3, [fp, #-8]
8016b928:	e5933004 	ldr	r3, [r3, #4]
8016b92c:	e1a02823 	lsr	r2, r3, #16
8016b930:	e51b300c 	ldr	r3, [fp, #-12]
8016b934:	e5832000 	str	r2, [r3]
    *Capid=(Reg->R0)&0xFFFF;
8016b938:	e51b3008 	ldr	r3, [fp, #-8]
8016b93c:	e5933004 	ldr	r3, [r3, #4]
8016b940:	e6ff2073 	uxth	r2, r3
8016b944:	e51b3010 	ldr	r3, [fp, #-16]
8016b948:	e5832000 	str	r2, [r3]
    Param[0]=Reg->R1;
8016b94c:	e51b3008 	ldr	r3, [fp, #-8]
8016b950:	e5932008 	ldr	r2, [r3, #8]
8016b954:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016b958:	e5832000 	str	r2, [r3]
    Param[1]=Reg->R2;
8016b95c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016b960:	e2833004 	add	r3, r3, #4
8016b964:	e51b2008 	ldr	r2, [fp, #-8]
8016b968:	e592200c 	ldr	r2, [r2, #12]
8016b96c:	e5832000 	str	r2, [r3]
    Param[2]=Reg->R3;
8016b970:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016b974:	e2833008 	add	r3, r3, #8
8016b978:	e51b2008 	ldr	r2, [fp, #-8]
8016b97c:	e5922010 	ldr	r2, [r2, #16]
8016b980:	e5832000 	str	r2, [r3]
}
8016b984:	e320f000 	nop	{0}
8016b988:	e28bd000 	add	sp, fp, #0
8016b98c:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016b990:	e12fff1e 	bx	lr

8016b994 <__RME_Svc_Retval_Set>:
Input       : rme_ret_t Retval - The return value.
Output      : struct RME_Reg_Struct* Reg - The register set.
Return      : None.
******************************************************************************/
void __RME_Svc_Retval_Set(struct RME_Reg_Struct* Reg,rme_ret_t Retval)
{
8016b994:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016b998:	e28db000 	add	fp, sp, #0
8016b99c:	e24dd00c 	sub	sp, sp, #12
8016b9a0:	e50b0008 	str	r0, [fp, #-8]
8016b9a4:	e50b100c 	str	r1, [fp, #-12]
    Reg->R0=(rme_ptr_t)Retval;
8016b9a8:	e51b200c 	ldr	r2, [fp, #-12]
8016b9ac:	e51b3008 	ldr	r3, [fp, #-8]
8016b9b0:	e5832004 	str	r2, [r3, #4]
}
8016b9b4:	e320f000 	nop	{0}
8016b9b8:	e28bd000 	add	sp, fp, #0
8016b9bc:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016b9c0:	e12fff1e 	bx	lr

8016b9c4 <__RME_Thd_Reg_Init>:
Output      : struct RME_Reg_Struct* Reg - The register set content generated.
Return      : None.
******************************************************************************/
void __RME_Thd_Reg_Init(rme_ptr_t Attr,rme_ptr_t Entry,rme_ptr_t Stack,rme_ptr_t Param,
                                       struct RME_Reg_Struct* Reg)
{
8016b9c4:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016b9c8:	e28db000 	add	fp, sp, #0
8016b9cc:	e24dd014 	sub	sp, sp, #20
8016b9d0:	e50b0008 	str	r0, [fp, #-8]
8016b9d4:	e50b100c 	str	r1, [fp, #-12]
8016b9d8:	e50b2010 	str	r2, [fp, #-16]
8016b9dc:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    /* Set the entry and stack */
    Reg->PC=Entry;
8016b9e0:	e59b3004 	ldr	r3, [fp, #4]
8016b9e4:	e51b200c 	ldr	r2, [fp, #-12]
8016b9e8:	e583203c 	str	r2, [r3, #60]	@ 0x3c
    Reg->SP=Stack;
8016b9ec:	e59b3004 	ldr	r3, [fp, #4]
8016b9f0:	e51b2010 	ldr	r2, [fp, #-16]
8016b9f4:	e5832034 	str	r2, [r3, #52]	@ 0x34
    /* Set the parameter */
    Reg->R0=Param;
8016b9f8:	e59b3004 	ldr	r3, [fp, #4]
8016b9fc:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
8016ba00:	e5832004 	str	r2, [r3, #4]
}
8016ba04:	e320f000 	nop	{0}
8016ba08:	e28bd000 	add	sp, fp, #0
8016ba0c:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016ba10:	e12fff1e 	bx	lr

8016ba14 <__RME_Thd_Reg_Copy>:
Input       : struct RME_Reg_Struct* Src - The source register set.
Output      : struct RME_Reg_Struct* Dst - The destination register set.
Return      : None.
******************************************************************************/
void __RME_Thd_Reg_Copy(struct RME_Reg_Struct* Dst, struct RME_Reg_Struct* Src)
{
8016ba14:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016ba18:	e28db000 	add	fp, sp, #0
8016ba1c:	e24dd00c 	sub	sp, sp, #12
8016ba20:	e50b0008 	str	r0, [fp, #-8]
8016ba24:	e50b100c 	str	r1, [fp, #-12]
    /* Make sure that the ordering is the same so the compiler can optimize */
    Dst->CPSR=Src->CPSR;
8016ba28:	e51b300c 	ldr	r3, [fp, #-12]
8016ba2c:	e5932000 	ldr	r2, [r3]
8016ba30:	e51b3008 	ldr	r3, [fp, #-8]
8016ba34:	e5832000 	str	r2, [r3]
    Dst->R0=Src->R0;
8016ba38:	e51b300c 	ldr	r3, [fp, #-12]
8016ba3c:	e5932004 	ldr	r2, [r3, #4]
8016ba40:	e51b3008 	ldr	r3, [fp, #-8]
8016ba44:	e5832004 	str	r2, [r3, #4]
    Dst->R1=Src->R1;
8016ba48:	e51b300c 	ldr	r3, [fp, #-12]
8016ba4c:	e5932008 	ldr	r2, [r3, #8]
8016ba50:	e51b3008 	ldr	r3, [fp, #-8]
8016ba54:	e5832008 	str	r2, [r3, #8]
    Dst->R2=Src->R2;
8016ba58:	e51b300c 	ldr	r3, [fp, #-12]
8016ba5c:	e593200c 	ldr	r2, [r3, #12]
8016ba60:	e51b3008 	ldr	r3, [fp, #-8]
8016ba64:	e583200c 	str	r2, [r3, #12]
    Dst->R3=Src->R3;
8016ba68:	e51b300c 	ldr	r3, [fp, #-12]
8016ba6c:	e5932010 	ldr	r2, [r3, #16]
8016ba70:	e51b3008 	ldr	r3, [fp, #-8]
8016ba74:	e5832010 	str	r2, [r3, #16]
    Dst->R4=Src->R4;
8016ba78:	e51b300c 	ldr	r3, [fp, #-12]
8016ba7c:	e5932014 	ldr	r2, [r3, #20]
8016ba80:	e51b3008 	ldr	r3, [fp, #-8]
8016ba84:	e5832014 	str	r2, [r3, #20]
    Dst->R5=Src->R5;
8016ba88:	e51b300c 	ldr	r3, [fp, #-12]
8016ba8c:	e5932018 	ldr	r2, [r3, #24]
8016ba90:	e51b3008 	ldr	r3, [fp, #-8]
8016ba94:	e5832018 	str	r2, [r3, #24]
    Dst->R6=Src->R6;
8016ba98:	e51b300c 	ldr	r3, [fp, #-12]
8016ba9c:	e593201c 	ldr	r2, [r3, #28]
8016baa0:	e51b3008 	ldr	r3, [fp, #-8]
8016baa4:	e583201c 	str	r2, [r3, #28]
    Dst->R7=Src->R7;
8016baa8:	e51b300c 	ldr	r3, [fp, #-12]
8016baac:	e5932020 	ldr	r2, [r3, #32]
8016bab0:	e51b3008 	ldr	r3, [fp, #-8]
8016bab4:	e5832020 	str	r2, [r3, #32]
    Dst->R8=Src->R8;
8016bab8:	e51b300c 	ldr	r3, [fp, #-12]
8016babc:	e5932024 	ldr	r2, [r3, #36]	@ 0x24
8016bac0:	e51b3008 	ldr	r3, [fp, #-8]
8016bac4:	e5832024 	str	r2, [r3, #36]	@ 0x24
    Dst->R9=Src->R9;
8016bac8:	e51b300c 	ldr	r3, [fp, #-12]
8016bacc:	e5932028 	ldr	r2, [r3, #40]	@ 0x28
8016bad0:	e51b3008 	ldr	r3, [fp, #-8]
8016bad4:	e5832028 	str	r2, [r3, #40]	@ 0x28
    Dst->R10=Src->R10;
8016bad8:	e51b300c 	ldr	r3, [fp, #-12]
8016badc:	e593202c 	ldr	r2, [r3, #44]	@ 0x2c
8016bae0:	e51b3008 	ldr	r3, [fp, #-8]
8016bae4:	e583202c 	str	r2, [r3, #44]	@ 0x2c
    Dst->R11=Src->R11;
8016bae8:	e51b300c 	ldr	r3, [fp, #-12]
8016baec:	e5932030 	ldr	r2, [r3, #48]	@ 0x30
8016baf0:	e51b3008 	ldr	r3, [fp, #-8]
8016baf4:	e5832030 	str	r2, [r3, #48]	@ 0x30
    Dst->SP=Src->SP;
8016baf8:	e51b300c 	ldr	r3, [fp, #-12]
8016bafc:	e5932034 	ldr	r2, [r3, #52]	@ 0x34
8016bb00:	e51b3008 	ldr	r3, [fp, #-8]
8016bb04:	e5832034 	str	r2, [r3, #52]	@ 0x34
    Dst->LR=Src->LR;
8016bb08:	e51b300c 	ldr	r3, [fp, #-12]
8016bb0c:	e5932038 	ldr	r2, [r3, #56]	@ 0x38
8016bb10:	e51b3008 	ldr	r3, [fp, #-8]
8016bb14:	e5832038 	str	r2, [r3, #56]	@ 0x38
    Dst->PC=Src->PC;
8016bb18:	e51b300c 	ldr	r3, [fp, #-12]
8016bb1c:	e593203c 	ldr	r2, [r3, #60]	@ 0x3c
8016bb20:	e51b3008 	ldr	r3, [fp, #-8]
8016bb24:	e583203c 	str	r2, [r3, #60]	@ 0x3c
}
8016bb28:	e320f000 	nop	{0}
8016bb2c:	e28bd000 	add	sp, fp, #0
8016bb30:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016bb34:	e12fff1e 	bx	lr

8016bb38 <__RME_Inv_Reg_Save>:
Input       : struct RME_Reg_Struct* Reg - The register set.
Output      : struct RME_Iret_Struct* Ret - The invocation return register context.
Return      : None.
******************************************************************************/
void __RME_Inv_Reg_Save(struct RME_Iret_Struct* Ret, struct RME_Reg_Struct* Reg)
{
8016bb38:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016bb3c:	e28db000 	add	fp, sp, #0
8016bb40:	e24dd00c 	sub	sp, sp, #12
8016bb44:	e50b0008 	str	r0, [fp, #-8]
8016bb48:	e50b100c 	str	r1, [fp, #-12]
    Ret->PC=Reg->PC;
8016bb4c:	e51b300c 	ldr	r3, [fp, #-12]
8016bb50:	e593203c 	ldr	r2, [r3, #60]	@ 0x3c
8016bb54:	e51b3008 	ldr	r3, [fp, #-8]
8016bb58:	e5832000 	str	r2, [r3]
    Ret->SP=Reg->SP;
8016bb5c:	e51b300c 	ldr	r3, [fp, #-12]
8016bb60:	e5932034 	ldr	r2, [r3, #52]	@ 0x34
8016bb64:	e51b3008 	ldr	r3, [fp, #-8]
8016bb68:	e5832004 	str	r2, [r3, #4]
}
8016bb6c:	e320f000 	nop	{0}
8016bb70:	e28bd000 	add	sp, fp, #0
8016bb74:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016bb78:	e12fff1e 	bx	lr

8016bb7c <__RME_Inv_Reg_Restore>:
Input       : struct RME_Iret_Struct* Ret - The invocation return register context.
Output      : struct RME_Reg_Struct* Reg - The register set.
Return      : None.
******************************************************************************/
void __RME_Inv_Reg_Restore(struct RME_Reg_Struct* Reg, struct RME_Iret_Struct* Ret)
{
8016bb7c:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016bb80:	e28db000 	add	fp, sp, #0
8016bb84:	e24dd00c 	sub	sp, sp, #12
8016bb88:	e50b0008 	str	r0, [fp, #-8]
8016bb8c:	e50b100c 	str	r1, [fp, #-12]
    Reg->PC=Ret->PC;
8016bb90:	e51b300c 	ldr	r3, [fp, #-12]
8016bb94:	e5932000 	ldr	r2, [r3]
8016bb98:	e51b3008 	ldr	r3, [fp, #-8]
8016bb9c:	e583203c 	str	r2, [r3, #60]	@ 0x3c
    Reg->SP=Ret->SP;
8016bba0:	e51b300c 	ldr	r3, [fp, #-12]
8016bba4:	e5932004 	ldr	r2, [r3, #4]
8016bba8:	e51b3008 	ldr	r3, [fp, #-8]
8016bbac:	e5832034 	str	r2, [r3, #52]	@ 0x34
}
8016bbb0:	e320f000 	nop	{0}
8016bbb4:	e28bd000 	add	sp, fp, #0
8016bbb8:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016bbbc:	e12fff1e 	bx	lr

8016bbc0 <__RME_Inv_Retval_Set>:
Output      : struct RME_Reg_Struct* Reg - The register set.
Return      : None.
******************************************************************************/
void __RME_Inv_Retval_Set(struct RME_Reg_Struct* Reg,
                          rme_ret_t Retval)
{
8016bbc0:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016bbc4:	e28db000 	add	fp, sp, #0
8016bbc8:	e24dd00c 	sub	sp, sp, #12
8016bbcc:	e50b0008 	str	r0, [fp, #-8]
8016bbd0:	e50b100c 	str	r1, [fp, #-12]
    Reg->R5=(rme_ptr_t)Retval;
8016bbd4:	e51b200c 	ldr	r2, [fp, #-12]
8016bbd8:	e51b3008 	ldr	r3, [fp, #-8]
8016bbdc:	e5832018 	str	r2, [r3, #24]
}
8016bbe0:	e320f000 	nop	{0}
8016bbe4:	e28bd000 	add	sp, fp, #0
8016bbe8:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016bbec:	e12fff1e 	bx	lr

8016bbf0 <__RME_Kfn_Handler>:
                                           struct RME_Reg_Struct* Reg,
                                           rme_ptr_t Func_ID,
                                           rme_ptr_t Sub_ID,
                                           rme_ptr_t Param1,
                                           rme_ptr_t Param2)
{
8016bbf0:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016bbf4:	e28db000 	add	fp, sp, #0
8016bbf8:	e24dd014 	sub	sp, sp, #20
8016bbfc:	e50b0008 	str	r0, [fp, #-8]
8016bc00:	e50b100c 	str	r1, [fp, #-12]
8016bc04:	e50b2010 	str	r2, [fp, #-16]
8016bc08:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
	/* Currently no kernel function implemented */
    return 0;
8016bc0c:	e3a03000 	mov	r3, #0
}
8016bc10:	e1a00003 	mov	r0, r3
8016bc14:	e28bd000 	add	sp, fp, #0
8016bc18:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016bc1c:	e12fff1e 	bx	lr

8016bc20 <__RME_A7A_Undefined_Handler>:
Input       : struct RME_Reg_Struct* Reg - The register set when entering the handler.
Output      : struct RME_Reg_Struct* Reg - The register set when exiting the handler.
Return      : None.
******************************************************************************/
void __RME_A7A_Undefined_Handler(struct RME_Reg_Struct* Reg)
{
8016bc20:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016bc24:	e28db000 	add	fp, sp, #0
8016bc28:	e24dd00c 	sub	sp, sp, #12
8016bc2c:	e50b0008 	str	r0, [fp, #-8]
	/* We don't handle undefined instructions now */
	while(1);
8016bc30:	eafffffe 	b	8016bc30 <__RME_A7A_Undefined_Handler+0x10>

8016bc34 <__RME_A7A_Prefetch_Abort_Handler>:
Input       : struct RME_Reg_Struct* Reg - The register set when entering the handler.
Output      : struct RME_Reg_Struct* Reg - The register set when exiting the handler.
Return      : None.
******************************************************************************/
void __RME_A7A_Prefetch_Abort_Handler(struct RME_Reg_Struct* Reg)
{
8016bc34:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016bc38:	e28db000 	add	fp, sp, #0
8016bc3c:	e24dd00c 	sub	sp, sp, #12
8016bc40:	e50b0008 	str	r0, [fp, #-8]
	/* We don't handle prefetch aborts now */
	while(1);
8016bc44:	eafffffe 	b	8016bc44 <__RME_A7A_Prefetch_Abort_Handler+0x10>

8016bc48 <__RME_A7A_Data_Abort_Handler>:
Input       : struct RME_Reg_Struct* Reg - The register set when entering the handler.
Output      : struct RME_Reg_Struct* Reg - The register set when exiting the handler.
Return      : None.
******************************************************************************/
void __RME_A7A_Data_Abort_Handler(struct RME_Reg_Struct* Reg)
{
8016bc48:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016bc4c:	e28db000 	add	fp, sp, #0
8016bc50:	e24dd00c 	sub	sp, sp, #12
8016bc54:	e50b0008 	str	r0, [fp, #-8]
	/* We don't handle data aborts now */
	while(1);
8016bc58:	eafffffe 	b	8016bc58 <__RME_A7A_Data_Abort_Handler+0x10>

8016bc5c <__RME_A7A_IRQ_Handler>:
Input       : struct RME_Reg_Struct* Reg - The register set when entering the handler.
Output      : struct RME_Reg_Struct* Reg - The register set when exiting the handler.
Return      : None.
******************************************************************************/
void __RME_A7A_IRQ_Handler(struct RME_Reg_Struct* Reg)
{
8016bc5c:	e92d4800 	push	{fp, lr}
8016bc60:	e28db004 	add	fp, sp, #4
8016bc64:	e24dd010 	sub	sp, sp, #16
8016bc68:	e50b0010 	str	r0, [fp, #-16]
	rme_ptr_t Int_ID;
	rme_ptr_t CPUID;

	/* What interrupt is this? */
	Int_ID=RME_A7A_GICC_IAR;
8016bc6c:	e3a03f43 	mov	r3, #268	@ 0x10c
8016bc70:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016bc74:	e5933000 	ldr	r3, [r3]
8016bc78:	e50b3008 	str	r3, [fp, #-8]
	CPUID=Int_ID>>10;
8016bc7c:	e51b3008 	ldr	r3, [fp, #-8]
8016bc80:	e1a03523 	lsr	r3, r3, #10
8016bc84:	e50b300c 	str	r3, [fp, #-12]
	Int_ID&=0x3FFU;
8016bc88:	e51b3008 	ldr	r3, [fp, #-8]
8016bc8c:	e7e93053 	ubfx	r3, r3, #0, #10
8016bc90:	e50b3008 	str	r3, [fp, #-8]
    RME_DBG_S("\r\nINT_ID is ");
8016bc94:	e30c04d8 	movw	r0, #50392	@ 0xc4d8
8016bc98:	e3480016 	movt	r0, #32790	@ 0x8016
8016bc9c:	ebffd399 	bl	80160b08 <RME_Str_Print>
	RME_DBG_I(Int_ID);
8016bca0:	e51b3008 	ldr	r3, [fp, #-8]
8016bca4:	e1a00003 	mov	r0, r3
8016bca8:	ebffd2f7 	bl	8016088c <RME_Int_Print>

#if(RME_A7A_GIC_TYPE==RME_A7A_GIC_V1)
	/* Is this a spurious interrupt? (Can't be 1022 because GICv1 don't have group1) */
	RME_ASSERT(Int_ID!=1022);
8016bcac:	e51b3008 	ldr	r3, [fp, #-8]
8016bcb0:	e30023fe 	movw	r2, #1022	@ 0x3fe
8016bcb4:	e1530002 	cmp	r3, r2
8016bcb8:	1a000008 	bne	8016bce0 <__RME_A7A_IRQ_Handler+0x84>
8016bcbc:	e30c34e8 	movw	r3, #50408	@ 0xc4e8
8016bcc0:	e3483016 	movt	r3, #32790	@ 0x8016
8016bcc4:	e30c24f4 	movw	r2, #50420	@ 0xc4f4
8016bcc8:	e3482016 	movt	r2, #32790	@ 0x8016
8016bccc:	e30012b6 	movw	r1, #694	@ 0x2b6
8016bcd0:	e30c0500 	movw	r0, #50432	@ 0xc500
8016bcd4:	e3480016 	movt	r0, #32790	@ 0x8016
8016bcd8:	ebffd3a9 	bl	80160b84 <RME_Log>
8016bcdc:	eafffffe 	b	8016bcdc <__RME_A7A_IRQ_Handler+0x80>
	if(Int_ID==1023)
8016bce0:	e51b3008 	ldr	r3, [fp, #-8]
8016bce4:	e30023ff 	movw	r2, #1023	@ 0x3ff
8016bce8:	e1530002 	cmp	r3, r2
8016bcec:	0a00003d 	beq	8016bde8 <__RME_A7A_IRQ_Handler+0x18c>
		return;
	/* Only the booting processor will receive timer interrupts */
#if((RME_A7A_CPU_TYPE==RME_A7A_CPU_CORTEX_A5)|| \
	(RME_A7A_CPU_TYPE==RME_A7A_CPU_CORTEX_A9))
	/* Is is an timer interrupt? (we know that it is at 29) */
	if(Int_ID==29)
8016bcf0:	e51b3008 	ldr	r3, [fp, #-8]
8016bcf4:	e353001d 	cmp	r3, #29
8016bcf8:	1a00000b 	bne	8016bd2c <__RME_A7A_IRQ_Handler+0xd0>
	{
		/* Clear the interrupt flag */
	    RME_A7A_PTWD_PTISR=0;
8016bcfc:	e300360c 	movw	r3, #1548	@ 0x60c
8016bd00:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016bd04:	e3a02000 	mov	r2, #0
8016bd08:	e5832000 	str	r2, [r3]
		//_RME_Tick_Handler(Reg);
	    _RME_Tim_Handler(Reg,1);
8016bd0c:	e3a01001 	mov	r1, #1
8016bd10:	e51b0010 	ldr	r0, [fp, #-16]
8016bd14:	ebffd697 	bl	80161778 <_RME_Tim_Handler>
		/* Send interrupt to all other processors to notify them about this */
		/* EOI the interrupt */
		RME_A7A_GICC_EOIR=Int_ID;
8016bd18:	e3a03e11 	mov	r3, #272	@ 0x110
8016bd1c:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016bd20:	e51b2008 	ldr	r2, [fp, #-8]
8016bd24:	e5832000 	str	r2, [r3]
		return;
8016bd28:	ea00002f 	b	8016bdec <__RME_A7A_IRQ_Handler+0x190>

#else

#endif
	/* Is this a coprocessor timer interrupt? (We use interrupt number 0 for these) */
	if(Int_ID==0)
8016bd2c:	e51b3008 	ldr	r3, [fp, #-8]
8016bd30:	e3530000 	cmp	r3, #0
8016bd34:	1a000010 	bne	8016bd7c <__RME_A7A_IRQ_Handler+0x120>
	{
		/* This must have originated from interface 0 */
		RME_ASSERT(CPUID==0);
8016bd38:	e51b300c 	ldr	r3, [fp, #-12]
8016bd3c:	e3530000 	cmp	r3, #0
8016bd40:	0a000008 	beq	8016bd68 <__RME_A7A_IRQ_Handler+0x10c>
8016bd44:	e30c34e8 	movw	r3, #50408	@ 0xc4e8
8016bd48:	e3483016 	movt	r3, #32790	@ 0x8016
8016bd4c:	e30c24f4 	movw	r2, #50420	@ 0xc4f4
8016bd50:	e3482016 	movt	r2, #32790	@ 0x8016
8016bd54:	e30012d3 	movw	r1, #723	@ 0x2d3
8016bd58:	e30c0500 	movw	r0, #50432	@ 0xc500
8016bd5c:	e3480016 	movt	r0, #32790	@ 0x8016
8016bd60:	ebffd387 	bl	80160b84 <RME_Log>
8016bd64:	eafffffe 	b	8016bd64 <__RME_A7A_IRQ_Handler+0x108>
		//_RME_Tick_SMP_Handler(Reg);
		/* EOI the interrupt */
		RME_A7A_GICC_EOIR=Int_ID;
8016bd68:	e3a03e11 	mov	r3, #272	@ 0x110
8016bd6c:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016bd70:	e51b2008 	ldr	r2, [fp, #-8]
8016bd74:	e5832000 	str	r2, [r3]
		return;
8016bd78:	ea00001b 	b	8016bdec <__RME_A7A_IRQ_Handler+0x190>
	}

	/* Is this an other IPI? (All the rest of the SGIs are these) */
	if(Int_ID<16)
8016bd7c:	e51b3008 	ldr	r3, [fp, #-8]
8016bd80:	e353000f 	cmp	r3, #15
8016bd84:	8a00000b 	bhi	8016bdb8 <__RME_A7A_IRQ_Handler+0x15c>
	{
		_RME_A7A_SGI_Handler(Reg,CPUID,Int_ID);
8016bd88:	e51b2008 	ldr	r2, [fp, #-8]
8016bd8c:	e51b100c 	ldr	r1, [fp, #-12]
8016bd90:	e51b0010 	ldr	r0, [fp, #-16]
8016bd94:	eb000016 	bl	8016bdf4 <_RME_A7A_SGI_Handler>
		/* EOI the interrupt */
		RME_A7A_GICC_EOIR=(CPUID<<10U)|Int_ID;
8016bd98:	e51b300c 	ldr	r3, [fp, #-12]
8016bd9c:	e1a01503 	lsl	r1, r3, #10
8016bda0:	e3a03e11 	mov	r3, #272	@ 0x110
8016bda4:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016bda8:	e51b2008 	ldr	r2, [fp, #-8]
8016bdac:	e1812002 	orr	r2, r1, r2
8016bdb0:	e5832000 	str	r2, [r3]
		return;
8016bdb4:	ea00000c 	b	8016bdec <__RME_A7A_IRQ_Handler+0x190>
	}

	/* Is this an casual interrupt? */
	RME_ASSERT(CPUID==0);
8016bdb8:	e51b300c 	ldr	r3, [fp, #-12]
8016bdbc:	e3530000 	cmp	r3, #0
8016bdc0:	0a000009 	beq	8016bdec <__RME_A7A_IRQ_Handler+0x190>
8016bdc4:	e30c34e8 	movw	r3, #50408	@ 0xc4e8
8016bdc8:	e3483016 	movt	r3, #32790	@ 0x8016
8016bdcc:	e30c24f4 	movw	r2, #50420	@ 0xc4f4
8016bdd0:	e3482016 	movt	r2, #32790	@ 0x8016
8016bdd4:	e3a01fb9 	mov	r1, #740	@ 0x2e4
8016bdd8:	e30c0500 	movw	r0, #50432	@ 0xc500
8016bddc:	e3480016 	movt	r0, #32790	@ 0x8016
8016bde0:	ebffd367 	bl	80160b84 <RME_Log>
8016bde4:	eafffffe 	b	8016bde4 <__RME_A7A_IRQ_Handler+0x188>
		return;
8016bde8:	e320f000 	nop	{0}

}
8016bdec:	e24bd004 	sub	sp, fp, #4
8016bdf0:	e8bd8800 	pop	{fp, pc}

8016bdf4 <_RME_A7A_SGI_Handler>:
              rme_ptr_t Int_ID - The ID of the SGI.
Output      : struct RME_Reg_Struct* Reg - The register set when exiting the handler.
Return      : None.
******************************************************************************/
void _RME_A7A_SGI_Handler(struct RME_Reg_Struct* Reg, rme_ptr_t CPUID, rme_ptr_t Int_ID)
{
8016bdf4:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016bdf8:	e28db000 	add	fp, sp, #0
8016bdfc:	e24dd014 	sub	sp, sp, #20
8016be00:	e50b0008 	str	r0, [fp, #-8]
8016be04:	e50b100c 	str	r1, [fp, #-12]
8016be08:	e50b2010 	str	r2, [fp, #-16]
	/* Not handling SGIs */
	return;
8016be0c:	e320f000 	nop	{0}
}
8016be10:	e28bd000 	add	sp, fp, #0
8016be14:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016be18:	e12fff1e 	bx	lr

8016be1c <__RME_Pgt_Set>:
Input       : rme_ptr_t Pgt - The virtual address of the page table.
Output      : None.
Return      : None.
******************************************************************************/
void __RME_Pgt_Set(rme_ptr_t Pgt)
{
8016be1c:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016be20:	e28db000 	add	fp, sp, #0
8016be24:	e24dd00c 	sub	sp, sp, #12
8016be28:	e50b0008 	str	r0, [fp, #-8]

}
8016be2c:	e320f000 	nop	{0}
8016be30:	e28bd000 	add	sp, fp, #0
8016be34:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016be38:	e12fff1e 	bx	lr

8016be3c <__RME_Pgt_Check>:
Output      : None.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Check(rme_ptr_t Start_Addr, rme_ptr_t Is_Top,
                            rme_ptr_t Size_Order, rme_ptr_t Num_Order, rme_ptr_t Vaddr)
{
8016be3c:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016be40:	e28db000 	add	fp, sp, #0
8016be44:	e24dd014 	sub	sp, sp, #20
8016be48:	e50b0008 	str	r0, [fp, #-8]
8016be4c:	e50b100c 	str	r1, [fp, #-12]
8016be50:	e50b2010 	str	r2, [fp, #-16]
8016be54:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    /* Top-level - 1MB pages, 4096 entries, 16kB alignment */
    if(Is_Top!=0)
8016be58:	e51b300c 	ldr	r3, [fp, #-12]
8016be5c:	e3530000 	cmp	r3, #0
8016be60:	0a00000f 	beq	8016bea4 <__RME_Pgt_Check+0x68>
    {
        if(Size_Order!=RME_PGT_SIZE_1M)
8016be64:	e51b3010 	ldr	r3, [fp, #-16]
8016be68:	e3530014 	cmp	r3, #20
8016be6c:	0a000001 	beq	8016be78 <__RME_Pgt_Check+0x3c>
            return RME_ERR_HAL_FAIL;
8016be70:	e3e03000 	mvn	r3, #0
8016be74:	ea00001b 	b	8016bee8 <__RME_Pgt_Check+0xac>
        if(Num_Order!=RME_PGT_NUM_4K)
8016be78:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016be7c:	e353000c 	cmp	r3, #12
8016be80:	0a000001 	beq	8016be8c <__RME_Pgt_Check+0x50>
            return RME_ERR_HAL_FAIL;
8016be84:	e3e03000 	mvn	r3, #0
8016be88:	ea000016 	b	8016bee8 <__RME_Pgt_Check+0xac>
        if((Vaddr&0x3FFF)!=0)
8016be8c:	e59b3004 	ldr	r3, [fp, #4]
8016be90:	e7ed3053 	ubfx	r3, r3, #0, #14
8016be94:	e3530000 	cmp	r3, #0
8016be98:	0a000011 	beq	8016bee4 <__RME_Pgt_Check+0xa8>
            return RME_ERR_HAL_FAIL;
8016be9c:	e3e03000 	mvn	r3, #0
8016bea0:	ea000010 	b	8016bee8 <__RME_Pgt_Check+0xac>
    }
    /* Second-level - 1MB pages, 4096 entries, 16kB alignment */
    else
    {
        if(Size_Order!=RME_PGT_SIZE_64K)
8016bea4:	e51b3010 	ldr	r3, [fp, #-16]
8016bea8:	e3530010 	cmp	r3, #16
8016beac:	0a000001 	beq	8016beb8 <__RME_Pgt_Check+0x7c>
            return RME_ERR_HAL_FAIL;
8016beb0:	e3e03000 	mvn	r3, #0
8016beb4:	ea00000b 	b	8016bee8 <__RME_Pgt_Check+0xac>
        if(Num_Order!=RME_PGT_NUM_1K)
8016beb8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016bebc:	e353000a 	cmp	r3, #10
8016bec0:	0a000001 	beq	8016becc <__RME_Pgt_Check+0x90>
            return RME_ERR_HAL_FAIL;
8016bec4:	e3e03000 	mvn	r3, #0
8016bec8:	ea000006 	b	8016bee8 <__RME_Pgt_Check+0xac>
        if((Vaddr&0x3FF)!=0)
8016becc:	e59b3004 	ldr	r3, [fp, #4]
8016bed0:	e7e93053 	ubfx	r3, r3, #0, #10
8016bed4:	e3530000 	cmp	r3, #0
8016bed8:	0a000001 	beq	8016bee4 <__RME_Pgt_Check+0xa8>
            return RME_ERR_HAL_FAIL;
8016bedc:	e3e03000 	mvn	r3, #0
8016bee0:	ea000000 	b	8016bee8 <__RME_Pgt_Check+0xac>
    }

    return 0;
8016bee4:	e3a03000 	mov	r3, #0
}
8016bee8:	e1a00003 	mov	r0, r3
8016beec:	e28bd000 	add	sp, fp, #0
8016bef0:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016bef4:	e12fff1e 	bx	lr

8016bef8 <__RME_Pgt_Init>:
Input       : struct RME_Cap_Pgt* - The capability to the page table to operate on.
Output      : None.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Init(struct RME_Cap_Pgt* Pgt_Op)
{
8016bef8:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016befc:	e28db000 	add	fp, sp, #0
8016bf00:	e24dd00c 	sub	sp, sp, #12
8016bf04:	e50b0008 	str	r0, [fp, #-8]

    RME_A7A_PGREG_POS(Ptr).Parent_Cnt=0;
    RME_A7A_PGREG_POS(Ptr).ASID_Child_Cnt=0;
    return 0;
#endif
}
8016bf08:	e320f000 	nop	{0}
8016bf0c:	e1a00003 	mov	r0, r3
8016bf10:	e28bd000 	add	sp, fp, #0
8016bf14:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016bf18:	e12fff1e 	bx	lr

8016bf1c <__RME_Pgt_Del_Check>:
Input       : struct RME_Cap_Pgt Pgt_Op* - The capability to the page table to operate on.
Output      : None.
Return      : rme_ptr_t - If can be deleted, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Del_Check(struct RME_Cap_Pgt* Pgt_Op)
{
8016bf1c:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016bf20:	e28db000 	add	fp, sp, #0
8016bf24:	e24dd00c 	sub	sp, sp, #12
8016bf28:	e50b0008 	str	r0, [fp, #-8]
    	        return 0;
    }

    return RME_ERR_HAL_FAIL;
    #endif
}
8016bf2c:	e320f000 	nop	{0}
8016bf30:	e1a00003 	mov	r0, r3
8016bf34:	e28bd000 	add	sp, fp, #0
8016bf38:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016bf3c:	e12fff1e 	bx	lr

8016bf40 <__RME_Pgt_Page_Map>:
                                them into architecture specific page table's settings.
Output      : None.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Page_Map(struct RME_Cap_Pgt* Pgt_Op, rme_ptr_t Paddr, rme_ptr_t Pos, rme_ptr_t Flags)
{
8016bf40:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016bf44:	e28db000 	add	fp, sp, #0
8016bf48:	e24dd014 	sub	sp, sp, #20
8016bf4c:	e50b0008 	str	r0, [fp, #-8]
8016bf50:	e50b100c 	str	r1, [fp, #-12]
8016bf54:	e50b2010 	str	r2, [fp, #-16]
8016bf58:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    if(RME_COMP_SWAP(&(Table[Pos]),0,A7A_Flags)==0)
        return RME_ERR_HAL_FAIL;

    return 0;
    #endif
}
8016bf5c:	e320f000 	nop	{0}
8016bf60:	e1a00003 	mov	r0, r3
8016bf64:	e28bd000 	add	sp, fp, #0
8016bf68:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016bf6c:	e12fff1e 	bx	lr

8016bf70 <__RME_Pgt_Page_Unmap>:
              rme_ptr_t Pos - The position in the page table.
Output      : None.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Page_Unmap(struct RME_Cap_Pgt* Pgt_Op, rme_ptr_t Pos)
{
8016bf70:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016bf74:	e28db000 	add	fp, sp, #0
8016bf78:	e24dd00c 	sub	sp, sp, #12
8016bf7c:	e50b0008 	str	r0, [fp, #-8]
8016bf80:	e50b100c 	str	r1, [fp, #-12]
    if(RME_COMP_SWAP(&(Table[Pos]),Temp,0)==0)
        return RME_ERR_HAL_FAIL;

    return 0;
    #endif
}
8016bf84:	e320f000 	nop	{0}
8016bf88:	e1a00003 	mov	r0, r3
8016bf8c:	e28bd000 	add	sp, fp, #0
8016bf90:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016bf94:	e12fff1e 	bx	lr

8016bf98 <__RME_Pgt_Pgdir_Map>:
Output      : None.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Pgdir_Map(struct RME_Cap_Pgt* Pgt_Parent, rme_ptr_t Pos,
                                struct RME_Cap_Pgt* Pgt_Child, rme_ptr_t Flags)
{
8016bf98:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016bf9c:	e28db000 	add	fp, sp, #0
8016bfa0:	e24dd014 	sub	sp, sp, #20
8016bfa4:	e50b0008 	str	r0, [fp, #-8]
8016bfa8:	e50b100c 	str	r1, [fp, #-12]
8016bfac:	e50b2010 	str	r2, [fp, #-16]
8016bfb0:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    RME_FETCH_ADD((rme_ptr_t*)&(RME_A7A_PGREG_POS(Child_Table).Parent_Cnt),1);
    RME_FETCH_ADD((rme_ptr_t*)&(RME_A7A_PGREG_POS(Parent_Table).ASID_Child_Cnt),1);

    return 0;
    #endif
}
8016bfb4:	e320f000 	nop	{0}
8016bfb8:	e1a00003 	mov	r0, r3
8016bfbc:	e28bd000 	add	sp, fp, #0
8016bfc0:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016bfc4:	e12fff1e 	bx	lr

8016bfc8 <__RME_Pgt_Pgdir_Unmap>:
Output      : None.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ret_t __RME_Pgt_Pgdir_Unmap(struct RME_Cap_Pgt* Pgt_Parent,rme_ptr_t Pos,
                                               struct RME_Cap_Pgt* Pgt_Child)
{
8016bfc8:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016bfcc:	e28db000 	add	fp, sp, #0
8016bfd0:	e24dd014 	sub	sp, sp, #20
8016bfd4:	e50b0008 	str	r0, [fp, #-8]
8016bfd8:	e50b100c 	str	r1, [fp, #-12]
8016bfdc:	e50b2010 	str	r2, [fp, #-16]
   return 0;
8016bfe0:	e3a03000 	mov	r3, #0
}
8016bfe4:	e1a00003 	mov	r0, r3
8016bfe8:	e28bd000 	add	sp, fp, #0
8016bfec:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016bff0:	e12fff1e 	bx	lr

8016bff4 <__RME_Pgt_Lookup>:
Output      : rme_ptr_t* Paddr - The physical address of the page.
              rme_ptr_t* Flags - The RME standard flags of the page.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Lookup(struct RME_Cap_Pgt* Pgt_Op, rme_ptr_t Pos, rme_ptr_t* Paddr, rme_ptr_t* Flags)
{
8016bff4:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016bff8:	e28db000 	add	fp, sp, #0
8016bffc:	e24dd014 	sub	sp, sp, #20
8016c000:	e50b0008 	str	r0, [fp, #-8]
8016c004:	e50b100c 	str	r1, [fp, #-12]
8016c008:	e50b2010 	str	r2, [fp, #-16]
8016c00c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
            *Flags=RME_A7A_PGFLG_1M_NAT2RME(Temp);
    }

    return 0;
    #endif
}
8016c010:	e320f000 	nop	{0}
8016c014:	e1a00003 	mov	r0, r3
8016c018:	e28bd000 	add	sp, fp, #0
8016c01c:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016c020:	e12fff1e 	bx	lr
8016c024:	00000000 	andeq	r0, r0, r0

8016c028 <__divsi3>:
8016c028:	2900      	cmp	r1, #0
8016c02a:	f000 813e 	beq.w	8016c2aa <.divsi3_skip_div0_test+0x27c>

8016c02e <.divsi3_skip_div0_test>:
8016c02e:	ea80 0c01 	eor.w	ip, r0, r1
8016c032:	bf48      	it	mi
8016c034:	4249      	negmi	r1, r1
8016c036:	1e4a      	subs	r2, r1, #1
8016c038:	f000 811f 	beq.w	8016c27a <.divsi3_skip_div0_test+0x24c>
8016c03c:	0003      	movs	r3, r0
8016c03e:	bf48      	it	mi
8016c040:	4243      	negmi	r3, r0
8016c042:	428b      	cmp	r3, r1
8016c044:	f240 811e 	bls.w	8016c284 <.divsi3_skip_div0_test+0x256>
8016c048:	4211      	tst	r1, r2
8016c04a:	f000 8123 	beq.w	8016c294 <.divsi3_skip_div0_test+0x266>
8016c04e:	fab3 f283 	clz	r2, r3
8016c052:	fab1 f081 	clz	r0, r1
8016c056:	eba0 0202 	sub.w	r2, r0, r2
8016c05a:	f1c2 021f 	rsb	r2, r2, #31
8016c05e:	a004      	add	r0, pc, #16	@ (adr r0, 8016c070 <.divsi3_skip_div0_test+0x42>)
8016c060:	eb00 1202 	add.w	r2, r0, r2, lsl #4
8016c064:	f04f 0000 	mov.w	r0, #0
8016c068:	4697      	mov	pc, r2
8016c06a:	bf00      	nop
8016c06c:	f3af 8000 	nop.w
8016c070:	ebb3 7fc1 	cmp.w	r3, r1, lsl #31
8016c074:	bf00      	nop
8016c076:	eb40 0000 	adc.w	r0, r0, r0
8016c07a:	bf28      	it	cs
8016c07c:	eba3 73c1 	subcs.w	r3, r3, r1, lsl #31
8016c080:	ebb3 7f81 	cmp.w	r3, r1, lsl #30
8016c084:	bf00      	nop
8016c086:	eb40 0000 	adc.w	r0, r0, r0
8016c08a:	bf28      	it	cs
8016c08c:	eba3 7381 	subcs.w	r3, r3, r1, lsl #30
8016c090:	ebb3 7f41 	cmp.w	r3, r1, lsl #29
8016c094:	bf00      	nop
8016c096:	eb40 0000 	adc.w	r0, r0, r0
8016c09a:	bf28      	it	cs
8016c09c:	eba3 7341 	subcs.w	r3, r3, r1, lsl #29
8016c0a0:	ebb3 7f01 	cmp.w	r3, r1, lsl #28
8016c0a4:	bf00      	nop
8016c0a6:	eb40 0000 	adc.w	r0, r0, r0
8016c0aa:	bf28      	it	cs
8016c0ac:	eba3 7301 	subcs.w	r3, r3, r1, lsl #28
8016c0b0:	ebb3 6fc1 	cmp.w	r3, r1, lsl #27
8016c0b4:	bf00      	nop
8016c0b6:	eb40 0000 	adc.w	r0, r0, r0
8016c0ba:	bf28      	it	cs
8016c0bc:	eba3 63c1 	subcs.w	r3, r3, r1, lsl #27
8016c0c0:	ebb3 6f81 	cmp.w	r3, r1, lsl #26
8016c0c4:	bf00      	nop
8016c0c6:	eb40 0000 	adc.w	r0, r0, r0
8016c0ca:	bf28      	it	cs
8016c0cc:	eba3 6381 	subcs.w	r3, r3, r1, lsl #26
8016c0d0:	ebb3 6f41 	cmp.w	r3, r1, lsl #25
8016c0d4:	bf00      	nop
8016c0d6:	eb40 0000 	adc.w	r0, r0, r0
8016c0da:	bf28      	it	cs
8016c0dc:	eba3 6341 	subcs.w	r3, r3, r1, lsl #25
8016c0e0:	ebb3 6f01 	cmp.w	r3, r1, lsl #24
8016c0e4:	bf00      	nop
8016c0e6:	eb40 0000 	adc.w	r0, r0, r0
8016c0ea:	bf28      	it	cs
8016c0ec:	eba3 6301 	subcs.w	r3, r3, r1, lsl #24
8016c0f0:	ebb3 5fc1 	cmp.w	r3, r1, lsl #23
8016c0f4:	bf00      	nop
8016c0f6:	eb40 0000 	adc.w	r0, r0, r0
8016c0fa:	bf28      	it	cs
8016c0fc:	eba3 53c1 	subcs.w	r3, r3, r1, lsl #23
8016c100:	ebb3 5f81 	cmp.w	r3, r1, lsl #22
8016c104:	bf00      	nop
8016c106:	eb40 0000 	adc.w	r0, r0, r0
8016c10a:	bf28      	it	cs
8016c10c:	eba3 5381 	subcs.w	r3, r3, r1, lsl #22
8016c110:	ebb3 5f41 	cmp.w	r3, r1, lsl #21
8016c114:	bf00      	nop
8016c116:	eb40 0000 	adc.w	r0, r0, r0
8016c11a:	bf28      	it	cs
8016c11c:	eba3 5341 	subcs.w	r3, r3, r1, lsl #21
8016c120:	ebb3 5f01 	cmp.w	r3, r1, lsl #20
8016c124:	bf00      	nop
8016c126:	eb40 0000 	adc.w	r0, r0, r0
8016c12a:	bf28      	it	cs
8016c12c:	eba3 5301 	subcs.w	r3, r3, r1, lsl #20
8016c130:	ebb3 4fc1 	cmp.w	r3, r1, lsl #19
8016c134:	bf00      	nop
8016c136:	eb40 0000 	adc.w	r0, r0, r0
8016c13a:	bf28      	it	cs
8016c13c:	eba3 43c1 	subcs.w	r3, r3, r1, lsl #19
8016c140:	ebb3 4f81 	cmp.w	r3, r1, lsl #18
8016c144:	bf00      	nop
8016c146:	eb40 0000 	adc.w	r0, r0, r0
8016c14a:	bf28      	it	cs
8016c14c:	eba3 4381 	subcs.w	r3, r3, r1, lsl #18
8016c150:	ebb3 4f41 	cmp.w	r3, r1, lsl #17
8016c154:	bf00      	nop
8016c156:	eb40 0000 	adc.w	r0, r0, r0
8016c15a:	bf28      	it	cs
8016c15c:	eba3 4341 	subcs.w	r3, r3, r1, lsl #17
8016c160:	ebb3 4f01 	cmp.w	r3, r1, lsl #16
8016c164:	bf00      	nop
8016c166:	eb40 0000 	adc.w	r0, r0, r0
8016c16a:	bf28      	it	cs
8016c16c:	eba3 4301 	subcs.w	r3, r3, r1, lsl #16
8016c170:	ebb3 3fc1 	cmp.w	r3, r1, lsl #15
8016c174:	bf00      	nop
8016c176:	eb40 0000 	adc.w	r0, r0, r0
8016c17a:	bf28      	it	cs
8016c17c:	eba3 33c1 	subcs.w	r3, r3, r1, lsl #15
8016c180:	ebb3 3f81 	cmp.w	r3, r1, lsl #14
8016c184:	bf00      	nop
8016c186:	eb40 0000 	adc.w	r0, r0, r0
8016c18a:	bf28      	it	cs
8016c18c:	eba3 3381 	subcs.w	r3, r3, r1, lsl #14
8016c190:	ebb3 3f41 	cmp.w	r3, r1, lsl #13
8016c194:	bf00      	nop
8016c196:	eb40 0000 	adc.w	r0, r0, r0
8016c19a:	bf28      	it	cs
8016c19c:	eba3 3341 	subcs.w	r3, r3, r1, lsl #13
8016c1a0:	ebb3 3f01 	cmp.w	r3, r1, lsl #12
8016c1a4:	bf00      	nop
8016c1a6:	eb40 0000 	adc.w	r0, r0, r0
8016c1aa:	bf28      	it	cs
8016c1ac:	eba3 3301 	subcs.w	r3, r3, r1, lsl #12
8016c1b0:	ebb3 2fc1 	cmp.w	r3, r1, lsl #11
8016c1b4:	bf00      	nop
8016c1b6:	eb40 0000 	adc.w	r0, r0, r0
8016c1ba:	bf28      	it	cs
8016c1bc:	eba3 23c1 	subcs.w	r3, r3, r1, lsl #11
8016c1c0:	ebb3 2f81 	cmp.w	r3, r1, lsl #10
8016c1c4:	bf00      	nop
8016c1c6:	eb40 0000 	adc.w	r0, r0, r0
8016c1ca:	bf28      	it	cs
8016c1cc:	eba3 2381 	subcs.w	r3, r3, r1, lsl #10
8016c1d0:	ebb3 2f41 	cmp.w	r3, r1, lsl #9
8016c1d4:	bf00      	nop
8016c1d6:	eb40 0000 	adc.w	r0, r0, r0
8016c1da:	bf28      	it	cs
8016c1dc:	eba3 2341 	subcs.w	r3, r3, r1, lsl #9
8016c1e0:	ebb3 2f01 	cmp.w	r3, r1, lsl #8
8016c1e4:	bf00      	nop
8016c1e6:	eb40 0000 	adc.w	r0, r0, r0
8016c1ea:	bf28      	it	cs
8016c1ec:	eba3 2301 	subcs.w	r3, r3, r1, lsl #8
8016c1f0:	ebb3 1fc1 	cmp.w	r3, r1, lsl #7
8016c1f4:	bf00      	nop
8016c1f6:	eb40 0000 	adc.w	r0, r0, r0
8016c1fa:	bf28      	it	cs
8016c1fc:	eba3 13c1 	subcs.w	r3, r3, r1, lsl #7
8016c200:	ebb3 1f81 	cmp.w	r3, r1, lsl #6
8016c204:	bf00      	nop
8016c206:	eb40 0000 	adc.w	r0, r0, r0
8016c20a:	bf28      	it	cs
8016c20c:	eba3 1381 	subcs.w	r3, r3, r1, lsl #6
8016c210:	ebb3 1f41 	cmp.w	r3, r1, lsl #5
8016c214:	bf00      	nop
8016c216:	eb40 0000 	adc.w	r0, r0, r0
8016c21a:	bf28      	it	cs
8016c21c:	eba3 1341 	subcs.w	r3, r3, r1, lsl #5
8016c220:	ebb3 1f01 	cmp.w	r3, r1, lsl #4
8016c224:	bf00      	nop
8016c226:	eb40 0000 	adc.w	r0, r0, r0
8016c22a:	bf28      	it	cs
8016c22c:	eba3 1301 	subcs.w	r3, r3, r1, lsl #4
8016c230:	ebb3 0fc1 	cmp.w	r3, r1, lsl #3
8016c234:	bf00      	nop
8016c236:	eb40 0000 	adc.w	r0, r0, r0
8016c23a:	bf28      	it	cs
8016c23c:	eba3 03c1 	subcs.w	r3, r3, r1, lsl #3
8016c240:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
8016c244:	bf00      	nop
8016c246:	eb40 0000 	adc.w	r0, r0, r0
8016c24a:	bf28      	it	cs
8016c24c:	eba3 0381 	subcs.w	r3, r3, r1, lsl #2
8016c250:	ebb3 0f41 	cmp.w	r3, r1, lsl #1
8016c254:	bf00      	nop
8016c256:	eb40 0000 	adc.w	r0, r0, r0
8016c25a:	bf28      	it	cs
8016c25c:	eba3 0341 	subcs.w	r3, r3, r1, lsl #1
8016c260:	ebb3 0f01 	cmp.w	r3, r1
8016c264:	bf00      	nop
8016c266:	eb40 0000 	adc.w	r0, r0, r0
8016c26a:	bf28      	it	cs
8016c26c:	eba3 0301 	subcs.w	r3, r3, r1
8016c270:	f1bc 0f00 	cmp.w	ip, #0
8016c274:	bf48      	it	mi
8016c276:	4240      	negmi	r0, r0
8016c278:	4770      	bx	lr
8016c27a:	ea9c 0f00 	teq	ip, r0
8016c27e:	bf48      	it	mi
8016c280:	4240      	negmi	r0, r0
8016c282:	4770      	bx	lr
8016c284:	bf38      	it	cc
8016c286:	2000      	movcc	r0, #0
8016c288:	bf04      	itt	eq
8016c28a:	ea4f 70ec 	moveq.w	r0, ip, asr #31
8016c28e:	f040 0001 	orreq.w	r0, r0, #1
8016c292:	4770      	bx	lr
8016c294:	fab1 f281 	clz	r2, r1
8016c298:	f1c2 021f 	rsb	r2, r2, #31
8016c29c:	f1bc 0f00 	cmp.w	ip, #0
8016c2a0:	fa23 f002 	lsr.w	r0, r3, r2
8016c2a4:	bf48      	it	mi
8016c2a6:	4240      	negmi	r0, r0
8016c2a8:	4770      	bx	lr
8016c2aa:	2800      	cmp	r0, #0
8016c2ac:	bfc8      	it	gt
8016c2ae:	f06f 4000 	mvngt.w	r0, #2147483648	@ 0x80000000
8016c2b2:	bfb8      	it	lt
8016c2b4:	f04f 4000 	movlt.w	r0, #2147483648	@ 0x80000000
8016c2b8:	f000 b80e 	b.w	8016c2d8 <__aeabi_idiv0>

8016c2bc <__aeabi_idivmod>:
8016c2bc:	2900      	cmp	r1, #0
8016c2be:	d0f4      	beq.n	8016c2aa <.divsi3_skip_div0_test+0x27c>
8016c2c0:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
8016c2c4:	f7ff feb3 	bl	8016c02e <.divsi3_skip_div0_test>
8016c2c8:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
8016c2cc:	fb02 f300 	mul.w	r3, r2, r0
8016c2d0:	eba1 0103 	sub.w	r1, r1, r3
8016c2d4:	4770      	bx	lr
8016c2d6:	bf00      	nop

8016c2d8 <__aeabi_idiv0>:
8016c2d8:	4770      	bx	lr
8016c2da:	bf00      	nop
