
RME.elf:     file format elf32-littlearm


Disassembly of section .text:

80100000 <_start>:
    .global             __bss_end__
    .global             __va_offset__
    .global             main
_start:
    .global             _start
    LDR                 R0,=__bss_start__
80100000:	e59f01b0 	ldr	r0, [pc, #432]	@ 801001b8 <finish+0x20>
    LDR                 R1,=__bss_end__
80100004:	e59f11b0 	ldr	r1, [pc, #432]	@ 801001bc <finish+0x24>
    LDR                 R2,=__va_offset__
80100008:	e59f21b0 	ldr	r2, [pc, #432]	@ 801001c0 <finish+0x28>
    SUB                 R0,R0,R2
8010000c:	e0400002 	sub	r0, r0, r2
    SUB                 R1,R1,R2
80100010:	e0411002 	sub	r1, r1, r2
    LDR                 R2,=0x00        
80100014:	e3a02000 	mov	r2, #0

80100018 <clear_bss>:
clear_bss:
    CMP                 R0,R1
80100018:	e1500001 	cmp	r0, r1
    BEQ                 clear_done
8010001c:	0a000002 	beq	8010002c <clear_done>
    STR                 R2,[R0]
80100020:	e5802000 	str	r2, [r0]
    ADD                 R0,#0x04
80100024:	e2800004 	add	r0, r0, #4
    B                   clear_bss
80100028:	eafffffa 	b	80100018 <clear_bss>

8010002c <clear_done>:
clear_done:
    /* Set stacks for all modes */
    LDR                 R4,=__RME_A7A_Stack_Start
8010002c:	e59f4190 	ldr	r4, [pc, #400]	@ 801001c4 <finish+0x2c>
    ADD                 R4,#0x10000
80100030:	e2844801 	add	r4, r4, #65536	@ 0x10000
    /* IRQ mode */
    LDR                 R0,=0x600F00D2
80100034:	e59f018c 	ldr	r0, [pc, #396]	@ 801001c8 <finish+0x30>
    MSR                 CPSR,R0
80100038:	e129f000 	msr	CPSR_fc, r0
    MOV                 SP,R4
8010003c:	e1a0d004 	mov	sp, r4
    /* ABT mode */
    LDR                 R0,=0x600F00D7
80100040:	e59f0184 	ldr	r0, [pc, #388]	@ 801001cc <finish+0x34>
    MSR                 CPSR,R0
80100044:	e129f000 	msr	CPSR_fc, r0
    MOV                 SP,R4
80100048:	e1a0d004 	mov	sp, r4
    /* FIQ mode */
    LDR                 R0,=0x600F00D1
8010004c:	e59f017c 	ldr	r0, [pc, #380]	@ 801001d0 <finish+0x38>
    MSR                 CPSR,R0
80100050:	e129f000 	msr	CPSR_fc, r0
    MOV                 SP,R4
80100054:	e1a0d004 	mov	sp, r4
    /* UND mode */
    LDR                 R0,=0x600F00DB
80100058:	e59f0174 	ldr	r0, [pc, #372]	@ 801001d4 <finish+0x3c>
    MSR                 CPSR,R0
8010005c:	e129f000 	msr	CPSR_fc, r0
    MOV                 SP,R4
80100060:	e1a0d004 	mov	sp, r4
    /* SYS mode */
    LDR                 R0,=0x600F00DB
80100064:	e59f0168 	ldr	r0, [pc, #360]	@ 801001d4 <finish+0x3c>
    MSR                 CPSR,R0
80100068:	e129f000 	msr	CPSR_fc, r0
    MOV                 SP,R4
8010006c:	e1a0d004 	mov	sp, r4
    /* SVC mode */
    LDR                 R0,=0x600F00D3
80100070:	e59f0160 	ldr	r0, [pc, #352]	@ 801001d8 <finish+0x40>
    MSR                 CPSR,R0
80100074:	e129f000 	msr	CPSR_fc, r0
    MOV                 SP,R4
80100078:	e1a0d004 	mov	sp, r4

    /* Turn off the MMU and all cache if it is already enabled. There's no need
     * to turn cache off because we are not modifying the instruction stream at
     * all; the TLB walker will start walking from L1D if it is enabled */
    CP15_GET_INIT       CRN=C1 OP1=0 CRM=C0 OP2=0   //08C5187A off, 08C5187F on
8010007c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    LDR                 R1,=~((1<<2)|(1<<0))
80100080:	e3e01005 	mvn	r1, #5
    AND                 R0,R0,R1
80100084:	e0000001 	and	r0, r0, r1
    CP15_SET_INIT       CRN=C1 OP1=0 CRM=C0 OP2=0 /* SCTLR.AFE,TRE,I,C,M */
80100088:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    ISB
8010008c:	f57ff06f 	isb	sy
    /* Flush TLB */
    LDR                 R0,=0x00
80100090:	e3a00000 	mov	r0, #0
    CP15_SET_INIT       CRN=C8 OP1=0 CRM=C7 OP2=0 /* TLBIALL */
80100094:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
    ISB
80100098:	f57ff06f 	isb	sy
     * R5: Number of pages
     * R6: Property mask
     * R7: Page counter
     * R8: Write index register
     * R9: Write content register */
    LDR                 R0,=RME_A7A_Mem_Info   //165F18
8010009c:	e59f0138 	ldr	r0, [pc, #312]	@ 801001dc <finish+0x44>
    LDR                 R1,=__RME_A7A_Kern_Pgt //150000
801000a0:	e59f1138 	ldr	r1, [pc, #312]	@ 801001e0 <finish+0x48>
    LDR                 R2,=__va_offset__
801000a4:	e59f2114 	ldr	r2, [pc, #276]	@ 801001c0 <finish+0x28>
    /* Calculate the actual address */
    SUB                 R0,R0,R2
801000a8:	e0400002 	sub	r0, r0, r2
    SUB                 R1,R1,R2
801000ac:	e0411002 	sub	r1, r1, r2
    /* Calculate the configuration end address */
    LDR                 R3,[R0]
801000b0:	e5903000 	ldr	r3, [r0]
    LSL					R3,R3,#2
801000b4:	e1a03103 	lsl	r3, r3, #2
    ADD                 R2,R0,R3
801000b8:	e0802003 	add	r2, r0, r3
    ADD                 R0,R0,#0x04
801000bc:	e2800004 	add	r0, r0, #4

801000c0 <load_config>:
    /* Load configurations and generate page table layout one by one */
load_config:
    LDMIA               R0!,{R3-R6}
801000c0:	e8b00078 	ldm	r0!, {r3, r4, r5, r6}
    MOV                 R7,#0x00
801000c4:	e3a07000 	mov	r7, #0
    LSR                 R8,R4,#18
801000c8:	e1a08924 	lsr	r8, r4, #18
    ADD                 R8,R1,R8
801000cc:	e0818008 	add	r8, r1, r8
    ORR                 R9,R3,R6
801000d0:	e1839006 	orr	r9, r3, r6

801000d4 <fill_pgtbl>:

fill_pgtbl:
    STR                 R9,[R8]
801000d4:	e5889000 	str	r9, [r8]
    ADD                 R8,R8,#4
801000d8:	e2888004 	add	r8, r8, #4
    ADD                 R7,R7,#1
801000dc:	e2877001 	add	r7, r7, #1
    ADD                 R9,R9,#0x100000
801000e0:	e2899601 	add	r9, r9, #1048576	@ 0x100000

    CMP                 R7,R5
801000e4:	e1570005 	cmp	r7, r5
    BNE                 fill_pgtbl
801000e8:	1afffff9 	bne	801000d4 <fill_pgtbl>

    CMP                 R0,R2
801000ec:	e1500002 	cmp	r0, r2
    BNE                 load_config
801000f0:	1afffff2 	bne	801000c0 <load_config>

    ISB
801000f4:	f57ff06f 	isb	sy

    /* Set the registers */
    LDR                 R0,=0x01
801000f8:	e3a00001 	mov	r0, #1
    CP15_SET_INIT       CRN=C2 OP1=0 CRM=C0 OP2=2 /* TTBCR, TTBR1 in use when accessing > 2GB */
801000fc:	ee020f50 	mcr	15, 0, r0, cr2, cr0, {2}
    ISB
80100100:	f57ff06f 	isb	sy

    LDR                 R0,=0xFFFFFFFFF//0x55555555
80100104:	e3e00000 	mvn	r0, #0
    CP15_SET_INIT       CRN=C3 OP1=0 CRM=C0 OP2=0 /* DACR */
80100108:	ee030f10 	mcr	15, 0, r0, cr3, cr0, {0}
    ISB
8010010c:	f57ff06f 	isb	sy

    LDR                 R0,=0x000A00A4
80100110:	e59f00cc 	ldr	r0, [pc, #204]	@ 801001e4 <finish+0x4c>
    CP15_SET_INIT       CRN=C10 OP1=0 CRM=C2 OP2=0 /* PRRR */
80100114:	ee0a0f12 	mcr	15, 0, r0, cr10, cr2, {0}
    ISB
80100118:	f57ff06f 	isb	sy

    LDR                 R0,=0x006C006C
8010011c:	e59f00c4 	ldr	r0, [pc, #196]	@ 801001e8 <finish+0x50>
    CP15_SET_INIT       CRN=C10 OP1=0 CRM=C2 OP2=1 /* NMRR */
80100120:	ee0a0f32 	mcr	15, 0, r0, cr10, cr2, {1}
    ISB
80100124:	f57ff06f 	isb	sy

    /* Set base address */
    LDR                 R0,=__RME_A7A_Kern_Pgt
80100128:	e59f00b0 	ldr	r0, [pc, #176]	@ 801001e0 <finish+0x48>
    LDR                 R1,=__va_offset__
8010012c:	e59f108c 	ldr	r1, [pc, #140]	@ 801001c0 <finish+0x28>
    SUB                 R0,R0,R1 //R0=00150000
80100130:	e0400001 	sub	r0, r0, r1
    ORR					R0,R0,#0x09 /* Stuff to write into TTBR */
80100134:	e3800009 	orr	r0, r0, #9
    CP15_SET_INIT       CRN=C2 OP1=0 CRM=C0 OP2=0 /* TTBR0 */
80100138:	ee020f10 	mcr	15, 0, r0, cr2, cr0, {0}
    CP15_SET_INIT       CRN=C2 OP1=0 CRM=C0 OP2=1 /* TTBR1 */
8010013c:	ee020f30 	mcr	15, 0, r0, cr2, cr0, {1}
    /* Load the main function address to R3 first to prepare for a long jump */
    LDR                 R3,=main  //R3=80165848
80100140:	e59f30a4 	ldr	r3, [pc, #164]	@ 801001ec <finish+0x54>
    ISB
80100144:	f57ff06f 	isb	sy

    /* Turn on paging and cache */
    CP15_GET_INIT       CRN=C1 OP1=0 CRM=C0 OP2=0
80100148:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    //LDR                 R1,=(1<<29)|(1<<28)|(1<<12)|(1<<2)|(1<<0) //R1=30001005 |(1<<12)|(1<<2)|(1<<0)
    LDR  				R1,=(1<<29)|(1<<28)|(0<<12)|(1<<2)|(1<<0)
8010014c:	e3a01253 	mov	r1, #805306373	@ 0x30000005
    ORR                 R0,R0,R1           //SCTCR=38C5187F
80100150:	e1800001 	orr	r0, r0, r1
    BIC 				r0, r0, #(1 << 12) //SCTCR=38C5087F
80100154:	e3c00a01 	bic	r0, r0, #4096	@ 0x1000
    /* Print a hex number in LR, R12 used as counter print r0 ********************************************/
    MOV 				LR,R0
80100158:	e1a0e000 	mov	lr, r0
    MOV					R12,#32     /* 32-bits */
8010015c:	e3a0c020 	mov	ip, #32

80100160 <nextdigit>:
nextdigit:
    SUB					R12,R12,#0x04
80100160:	e24cc004 	sub	ip, ip, #4
    LSR					R11,LR,R12
80100164:	e1a0bc3e 	lsr	fp, lr, ip
	AND					R11,R11,#0x0F
80100168:	e20bb00f 	and	fp, fp, #15
	CMP					R11,#0x09
8010016c:	e35b0009 	cmp	fp, #9
	BGE					bigger
80100170:	aa000001 	bge	8010017c <bigger>
	ADD					R11,R11,#0x30 /* add '0' */
80100174:	e28bb030 	add	fp, fp, #48	@ 0x30
	B					printwait
80100178:	ea000000 	b	80100180 <printwait>

8010017c <bigger>:
bigger:
	ADD					R11,R11,#(0x41-10) /* add 'A' */
8010017c:	e28bb037 	add	fp, fp, #55	@ 0x37

80100180 <printwait>:
printwait:
    LDR                 R10,=0xE000102C
80100180:	e59fa068 	ldr	sl, [pc, #104]	@ 801001f0 <finish+0x58>
    LDR					R10,[R10]
80100184:	e59aa000 	ldr	sl, [sl]
    TST					R10,#0x08
80100188:	e31a0008 	tst	sl, #8
    BEQ					printwait
8010018c:	0afffffb 	beq	80100180 <printwait>
    LDR                 R10,=0xE0001030
80100190:	e59fa05c 	ldr	sl, [pc, #92]	@ 801001f4 <finish+0x5c>
    STR                 R11,[R10]
80100194:	e58ab000 	str	fp, [sl]

80100198 <finish>:
finish:
	CMP					R12,#0x00
80100198:	e35c0000 	cmp	ip, #0
	BNE					nextdigit
8010019c:	1affffef 	bne	80100160 <nextdigit>
    /* Print a hex number in LR, R12 used as counter ********************************************/
    CP15_SET_INIT       CRN=C1 OP1=0 CRM=C0 OP2=0 /* SCTLR.AFE,TRE,I,C,M */
801001a0:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    ISB
801001a4:	f57ff06f 	isb	sy

    /* Flush TLB again */
    LDR                 R0,=0x00
801001a8:	e3a00000 	mov	r0, #0
    CP15_SET_INIT       CRN=C8 OP1=0 CRM=C7 OP2=0 /* TLBIALL */
801001ac:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
    ISB
801001b0:	f57ff06f 	isb	sy

    /* Branch to main function */
    BX                  R3
801001b4:	e12fff13 	bx	r3
    LDR                 R0,=__bss_start__
801001b8:	80170000 	.word	0x80170000
    LDR                 R1,=__bss_end__
801001bc:	80190118 	.word	0x80190118
    LDR                 R2,=__va_offset__
801001c0:	80000000 	.word	0x80000000
    LDR                 R4,=__RME_A7A_Stack_Start
801001c4:	80100200 	.word	0x80100200
    LDR                 R0,=0x600F00D2
801001c8:	600f00d2 	.word	0x600f00d2
    LDR                 R0,=0x600F00D7
801001cc:	600f00d7 	.word	0x600f00d7
    LDR                 R0,=0x600F00D1
801001d0:	600f00d1 	.word	0x600f00d1
    LDR                 R0,=0x600F00DB
801001d4:	600f00db 	.word	0x600f00db
    LDR                 R0,=0x600F00D3
801001d8:	600f00d3 	.word	0x600f00d3
    LDR                 R0,=RME_A7A_Mem_Info   //165F18
801001dc:	8016ebf8 	.word	0x8016ebf8
    LDR                 R1,=__RME_A7A_Kern_Pgt //150000
801001e0:	80150000 	.word	0x80150000
    LDR                 R0,=0x000A00A4
801001e4:	000a00a4 	.word	0x000a00a4
    LDR                 R0,=0x006C006C
801001e8:	006c006c 	.word	0x006c006c
    LDR                 R3,=main  //R3=80165848
801001ec:	8016cdbc 	.word	0x8016cdbc
    LDR                 R10,=0xE000102C
801001f0:	e000102c 	.word	0xe000102c
    LDR                 R10,=0xE0001030
801001f4:	e0001030 	.word	0xe0001030
801001f8:	e320f000 	nop	{0}
801001fc:	e320f000 	nop	{0}

80100200 <__RME_A7A_Stack_Start>:
	...

80140200 <__RME_A7A_Stack_End>:
	...

80150000 <__RME_A7A_Kern_Pgt>:
	...

80160000 <__RME_A7A_Vector_Table>:
__RME_A7A_Kern_Pgt:
    .space              65536
/* Vectors *******************************************************************/
    .align              8
__RME_A7A_Vector_Table:
    B                   Reset_Handler
80160000:	ea0001d9 	b	8016076c <Reset_Handler>
    B                   Undefined_Handler
80160004:	ea0001d9 	b	80160770 <Undefined_Handler>
    B                   SVC_Handler
80160008:	ea000202 	b	80160818 <SVC_Handler>
    B                   Prefetch_Abort_Handler
8016000c:	ea0001e5 	b	801607a8 <Prefetch_Abort_Handler>
    B                   Data_Abort_Handler
80160010:	ea0001f2 	b	801607e0 <Data_Abort_Handler>
    B                   Unused_Handler
80160014:	ea0001d4 	b	8016076c <Reset_Handler>
    B                   IRQ_Handler
80160018:	ea00020c 	b	80160850 <IRQ_Handler>
    B                   FIQ_Handler
8016001c:	ea000219 	b	80160888 <FIQ_Handler>

80160020 <__RME_A7A_CPSR_Get>:
Output      : None.
Return      : R0 - The XXXX register contents.
******************************************************************************/
/* CPSR & SPSR */
__RME_A7A_CPSR_Get:
    MRS                 R0,CPSR
80160020:	e10f0000 	mrs	r0, CPSR
    BX                  LR
80160024:	e12fff1e 	bx	lr

80160028 <__RME_A7A_SPSR_Get>:
__RME_A7A_SPSR_Get:
    MRS                 R0,SPSR
80160028:	e14f0000 	mrs	r0, SPSR
    BX                  LR
8016002c:	e12fff1e 	bx	lr

80160030 <__RME_A7A_MIDR_Get>:

/* Main ID register */
__RME_A7A_MIDR_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C0 OP2=0
80160030:	ee100f10 	mrc	15, 0, r0, cr0, cr0, {0}
80160034:	e12fff1e 	bx	lr

80160038 <__RME_A7A_CTR_Get>:
/* Cache type register */
__RME_A7A_CTR_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C0 OP2=1
80160038:	ee100f30 	mrc	15, 0, r0, cr0, cr0, {1}
8016003c:	e12fff1e 	bx	lr

80160040 <__RME_A7A_TCMTR_Get>:
/* TCM type register */
__RME_A7A_TCMTR_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C0 OP2=2
80160040:	ee100f50 	mrc	15, 0, r0, cr0, cr0, {2}
80160044:	e12fff1e 	bx	lr

80160048 <__RME_A7A_TLBTR_Get>:
/* TLB type register */
__RME_A7A_TLBTR_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C0 OP2=3
80160048:	ee100f70 	mrc	15, 0, r0, cr0, cr0, {3}
8016004c:	e12fff1e 	bx	lr

80160050 <__RME_A7A_MPIDR_Get>:
/* Multiprocessor affinity register */
__RME_A7A_MPIDR_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C0 OP2=5
80160050:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
80160054:	e12fff1e 	bx	lr

80160058 <__RME_A7A_REVIDR_Get>:
/* Revision ID register */
__RME_A7A_REVIDR_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C0 OP2=6
80160058:	ee100fd0 	mrc	15, 0, r0, cr0, cr0, {6}
8016005c:	e12fff1e 	bx	lr

80160060 <__RME_A7A_ID_PFR0_Get>:
/* Processor feature register 0 */
__RME_A7A_ID_PFR0_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=0
80160060:	ee100f11 	mrc	15, 0, r0, cr0, cr1, {0}
80160064:	e12fff1e 	bx	lr

80160068 <__RME_A7A_ID_PFR1_Get>:
/* Processor feature register 1 */
__RME_A7A_ID_PFR1_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=1
80160068:	ee100f31 	mrc	15, 0, r0, cr0, cr1, {1}
8016006c:	e12fff1e 	bx	lr

80160070 <__RME_A7A_ID_DFR0_Get>:
/* Debug feature register 0 */
__RME_A7A_ID_DFR0_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=2
80160070:	ee100f51 	mrc	15, 0, r0, cr0, cr1, {2}
80160074:	e12fff1e 	bx	lr

80160078 <__RME_A7A_ID_AFR0_Get>:
/* Auxiliary feature register 0 */
__RME_A7A_ID_AFR0_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=3
80160078:	ee100f71 	mrc	15, 0, r0, cr0, cr1, {3}
8016007c:	e12fff1e 	bx	lr

80160080 <__RME_A7A_ID_MMFR0_Get>:
/* Memory model feature register 0 */
__RME_A7A_ID_MMFR0_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=4
80160080:	ee100f91 	mrc	15, 0, r0, cr0, cr1, {4}
80160084:	e12fff1e 	bx	lr

80160088 <__RME_A7A_ID_MMFR1_Get>:
/* Memory model feature register 1 */
__RME_A7A_ID_MMFR1_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=5
80160088:	ee100fb1 	mrc	15, 0, r0, cr0, cr1, {5}
8016008c:	e12fff1e 	bx	lr

80160090 <__RME_A7A_ID_MMFR2_Get>:
/* Memory model feature register 2 */
__RME_A7A_ID_MMFR2_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=6
80160090:	ee100fd1 	mrc	15, 0, r0, cr0, cr1, {6}
80160094:	e12fff1e 	bx	lr

80160098 <__RME_A7A_ID_MMFR3_Get>:
/* Memory model feature register 3 */
__RME_A7A_ID_MMFR3_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C1 OP2=7
80160098:	ee100ff1 	mrc	15, 0, r0, cr0, cr1, {7}
8016009c:	e12fff1e 	bx	lr

801600a0 <__RME_A7A_ID_ISAR0_Get>:
/* ISA feature register 0 */
__RME_A7A_ID_ISAR0_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C2 OP2=0
801600a0:	ee100f12 	mrc	15, 0, r0, cr0, cr2, {0}
801600a4:	e12fff1e 	bx	lr

801600a8 <__RME_A7A_ID_ISAR1_Get>:
/* ISA feature register 1 */
__RME_A7A_ID_ISAR1_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C2 OP2=1
801600a8:	ee100f32 	mrc	15, 0, r0, cr0, cr2, {1}
801600ac:	e12fff1e 	bx	lr

801600b0 <__RME_A7A_ID_ISAR2_Get>:
/* ISA feature register 2 */
__RME_A7A_ID_ISAR2_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C2 OP2=2
801600b0:	ee100f52 	mrc	15, 0, r0, cr0, cr2, {2}
801600b4:	e12fff1e 	bx	lr

801600b8 <__RME_A7A_ID_ISAR3_Get>:
/* ISA feature register 3 */
__RME_A7A_ID_ISAR3_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C2 OP2=3
801600b8:	ee100f72 	mrc	15, 0, r0, cr0, cr2, {3}
801600bc:	e12fff1e 	bx	lr

801600c0 <__RME_A7A_ID_ISAR4_Get>:
/* ISA feature register 4 */
__RME_A7A_ID_ISAR4_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C2 OP2=4
801600c0:	ee100f92 	mrc	15, 0, r0, cr0, cr2, {4}
801600c4:	e12fff1e 	bx	lr

801600c8 <__RME_A7A_ID_ISAR5_Get>:
/* ISA feature register 5 */
__RME_A7A_ID_ISAR5_Get:
    CP15_GET            CRN=C0 OP1=0 CRM=C2 OP2=5
801600c8:	ee100fb2 	mrc	15, 0, r0, cr0, cr2, {5}
801600cc:	e12fff1e 	bx	lr

801600d0 <__RME_A7A_ID_CCSIDR_Get>:
/* Cache size ID registers */
__RME_A7A_ID_CCSIDR_Get:
    CP15_GET            CRN=C0 OP1=1 CRM=C0 OP2=0
801600d0:	ee300f10 	mrc	15, 1, r0, cr0, cr0, {0}
801600d4:	e12fff1e 	bx	lr

801600d8 <__RME_A7A_ID_CLIDR_Get>:
/* Cache level ID register */
__RME_A7A_ID_CLIDR_Get:
    CP15_GET            CRN=C0 OP1=1 CRM=C0 OP2=1
801600d8:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
801600dc:	e12fff1e 	bx	lr

801600e0 <__RME_A7A_ID_AIDR_Get>:
/* Auxiliary ID register */
__RME_A7A_ID_AIDR_Get:
    CP15_GET            CRN=C0 OP1=1 CRM=C0 OP2=7
801600e0:	ee300ff0 	mrc	15, 1, r0, cr0, cr0, {7}
801600e4:	e12fff1e 	bx	lr

801600e8 <__RME_A7A_ID_CSSELR_Get>:
/* Cache size selection register */
__RME_A7A_ID_CSSELR_Get:
    CP15_GET            CRN=C0 OP1=2 CRM=C0 OP2=0
801600e8:	ee500f10 	mrc	15, 2, r0, cr0, cr0, {0}
801600ec:	e12fff1e 	bx	lr

801600f0 <__RME_A7A_ID_VPIDR_Get>:
/* Virtualization processor ID register  */
__RME_A7A_ID_VPIDR_Get:
    CP15_GET            CRN=C0 OP1=4 CRM=C0 OP2=0
801600f0:	ee900f10 	mrc	15, 4, r0, cr0, cr0, {0}
801600f4:	e12fff1e 	bx	lr

801600f8 <__RME_A7A_ID_VMPIDR_Get>:
/* Virtualization multiprocessor ID register */
__RME_A7A_ID_VMPIDR_Get:
    CP15_GET            CRN=C0 OP1=4 CRM=C0 OP2=5
801600f8:	ee900fb0 	mrc	15, 4, r0, cr0, cr0, {5}
801600fc:	e12fff1e 	bx	lr

80160100 <__RME_A7A_SCTLR_Get>:

/* System control register */
__RME_A7A_SCTLR_Get:
    CP15_GET            CRN=C1 OP1=0 CRM=C0 OP2=0
80160100:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
80160104:	e12fff1e 	bx	lr

80160108 <__RME_A7A_ACTLR_Get>:
/* Auxiliary control register */
__RME_A7A_ACTLR_Get:
    CP15_GET            CRN=C1 OP1=0 CRM=C0 OP2=1
80160108:	ee110f30 	mrc	15, 0, r0, cr1, cr0, {1}
8016010c:	e12fff1e 	bx	lr

80160110 <__RME_A7A_CPACR_Get>:
/* Coprocessor auxiliary control register */
__RME_A7A_CPACR_Get:
    CP15_GET            CRN=C1 OP1=0 CRM=C0 OP2=2
80160110:	ee110f50 	mrc	15, 0, r0, cr1, cr0, {2}
80160114:	e12fff1e 	bx	lr

80160118 <__RME_A7A_SCR_Get>:
/* Secure configuration register */
__RME_A7A_SCR_Get:
    CP15_GET            CRN=C1 OP1=0 CRM=C1 OP2=0
80160118:	ee110f11 	mrc	15, 0, r0, cr1, cr1, {0}
8016011c:	e12fff1e 	bx	lr

80160120 <__RME_A7A_SDER_Get>:
/* Secure debug enable register */
__RME_A7A_SDER_Get:
    CP15_GET            CRN=C1 OP1=0 CRM=C1 OP2=1
80160120:	ee110f31 	mrc	15, 0, r0, cr1, cr1, {1}
80160124:	e12fff1e 	bx	lr

80160128 <__RME_A7A_NSACR_Get>:
/* Non-secure access control register */
__RME_A7A_NSACR_Get:
    CP15_GET            CRN=C1 OP1=0 CRM=C1 OP2=2
80160128:	ee110f51 	mrc	15, 0, r0, cr1, cr1, {2}
8016012c:	e12fff1e 	bx	lr

80160130 <__RME_A7A_HSCTLR_Get>:
/* Hyp system control register */
__RME_A7A_HSCTLR_Get:
    CP15_GET            CRN=C1 OP1=4 CRM=C0 OP2=0
80160130:	ee910f10 	mrc	15, 4, r0, cr1, cr0, {0}
80160134:	e12fff1e 	bx	lr

80160138 <__RME_A7A_HACTLR_Get>:
/* Hyp auxiliary control register */
__RME_A7A_HACTLR_Get:
    CP15_GET            CRN=C1 OP1=4 CRM=C0 OP2=1
80160138:	ee910f30 	mrc	15, 4, r0, cr1, cr0, {1}
8016013c:	e12fff1e 	bx	lr

80160140 <__RME_A7A_HCR_Get>:
/* Hyp configuration register */
__RME_A7A_HCR_Get:
    CP15_GET            CRN=C1 OP1=4 CRM=C1 OP2=0
80160140:	ee910f11 	mrc	15, 4, r0, cr1, cr1, {0}
80160144:	e12fff1e 	bx	lr

80160148 <__RME_A7A_HDCR_Get>:
/* Hyp debug configuration register */
__RME_A7A_HDCR_Get:
    CP15_GET            CRN=C1 OP1=4 CRM=C1 OP2=1
80160148:	ee910f31 	mrc	15, 4, r0, cr1, cr1, {1}
8016014c:	e12fff1e 	bx	lr

80160150 <__RME_A7A_HCPTR_Get>:
/* Hyp coprocessor trap register */
__RME_A7A_HCPTR_Get:
    CP15_GET            CRN=C1 OP1=4 CRM=C1 OP2=2
80160150:	ee910f51 	mrc	15, 4, r0, cr1, cr1, {2}
80160154:	e12fff1e 	bx	lr

80160158 <__RME_A7A_HSTR_Get>:
/* Hyp system trap register */
__RME_A7A_HSTR_Get:
    CP15_GET            CRN=C1 OP1=4 CRM=C1 OP2=3
80160158:	ee910f71 	mrc	15, 4, r0, cr1, cr1, {3}
8016015c:	e12fff1e 	bx	lr

80160160 <__RME_A7A_HACR_Get>:
/* Hyp auxiliary configuration register */
__RME_A7A_HACR_Get:
    CP15_GET            CRN=C1 OP1=4 CRM=C1 OP2=7
80160160:	ee910ff1 	mrc	15, 4, r0, cr1, cr1, {7}
80160164:	e12fff1e 	bx	lr

80160168 <__RME_A7A_TTBR0_Get>:

/* Translation table base register 0 - 32bit. We do not support PAE of any kind */
__RME_A7A_TTBR0_Get:
    CP15_GET            CRN=C2 OP1=0 CRM=C0 OP2=0
80160168:	ee120f10 	mrc	15, 0, r0, cr2, cr0, {0}
8016016c:	e12fff1e 	bx	lr

80160170 <__RME_A7A_TTBR1_Get>:
/* Translation table base register 1 - 32bit. We do not support PAE of any kind */
__RME_A7A_TTBR1_Get:
    CP15_GET            CRN=C2 OP1=0 CRM=C0 OP2=1
80160170:	ee120f30 	mrc	15, 0, r0, cr2, cr0, {1}
80160174:	e12fff1e 	bx	lr

80160178 <__RME_A7A_TTBCR_Get>:
/* Translation table base controle register */
__RME_A7A_TTBCR_Get:
    CP15_GET            CRN=C2 OP1=0 CRM=C0 OP2=2
80160178:	ee120f50 	mrc	15, 0, r0, cr2, cr0, {2}
8016017c:	e12fff1e 	bx	lr

80160180 <__RME_A7A_HTCR_Get>:
/* Hyp translation control register */
__RME_A7A_HTCR_Get:
    CP15_GET            CRN=C2 OP1=4 CRM=C0 OP2=2
80160180:	ee920f50 	mrc	15, 4, r0, cr2, cr0, {2}
80160184:	e12fff1e 	bx	lr

80160188 <__RME_A7A_VTCR_Get>:
/* Virtualization translation control register */
__RME_A7A_VTCR_Get:
    CP15_GET            CRN=C2 OP1=4 CRM=C1 OP2=2
80160188:	ee920f51 	mrc	15, 4, r0, cr2, cr1, {2}
8016018c:	e12fff1e 	bx	lr

80160190 <__RME_A7A_DACR_Get>:
/* Domain access control register */
__RME_A7A_DACR_Get:
    CP15_GET            CRN=C3 OP1=0 CRM=C0 OP2=0
80160190:	ee130f10 	mrc	15, 0, r0, cr3, cr0, {0}
80160194:	e12fff1e 	bx	lr

80160198 <__RME_A7A_DFSR_Get>:

/* Data fault status register */
__RME_A7A_DFSR_Get:
    CP15_GET            CRN=C5 OP1=0 CRM=C0 OP2=0
80160198:	ee150f10 	mrc	15, 0, r0, cr5, cr0, {0}
8016019c:	e12fff1e 	bx	lr

801601a0 <__RME_A7A_IFSR_Get>:
/* Instruction fault status register */
__RME_A7A_IFSR_Get:
    CP15_GET            CRN=C5 OP1=0 CRM=C0 OP2=1
801601a0:	ee150f30 	mrc	15, 0, r0, cr5, cr0, {1}
801601a4:	e12fff1e 	bx	lr

801601a8 <__RME_A7A_ADFSR_Get>:
/* Auxiliary data fault status register */
__RME_A7A_ADFSR_Get:
    CP15_GET            CRN=C5 OP1=0 CRM=C1 OP2=0
801601a8:	ee150f11 	mrc	15, 0, r0, cr5, cr1, {0}
801601ac:	e12fff1e 	bx	lr

801601b0 <__RME_A7A_AIFSR_Get>:
/* Auxiliary instruction fault status register */
__RME_A7A_AIFSR_Get:
    CP15_GET            CRN=C5 OP1=0 CRM=C1 OP2=1
801601b0:	ee150f31 	mrc	15, 0, r0, cr5, cr1, {1}
801601b4:	e12fff1e 	bx	lr

801601b8 <__RME_A7A_HADFSR_Get>:
/* Hyp auxiliary data fault status register */
__RME_A7A_HADFSR_Get:
    CP15_GET            CRN=C5 OP1=4 CRM=C1 OP2=0
801601b8:	ee950f11 	mrc	15, 4, r0, cr5, cr1, {0}
801601bc:	e12fff1e 	bx	lr

801601c0 <__RME_A7A_HAIFSR_Get>:
/* Hyp auxiliary instruction fault status register */
__RME_A7A_HAIFSR_Get:
    CP15_GET            CRN=C5 OP1=4 CRM=C1 OP2=1
801601c0:	ee950f31 	mrc	15, 4, r0, cr5, cr1, {1}
801601c4:	e12fff1e 	bx	lr

801601c8 <__RME_A7A_HSR_Get>:
/* Hyp syndrome register */
__RME_A7A_HSR_Get:
    CP15_GET            CRN=C5 OP1=4 CRM=C2 OP2=0
801601c8:	ee950f12 	mrc	15, 4, r0, cr5, cr2, {0}
801601cc:	e12fff1e 	bx	lr

801601d0 <__RME_A7A_DFAR_Get>:
/* Data fault address register */
__RME_A7A_DFAR_Get:
    CP15_GET            CRN=C6 OP1=0 CRM=C0 OP2=0
801601d0:	ee160f10 	mrc	15, 0, r0, cr6, cr0, {0}
801601d4:	e12fff1e 	bx	lr

801601d8 <__RME_A7A_IFAR_Get>:
/* Instruction fault address register */
__RME_A7A_IFAR_Get:
    CP15_GET            CRN=C6 OP1=0 CRM=C0 OP2=2
801601d8:	ee160f50 	mrc	15, 0, r0, cr6, cr0, {2}
801601dc:	e12fff1e 	bx	lr

801601e0 <__RME_A7A_HDFAR_Get>:
/* Hyp data fault address register */
__RME_A7A_HDFAR_Get:
    CP15_GET            CRN=C6 OP1=4 CRM=C0 OP2=0
801601e0:	ee960f10 	mrc	15, 4, r0, cr6, cr0, {0}
801601e4:	e12fff1e 	bx	lr

801601e8 <__RME_A7A_HIFAR_Get>:
/* Hyp instruction fault address register */
__RME_A7A_HIFAR_Get:
    CP15_GET            CRN=C6 OP1=4 CRM=C0 OP2=2
801601e8:	ee960f50 	mrc	15, 4, r0, cr6, cr0, {2}
801601ec:	e12fff1e 	bx	lr

801601f0 <__RME_A7A_HPFAR_Get>:
/* Hyp IPA fault address register */
__RME_A7A_HPFAR_Get:
    CP15_GET            CRN=C6 OP1=4 CRM=C0 OP2=4
801601f0:	ee960f90 	mrc	15, 4, r0, cr6, cr0, {4}
801601f4:	e12fff1e 	bx	lr

801601f8 <__RME_A7A_PAR_Get>:

/* Physical address register */
__RME_A7A_PAR_Get:
    CP15_GET            CRN=C7 OP1=0 CRM=C4 OP2=0
801601f8:	ee170f14 	mrc	15, 0, r0, cr7, cr4, {0}
801601fc:	e12fff1e 	bx	lr

80160200 <__RME_A7A_TLBLR_Get>:

/* C9 registers currently unsupported */

/* TLB lockdown register - Cortex-A9 */
__RME_A7A_TLBLR_Get:
    CP15_GET            CRN=C10 OP1=0 CRM=C0 OP2=0
80160200:	ee1a0f10 	mrc	15, 0, r0, cr10, cr0, {0}
80160204:	e12fff1e 	bx	lr

80160208 <__RME_A7A_PRRR_Get>:
/* Primary region remap register */
__RME_A7A_PRRR_Get:
    CP15_GET            CRN=C10 OP1=0 CRM=C2 OP2=0
80160208:	ee1a0f12 	mrc	15, 0, r0, cr10, cr2, {0}
8016020c:	e12fff1e 	bx	lr

80160210 <__RME_A7A_NMRR_Get>:
/* Normal memory remap register */
__RME_A7A_NMRR_Get:
    CP15_GET            CRN=C10 OP1=0 CRM=C2 OP2=1
80160210:	ee1a0f32 	mrc	15, 0, r0, cr10, cr2, {1}
80160214:	e12fff1e 	bx	lr

80160218 <__RME_A7A_AMAIR0_Get>:
/* Auxiliary memory attribute indirection register 0 */
__RME_A7A_AMAIR0_Get:
    CP15_GET            CRN=C10 OP1=0 CRM=C3 OP2=0
80160218:	ee1a0f13 	mrc	15, 0, r0, cr10, cr3, {0}
8016021c:	e12fff1e 	bx	lr

80160220 <__RME_A7A_AMAIR1_Get>:
/* Auxiliary memory attribute indirection register 1 */
__RME_A7A_AMAIR1_Get:
    CP15_GET            CRN=C10 OP1=0 CRM=C3 OP2=1
80160220:	ee1a0f33 	mrc	15, 0, r0, cr10, cr3, {1}
80160224:	e12fff1e 	bx	lr

80160228 <__RME_A7A_HMAIR0_Get>:
/* Hyp memory attribute indirection register 0 */
__RME_A7A_HMAIR0_Get:
    CP15_GET            CRN=C10 OP1=4 CRM=C2 OP2=0
80160228:	ee9a0f12 	mrc	15, 4, r0, cr10, cr2, {0}
8016022c:	e12fff1e 	bx	lr

80160230 <__RME_A7A_HMAIR1_Get>:
/* Hyp memory attribute indirection register 1 */
__RME_A7A_HMAIR1_Get:
    CP15_GET            CRN=C10 OP1=4 CRM=C2 OP2=1
80160230:	ee9a0f32 	mrc	15, 4, r0, cr10, cr2, {1}
80160234:	e12fff1e 	bx	lr

80160238 <__RME_A7A_HAMAIR0_Get>:
/* Hyp auxiliary memory attribute indirection register 0 */
__RME_A7A_HAMAIR0_Get:
    CP15_GET            CRN=C10 OP1=4 CRM=C3 OP2=0
80160238:	ee9a0f13 	mrc	15, 4, r0, cr10, cr3, {0}
8016023c:	e12fff1e 	bx	lr

80160240 <__RME_A7A_HAMAIR1_Get>:
/* Hyp auxiliary memory attribute indirection register 1 */
__RME_A7A_HAMAIR1_Get:
    CP15_GET            CRN=C10 OP1=4 CRM=C3 OP2=1
80160240:	ee9a0f33 	mrc	15, 4, r0, cr10, cr3, {1}
80160244:	e12fff1e 	bx	lr

80160248 <__RME_A7A_VBAR_Get>:

/* Vector base address register */
__RME_A7A_VBAR_Get:
    CP15_GET            CRN=C12 OP1=0 CRM=C0 OP2=0
80160248:	ee1c0f10 	mrc	15, 0, r0, cr12, cr0, {0}
8016024c:	e12fff1e 	bx	lr

80160250 <__RME_A7A_MVBAR_Get>:
/* Vector base address register */
__RME_A7A_MVBAR_Get:
    CP15_GET            CRN=C12 OP1=0 CRM=C0 OP2=1
80160250:	ee1c0f30 	mrc	15, 0, r0, cr12, cr0, {1}
80160254:	e12fff1e 	bx	lr

80160258 <__RME_A7A_ISR_Get>:
/* Interrupt status register */
__RME_A7A_ISR_Get:
    CP15_GET            CRN=C12 OP1=0 CRM=C1 OP2=0
80160258:	ee1c0f11 	mrc	15, 0, r0, cr12, cr1, {0}
8016025c:	e12fff1e 	bx	lr

80160260 <__RME_A7A_HVBAR_Get>:
/* Hyp vector base address register */
__RME_A7A_HVBAR_Get:
    CP15_GET            CRN=C12 OP1=4 CRM=C0 OP2=0
80160260:	ee9c0f10 	mrc	15, 4, r0, cr12, cr0, {0}
80160264:	e12fff1e 	bx	lr

80160268 <__RME_A7A_FCSEIDR_Get>:

/* FCSE PID register */
__RME_A7A_FCSEIDR_Get:
    CP15_GET            CRN=C13 OP1=0 CRM=C0 OP2=0
80160268:	ee1d0f10 	mrc	15, 0, r0, cr13, cr0, {0}
8016026c:	e12fff1e 	bx	lr

80160270 <__RME_A7A_CONTEXTIDR_Get>:
/* Context ID register */
__RME_A7A_CONTEXTIDR_Get:
    CP15_GET            CRN=C13 OP1=0 CRM=C0 OP2=1
80160270:	ee1d0f30 	mrc	15, 0, r0, cr13, cr0, {1}
80160274:	e12fff1e 	bx	lr

80160278 <__RME_A7A_TPIDRURW_Get>:
/* User read/write software thread register */
__RME_A7A_TPIDRURW_Get:
    CP15_GET            CRN=C13 OP1=0 CRM=C0 OP2=2
80160278:	ee1d0f50 	mrc	15, 0, r0, cr13, cr0, {2}
8016027c:	e12fff1e 	bx	lr

80160280 <__RME_A7A_TPIDRURO_Get>:
/* User read-only software thread register */
__RME_A7A_TPIDRURO_Get:
    CP15_GET            CRN=C13 OP1=0 CRM=C0 OP2=3
80160280:	ee1d0f70 	mrc	15, 0, r0, cr13, cr0, {3}
80160284:	e12fff1e 	bx	lr

80160288 <__RME_A7A_TPIDRPRW_Get>:
/* PL1-only software thread register */
__RME_A7A_TPIDRPRW_Get:
    CP15_GET            CRN=C13 OP1=0 CRM=C0 OP2=4
80160288:	ee1d0f90 	mrc	15, 0, r0, cr13, cr0, {4}
8016028c:	e12fff1e 	bx	lr

80160290 <__RME_A7A_HTPIDR_Get>:
/* Hyp read/write software thread register */
__RME_A7A_HTPIDR_Get:
    CP15_GET            CRN=C13 OP1=4 CRM=C0 OP2=2
80160290:	ee9d0f50 	mrc	15, 4, r0, cr13, cr0, {2}
80160294:	e12fff1e 	bx	lr

80160298 <__RME_A7A_CNTFRQ_Get>:

/* Counter frequency register */
__RME_A7A_CNTFRQ_Get:
    CP15_GET            CRN=C14 OP1=0 CRM=C0 OP2=0
80160298:	ee1e0f10 	mrc	15, 0, r0, cr14, cr0, {0}
8016029c:	e12fff1e 	bx	lr

801602a0 <__RME_A7A_CNTKCTL_Get>:
/* Timer PL1 control register */
__RME_A7A_CNTKCTL_Get:
    CP15_GET            CRN=C14 OP1=0 CRM=C1 OP2=0
801602a0:	ee1e0f11 	mrc	15, 0, r0, cr14, cr1, {0}
801602a4:	e12fff1e 	bx	lr

801602a8 <__RME_A7A_CNTP_TVAL_Get>:
/* PL1 physical timer value register */
__RME_A7A_CNTP_TVAL_Get:
    CP15_GET            CRN=C14 OP1=0 CRM=C2 OP2=0
801602a8:	ee1e0f12 	mrc	15, 0, r0, cr14, cr2, {0}
801602ac:	e12fff1e 	bx	lr

801602b0 <__RME_A7A_CNTP_CTL_Get>:
/* PL1 physical timer control register */
__RME_A7A_CNTP_CTL_Get:
    CP15_GET            CRN=C14 OP1=0 CRM=C2 OP2=1
801602b0:	ee1e0f32 	mrc	15, 0, r0, cr14, cr2, {1}
801602b4:	e12fff1e 	bx	lr

801602b8 <__RME_A7A_CNTV_TVAL_Get>:
/* Virtual timer value register */
__RME_A7A_CNTV_TVAL_Get:
    CP15_GET            CRN=C14 OP1=0 CRM=C3 OP2=0
801602b8:	ee1e0f13 	mrc	15, 0, r0, cr14, cr3, {0}
801602bc:	e12fff1e 	bx	lr

801602c0 <__RME_A7A_CNTV_CTL_Get>:
/* Virtual timer control register */
__RME_A7A_CNTV_CTL_Get:
    CP15_GET            CRN=C14 OP1=0 CRM=C3 OP2=1
801602c0:	ee1e0f33 	mrc	15, 0, r0, cr14, cr3, {1}
801602c4:	e12fff1e 	bx	lr

801602c8 <__RME_A7A_CNTHCTL_Get>:
/* Timer PL2 control register */
__RME_A7A_CNTHCTL_Get:
    CP15_GET            CRN=C14 OP1=4 CRM=C1 OP2=0
801602c8:	ee9e0f11 	mrc	15, 4, r0, cr14, cr1, {0}
801602cc:	e12fff1e 	bx	lr

801602d0 <__RME_A7A_CNTHP_TVAL_Get>:
/* PL2 physical timer value register */
__RME_A7A_CNTHP_TVAL_Get:
    CP15_GET            CRN=C14 OP1=4 CRM=C2 OP2=0
801602d0:	ee9e0f12 	mrc	15, 4, r0, cr14, cr2, {0}
801602d4:	e12fff1e 	bx	lr

801602d8 <__RME_A7A_CNTHP_CTL_Get>:
/* PL2 physical timer control register */
__RME_A7A_CNTHP_CTL_Get:
    CP15_GET            CRN=C14 OP1=4 CRM=C2 OP2=1
801602d8:	ee9e0f32 	mrc	15, 4, r0, cr14, cr2, {1}
801602dc:	e12fff1e 	bx	lr

801602e0 <__RME_A7A_CNTPCT_DW_Get>:
              rme_ptr_t* R1 - The pointer to the higher bits.
Return      : None.
******************************************************************************/
/* Physical count register */
__RME_A7A_CNTPCT_DW_Get:
    CP15_GET_DOUBLE     CRM=C14 OP=0
801602e0:	ec532f0e 	mrrc	15, 0, r2, r3, cr14
801602e4:	e5802000 	str	r2, [r0]
801602e8:	e5813000 	str	r3, [r1]
801602ec:	e12fff1e 	bx	lr

801602f0 <__RME_A7A_CNTVCT_DW_Get>:
/* Virtual count register */
__RME_A7A_CNTVCT_DW_Get:
    CP15_GET_DOUBLE     CRM=C14 OP=1
801602f0:	ec532f1e 	mrrc	15, 1, r2, r3, cr14
801602f4:	e5802000 	str	r2, [r0]
801602f8:	e5813000 	str	r3, [r1]
801602fc:	e12fff1e 	bx	lr

80160300 <__RME_A7A_CNTP_CVAL_DW_Get>:
/* PL1 physical timer compare value register */
__RME_A7A_CNTP_CVAL_DW_Get:
    CP15_GET_DOUBLE     CRM=C14 OP=2
80160300:	ec532f2e 	mrrc	15, 2, r2, r3, cr14
80160304:	e5802000 	str	r2, [r0]
80160308:	e5813000 	str	r3, [r1]
8016030c:	e12fff1e 	bx	lr

80160310 <__RME_A7A_CNTV_CVAL_DW_Get>:
/* Virtual timer compare value register */
__RME_A7A_CNTV_CVAL_DW_Get:
    CP15_GET_DOUBLE     CRM=C14 OP=3
80160310:	ec532f3e 	mrrc	15, 3, r2, r3, cr14
80160314:	e5802000 	str	r2, [r0]
80160318:	e5813000 	str	r3, [r1]
8016031c:	e12fff1e 	bx	lr

80160320 <__RME_A7A_CNTVOFF_DW_Get>:
/* Virtual offset register */
__RME_A7A_CNTVOFF_DW_Get:
    CP15_GET_DOUBLE     CRM=C14 OP=4
80160320:	ec532f4e 	mrrc	15, 4, r2, r3, cr14
80160324:	e5802000 	str	r2, [r0]
80160328:	e5813000 	str	r3, [r1]
8016032c:	e12fff1e 	bx	lr

80160330 <__RME_A7A_CNTHP_CVAL_DW_Get>:
/* L2 physical timer compare value register */
__RME_A7A_CNTHP_CVAL_DW_Get:
    CP15_GET_DOUBLE     CRM=C14 OP=6
80160330:	ec532f6e 	mrrc	15, 6, r2, r3, cr14
80160334:	e5802000 	str	r2, [r0]
80160338:	e5813000 	str	r3, [r1]
8016033c:	e12fff1e 	bx	lr

80160340 <__RME_A7A_CPSR_Set>:
Output      : None.
Return      : None.
******************************************************************************/
/* CPSR & SPSR */
__RME_A7A_CPSR_Set:
    MSR                 CPSR,R0
80160340:	e129f000 	msr	CPSR_fc, r0
    BX                  LR
80160344:	e12fff1e 	bx	lr

80160348 <__RME_A7A_SPSR_Set>:
__RME_A7A_SPSR_Set:
    MSR                 SPSR,R0
80160348:	e169f000 	msr	SPSR_fc, r0
    BX                  LR
8016034c:	e12fff1e 	bx	lr

80160350 <__RME_A7A_ID_CSSELR_Set>:

/* Cache size selection register */
__RME_A7A_ID_CSSELR_Set:
    CP15_SET            CRN=C0 OP1=2 CRM=C0 OP2=0
80160350:	ee400f10 	mcr	15, 2, r0, cr0, cr0, {0}
80160354:	e12fff1e 	bx	lr

80160358 <__RME_A7A_ID_VPIDR_Set>:
/* Virtualization processor ID register  */
__RME_A7A_ID_VPIDR_Set:
    CP15_SET            CRN=C0 OP1=4 CRM=C0 OP2=0
80160358:	ee800f10 	mcr	15, 4, r0, cr0, cr0, {0}
8016035c:	e12fff1e 	bx	lr

80160360 <__RME_A7A_ID_VMPIDR_Set>:
/* Virtualization multiprocessor ID register */
__RME_A7A_ID_VMPIDR_Set:
    CP15_SET            CRN=C0 OP1=4 CRM=C0 OP2=5
80160360:	ee800fb0 	mcr	15, 4, r0, cr0, cr0, {5}
80160364:	e12fff1e 	bx	lr

80160368 <__RME_A7A_SCTLR_Set>:

/* System control register */
__RME_A7A_SCTLR_Set:
    CP15_SET            CRN=C1 OP1=0 CRM=C0 OP2=0
80160368:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
8016036c:	e12fff1e 	bx	lr

80160370 <__RME_A7A_ACTLR_Set>:
/* Auxiliary control register */
__RME_A7A_ACTLR_Set:
    CP15_SET            CRN=C1 OP1=0 CRM=C0 OP2=1
80160370:	ee010f30 	mcr	15, 0, r0, cr1, cr0, {1}
80160374:	e12fff1e 	bx	lr

80160378 <__RME_A7A_CPACR_Set>:
/* Coprocessor auxiliary control register */
__RME_A7A_CPACR_Set:
    CP15_SET            CRN=C1 OP1=0 CRM=C0 OP2=2
80160378:	ee010f50 	mcr	15, 0, r0, cr1, cr0, {2}
8016037c:	e12fff1e 	bx	lr

80160380 <__RME_A7A_SCR_Set>:
/* Secure configuration register */
__RME_A7A_SCR_Set:
    CP15_SET            CRN=C1 OP1=0 CRM=C1 OP2=0
80160380:	ee010f11 	mcr	15, 0, r0, cr1, cr1, {0}
80160384:	e12fff1e 	bx	lr

80160388 <__RME_A7A_SDER_Set>:
/* Secure debug enable register */
__RME_A7A_SDER_Set:
    CP15_SET            CRN=C1 OP1=0 CRM=C1 OP2=1
80160388:	ee010f31 	mcr	15, 0, r0, cr1, cr1, {1}
8016038c:	e12fff1e 	bx	lr

80160390 <__RME_A7A_NSACR_Set>:
/* Non-secure access control register */
__RME_A7A_NSACR_Set:
    CP15_SET            CRN=C1 OP1=0 CRM=C1 OP2=2
80160390:	ee010f51 	mcr	15, 0, r0, cr1, cr1, {2}
80160394:	e12fff1e 	bx	lr

80160398 <__RME_A7A_HSCTLR_Set>:
/* Hyp system control register */
__RME_A7A_HSCTLR_Set:
    CP15_SET            CRN=C1 OP1=4 CRM=C0 OP2=0
80160398:	ee810f10 	mcr	15, 4, r0, cr1, cr0, {0}
8016039c:	e12fff1e 	bx	lr

801603a0 <__RME_A7A_HACTLR_Set>:
/* Hyp auxiliary control register */
__RME_A7A_HACTLR_Set:
    CP15_SET            CRN=C1 OP1=4 CRM=C0 OP2=1
801603a0:	ee810f30 	mcr	15, 4, r0, cr1, cr0, {1}
801603a4:	e12fff1e 	bx	lr

801603a8 <__RME_A7A_HCR_Set>:
/* Hyp configuration register */
__RME_A7A_HCR_Set:
    CP15_SET            CRN=C1 OP1=4 CRM=C1 OP2=0
801603a8:	ee810f11 	mcr	15, 4, r0, cr1, cr1, {0}
801603ac:	e12fff1e 	bx	lr

801603b0 <__RME_A7A_HDCR_Set>:
/* Hyp debug configuration register */
__RME_A7A_HDCR_Set:
    CP15_SET            CRN=C1 OP1=4 CRM=C1 OP2=1
801603b0:	ee810f31 	mcr	15, 4, r0, cr1, cr1, {1}
801603b4:	e12fff1e 	bx	lr

801603b8 <__RME_A7A_HCPTR_Set>:
/* Hyp coprocessor trap register */
__RME_A7A_HCPTR_Set:
    CP15_SET            CRN=C1 OP1=4 CRM=C1 OP2=2
801603b8:	ee810f51 	mcr	15, 4, r0, cr1, cr1, {2}
801603bc:	e12fff1e 	bx	lr

801603c0 <__RME_A7A_HSTR_Set>:
/* Hyp system trap register */
__RME_A7A_HSTR_Set:
    CP15_SET            CRN=C1 OP1=4 CRM=C1 OP2=3
801603c0:	ee810f71 	mcr	15, 4, r0, cr1, cr1, {3}
801603c4:	e12fff1e 	bx	lr

801603c8 <__RME_A7A_HACR_Set>:
/* Hyp auxiliary configuration register */
__RME_A7A_HACR_Set:
    CP15_SET            CRN=C1 OP1=4 CRM=C1 OP2=7
801603c8:	ee810ff1 	mcr	15, 4, r0, cr1, cr1, {7}
801603cc:	e12fff1e 	bx	lr

801603d0 <__RME_A7A_Pgt_Set>:

/* Translation table base register 0 - 32bit. We do not support PAE of any kind.
 * This operation also sets the page table of this architecture */
__RME_A7A_TTBR0_Set:
__RME_A7A_Pgt_Set:
    CP15_SET            CRN=C2 OP1=0 CRM=C0 OP2=0
801603d0:	ee020f10 	mcr	15, 0, r0, cr2, cr0, {0}
801603d4:	e12fff1e 	bx	lr

801603d8 <__RME_A7A_TTBR1_Set>:
/* Translation table base register 1 - 32bit. We do not support PAE of any kind */
__RME_A7A_TTBR1_Set:
    CP15_SET            CRN=C2 OP1=0 CRM=C0 OP2=1
801603d8:	ee020f30 	mcr	15, 0, r0, cr2, cr0, {1}
801603dc:	e12fff1e 	bx	lr

801603e0 <__RME_A7A_TTBCR_Set>:
/* Translation table base controle register */
__RME_A7A_TTBCR_Set:
    CP15_SET            CRN=C2 OP1=0 CRM=C0 OP2=2
801603e0:	ee020f50 	mcr	15, 0, r0, cr2, cr0, {2}
801603e4:	e12fff1e 	bx	lr

801603e8 <__RME_A7A_HTCR_Set>:
/* Hyp translation control register */
__RME_A7A_HTCR_Set:
    CP15_SET            CRN=C2 OP1=4 CRM=C0 OP2=2
801603e8:	ee820f50 	mcr	15, 4, r0, cr2, cr0, {2}
801603ec:	e12fff1e 	bx	lr

801603f0 <__RME_A7A_VTCR_Set>:
/* Virtualization translation control register */
__RME_A7A_VTCR_Set:
    CP15_SET            CRN=C2 OP1=4 CRM=C1 OP2=2
801603f0:	ee820f51 	mcr	15, 4, r0, cr2, cr1, {2}
801603f4:	e12fff1e 	bx	lr

801603f8 <__RME_A7A_DACR_Set>:
/* Domain access control register */
__RME_A7A_DACR_Set:
    CP15_SET            CRN=C3 OP1=0 CRM=C0 OP2=0
801603f8:	ee030f10 	mcr	15, 0, r0, cr3, cr0, {0}
801603fc:	e12fff1e 	bx	lr

80160400 <__RME_A7A_DFSR_Set>:

/* Data fault status register */
__RME_A7A_DFSR_Set:
    CP15_SET            CRN=C5 OP1=0 CRM=C0 OP2=0
80160400:	ee050f10 	mcr	15, 0, r0, cr5, cr0, {0}
80160404:	e12fff1e 	bx	lr

80160408 <__RME_A7A_IFSR_Set>:
/* Instruction fault status register */
__RME_A7A_IFSR_Set:
    CP15_SET            CRN=C5 OP1=0 CRM=C0 OP2=1
80160408:	ee050f30 	mcr	15, 0, r0, cr5, cr0, {1}
8016040c:	e12fff1e 	bx	lr

80160410 <__RME_A7A_ADFSR_Set>:
/* Auxiliary data fault status register */
__RME_A7A_ADFSR_Set:
    CP15_SET            CRN=C5 OP1=0 CRM=C1 OP2=0
80160410:	ee050f11 	mcr	15, 0, r0, cr5, cr1, {0}
80160414:	e12fff1e 	bx	lr

80160418 <__RME_A7A_AIFSR_Set>:
/* Auxiliary instruction fault status register */
__RME_A7A_AIFSR_Set:
    CP15_SET            CRN=C5 OP1=0 CRM=C1 OP2=1
80160418:	ee050f31 	mcr	15, 0, r0, cr5, cr1, {1}
8016041c:	e12fff1e 	bx	lr

80160420 <__RME_A7A_HADFSR_Set>:
/* Hyp auxiliary data fault status register */
__RME_A7A_HADFSR_Set:
    CP15_SET            CRN=C5 OP1=4 CRM=C1 OP2=0
80160420:	ee850f11 	mcr	15, 4, r0, cr5, cr1, {0}
80160424:	e12fff1e 	bx	lr

80160428 <__RME_A7A_HAIFSR_Set>:
/* Hyp auxiliary instruction fault status register */
__RME_A7A_HAIFSR_Set:
    CP15_SET            CRN=C5 OP1=4 CRM=C1 OP2=1
80160428:	ee850f31 	mcr	15, 4, r0, cr5, cr1, {1}
8016042c:	e12fff1e 	bx	lr

80160430 <__RME_A7A_HSR_Set>:
/* Hyp syndrome register */
__RME_A7A_HSR_Set:
    CP15_SET            CRN=C5 OP1=4 CRM=C2 OP2=0
80160430:	ee850f12 	mcr	15, 4, r0, cr5, cr2, {0}
80160434:	e12fff1e 	bx	lr

80160438 <__RME_A7A_DFAR_Set>:
/* Data fault address register */
__RME_A7A_DFAR_Set:
    CP15_SET            CRN=C6 OP1=0 CRM=C0 OP2=0
80160438:	ee060f10 	mcr	15, 0, r0, cr6, cr0, {0}
8016043c:	e12fff1e 	bx	lr

80160440 <__RME_A7A_IFAR_Set>:
/* Instruction fault address register */
__RME_A7A_IFAR_Set:
    CP15_SET            CRN=C6 OP1=0 CRM=C0 OP2=2
80160440:	ee060f50 	mcr	15, 0, r0, cr6, cr0, {2}
80160444:	e12fff1e 	bx	lr

80160448 <__RME_A7A_HDFAR_Set>:
/* Hyp data fault address register */
__RME_A7A_HDFAR_Set:
    CP15_SET            CRN=C6 OP1=4 CRM=C0 OP2=0
80160448:	ee860f10 	mcr	15, 4, r0, cr6, cr0, {0}
8016044c:	e12fff1e 	bx	lr

80160450 <__RME_A7A_HIFAR_Set>:
/* Hyp instruction fault address register */
__RME_A7A_HIFAR_Set:
    CP15_SET            CRN=C6 OP1=4 CRM=C0 OP2=2
80160450:	ee860f50 	mcr	15, 4, r0, cr6, cr0, {2}
80160454:	e12fff1e 	bx	lr

80160458 <__RME_A7A_HPFAR_Set>:
/* Hyp IPA fault address register */
__RME_A7A_HPFAR_Set:
    CP15_SET            CRN=C6 OP1=4 CRM=C0 OP2=4
80160458:	ee860f90 	mcr	15, 4, r0, cr6, cr0, {4}
8016045c:	e12fff1e 	bx	lr

80160460 <__RME_A7A_ICIALLUIS_Set>:

/* Instruction cache invalidate all to PoU inner shareable */
__RME_A7A_ICIALLUIS_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C1 OP2=0
80160460:	ee070f11 	mcr	15, 0, r0, cr7, cr1, {0}
80160464:	e12fff1e 	bx	lr

80160468 <__RME_A7A_BPIALLIS_Set>:
/* Branch predictor invalidate all inner shareable */
__RME_A7A_BPIALLIS_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C1 OP2=6
80160468:	ee070fd1 	mcr	15, 0, r0, cr7, cr1, {6}
8016046c:	e12fff1e 	bx	lr

80160470 <__RME_A7A_PAR_Set>:
/* Physical address register */
__RME_A7A_PAR_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C4 OP2=6
80160470:	ee070fd4 	mcr	15, 0, r0, cr7, cr4, {6}
80160474:	e12fff1e 	bx	lr

80160478 <__RME_A7A_ICIALLU_Set>:
/* Instruction cache invalidate all to PoU */
__RME_A7A_ICIALLU_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C5 OP2=0
80160478:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
8016047c:	e12fff1e 	bx	lr

80160480 <__RME_A7A_ICIMVAU_Set>:
/* Invalidate instruction cache by MVA to PoU */
__RME_A7A_ICIMVAU_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C5 OP2=1
80160480:	ee070f35 	mcr	15, 0, r0, cr7, cr5, {1}
80160484:	e12fff1e 	bx	lr

80160488 <__RME_A7A_CP15ISB_Set>:
/* ISB register - deprecated */
__RME_A7A_CP15ISB_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C5 OP2=4
80160488:	ee070f95 	mcr	15, 0, r0, cr7, cr5, {4}
8016048c:	e12fff1e 	bx	lr

80160490 <__RME_A7A_BPIALL_Set>:
/* Invalidate entire branch predictor array */
__RME_A7A_BPIALL_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C5 OP2=6
80160490:	ee070fd5 	mcr	15, 0, r0, cr7, cr5, {6}
80160494:	e12fff1e 	bx	lr

80160498 <__RME_A7A_BPIMVA_Set>:
/* Invalidate MVA from branch predictors */
__RME_A7A_BPIMVA_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C5 OP2=7
80160498:	ee070ff5 	mcr	15, 0, r0, cr7, cr5, {7}
8016049c:	e12fff1e 	bx	lr

801604a0 <__RME_A7A_DCIMVAC_Set>:
/* Invalidate data cache by MVA to PoC */
__RME_A7A_DCIMVAC_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C6 OP2=1
801604a0:	ee070f36 	mcr	15, 0, r0, cr7, cr6, {1}
801604a4:	e12fff1e 	bx	lr

801604a8 <__RME_A7A_DCISW_Set>:
/* Invalidate data cache line by set/way */
__RME_A7A_DCISW_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C6 OP2=2
801604a8:	ee070f56 	mcr	15, 0, r0, cr7, cr6, {2}
801604ac:	e12fff1e 	bx	lr

801604b0 <__RME_A7A_ATS1CPR_Set>:
/* Priviledged read VA to PA translation */
__RME_A7A_ATS1CPR_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=0
801604b0:	ee070f18 	mcr	15, 0, r0, cr7, cr8, {0}
801604b4:	e12fff1e 	bx	lr

801604b8 <__RME_A7A_ATS1CPW_Set>:
/* Priviledged write VA to PA translation */
__RME_A7A_ATS1CPW_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=1
801604b8:	ee070f38 	mcr	15, 0, r0, cr7, cr8, {1}
801604bc:	e12fff1e 	bx	lr

801604c0 <__RME_A7A_ATS1CUR_Set>:
/* User read VA to PA translation */
__RME_A7A_ATS1CUR_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=2
801604c0:	ee070f58 	mcr	15, 0, r0, cr7, cr8, {2}
801604c4:	e12fff1e 	bx	lr

801604c8 <__RME_A7A_ATS1CUW_Set>:
/* User write VA to PA translation */
__RME_A7A_ATS1CUW_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=3
801604c8:	ee070f78 	mcr	15, 0, r0, cr7, cr8, {3}
801604cc:	e12fff1e 	bx	lr

801604d0 <__RME_A7A_ATS12NSOPR_Set>:
/* Priviledged read VA to PA translation, other security state */
__RME_A7A_ATS12NSOPR_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=4
801604d0:	ee070f98 	mcr	15, 0, r0, cr7, cr8, {4}
801604d4:	e12fff1e 	bx	lr

801604d8 <__RME_A7A_ATS12NSOPW_Set>:
/* Priviledged write VA to PA translation, other security state */
__RME_A7A_ATS12NSOPW_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=5
801604d8:	ee070fb8 	mcr	15, 0, r0, cr7, cr8, {5}
801604dc:	e12fff1e 	bx	lr

801604e0 <__RME_A7A_ATS12NSOUR_Set>:
/* User read VA to PA translation, other security state */
__RME_A7A_ATS12NSOUR_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=6
801604e0:	ee070fd8 	mcr	15, 0, r0, cr7, cr8, {6}
801604e4:	e12fff1e 	bx	lr

801604e8 <__RME_A7A_ATS12NSOUW_Set>:
/* User write VA to PA translation, other security state */
__RME_A7A_ATS12NSOUW_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C8 OP2=7
801604e8:	ee070ff8 	mcr	15, 0, r0, cr7, cr8, {7}
801604ec:	e12fff1e 	bx	lr

801604f0 <__RME_A7A_DCCMVAC_Set>:
/* Clean data cache line by MVA to PoC */
__RME_A7A_DCCMVAC_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C10 OP2=1
801604f0:	ee070f3a 	mcr	15, 0, r0, cr7, cr10, {1}
801604f4:	e12fff1e 	bx	lr

801604f8 <__RME_A7A_DCCSW_Set>:
/* Clean data cache line by set/way */
__RME_A7A_DCCSW_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C10 OP2=2
801604f8:	ee070f5a 	mcr	15, 0, r0, cr7, cr10, {2}
801604fc:	e12fff1e 	bx	lr

80160500 <__RME_A7A_CP15DSB_Set>:
/* DSB register - deprecated */
__RME_A7A_CP15DSB_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C10 OP2=4
80160500:	ee070f9a 	mcr	15, 0, r0, cr7, cr10, {4}
80160504:	e12fff1e 	bx	lr

80160508 <__RME_A7A_CP15DMB_Set>:
/* DMB register - deprecated */
__RME_A7A_CP15DMB_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C10 OP2=5
80160508:	ee070fba 	mcr	15, 0, r0, cr7, cr10, {5}
8016050c:	e12fff1e 	bx	lr

80160510 <__RME_A7A_DCCMVAU_Set>:
/* Clean data cache line by MVA to PoU */
__RME_A7A_DCCMVAU_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C11 OP2=1
80160510:	ee070f3b 	mcr	15, 0, r0, cr7, cr11, {1}
80160514:	e12fff1e 	bx	lr

80160518 <__RME_A7A_DCCIMVAC_Set>:
/* Clean and invalidate data cache line by MVA to PoC */
__RME_A7A_DCCIMVAC_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C14 OP2=1
80160518:	ee070f3e 	mcr	15, 0, r0, cr7, cr14, {1}
8016051c:	e12fff1e 	bx	lr

80160520 <__RME_A7A_DCCISW_Set>:
/* Clean and invalidate data cache line by set/way */
__RME_A7A_DCCISW_Set:
    CP15_SET            CRN=C7 OP1=0 CRM=C14 OP2=2
80160520:	ee070f5e 	mcr	15, 0, r0, cr7, cr14, {2}
80160524:	e12fff1e 	bx	lr

80160528 <__RME_A7A_ATS1HR_Set>:
/* Hyp mode read translation */
__RME_A7A_ATS1HR_Set:
    CP15_SET            CRN=C7 OP1=4 CRM=C8 OP2=0
80160528:	ee870f18 	mcr	15, 4, r0, cr7, cr8, {0}
8016052c:	e12fff1e 	bx	lr

80160530 <__RME_A7A_ATS1HW_Set>:
/* Hyp mode write translation */
__RME_A7A_ATS1HW_Set:
    CP15_SET            CRN=C7 OP1=4 CRM=C8 OP2=1
80160530:	ee870f38 	mcr	15, 4, r0, cr7, cr8, {1}
80160534:	e12fff1e 	bx	lr

80160538 <__RME_A7A_TLBIALLIS_Set>:

/* Invalidate entire TLB IS */
__RME_A7A_TLBIALLIS_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C3 OP2=0
80160538:	ee080f13 	mcr	15, 0, r0, cr8, cr3, {0}
8016053c:	e12fff1e 	bx	lr

80160540 <__RME_A7A_TLBIMVAIS_Set>:
/* Invalidate unified TLB entry by MVA and ASID IS */
__RME_A7A_TLBIMVAIS_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C3 OP2=1
80160540:	ee080f33 	mcr	15, 0, r0, cr8, cr3, {1}
80160544:	e12fff1e 	bx	lr

80160548 <__RME_A7A_TLBIASIDIS_Set>:
/* Invalidate unified TLB by ASID match IS */
__RME_A7A_TLBIASIDIS_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C3 OP2=2
80160548:	ee080f53 	mcr	15, 0, r0, cr8, cr3, {2}
8016054c:	e12fff1e 	bx	lr

80160550 <__RME_A7A_TLBIMVAAIS_Set>:
/* Invalidate unified TLB entry by MVA all ASID IS */
__RME_A7A_TLBIMVAAIS_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C3 OP2=3
80160550:	ee080f73 	mcr	15, 0, r0, cr8, cr3, {3}
80160554:	e12fff1e 	bx	lr

80160558 <__RME_A7A_ITLBIALL_Set>:
/* Invalidate instruction TLB */
__RME_A7A_ITLBIALL_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C5 OP2=0
80160558:	ee080f15 	mcr	15, 0, r0, cr8, cr5, {0}
8016055c:	e12fff1e 	bx	lr

80160560 <__RME_A7A_ITLBIMVA_Set>:
/* Invalidate instruction TLB entry by MVA and ASID */
__RME_A7A_ITLBIMVA_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C5 OP2=1
80160560:	ee080f35 	mcr	15, 0, r0, cr8, cr5, {1}
80160564:	e12fff1e 	bx	lr

80160568 <__RME_A7A_ITLBIASID_Set>:
/* Invalidate instruction TLB by ASID match */
__RME_A7A_ITLBIASID_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C5 OP2=2
80160568:	ee080f55 	mcr	15, 0, r0, cr8, cr5, {2}
8016056c:	e12fff1e 	bx	lr

80160570 <__RME_A7A_DTLBIALL_Set>:
/* Invalidate data TLB */
__RME_A7A_DTLBIALL_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C6 OP2=0
80160570:	ee080f16 	mcr	15, 0, r0, cr8, cr6, {0}
80160574:	e12fff1e 	bx	lr

80160578 <__RME_A7A_DTLBIMVA_Set>:
/* Invalidate data TLB entry by MVA and ASID */
__RME_A7A_DTLBIMVA_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C6 OP2=1
80160578:	ee080f36 	mcr	15, 0, r0, cr8, cr6, {1}
8016057c:	e12fff1e 	bx	lr

80160580 <__RME_A7A_DTLBIASID_Set>:
/* Invalidate data TLB by ASID match */
__RME_A7A_DTLBIASID_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C6 OP2=2
80160580:	ee080f56 	mcr	15, 0, r0, cr8, cr6, {2}
80160584:	e12fff1e 	bx	lr

80160588 <__RME_A7A_TLBIALL_Set>:
/* Invalidate unified TLB */
__RME_A7A_TLBIALL_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C7 OP2=0
80160588:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
8016058c:	e12fff1e 	bx	lr

80160590 <__RME_A7A_TLBIMVA_Set>:
/* Invalidate unified TLB entry by MVA and ASID */
__RME_A7A_TLBIMVA_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C7 OP2=1
80160590:	ee080f37 	mcr	15, 0, r0, cr8, cr7, {1}
80160594:	e12fff1e 	bx	lr

80160598 <__RME_A7A_TLBIASID_Set>:
/* Invalidate unified TLB by ASID match */
__RME_A7A_TLBIASID_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C7 OP2=2
80160598:	ee080f57 	mcr	15, 0, r0, cr8, cr7, {2}
8016059c:	e12fff1e 	bx	lr

801605a0 <__RME_A7A_TLBIMVAA_Set>:
/* Invalidate unified TLB entries by MVA all ASID */
__RME_A7A_TLBIMVAA_Set:
    CP15_SET            CRN=C8 OP1=0 CRM=C7 OP2=3
801605a0:	ee080f77 	mcr	15, 0, r0, cr8, cr7, {3}
801605a4:	e12fff1e 	bx	lr

801605a8 <__RME_A7A_TLBIALLHIS_Set>:
/* Invalidate entire Hyp unified TLB IS */
__RME_A7A_TLBIALLHIS_Set:
    CP15_SET            CRN=C8 OP1=4 CRM=C3 OP2=0
801605a8:	ee880f13 	mcr	15, 4, r0, cr8, cr3, {0}
801605ac:	e12fff1e 	bx	lr

801605b0 <__RME_A7A_TLBIMVAHIS_Set>:
/* Invalidate Hyp unified TLB entry by MVA IS */
__RME_A7A_TLBIMVAHIS_Set:
    CP15_SET            CRN=C8 OP1=4 CRM=C3 OP2=1
801605b0:	ee880f33 	mcr	15, 4, r0, cr8, cr3, {1}
801605b4:	e12fff1e 	bx	lr

801605b8 <__RME_A7A_TLBIALLNSNHIS_Set>:
/* Invalidate entire Non-secure non-Hyp unified TLB IS */
__RME_A7A_TLBIALLNSNHIS_Set:
    CP15_SET            CRN=C8 OP1=4 CRM=C3 OP2=4
801605b8:	ee880f93 	mcr	15, 4, r0, cr8, cr3, {4}
801605bc:	e12fff1e 	bx	lr

801605c0 <__RME_A7A_TLBIALLH_Set>:
/* Invalidate entire Hyp unified TLB */
__RME_A7A_TLBIALLH_Set:
    CP15_SET            CRN=C8 OP1=4 CRM=C7 OP2=0
801605c0:	ee880f17 	mcr	15, 4, r0, cr8, cr7, {0}
801605c4:	e12fff1e 	bx	lr

801605c8 <__RME_A7A_TLBIMVAH_Set>:
/* Invalidate Hyp unified TLB entry by MVA */
__RME_A7A_TLBIMVAH_Set:
    CP15_SET            CRN=C8 OP1=4 CRM=C7 OP2=1
801605c8:	ee880f37 	mcr	15, 4, r0, cr8, cr7, {1}
801605cc:	e12fff1e 	bx	lr

801605d0 <__RME_A7A_TLBIALLNSNH_Set>:
/* Invalidate entire Non-secure non-Hyp unified TLB */
__RME_A7A_TLBIALLNSNH_Set:
    CP15_SET            CRN=C8 OP1=4 CRM=C7 OP2=4
801605d0:	ee880f97 	mcr	15, 4, r0, cr8, cr7, {4}
801605d4:	e12fff1e 	bx	lr

801605d8 <__RME_A7A_TLBLR_Set>:

/* C9 registers currently unsupported */

/* TLB lockdown register - Cortex-A9 */
__RME_A7A_TLBLR_Set:
    CP15_SET            CRN=C10 OP1=0 CRM=C0 OP2=0
801605d8:	ee0a0f10 	mcr	15, 0, r0, cr10, cr0, {0}
801605dc:	e12fff1e 	bx	lr

801605e0 <__RME_A7A_PRRR_Set>:
/* Primary region remap register */
__RME_A7A_PRRR_Set:
    CP15_SET            CRN=C10 OP1=0 CRM=C2 OP2=0
801605e0:	ee0a0f12 	mcr	15, 0, r0, cr10, cr2, {0}
801605e4:	e12fff1e 	bx	lr

801605e8 <__RME_A7A_NMRR_Set>:
/* Normal memory remap register */
__RME_A7A_NMRR_Set:
    CP15_SET            CRN=C10 OP1=0 CRM=C2 OP2=1
801605e8:	ee0a0f32 	mcr	15, 0, r0, cr10, cr2, {1}
801605ec:	e12fff1e 	bx	lr

801605f0 <__RME_A7A_AMAIR0_Set>:
/* Auxiliary memory attribute indirection register 0 */
__RME_A7A_AMAIR0_Set:
    CP15_SET            CRN=C10 OP1=0 CRM=C3 OP2=0
801605f0:	ee0a0f13 	mcr	15, 0, r0, cr10, cr3, {0}
801605f4:	e12fff1e 	bx	lr

801605f8 <__RME_A7A_AMAIR1_Set>:
/* Auxiliary memory attribute indirection register 1 */
__RME_A7A_AMAIR1_Set:
    CP15_SET            CRN=C10 OP1=0 CRM=C3 OP2=1
801605f8:	ee0a0f33 	mcr	15, 0, r0, cr10, cr3, {1}
801605fc:	e12fff1e 	bx	lr

80160600 <__RME_A7A_HMAIR0_Set>:
/* Hyp memory attribute indirection register 0 */
__RME_A7A_HMAIR0_Set:
    CP15_SET            CRN=C10 OP1=4 CRM=C2 OP2=0
80160600:	ee8a0f12 	mcr	15, 4, r0, cr10, cr2, {0}
80160604:	e12fff1e 	bx	lr

80160608 <__RME_A7A_HMAIR1_Set>:
/* Hyp memory attribute indirection register 1 */
__RME_A7A_HMAIR1_Set:
    CP15_SET            CRN=C10 OP1=4 CRM=C2 OP2=1
80160608:	ee8a0f32 	mcr	15, 4, r0, cr10, cr2, {1}
8016060c:	e12fff1e 	bx	lr

80160610 <__RME_A7A_HAMAIR0_Set>:
/* Hyp auxiliary memory attribute indirection register 0 */
__RME_A7A_HAMAIR0_Set:
    CP15_SET            CRN=C10 OP1=4 CRM=C3 OP2=0
80160610:	ee8a0f13 	mcr	15, 4, r0, cr10, cr3, {0}
80160614:	e12fff1e 	bx	lr

80160618 <__RME_A7A_HAMAIR1_Set>:
/* Hyp auxiliary memory attribute indirection register 1 */
__RME_A7A_HAMAIR1_Set:
    CP15_SET            CRN=C10 OP1=4 CRM=C3 OP2=1
80160618:	ee8a0f33 	mcr	15, 4, r0, cr10, cr3, {1}
8016061c:	e12fff1e 	bx	lr

80160620 <__RME_A7A_VBAR_Set>:

/* Vector base address register */
__RME_A7A_VBAR_Set:
    CP15_SET            CRN=C12 OP1=0 CRM=C0 OP2=0
80160620:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
80160624:	e12fff1e 	bx	lr

80160628 <__RME_A7A_MVBAR_Set>:
/* Vector base address register */
__RME_A7A_MVBAR_Set:
    CP15_SET            CRN=C12 OP1=0 CRM=C0 OP2=1
80160628:	ee0c0f30 	mcr	15, 0, r0, cr12, cr0, {1}
8016062c:	e12fff1e 	bx	lr

80160630 <__RME_A7A_HVBAR_Set>:
/* Hyp vector base address register */
__RME_A7A_HVBAR_Set:
    CP15_SET            CRN=C12 OP1=4 CRM=C0 OP2=0
80160630:	ee8c0f10 	mcr	15, 4, r0, cr12, cr0, {0}
80160634:	e12fff1e 	bx	lr

80160638 <__RME_A7A_CONTEXTIDR_Set>:

/* Context ID register */
__RME_A7A_CONTEXTIDR_Set:
    CP15_SET            CRN=C13 OP1=0 CRM=C0 OP2=1
80160638:	ee0d0f30 	mcr	15, 0, r0, cr13, cr0, {1}
8016063c:	e12fff1e 	bx	lr

80160640 <__RME_A7A_TPIDRURW_Set>:
/* User read/write software thread register */
__RME_A7A_TPIDRURW_Set:
    CP15_SET            CRN=C13 OP1=0 CRM=C0 OP2=2
80160640:	ee0d0f50 	mcr	15, 0, r0, cr13, cr0, {2}
80160644:	e12fff1e 	bx	lr

80160648 <__RME_A7A_TPIDRURO_Set>:
/* User read-only software thread register */
__RME_A7A_TPIDRURO_Set:
    CP15_SET            CRN=C13 OP1=0 CRM=C0 OP2=3
80160648:	ee0d0f70 	mcr	15, 0, r0, cr13, cr0, {3}
8016064c:	e12fff1e 	bx	lr

80160650 <__RME_A7A_TPIDRPRW_Set>:
/* PL1-only software thread register */
__RME_A7A_TPIDRPRW_Set:
    CP15_SET            CRN=C13 OP1=0 CRM=C0 OP2=4
80160650:	ee0d0f90 	mcr	15, 0, r0, cr13, cr0, {4}
80160654:	e12fff1e 	bx	lr

80160658 <__RME_A7A_HTPIDR_Set>:
/* Hyp read/write software thread register */
__RME_A7A_HTPIDR_Set:
    CP15_SET            CRN=C13 OP1=4 CRM=C0 OP2=2
80160658:	ee8d0f50 	mcr	15, 4, r0, cr13, cr0, {2}
8016065c:	e12fff1e 	bx	lr

80160660 <__RME_A7A_CNTFRQ_Set>:

/* Counter frequency register */
__RME_A7A_CNTFRQ_Set:
    CP15_SET            CRN=C14 OP1=0 CRM=C0 OP2=0
80160660:	ee0e0f10 	mcr	15, 0, r0, cr14, cr0, {0}
80160664:	e12fff1e 	bx	lr

80160668 <__RME_A7A_CNTKCTL_Set>:
/* Timer PL1 control register */
__RME_A7A_CNTKCTL_Set:
    CP15_SET            CRN=C14 OP1=0 CRM=C1 OP2=0
80160668:	ee0e0f11 	mcr	15, 0, r0, cr14, cr1, {0}
8016066c:	e12fff1e 	bx	lr

80160670 <__RME_A7A_CNTP_TVAL_Set>:
/* PL1 physical timer value register */
__RME_A7A_CNTP_TVAL_Set:
    CP15_SET            CRN=C14 OP1=0 CRM=C2 OP2=0
80160670:	ee0e0f12 	mcr	15, 0, r0, cr14, cr2, {0}
80160674:	e12fff1e 	bx	lr

80160678 <__RME_A7A_CNTP_CTL_Set>:
/* PL1 physical timer control register */
__RME_A7A_CNTP_CTL_Set:
    CP15_SET            CRN=C14 OP1=0 CRM=C2 OP2=1
80160678:	ee0e0f32 	mcr	15, 0, r0, cr14, cr2, {1}
8016067c:	e12fff1e 	bx	lr

80160680 <__RME_A7A_CNTV_TVAL_Set>:
/* Virtual timer value register */
__RME_A7A_CNTV_TVAL_Set:
    CP15_SET            CRN=C14 OP1=0 CRM=C3 OP2=0
80160680:	ee0e0f13 	mcr	15, 0, r0, cr14, cr3, {0}
80160684:	e12fff1e 	bx	lr

80160688 <__RME_A7A_CNTV_CTL_Set>:
/* Virtual timer control register */
__RME_A7A_CNTV_CTL_Set:
    CP15_SET            CRN=C14 OP1=0 CRM=C3 OP2=1
80160688:	ee0e0f33 	mcr	15, 0, r0, cr14, cr3, {1}
8016068c:	e12fff1e 	bx	lr

80160690 <__RME_A7A_CNTHCTL_Set>:
/* Timer PL2 control register */
__RME_A7A_CNTHCTL_Set:
    CP15_SET            CRN=C14 OP1=4 CRM=C1 OP2=0
80160690:	ee8e0f11 	mcr	15, 4, r0, cr14, cr1, {0}
80160694:	e12fff1e 	bx	lr

80160698 <__RME_A7A_CNTHP_TVAL_Set>:
/* PL2 physical timer value register */
__RME_A7A_CNTHP_TVAL_Set:
    CP15_SET            CRN=C14 OP1=4 CRM=C2 OP2=0
80160698:	ee8e0f12 	mcr	15, 4, r0, cr14, cr2, {0}
8016069c:	e12fff1e 	bx	lr

801606a0 <__RME_A7A_CNTHP_CTL_Set>:
/* PL2 physical timer control register */
__RME_A7A_CNTHP_CTL_Set:
    CP15_SET            CRN=C14 OP1=4 CRM=C2 OP2=1
801606a0:	ee8e0f32 	mcr	15, 4, r0, cr14, cr2, {1}
801606a4:	e12fff1e 	bx	lr

801606a8 <__RME_A7A_CNTP_CVAL_DW_Set>:
Output      : None.
Return      : None.
******************************************************************************/
/* PL1 physical timer compare value register */
__RME_A7A_CNTP_CVAL_DW_Set:
    CP15_SET_DOUBLE     CRM=C14 OP=2
801606a8:	ec400f2e 	mcrr	15, 2, r0, r0, cr14
801606ac:	e12fff1e 	bx	lr

801606b0 <__RME_A7A_CNTV_CVAL_DW_Set>:
/* Virtual timer compare value register */
__RME_A7A_CNTV_CVAL_DW_Set:
    CP15_SET_DOUBLE     CRM=C14 OP=3
801606b0:	ec400f3e 	mcrr	15, 3, r0, r0, cr14
801606b4:	e12fff1e 	bx	lr

801606b8 <__RME_A7A_CNTVOFF_DW_Set>:
/* Virtual offset register */
__RME_A7A_CNTVOFF_DW_Set:
    CP15_SET_DOUBLE     CRM=C14 OP=4
801606b8:	ec400f4e 	mcrr	15, 4, r0, r0, cr14
801606bc:	e12fff1e 	bx	lr

801606c0 <__RME_A7A_CNTHP_CVAL_DW_Set>:
/* L2 physical timer compare value register */
__RME_A7A_CNTHP_CVAL_DW_Set:
    CP15_SET_DOUBLE     CRM=C14 OP=6
801606c0:	ec400f6e 	mcrr	15, 6, r0, r0, cr14
801606c4:	e12fff1e 	bx	lr

801606c8 <__RME_A7A_Fetch_Add>:
              cnt_t Addend - The number to add.
Output      : ptr_t* Ptr - The pointer to the data.
Return      : ptr_t - The value before the addition.
******************************************************************************/
__RME_A7A_Fetch_Add:
    LDREX               R2,[R0]
801606c8:	e1902f9f 	ldrex	r2, [r0]
    ADD                 R3,R2,R1
801606cc:	e0823001 	add	r3, r2, r1
    STREX               R12,R3,[R0]
801606d0:	e180cf93 	strex	ip, r3, [r0]
    CMP                 R12,#0x00
801606d4:	e35c0000 	cmp	ip, #0
    BNE                 __RME_A7A_Fetch_Add
801606d8:	1afffffa 	bne	801606c8 <__RME_A7A_Fetch_Add>
    MOV                 R0,R2
801606dc:	e1a00002 	mov	r0, r2
    BX                  LR
801606e0:	e12fff1e 	bx	lr

801606e4 <__RME_A7A_Fetch_And>:
              cnt_t Operand - The number to logic AND with the destination.
Output      : ptr_t* Ptr - The pointer to the data.
Return      : ptr_t - The value before the AND operation.
******************************************************************************/
__RME_A7A_Fetch_And:
    LDREX               R2,[R0]
801606e4:	e1902f9f 	ldrex	r2, [r0]
    AND                 R3,R2,R1
801606e8:	e0023001 	and	r3, r2, r1
    STREX               R12,R3,[R0]
801606ec:	e180cf93 	strex	ip, r3, [r0]
    CMP                 R12,#0x00
801606f0:	e35c0000 	cmp	ip, #0
    BNE                 __RME_A7A_Fetch_Add
801606f4:	1afffff3 	bne	801606c8 <__RME_A7A_Fetch_Add>
    MOV                 R0,R2
801606f8:	e1a00002 	mov	r0, r2
    BX                  LR
801606fc:	e12fff1e 	bx	lr

80160700 <__RME_A7A_Read_Acquire>:
Input       : rme_ptr_t* R0 - Address to read from.
Output      : None.
Return      : None.
******************************************************************************/
__RME_A7A_Read_Acquire:
    LDR                 R0,[R0]
80160700:	e5900000 	ldr	r0, [r0]
    DMB
80160704:	f57ff05f 	dmb	sy
    BX                  LR
80160708:	e12fff1e 	bx	lr

8016070c <__RME_A7A_Write_Release>:
              rme_ptr_t R1 - Content to write to the address.
Output      : None.
Return      : None.
******************************************************************************/
__RME_A7A_Write_Release:
    DMB
8016070c:	f57ff05f 	dmb	sy
    STR                 R1,[R0]
80160710:	e5801000 	str	r1, [r0]
    BX                  LR
80160714:	e12fff1e 	bx	lr

80160718 <__RME_Int_Disable>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
__RME_Int_Disable:
    CPSID               I
80160718:	f10c0080 	cpsid	i
    BX                  LR
8016071c:	e12fff1e 	bx	lr

80160720 <__RME_Int_Enable>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
__RME_Int_Enable:
    CPSIE               I
80160720:	f1080080 	cpsie	i
    BX                  LR
80160724:	e12fff1e 	bx	lr

80160728 <__RME_A7A_Halt>:
Output      : None.
Return      : None.
******************************************************************************/
__RME_A7A_Halt:
    /* Wait for interrupt */
    WFI
80160728:	e320f003 	wfi
    BX                  LR
8016072c:	e12fff1e 	bx	lr

80160730 <_RME_Kmain>:
Input       : ptr_t Stack - The stack address to set SP to.
Output      : None.
Return      : None.
******************************************************************************/
_RME_Kmain:
    MOV                 R0,SP
80160730:	e1a0000d 	mov	r0, sp
    BL                  RME_Kmain
80160734:	eb0001a5 	bl	80160dd0 <RME_Kmain>

80160738 <__RME_A7A_MSB_Get>:
Input       : ptr_t Val - The value.
Output      : None.
Return      : ptr_t - The MSB position.
******************************************************************************/
__RME_A7A_MSB_Get:
    CLZ                 R1,R0
80160738:	e16f1f10 	clz	r1, r0
    MOV                 R0,#31
8016073c:	e3a0001f 	mov	r0, #31
    SUB                 R0,R1
80160740:	e0400001 	sub	r0, r0, r1
    BX                  LR
80160744:	e12fff1e 	bx	lr

80160748 <__RME_User_Enter>:
              ptr_t CPUID - The CPUID.
Output      : None.
Return      : None.
******************************************************************************/
__RME_User_Enter:
	PUSH				{R0}
80160748:	e52d0004 	push	{r0}		@ (str r0, [sp, #-4]!)
	PUSH				{R1}
8016074c:	e52d1004 	push	{r1}		@ (str r1, [sp, #-4]!)
    MOV                 R0,R2
80160750:	e1a00002 	mov	r0, r2
    /* Prepare the SPSR for user-level */
    LDR                 R2,=0x600F0010
80160754:	e59f2130 	ldr	r2, [pc, #304]	@ 8016088c <FIQ_Handler+0x4>
    MSR                 SPSR_cxsf,R2
80160758:	e16ff002 	msr	SPSR_fsxc, r2
    /* Exception return as well as restoring user-level SP and PC */
    MOV					R2,SP
8016075c:	e1a0200d 	mov	r2, sp
    LDMIA               R2,{SP}^
80160760:	e8d22000 	ldm	r2, {sp}^
    ADD					SP,R2,#0x04
80160764:	e282d004 	add	sp, r2, #4
    LDMIA               SP!,{PC}^
80160768:	e8fd8000 	ldm	sp!, {pc}^

8016076c <Reset_Handler>:
Output      : None.
Return      : None.
******************************************************************************/
Reset_Handler:
Unused_Handler:
    B                   .
8016076c:	eafffffe 	b	8016076c <Reset_Handler>

80160770 <Undefined_Handler>:
    /* Restore user-mode PC */
    LDMIA               SP!,{PC}^
.endm

Undefined_Handler:
    SAVE_GP_REGS
80160770:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
80160774:	e94d6000 	stmdb	sp, {sp, lr}^
80160778:	e24dd008 	sub	sp, sp, #8
8016077c:	e92d1fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
80160780:	e14f0000 	mrs	r0, SPSR
80160784:	e52d0004 	push	{r0}		@ (str r0, [sp, #-4]!)
80160788:	e1a0000d 	mov	r0, sp
    BL                  __RME_A7A_Undefined_Handler
8016078c:	eb0034fc 	bl	8016db84 <__RME_A7A_Undefined_Handler>
    RESTORE_GP_REGS
80160790:	e49d0004 	pop	{r0}		@ (ldr r0, [sp], #4)
80160794:	e16ff000 	msr	SPSR_fsxc, r0
80160798:	e8bd1fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
8016079c:	e8dd6000 	ldm	sp, {sp, lr}^
801607a0:	e28dd008 	add	sp, sp, #8
801607a4:	e8fd8000 	ldm	sp!, {pc}^

801607a8 <Prefetch_Abort_Handler>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
Prefetch_Abort_Handler:
    SAVE_GP_REGS
801607a8:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
801607ac:	e94d6000 	stmdb	sp, {sp, lr}^
801607b0:	e24dd008 	sub	sp, sp, #8
801607b4:	e92d1fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
801607b8:	e14f0000 	mrs	r0, SPSR
801607bc:	e52d0004 	push	{r0}		@ (str r0, [sp, #-4]!)
801607c0:	e1a0000d 	mov	r0, sp
    BL                  __RME_A7A_Prefetch_Abort_Handler
801607c4:	eb003514 	bl	8016dc1c <__RME_A7A_Prefetch_Abort_Handler>
    RESTORE_GP_REGS
801607c8:	e49d0004 	pop	{r0}		@ (ldr r0, [sp], #4)
801607cc:	e16ff000 	msr	SPSR_fsxc, r0
801607d0:	e8bd1fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
801607d4:	e8dd6000 	ldm	sp, {sp, lr}^
801607d8:	e28dd008 	add	sp, sp, #8
801607dc:	e8fd8000 	ldm	sp!, {pc}^

801607e0 <Data_Abort_Handler>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
Data_Abort_Handler:
    SAVE_GP_REGS
801607e0:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
801607e4:	e94d6000 	stmdb	sp, {sp, lr}^
801607e8:	e24dd008 	sub	sp, sp, #8
801607ec:	e92d1fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
801607f0:	e14f0000 	mrs	r0, SPSR
801607f4:	e52d0004 	push	{r0}		@ (str r0, [sp, #-4]!)
801607f8:	e1a0000d 	mov	r0, sp
    BL                  __RME_A7A_Data_Abort_Handler
801607fc:	eb003523 	bl	8016dc90 <__RME_A7A_Data_Abort_Handler>
    RESTORE_GP_REGS
80160800:	e49d0004 	pop	{r0}		@ (ldr r0, [sp], #4)
80160804:	e16ff000 	msr	SPSR_fsxc, r0
80160808:	e8bd1fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
8016080c:	e8dd6000 	ldm	sp, {sp, lr}^
80160810:	e28dd008 	add	sp, sp, #8
80160814:	e8fd8000 	ldm	sp!, {pc}^

80160818 <SVC_Handler>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
SVC_Handler:
    SAVE_GP_REGS
80160818:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
8016081c:	e94d6000 	stmdb	sp, {sp, lr}^
80160820:	e24dd008 	sub	sp, sp, #8
80160824:	e92d1fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
80160828:	e14f0000 	mrs	r0, SPSR
8016082c:	e52d0004 	push	{r0}		@ (str r0, [sp, #-4]!)
80160830:	e1a0000d 	mov	r0, sp
    BL                  _RME_Svc_Handler
80160834:	eb000178 	bl	80160e1c <_RME_Svc_Handler>
    RESTORE_GP_REGS
80160838:	e49d0004 	pop	{r0}		@ (ldr r0, [sp], #4)
8016083c:	e16ff000 	msr	SPSR_fsxc, r0
80160840:	e8bd1fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
80160844:	e8dd6000 	ldm	sp, {sp, lr}^
80160848:	e28dd008 	add	sp, sp, #8
8016084c:	e8fd8000 	ldm	sp!, {pc}^

80160850 <IRQ_Handler>:
IRQ_Handler:
    //LDR                 R0,=0x41210000
    //LDR                 R1,=0x55555555
   // STR                 R1,[R0]
   // B .
    SAVE_GP_REGS
80160850:	e52de004 	push	{lr}		@ (str lr, [sp, #-4]!)
80160854:	e94d6000 	stmdb	sp, {sp, lr}^
80160858:	e24dd008 	sub	sp, sp, #8
8016085c:	e92d1fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
80160860:	e14f0000 	mrs	r0, SPSR
80160864:	e52d0004 	push	{r0}		@ (str r0, [sp, #-4]!)
80160868:	e1a0000d 	mov	r0, sp
    BL                  __RME_A7A_IRQ_Handler
8016086c:	eb003524 	bl	8016dd04 <__RME_A7A_IRQ_Handler>
    RESTORE_GP_REGS
80160870:	e49d0004 	pop	{r0}		@ (ldr r0, [sp], #4)
80160874:	e16ff000 	msr	SPSR_fsxc, r0
80160878:	e8bd1fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
8016087c:	e8dd6000 	ldm	sp, {sp, lr}^
80160880:	e28dd008 	add	sp, sp, #8
80160884:	e8fd8000 	ldm	sp!, {pc}^

80160888 <FIQ_Handler>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
FIQ_Handler:
    B                   .
80160888:	eafffffe 	b	80160888 <FIQ_Handler>
    LDR                 R2,=0x600F0010
8016088c:	600f0010 	.word	0x600f0010

80160890 <RME_Int_Print>:
Output      : None.
Return      : rme_cnt_t - The length of the string printed.
******************************************************************************/
#if(RME_DBGLOG_ENABLE!=0U)
rme_cnt_t RME_Int_Print(rme_cnt_t Int)
{
80160890:	e92d4800 	push	{fp, lr}
80160894:	e28db004 	add	fp, sp, #4
80160898:	e24dd020 	sub	sp, sp, #32
8016089c:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
    rme_cnt_t Iter;
    rme_cnt_t Count;
    rme_cnt_t Div;
    
    /* Exit on zero */
    if(Int==0)
801608a0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801608a4:	e3530000 	cmp	r3, #0
801608a8:	1a000003 	bne	801608bc <RME_Int_Print+0x2c>
    {
        RME_COV_MARKER();

        __RME_Putchar('0');
801608ac:	e3a00030 	mov	r0, #48	@ 0x30
801608b0:	eb003147 	bl	8016cdd4 <__RME_Putchar>
        return 1;
801608b4:	e3a03001 	mov	r3, #1
801608b8:	ea000050 	b	80160a00 <RME_Int_Print+0x170>
        /* No action required */
    }


    /* Correct all negatives into positives */
    if(Int<0)
801608bc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801608c0:	e3530000 	cmp	r3, #0
801608c4:	aa000007 	bge	801608e8 <RME_Int_Print+0x58>
    {
        RME_COV_MARKER();

        __RME_Putchar('-');
801608c8:	e3a0002d 	mov	r0, #45	@ 0x2d
801608cc:	eb003140 	bl	8016cdd4 <__RME_Putchar>
        Abs=-Int;
801608d0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801608d4:	e2633000 	rsb	r3, r3, #0
801608d8:	e50b300c 	str	r3, [fp, #-12]
        Num=1;
801608dc:	e3a03001 	mov	r3, #1
801608e0:	e50b3008 	str	r3, [fp, #-8]
801608e4:	ea000003 	b	801608f8 <RME_Int_Print+0x68>
    }
    else
    {
        RME_COV_MARKER();

        Abs=Int;
801608e8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801608ec:	e50b300c 	str	r3, [fp, #-12]
        Num=0;
801608f0:	e3a03000 	mov	r3, #0
801608f4:	e50b3008 	str	r3, [fp, #-8]
    }

    /* How many digits are there? */
    Count=0;
801608f8:	e3a03000 	mov	r3, #0
801608fc:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Div=1;
80160900:	e3a03001 	mov	r3, #1
80160904:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Iter=Abs;
80160908:	e51b300c 	ldr	r3, [fp, #-12]
8016090c:	e50b3010 	str	r3, [fp, #-16]
    while(1U)
    {
        Iter/=10;
80160910:	e51b2010 	ldr	r2, [fp, #-16]
80160914:	e3063667 	movw	r3, #26215	@ 0x6667
80160918:	e3463666 	movt	r3, #26214	@ 0x6666
8016091c:	e0c31293 	smull	r1, r3, r3, r2
80160920:	e1a01143 	asr	r1, r3, #2
80160924:	e1a03fc2 	asr	r3, r2, #31
80160928:	e0413003 	sub	r3, r1, r3
8016092c:	e50b3010 	str	r3, [fp, #-16]
        Count++;
80160930:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80160934:	e2833001 	add	r3, r3, #1
80160938:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
        if(Iter!=0)
8016093c:	e51b3010 	ldr	r3, [fp, #-16]
80160940:	e3530000 	cmp	r3, #0
80160944:	0a000006 	beq	80160964 <RME_Int_Print+0xd4>
        {
            RME_COV_MARKER();

            Div*=10;
80160948:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016094c:	e1a03002 	mov	r3, r2
80160950:	e1a03103 	lsl	r3, r3, #2
80160954:	e0833002 	add	r3, r3, r2
80160958:	e1a03083 	lsl	r3, r3, #1
8016095c:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
        Iter/=10;
80160960:	eaffffea 	b	80160910 <RME_Int_Print+0x80>
        }
        else
        {
            RME_COV_MARKER();

            break;
80160964:	e320f000 	nop	{0}
        }
    }
    Num+=Count;
80160968:	e51b2008 	ldr	r2, [fp, #-8]
8016096c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80160970:	e0823003 	add	r3, r2, r3
80160974:	e50b3008 	str	r3, [fp, #-8]

    /* Print the integer */
    Iter=Abs;
80160978:	e51b300c 	ldr	r3, [fp, #-12]
8016097c:	e50b3010 	str	r3, [fp, #-16]

    while(Count>0)
80160980:	ea00001a 	b	801609f0 <RME_Int_Print+0x160>
    {
        Count--;
80160984:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80160988:	e2433001 	sub	r3, r3, #1
8016098c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
        __RME_Putchar((rme_s8_t)(Iter/Div)+'0');
80160990:	e51b1018 	ldr	r1, [fp, #-24]	@ 0xffffffe8
80160994:	e51b0010 	ldr	r0, [fp, #-16]
80160998:	fa00371e 	blx	8016e618 <__divsi3>
8016099c:	e1a03000 	mov	r3, r0
801609a0:	e6ef3073 	uxtb	r3, r3
801609a4:	e2833030 	add	r3, r3, #48	@ 0x30
801609a8:	e6ef3073 	uxtb	r3, r3
801609ac:	e6af3073 	sxtb	r3, r3
801609b0:	e1a00003 	mov	r0, r3
801609b4:	eb003106 	bl	8016cdd4 <__RME_Putchar>
        Iter=Iter%Div;
801609b8:	e51b3010 	ldr	r3, [fp, #-16]
801609bc:	e51b1018 	ldr	r1, [fp, #-24]	@ 0xffffffe8
801609c0:	e1a00003 	mov	r0, r3
801609c4:	fa0037b8 	blx	8016e8ac <__aeabi_idivmod>
801609c8:	e1a03001 	mov	r3, r1
801609cc:	e50b3010 	str	r3, [fp, #-16]
        Div/=10;
801609d0:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
801609d4:	e3063667 	movw	r3, #26215	@ 0x6667
801609d8:	e3463666 	movt	r3, #26214	@ 0x6666
801609dc:	e0c31293 	smull	r1, r3, r3, r2
801609e0:	e1a01143 	asr	r1, r3, #2
801609e4:	e1a03fc2 	asr	r3, r2, #31
801609e8:	e0413003 	sub	r3, r1, r3
801609ec:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    while(Count>0)
801609f0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801609f4:	e3530000 	cmp	r3, #0
801609f8:	caffffe1 	bgt	80160984 <RME_Int_Print+0xf4>
    }
    
    return Num;
801609fc:	e51b3008 	ldr	r3, [fp, #-8]
}
80160a00:	e1a00003 	mov	r0, r3
80160a04:	e24bd004 	sub	sp, fp, #4
80160a08:	e8bd8800 	pop	{fp, pc}

80160a0c <RME_Hex_Print>:
Output      : None.
Return      : rme_cnt_t - The length of the string printed.
******************************************************************************/
#if(RME_DBGLOG_ENABLE!=0U)
rme_cnt_t RME_Hex_Print(rme_ptr_t Uint)
{
80160a0c:	e92d4800 	push	{fp, lr}
80160a10:	e28db004 	add	fp, sp, #4
80160a14:	e24dd018 	sub	sp, sp, #24
80160a18:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
    rme_ptr_t Iter;
    rme_ptr_t Count;
    rme_ptr_t Num;
    
    /* Exit on zero */
    if(Uint==0U)
80160a1c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80160a20:	e3530000 	cmp	r3, #0
80160a24:	1a000003 	bne	80160a38 <RME_Hex_Print+0x2c>
    {
        RME_COV_MARKER();
        
        __RME_Putchar('0');
80160a28:	e3a00030 	mov	r0, #48	@ 0x30
80160a2c:	eb0030e8 	bl	8016cdd4 <__RME_Putchar>
        return 1;
80160a30:	e3a03001 	mov	r3, #1
80160a34:	ea000033 	b	80160b08 <RME_Hex_Print+0xfc>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Filter out all the zeroes */
    Count=0U;
80160a38:	e3a03000 	mov	r3, #0
80160a3c:	e50b300c 	str	r3, [fp, #-12]
    Iter=Uint;
80160a40:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80160a44:	e50b3008 	str	r3, [fp, #-8]
    while((Iter>>(RME_WORD_BIT-4U))==0U)
80160a48:	ea000005 	b	80160a64 <RME_Hex_Print+0x58>
    {
        Iter<<=4;
80160a4c:	e51b3008 	ldr	r3, [fp, #-8]
80160a50:	e1a03203 	lsl	r3, r3, #4
80160a54:	e50b3008 	str	r3, [fp, #-8]
        Count++;
80160a58:	e51b300c 	ldr	r3, [fp, #-12]
80160a5c:	e2833001 	add	r3, r3, #1
80160a60:	e50b300c 	str	r3, [fp, #-12]
    while((Iter>>(RME_WORD_BIT-4U))==0U)
80160a64:	e51b3008 	ldr	r3, [fp, #-8]
80160a68:	e1a03e23 	lsr	r3, r3, #28
80160a6c:	e3530000 	cmp	r3, #0
80160a70:	0afffff5 	beq	80160a4c <RME_Hex_Print+0x40>
    }
    
    /* Count is the number of pts to print */
    Count=RME_POW2(RME_WORD_ORDER-2U)-Count;
80160a74:	e51b300c 	ldr	r3, [fp, #-12]
80160a78:	e2633008 	rsb	r3, r3, #8
80160a7c:	e50b300c 	str	r3, [fp, #-12]
    Num=Count;
80160a80:	e51b300c 	ldr	r3, [fp, #-12]
80160a84:	e50b3010 	str	r3, [fp, #-16]
    while(Count>0U)
80160a88:	ea00001a 	b	80160af8 <RME_Hex_Print+0xec>
    {
        Count--;
80160a8c:	e51b300c 	ldr	r3, [fp, #-12]
80160a90:	e2433001 	sub	r3, r3, #1
80160a94:	e50b300c 	str	r3, [fp, #-12]
        Iter=(Uint>>(Count<<2U))&0x0FU;
80160a98:	e51b300c 	ldr	r3, [fp, #-12]
80160a9c:	e1a03103 	lsl	r3, r3, #2
80160aa0:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80160aa4:	e1a03332 	lsr	r3, r2, r3
80160aa8:	e203300f 	and	r3, r3, #15
80160aac:	e50b3008 	str	r3, [fp, #-8]
        if(Iter<10U)
80160ab0:	e51b3008 	ldr	r3, [fp, #-8]
80160ab4:	e3530009 	cmp	r3, #9
80160ab8:	8a000007 	bhi	80160adc <RME_Hex_Print+0xd0>
        {
            RME_COV_MARKER();
            
            __RME_Putchar((rme_s8_t)Iter+'0');
80160abc:	e51b3008 	ldr	r3, [fp, #-8]
80160ac0:	e6ef3073 	uxtb	r3, r3
80160ac4:	e2833030 	add	r3, r3, #48	@ 0x30
80160ac8:	e6ef3073 	uxtb	r3, r3
80160acc:	e6af3073 	sxtb	r3, r3
80160ad0:	e1a00003 	mov	r0, r3
80160ad4:	eb0030be 	bl	8016cdd4 <__RME_Putchar>
80160ad8:	ea000006 	b	80160af8 <RME_Hex_Print+0xec>
        }
        else
        {
            RME_COV_MARKER();
            
            __RME_Putchar((rme_s8_t)Iter+'A'-10);
80160adc:	e51b3008 	ldr	r3, [fp, #-8]
80160ae0:	e6ef3073 	uxtb	r3, r3
80160ae4:	e2833037 	add	r3, r3, #55	@ 0x37
80160ae8:	e6ef3073 	uxtb	r3, r3
80160aec:	e6af3073 	sxtb	r3, r3
80160af0:	e1a00003 	mov	r0, r3
80160af4:	eb0030b6 	bl	8016cdd4 <__RME_Putchar>
    while(Count>0U)
80160af8:	e51b300c 	ldr	r3, [fp, #-12]
80160afc:	e3530000 	cmp	r3, #0
80160b00:	1affffe1 	bne	80160a8c <RME_Hex_Print+0x80>
        }
    }
    
    return (rme_cnt_t)Num;
80160b04:	e51b3010 	ldr	r3, [fp, #-16]
}
80160b08:	e1a00003 	mov	r0, r3
80160b0c:	e24bd004 	sub	sp, fp, #4
80160b10:	e8bd8800 	pop	{fp, pc}

80160b14 <RME_Str_Print>:
Output      : None.
Return      : rme_cnt_t - The length of the string printed, the '\0' is not included.
******************************************************************************/
#if(RME_DBGLOG_ENABLE!=0U)
rme_cnt_t RME_Str_Print(const rme_s8_t* String)
{
80160b14:	e92d4800 	push	{fp, lr}
80160b18:	e28db004 	add	fp, sp, #4
80160b1c:	e24dd010 	sub	sp, sp, #16
80160b20:	e50b0010 	str	r0, [fp, #-16]
    rme_ptr_t Count;
    
    for(Count=0U;Count<RME_DBGLOG_MAX;Count++)
80160b24:	e3a03000 	mov	r3, #0
80160b28:	e50b3008 	str	r3, [fp, #-8]
80160b2c:	ea00000e 	b	80160b6c <RME_Str_Print+0x58>
    {
        if(String[Count]==(rme_s8_t)'\0')
80160b30:	e51b2010 	ldr	r2, [fp, #-16]
80160b34:	e51b3008 	ldr	r3, [fp, #-8]
80160b38:	e0823003 	add	r3, r2, r3
80160b3c:	e1d330d0 	ldrsb	r3, [r3]
80160b40:	e3530000 	cmp	r3, #0
80160b44:	0a00000c 	beq	80160b7c <RME_Str_Print+0x68>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        __RME_Putchar(String[Count]);
80160b48:	e51b2010 	ldr	r2, [fp, #-16]
80160b4c:	e51b3008 	ldr	r3, [fp, #-8]
80160b50:	e0823003 	add	r3, r2, r3
80160b54:	e1d330d0 	ldrsb	r3, [r3]
80160b58:	e1a00003 	mov	r0, r3
80160b5c:	eb00309c 	bl	8016cdd4 <__RME_Putchar>
    for(Count=0U;Count<RME_DBGLOG_MAX;Count++)
80160b60:	e51b3008 	ldr	r3, [fp, #-8]
80160b64:	e2833001 	add	r3, r3, #1
80160b68:	e50b3008 	str	r3, [fp, #-8]
80160b6c:	e51b3008 	ldr	r3, [fp, #-8]
80160b70:	e35300fe 	cmp	r3, #254	@ 0xfe
80160b74:	9affffed 	bls	80160b30 <RME_Str_Print+0x1c>
80160b78:	ea000000 	b	80160b80 <RME_Str_Print+0x6c>
            break;
80160b7c:	e320f000 	nop	{0}
    }
    
    return (rme_cnt_t)Count;
80160b80:	e51b3008 	ldr	r3, [fp, #-8]
}
80160b84:	e1a00003 	mov	r0, r3
80160b88:	e24bd004 	sub	sp, fp, #4
80160b8c:	e8bd8800 	pop	{fp, pc}

80160b90 <RME_Log>:
#ifndef RME_LOG
void RME_Log(const char* File,
             long Line,
             const char* Date,
             const char* Time)
{
80160b90:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160b94:	e28db000 	add	fp, sp, #0
80160b98:	e24dd014 	sub	sp, sp, #20
80160b9c:	e50b0008 	str	r0, [fp, #-8]
80160ba0:	e50b100c 	str	r1, [fp, #-12]
80160ba4:	e50b2010 	str	r2, [fp, #-16]
80160ba8:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    RME_DBG_S("\r\n"); \
    RME_DBG_S(Date); \
    RME_DBG_S(" , "); \
    RME_DBG_S(Time); \
    RME_DBG_S("\r\n"); \*/
}
80160bac:	e320f000 	nop	{0}
80160bb0:	e28bd000 	add	sp, fp, #0
80160bb4:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160bb8:	e12fff1e 	bx	lr

80160bbc <_RME_Comp_Swap_Single>:
Return      : rme_ptr_t - If successful, 1; else 0.
******************************************************************************/
rme_ptr_t _RME_Comp_Swap_Single(volatile rme_ptr_t* Ptr,
                                rme_ptr_t Old,
                                rme_ptr_t New)
{
80160bbc:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160bc0:	e28db000 	add	fp, sp, #0
80160bc4:	e24dd014 	sub	sp, sp, #20
80160bc8:	e50b0008 	str	r0, [fp, #-8]
80160bcc:	e50b100c 	str	r1, [fp, #-12]
80160bd0:	e50b2010 	str	r2, [fp, #-16]
    if(*Ptr==Old)
80160bd4:	e51b3008 	ldr	r3, [fp, #-8]
80160bd8:	e5933000 	ldr	r3, [r3]
80160bdc:	e51b200c 	ldr	r2, [fp, #-12]
80160be0:	e1520003 	cmp	r2, r3
80160be4:	1a000004 	bne	80160bfc <_RME_Comp_Swap_Single+0x40>
    {
        RME_COV_MARKER();
        
        *Ptr=New;
80160be8:	e51b3008 	ldr	r3, [fp, #-8]
80160bec:	e51b2010 	ldr	r2, [fp, #-16]
80160bf0:	e5832000 	str	r2, [r3]
        return 1U;
80160bf4:	e3a03001 	mov	r3, #1
80160bf8:	ea000000 	b	80160c00 <_RME_Comp_Swap_Single+0x44>
    {
        RME_COV_MARKER();
        /* No action required */
    }

    return 0U;
80160bfc:	e3a03000 	mov	r3, #0
}
80160c00:	e1a00003 	mov	r0, r3
80160c04:	e28bd000 	add	sp, fp, #0
80160c08:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160c0c:	e12fff1e 	bx	lr

80160c10 <_RME_Fetch_Add_Single>:
Output      : volatile rme_ptr_t* Ptr - The pointer to the data.
Return      : rme_ptr_t - The value before the addition.
*******************************************************************************/
rme_ptr_t _RME_Fetch_Add_Single(volatile rme_ptr_t* Ptr,
                                rme_cnt_t Addend)
{
80160c10:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160c14:	e28db000 	add	fp, sp, #0
80160c18:	e24dd014 	sub	sp, sp, #20
80160c1c:	e50b0010 	str	r0, [fp, #-16]
80160c20:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
    rme_cnt_t Old;

    Old=(rme_cnt_t)(*Ptr);
80160c24:	e51b3010 	ldr	r3, [fp, #-16]
80160c28:	e5933000 	ldr	r3, [r3]
80160c2c:	e50b3008 	str	r3, [fp, #-8]
    *Ptr=(rme_ptr_t)(Old+Addend);
80160c30:	e51b2008 	ldr	r2, [fp, #-8]
80160c34:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80160c38:	e0823003 	add	r3, r2, r3
80160c3c:	e1a02003 	mov	r2, r3
80160c40:	e51b3010 	ldr	r3, [fp, #-16]
80160c44:	e5832000 	str	r2, [r3]

    return (rme_ptr_t)Old;
80160c48:	e51b3008 	ldr	r3, [fp, #-8]
}
80160c4c:	e1a00003 	mov	r0, r3
80160c50:	e28bd000 	add	sp, fp, #0
80160c54:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160c58:	e12fff1e 	bx	lr

80160c5c <_RME_Fetch_And_Single>:
Output      : volatile rme_ptr_t* Ptr - The pointer to the data.
Return      : rme_ptr_t - The value before the AND operation.
******************************************************************************/
rme_ptr_t _RME_Fetch_And_Single(volatile rme_ptr_t* Ptr,
                                rme_ptr_t Operand)
{
80160c5c:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160c60:	e28db000 	add	fp, sp, #0
80160c64:	e24dd014 	sub	sp, sp, #20
80160c68:	e50b0010 	str	r0, [fp, #-16]
80160c6c:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
    rme_ptr_t Old;

    Old=*Ptr;
80160c70:	e51b3010 	ldr	r3, [fp, #-16]
80160c74:	e5933000 	ldr	r3, [r3]
80160c78:	e50b3008 	str	r3, [fp, #-8]
    *Ptr=Old&Operand;
80160c7c:	e51b2008 	ldr	r2, [fp, #-8]
80160c80:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80160c84:	e0022003 	and	r2, r2, r3
80160c88:	e51b3010 	ldr	r3, [fp, #-16]
80160c8c:	e5832000 	str	r2, [r3]

    return Old;
80160c90:	e51b3008 	ldr	r3, [fp, #-8]
}
80160c94:	e1a00003 	mov	r0, r3
80160c98:	e28bd000 	add	sp, fp, #0
80160c9c:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160ca0:	e12fff1e 	bx	lr

80160ca4 <_RME_List_Crt>:
Input       : struct RME_List* Head - The pointer to the list head.
Output      : None.
Return      : None.
******************************************************************************/
void _RME_List_Crt(struct RME_List* Head)
{
80160ca4:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160ca8:	e28db000 	add	fp, sp, #0
80160cac:	e24dd00c 	sub	sp, sp, #12
80160cb0:	e50b0008 	str	r0, [fp, #-8]
    Head->Prev=Head;
80160cb4:	e51b3008 	ldr	r3, [fp, #-8]
80160cb8:	e51b2008 	ldr	r2, [fp, #-8]
80160cbc:	e5832004 	str	r2, [r3, #4]
    Head->Next=Head;
80160cc0:	e51b3008 	ldr	r3, [fp, #-8]
80160cc4:	e51b2008 	ldr	r2, [fp, #-8]
80160cc8:	e5832000 	str	r2, [r3]
}
80160ccc:	e320f000 	nop	{0}
80160cd0:	e28bd000 	add	sp, fp, #0
80160cd4:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160cd8:	e12fff1e 	bx	lr

80160cdc <_RME_List_Del>:
Output      : None.
Return      : None.
******************************************************************************/
void _RME_List_Del(struct RME_List* Prev,
                   struct RME_List* Next)
{
80160cdc:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160ce0:	e28db000 	add	fp, sp, #0
80160ce4:	e24dd00c 	sub	sp, sp, #12
80160ce8:	e50b0008 	str	r0, [fp, #-8]
80160cec:	e50b100c 	str	r1, [fp, #-12]
    Next->Prev=Prev;
80160cf0:	e51b300c 	ldr	r3, [fp, #-12]
80160cf4:	e51b2008 	ldr	r2, [fp, #-8]
80160cf8:	e5832004 	str	r2, [r3, #4]
    Prev->Next=Next;
80160cfc:	e51b3008 	ldr	r3, [fp, #-8]
80160d00:	e51b200c 	ldr	r2, [fp, #-12]
80160d04:	e5832000 	str	r2, [r3]
}
80160d08:	e320f000 	nop	{0}
80160d0c:	e28bd000 	add	sp, fp, #0
80160d10:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160d14:	e12fff1e 	bx	lr

80160d18 <_RME_List_Ins>:
Return      : None.
******************************************************************************/
void _RME_List_Ins(struct RME_List* New,
                   struct RME_List* Prev,
                   struct RME_List* Next)
{
80160d18:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160d1c:	e28db000 	add	fp, sp, #0
80160d20:	e24dd014 	sub	sp, sp, #20
80160d24:	e50b0008 	str	r0, [fp, #-8]
80160d28:	e50b100c 	str	r1, [fp, #-12]
80160d2c:	e50b2010 	str	r2, [fp, #-16]
    Next->Prev=New;
80160d30:	e51b3010 	ldr	r3, [fp, #-16]
80160d34:	e51b2008 	ldr	r2, [fp, #-8]
80160d38:	e5832004 	str	r2, [r3, #4]
    New->Next=Next;
80160d3c:	e51b3008 	ldr	r3, [fp, #-8]
80160d40:	e51b2010 	ldr	r2, [fp, #-16]
80160d44:	e5832000 	str	r2, [r3]
    New->Prev=Prev;
80160d48:	e51b3008 	ldr	r3, [fp, #-8]
80160d4c:	e51b200c 	ldr	r2, [fp, #-12]
80160d50:	e5832004 	str	r2, [r3, #4]
    Prev->Next=New;
80160d54:	e51b300c 	ldr	r3, [fp, #-12]
80160d58:	e51b2008 	ldr	r2, [fp, #-8]
80160d5c:	e5832000 	str	r2, [r3]
}
80160d60:	e320f000 	nop	{0}
80160d64:	e28bd000 	add	sp, fp, #0
80160d68:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160d6c:	e12fff1e 	bx	lr

80160d70 <_RME_Diff>:
Output      : None.
Return      : rme_ptr_t - The distance.
******************************************************************************/
rme_ptr_t _RME_Diff(rme_ptr_t Num1,
                    rme_ptr_t Num2)
{
80160d70:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160d74:	e28db000 	add	fp, sp, #0
80160d78:	e24dd014 	sub	sp, sp, #20
80160d7c:	e50b0010 	str	r0, [fp, #-16]
80160d80:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
    rme_ptr_t Diff1;
    rme_ptr_t Diff2;
    
    Diff1=Num1-Num2;
80160d84:	e51b2010 	ldr	r2, [fp, #-16]
80160d88:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80160d8c:	e0423003 	sub	r3, r2, r3
80160d90:	e50b3008 	str	r3, [fp, #-8]
    Diff2=Num2-Num1;
80160d94:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80160d98:	e51b3010 	ldr	r3, [fp, #-16]
80160d9c:	e0423003 	sub	r3, r2, r3
80160da0:	e50b300c 	str	r3, [fp, #-12]
    
    if(Diff1>Diff2)
80160da4:	e51b2008 	ldr	r2, [fp, #-8]
80160da8:	e51b300c 	ldr	r3, [fp, #-12]
80160dac:	e1520003 	cmp	r2, r3
80160db0:	9a000001 	bls	80160dbc <_RME_Diff+0x4c>
    {
        RME_COV_MARKER();
        
        return Diff2;
80160db4:	e51b300c 	ldr	r3, [fp, #-12]
80160db8:	ea000000 	b	80160dc0 <_RME_Diff+0x50>
    }
    else
    {
        RME_COV_MARKER();
        
        return Diff1;
80160dbc:	e51b3008 	ldr	r3, [fp, #-8]
    }
}
80160dc0:	e1a00003 	mov	r0, r3
80160dc4:	e28bd000 	add	sp, fp, #0
80160dc8:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160dcc:	e12fff1e 	bx	lr

80160dd0 <RME_Kmain>:
Input       : None.
Output      : None.
Return      : rme_ret_t - This function never returns.
******************************************************************************/
rme_ret_t RME_Kmain(void)
{
80160dd0:	e92d4800 	push	{fp, lr}
80160dd4:	e28db004 	add	fp, sp, #4
    /* Disable all interrupts first */
    __RME_Int_Disable();
80160dd8:	ebfffe4e 	bl	80160718 <__RME_Int_Disable>
    /* Some low-level kernel assertions */
    _RME_Lowlvl_Check();
80160ddc:	eb000007 	bl	80160e00 <_RME_Lowlvl_Check>
    /* Hardware low-level init */
    __RME_Lowlvl_Init();
80160de0:	eb0030f6 	bl	8016d1c0 <__RME_Lowlvl_Init>
    /* Initialize the kernel page tables or memory mappings */
    __RME_Pgt_Kom_Init();
80160de4:	eb003111 	bl	8016d230 <__RME_Pgt_Kom_Init>
    
    /* Initialize the kernel object allocation table - default init */
    _RME_Kot_Init(RME_KOT_WORD_NUM);
80160de8:	e3a00902 	mov	r0, #32768	@ 0x8000
80160dec:	eb001045 	bl	80164f08 <_RME_Kot_Init>
    
    /* Boot into the first process */
    __RME_Boot();
80160df0:	eb003115 	bl	8016d24c <__RME_Boot>
    
    /* Should never reach here */
    return 0;
80160df4:	e3a03000 	mov	r3, #0
}
80160df8:	e1a00003 	mov	r0, r3
80160dfc:	e8bd8800 	pop	{fp, pc}

80160e00 <_RME_Lowlvl_Check>:
Input       : None.
Output      : None.
Return      : rme_ret_t - Always 0.
******************************************************************************/
static rme_ret_t _RME_Lowlvl_Check(void)
{
80160e00:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80160e04:	e28db000 	add	fp, sp, #0
    /* Kernel memory allocation minimal size aligned to word boundary */
    RME_ASSERT(RME_KOM_SLOT_ORDER>=RME_WORD_ORDER-3U);
    /* Make sure the number of priorities do not exceed half-word boundary */
    RME_ASSERT(RME_PREEMPT_PRIO_NUM<=RME_POW2(RME_WORD_BIT>>1));
    
    return 0;
80160e08:	e3a03000 	mov	r3, #0
}
80160e0c:	e1a00003 	mov	r0, r3
80160e10:	e28bd000 	add	sp, fp, #0
80160e14:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80160e18:	e12fff1e 	bx	lr

80160e1c <_RME_Svc_Handler>:
Input       : struct RME_Reg_Struct* Reg - The register set.
Output      : struct RME_Reg_Struct* Reg - The updated register set.
Return      : None.
******************************************************************************/
void _RME_Svc_Handler(struct RME_Reg_Struct* Reg)
{
80160e1c:	e92d4830 	push	{r4, r5, fp, lr}
80160e20:	e28db00c 	add	fp, sp, #12
80160e24:	e24dd048 	sub	sp, sp, #72	@ 0x48
80160e28:	e50b0038 	str	r0, [fp, #-56]	@ 0xffffffc8
    struct RME_Thd_Struct* Thd_Cur;
    struct RME_Inv_Struct* Inv_Top;
    struct RME_Cap_Cpt* Cpt;

    /* Get the system call parameters from the system call */
    __RME_Svc_Param_Get(Reg, &Svc, &Cid, Param);
80160e2c:	e24b3034 	sub	r3, fp, #52	@ 0x34
80160e30:	e24b2028 	sub	r2, fp, #40	@ 0x28
80160e34:	e24b1024 	sub	r1, fp, #36	@ 0x24
80160e38:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80160e3c:	eb003284 	bl	8016d854 <__RME_Svc_Param_Get>
    /* System call number takes [5:0] bits */
    Svc_Num=Svc&RME_MASK_END(5U);
80160e40:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80160e44:	e203303f 	and	r3, r3, #63	@ 0x3f
80160e48:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    
    /* Ultra-fast path - synchronous invocation returning */
    if(Svc_Num==RME_SVC_INV_RET)
80160e4c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80160e50:	e3530000 	cmp	r3, #0
80160e54:	1a00000c 	bne	80160e8c <_RME_Svc_Handler+0x70>
    {
        RME_COV_MARKER();
        
        Retval=_RME_Inv_Ret(Reg,                                            /* volatile struct RME_Reg_Struct* Reg */
80160e58:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80160e5c:	e3a02000 	mov	r2, #0
80160e60:	e1a01003 	mov	r1, r3
80160e64:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80160e68:	eb002e31 	bl	8016c734 <_RME_Inv_Ret>
80160e6c:	e50b0010 	str	r0, [fp, #-16]
                            Param[0],                                       /* rme_ptr_t Retval */
                            0U);                                            /* rme_ptr_t Is_Exc */
        RME_SWITCH_RETURN(Reg, Retval);
80160e70:	e51b3010 	ldr	r3, [fp, #-16]
80160e74:	e3530000 	cmp	r3, #0
80160e78:	aa000218 	bge	801616e0 <_RME_Svc_Handler+0x8c4>
80160e7c:	e51b1010 	ldr	r1, [fp, #-16]
80160e80:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80160e84:	eb003295 	bl	8016d8e0 <__RME_Svc_Retval_Set>
80160e88:	ea000214 	b	801616e0 <_RME_Svc_Handler+0x8c4>
        /* No action required */
    }
    
    /* Get our current capability table. No need to check whether it is frozen
     * because it can't be deleted anyway */
    Thd_Cur=RME_CPU_LOCAL()->Thd_Cur;
80160e8c:	e3003004 	movw	r3, #4
80160e90:	e3483017 	movt	r3, #32791	@ 0x8017
80160e94:	e5933004 	ldr	r3, [r3, #4]
80160e98:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    Inv_Top=RME_INVSTK_TOP(Thd_Cur);
80160e9c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80160ea0:	e593204c 	ldr	r2, [r3, #76]	@ 0x4c
80160ea4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80160ea8:	e283304c 	add	r3, r3, #76	@ 0x4c
80160eac:	e1520003 	cmp	r2, r3
80160eb0:	0a000002 	beq	80160ec0 <_RME_Svc_Handler+0xa4>
80160eb4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80160eb8:	e593304c 	ldr	r3, [r3, #76]	@ 0x4c
80160ebc:	ea000000 	b	80160ec4 <_RME_Svc_Handler+0xa8>
80160ec0:	e3a03000 	mov	r3, #0
80160ec4:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
    if(Inv_Top==RME_NULL)
80160ec8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80160ecc:	e3530000 	cmp	r3, #0
80160ed0:	1a000004 	bne	80160ee8 <_RME_Svc_Handler+0xcc>
    {
        RME_COV_MARKER();
        
        Cpt=Thd_Cur->Sched.Prc->Cpt;
80160ed4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80160ed8:	e593302c 	ldr	r3, [r3, #44]	@ 0x2c
80160edc:	e5933014 	ldr	r3, [r3, #20]
80160ee0:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
80160ee4:	ea000003 	b	80160ef8 <_RME_Svc_Handler+0xdc>
    }
    else
    {
        RME_COV_MARKER();
        
        Cpt=Inv_Top->Prc->Cpt;
80160ee8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80160eec:	e5933008 	ldr	r3, [r3, #8]
80160ef0:	e5933014 	ldr	r3, [r3, #20]
80160ef4:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    }

    /* Fast path - synchronous invocation activation */
    if(Svc_Num==RME_SVC_INV_ACT)
80160ef8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80160efc:	e3530001 	cmp	r3, #1
80160f00:	1a000014 	bne	80160f58 <_RME_Svc_Handler+0x13c>
    {
        RME_COV_MARKER();
        
        Retval=_RME_Inv_Act(Cpt,
                            Reg,                                            /* volatile struct RME_Reg_Struct* Reg */
                            (rme_cid_t)Param[0],                            /* rme_cid_t Cap_Inv */
80160f04:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
        Retval=_RME_Inv_Act(Cpt,
80160f08:	e1a02003 	mov	r2, r3
80160f0c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80160f10:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80160f14:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80160f18:	eb002d49 	bl	8016c444 <_RME_Inv_Act>
80160f1c:	e50b0010 	str	r0, [fp, #-16]
                            Param[1]);                                      /* rme_ptr_t Param */
       RME_DBG_S("\r\n CPSR= ");
80160f20:	e30e08cc 	movw	r0, #59596	@ 0xe8cc
80160f24:	e3480016 	movt	r0, #32790	@ 0x8016
80160f28:	ebfffef9 	bl	80160b14 <RME_Str_Print>
       RME_DBG_H(Reg->CPSR);
80160f2c:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80160f30:	e5933000 	ldr	r3, [r3]
80160f34:	e1a00003 	mov	r0, r3
80160f38:	ebfffeb3 	bl	80160a0c <RME_Hex_Print>
        RME_SWITCH_RETURN(Reg,Retval);
80160f3c:	e51b3010 	ldr	r3, [fp, #-16]
80160f40:	e3530000 	cmp	r3, #0
80160f44:	aa0001e5 	bge	801616e0 <_RME_Svc_Handler+0x8c4>
80160f48:	e51b1010 	ldr	r1, [fp, #-16]
80160f4c:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80160f50:	eb003262 	bl	8016d8e0 <__RME_Svc_Retval_Set>
80160f54:	ea0001e1 	b	801616e0 <_RME_Svc_Handler+0x8c4>
     * of these functions shall be: If the function is successful, they shall
     * perform the return value saving on proper register stacks by themselves;
     * if the function fails, it should not conduct such return value saving.
     * These paths are less optimized than synchronous invocation, but are still
     * optimized anyway. */
    switch(Svc_Num)
80160f58:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80160f5c:	e2432002 	sub	r2, r3, #2
80160f60:	e59f3780 	ldr	r3, [pc, #1920]	@ 801616e8 <_RME_Svc_Handler+0x8cc>
80160f64:	e3520007 	cmp	r2, #7
80160f68:	8a000094 	bhi	801611c0 <_RME_Svc_Handler+0x3a4>
80160f6c:	e793f102 	ldr	pc, [r3, r2, lsl #2]
80160f70:	e320f000 	nop	{0}
        {
            RME_COV_MARKER();
            
            Retval=_RME_Sig_Snd(Cpt,
                                Reg,                                        /* volatile struct RME_Reg_Struct* Reg */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Sig */
80160f74:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Sig_Snd(Cpt,
80160f78:	e1a02003 	mov	r2, r3
80160f7c:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80160f80:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80160f84:	eb00284f 	bl	8016b0c8 <_RME_Sig_Snd>
80160f88:	e50b0010 	str	r0, [fp, #-16]
            RME_SWITCH_RETURN(Reg,Retval);
80160f8c:	e51b3010 	ldr	r3, [fp, #-16]
80160f90:	e3530000 	cmp	r3, #0
80160f94:	aa0001d1 	bge	801616e0 <_RME_Svc_Handler+0x8c4>
80160f98:	e51b1010 	ldr	r1, [fp, #-16]
80160f9c:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80160fa0:	eb00324e 	bl	8016d8e0 <__RME_Svc_Retval_Set>
80160fa4:	ea0001cd 	b	801616e0 <_RME_Svc_Handler+0x8c4>
        {
            RME_COV_MARKER();
            
            Retval=_RME_Sig_Rcv(Cpt,
                                Reg,                                        /* volatile struct RME_Reg_Struct* Reg */
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Sig */
80160fa8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Sig_Rcv(Cpt,
80160fac:	e1a02003 	mov	r2, r3
80160fb0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80160fb4:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80160fb8:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80160fbc:	eb002905 	bl	8016b3d8 <_RME_Sig_Rcv>
80160fc0:	e50b0010 	str	r0, [fp, #-16]
                                Param[1]);                                  /* rme_ptr_t Option */
            RME_SWITCH_RETURN(Reg,Retval);
80160fc4:	e51b3010 	ldr	r3, [fp, #-16]
80160fc8:	e3530000 	cmp	r3, #0
80160fcc:	aa0001c3 	bge	801616e0 <_RME_Svc_Handler+0x8c4>
80160fd0:	e51b1010 	ldr	r1, [fp, #-16]
80160fd4:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80160fd8:	eb003240 	bl	8016d8e0 <__RME_Svc_Retval_Set>
80160fdc:	ea0001bf 	b	801616e0 <_RME_Svc_Handler+0x8c4>
        /* Call kernel functions */
        case RME_SVC_KFN:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Kfn_Act(Cpt,
80160fe0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80160fe4:	e1a0c003 	mov	ip, r3
                                Reg,                                        /* volatile struct RME_Reg_Struct* Reg */
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Kfn */
                                RME_PARAM_D0(Param[0]),                     /* rme_ptr_t Func_ID */
80160fe8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Kfn_Act(Cpt,
80160fec:	e6ff0073 	uxth	r0, r3
                                RME_PARAM_D1(Param[0]),                     /* rme_ptr_t Sub_ID */
80160ff0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Kfn_Act(Cpt,
80160ff4:	e1a03823 	lsr	r3, r3, #16
80160ff8:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
80160ffc:	e51b102c 	ldr	r1, [fp, #-44]	@ 0xffffffd4
80161000:	e58d1008 	str	r1, [sp, #8]
80161004:	e58d2004 	str	r2, [sp, #4]
80161008:	e58d3000 	str	r3, [sp]
8016100c:	e1a03000 	mov	r3, r0
80161010:	e1a0200c 	mov	r2, ip
80161014:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80161018:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016101c:	eb002ee5 	bl	8016cbb8 <_RME_Kfn_Act>
80161020:	e50b0010 	str	r0, [fp, #-16]
                                Param[1],                                   /* rme_ptr_t Param1 */
                                Param[2]);                                  /* rme_ptr_t Param2 */
            RME_SWITCH_RETURN(Reg, Retval);
80161024:	e51b3010 	ldr	r3, [fp, #-16]
80161028:	e3530000 	cmp	r3, #0
8016102c:	aa0001ab 	bge	801616e0 <_RME_Svc_Handler+0x8c4>
80161030:	e51b1010 	ldr	r1, [fp, #-16]
80161034:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80161038:	eb003228 	bl	8016d8e0 <__RME_Svc_Retval_Set>
8016103c:	ea0001a7 	b	801616e0 <_RME_Svc_Handler+0x8c4>
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Sched_Free(Cpt,
                                       Reg,                                 /* volatile struct RME_Reg_Struct* Reg */
                                       (rme_cid_t)Param[0]);                /* rme_cid_t Cap_Thd */
80161040:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Sched_Free(Cpt,
80161044:	e1a02003 	mov	r2, r3
80161048:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
8016104c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161050:	eb001f7c 	bl	80168e48 <_RME_Thd_Sched_Free>
80161054:	e50b0010 	str	r0, [fp, #-16]
            RME_SWITCH_RETURN(Reg,Retval);
80161058:	e51b3010 	ldr	r3, [fp, #-16]
8016105c:	e3530000 	cmp	r3, #0
80161060:	aa00019e 	bge	801616e0 <_RME_Svc_Handler+0x8c4>
80161064:	e51b1010 	ldr	r1, [fp, #-16]
80161068:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
8016106c:	eb00321b 	bl	8016d8e0 <__RME_Svc_Retval_Set>
80161070:	ea00019a 	b	801616e0 <_RME_Svc_Handler+0x8c4>
        /* Changing thread execution context */
        case RME_SVC_THD_EXEC_SET:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Exec_Set(Cpt,
80161074:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161078:	e1a00003 	mov	r0, r3
8016107c:	e51b1034 	ldr	r1, [fp, #-52]	@ 0xffffffcc
80161080:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80161084:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
80161088:	e58d2004 	str	r2, [sp, #4]
8016108c:	e58d3000 	str	r3, [sp]
80161090:	e1a03001 	mov	r3, r1
80161094:	e1a02000 	mov	r2, r0
80161098:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
8016109c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801610a0:	eb002056 	bl	80169200 <_RME_Thd_Exec_Set>
801610a4:	e50b0010 	str	r0, [fp, #-16]
                                     Reg,                                   /* volatile struct RME_Reg_Struct* Reg */
                                     (rme_cid_t)Cid,                        /* rme_cid_t Cap_Thd */
                                     Param[0],                              /* rme_ptr_t Entry */
                                     Param[1],                              /* rme_ptr_t Stack */
                                     Param[2]);                             /* rme_ptr_t Param */
            RME_SWITCH_RETURN(Reg,Retval);
801610a8:	e51b3010 	ldr	r3, [fp, #-16]
801610ac:	e3530000 	cmp	r3, #0
801610b0:	aa00018a 	bge	801616e0 <_RME_Svc_Handler+0x8c4>
801610b4:	e51b1010 	ldr	r1, [fp, #-16]
801610b8:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
801610bc:	eb003207 	bl	8016d8e0 <__RME_Svc_Retval_Set>
801610c0:	ea000186 	b	801616e0 <_RME_Svc_Handler+0x8c4>
        /* Changing thread priority (up to three threads at once) */
        case RME_SVC_THD_SCHED_PRIO:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Sched_Prio(Cpt,
801610c4:	e51be028 	ldr	lr, [fp, #-40]	@ 0xffffffd8
                                       Reg,                                 /* volatile struct RME_Reg_Struct* Reg */
                                       Cid,                                 /* rme_ptr_t Number */
                                       (rme_cid_t)RME_PARAM_D0(Param[0]),   /* rme_cid_t Cap_Thd0 */
801610c8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Sched_Prio(Cpt,
801610cc:	e6ff4073 	uxth	r4, r3
                                       RME_PARAM_D1(Param[0]),              /* rme_ptr_t Prio0 */
801610d0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Sched_Prio(Cpt,
801610d4:	e1a03823 	lsr	r3, r3, #16
                                       (rme_cid_t)RME_PARAM_D0(Param[1]),   /* rme_cid_t Cap_Thd1 */
801610d8:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Thd_Sched_Prio(Cpt,
801610dc:	e6ff2072 	uxth	r2, r2
                                       RME_PARAM_D1(Param[1]),              /* rme_ptr_t Prio1 */
801610e0:	e51b1030 	ldr	r1, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Thd_Sched_Prio(Cpt,
801610e4:	e1a01821 	lsr	r1, r1, #16
                                       (rme_cid_t)RME_PARAM_D0(Param[2]),   /* rme_cid_t Cap_Thd2 */
801610e8:	e51b002c 	ldr	r0, [fp, #-44]	@ 0xffffffd4
            Retval=_RME_Thd_Sched_Prio(Cpt,
801610ec:	e6ff0070 	uxth	r0, r0
                                       RME_PARAM_D1(Param[2]));             /* rme_ptr_t Prio2 */
801610f0:	e51bc02c 	ldr	ip, [fp, #-44]	@ 0xffffffd4
            Retval=_RME_Thd_Sched_Prio(Cpt,
801610f4:	e1a0c82c 	lsr	ip, ip, #16
801610f8:	e58dc010 	str	ip, [sp, #16]
801610fc:	e58d000c 	str	r0, [sp, #12]
80161100:	e58d1008 	str	r1, [sp, #8]
80161104:	e58d2004 	str	r2, [sp, #4]
80161108:	e58d3000 	str	r3, [sp]
8016110c:	e1a03004 	mov	r3, r4
80161110:	e1a0200e 	mov	r2, lr
80161114:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80161118:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016111c:	eb0020de 	bl	8016949c <_RME_Thd_Sched_Prio>
80161120:	e50b0010 	str	r0, [fp, #-16]
            RME_SWITCH_RETURN(Reg,Retval);
80161124:	e51b3010 	ldr	r3, [fp, #-16]
80161128:	e3530000 	cmp	r3, #0
8016112c:	aa00016b 	bge	801616e0 <_RME_Svc_Handler+0x8c4>
80161130:	e51b1010 	ldr	r1, [fp, #-16]
80161134:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80161138:	eb0031e8 	bl	8016d8e0 <__RME_Svc_Retval_Set>
8016113c:	ea000167 	b	801616e0 <_RME_Svc_Handler+0x8c4>
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Time_Xfer(Cpt,
                                      Reg,                                  /* volatile struct RME_Reg_Struct* Reg */
                                      (rme_cid_t)Param[0],                  /* rme_cid_t Cap_Thd_Dst */
80161140:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Time_Xfer(Cpt,
80161144:	e1a02003 	mov	r2, r3
                                      (rme_cid_t)Param[1],                  /* rme_cid_t Cap_Thd_Src */
80161148:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Thd_Time_Xfer(Cpt,
8016114c:	e1a01003 	mov	r1, r3
80161150:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161154:	e58d3000 	str	r3, [sp]
80161158:	e1a03001 	mov	r3, r1
8016115c:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80161160:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161164:	eb0022b0 	bl	80169c2c <_RME_Thd_Time_Xfer>
80161168:	e50b0010 	str	r0, [fp, #-16]
                                      Param[2]);                            /* rme_ptr_t Time */
            RME_SWITCH_RETURN(Reg,Retval);
8016116c:	e51b3010 	ldr	r3, [fp, #-16]
80161170:	e3530000 	cmp	r3, #0
80161174:	aa000159 	bge	801616e0 <_RME_Svc_Handler+0x8c4>
80161178:	e51b1010 	ldr	r1, [fp, #-16]
8016117c:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
80161180:	eb0031d6 	bl	8016d8e0 <__RME_Svc_Retval_Set>
80161184:	ea000155 	b	801616e0 <_RME_Svc_Handler+0x8c4>
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Swt(Cpt,
                                Reg,                                        /* volatile struct RME_Reg_Struct* Reg */
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Thd */
80161188:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Swt(Cpt,
8016118c:	e1a02003 	mov	r2, r3
80161190:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80161194:	e51b1038 	ldr	r1, [fp, #-56]	@ 0xffffffc8
80161198:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016119c:	eb00242c 	bl	8016a254 <_RME_Thd_Swt>
801611a0:	e50b0010 	str	r0, [fp, #-16]
                                Param[1]);                                  /* rme_ptr_t Full_Yield */
            RME_SWITCH_RETURN(Reg,Retval);
801611a4:	e51b3010 	ldr	r3, [fp, #-16]
801611a8:	e3530000 	cmp	r3, #0
801611ac:	aa00014b 	bge	801616e0 <_RME_Svc_Handler+0x8c4>
801611b0:	e51b1010 	ldr	r1, [fp, #-16]
801611b4:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
801611b8:	eb0031c8 	bl	8016d8e0 <__RME_Svc_Retval_Set>
801611bc:	ea000147 	b	801616e0 <_RME_Svc_Handler+0x8c4>
        }
        default:
        {
            RME_COV_MARKER();
            break;
801611c0:	e320f000 	nop	{0}
        }
    } 

    /* It is guaranteed that these functions will never cause a context switch */
    switch(Svc_Num)
801611c4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801611c8:	e243200a 	sub	r2, r3, #10
801611cc:	e59f3518 	ldr	r3, [pc, #1304]	@ 801616ec <_RME_Svc_Handler+0x8d0>
801611d0:	e3520017 	cmp	r2, #23
801611d4:	8a00013b 	bhi	801616c8 <_RME_Svc_Handler+0x8ac>
801611d8:	e793f102 	ldr	pc, [r3, r2, lsl #2]
801611dc:	e320f000 	nop	{0}
    {
        /* Capability table */
        case RME_SVC_CPT_CRT:
        {
            RME_COV_MARKER();
            Retval=_RME_Cpt_Crt(Cpt,
801611e0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801611e4:	e1a00003 	mov	r0, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt_Crt */
                                (rme_cid_t)RME_PARAM_D1(Param[0]),          /* rme_cid_t Cap_Kom */
801611e8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801611ec:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Cpt_Crt(Cpt,
801611f0:	e1a0c003 	mov	ip, r3
                                (rme_cid_t)RME_PARAM_D0(Param[0]),          /* rme_cid_t Cap_Crt */
801611f4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Cpt_Crt(Cpt,
801611f8:	e6ff1073 	uxth	r1, r3
801611fc:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80161200:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
80161204:	e58d2004 	str	r2, [sp, #4]
80161208:	e58d3000 	str	r3, [sp]
8016120c:	e1a03001 	mov	r3, r1
80161210:	e1a0200c 	mov	r2, ip
80161214:	e1a01000 	mov	r1, r0
80161218:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016121c:	eb0001a4 	bl	801618b4 <_RME_Cpt_Crt>
80161220:	e50b0010 	str	r0, [fp, #-16]
                                Param[1],                                   /* rme_ptr_t Raddr */
                                Param[2]);                                  /* rme_ptr_t Entry_Num */
            break;
80161224:	ea00012a 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        }
        case RME_SVC_CPT_DEL:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Cpt_Del(Cpt,
80161228:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016122c:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt_Del */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Cpt */
80161230:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Cpt_Del(Cpt,
80161234:	e1a02003 	mov	r2, r3
80161238:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016123c:	eb0002ec 	bl	80161df4 <_RME_Cpt_Del>
80161240:	e50b0010 	str	r0, [fp, #-16]
            break;
80161244:	ea000122 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        }
        case RME_SVC_CPT_FRZ:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Cpt_Frz(Cpt,
80161248:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016124c:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt_Frz */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Frz */
80161250:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Cpt_Frz(Cpt,
80161254:	e1a02003 	mov	r2, r3
80161258:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016125c:	eb0003da 	bl	801621cc <_RME_Cpt_Frz>
80161260:	e50b0010 	str	r0, [fp, #-16]
            break;
80161264:	ea00011a 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        case RME_SVC_CPT_ADD:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Cpt_Add(Cpt,
                                (rme_cid_t)RME_PARAM_D1(Param[0]),          /* rme_cid_t Cap_Cpt_Dst */
80161268:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
8016126c:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Cpt_Add(Cpt,
80161270:	e1a0e003 	mov	lr, r3
                                (rme_cid_t)RME_PARAM_D0(Param[0]),          /* rme_cid_t Cap_Dst */
80161274:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Cpt_Add(Cpt,
80161278:	e6ffc073 	uxth	ip, r3
                                (rme_cid_t)RME_PARAM_D1(Param[1]),          /* rme_cid_t Cap_Cpt_Src */
8016127c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80161280:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Cpt_Add(Cpt,
80161284:	e1a04003 	mov	r4, r3
                                (rme_cid_t)RME_PARAM_D0(Param[1]),          /* rme_cid_t Cap_Src */
80161288:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Cpt_Add(Cpt,
8016128c:	e6ff3073 	uxth	r3, r3
80161290:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
                                Param[2],                                   /* rme_ptr_t Flag */
                                RME_PARAM_KM(Svc,Cid));                     /* rme_ptr_t Ext_Flag */
80161294:	e51b1024 	ldr	r1, [fp, #-36]	@ 0xffffffdc
80161298:	e1a00801 	lsl	r0, r1, #16
            Retval=_RME_Cpt_Add(Cpt,
8016129c:	e51b1028 	ldr	r1, [fp, #-40]	@ 0xffffffd8
801612a0:	e1801001 	orr	r1, r0, r1
801612a4:	e58d1008 	str	r1, [sp, #8]
801612a8:	e58d2004 	str	r2, [sp, #4]
801612ac:	e58d3000 	str	r3, [sp]
801612b0:	e1a03004 	mov	r3, r4
801612b4:	e1a0200c 	mov	r2, ip
801612b8:	e1a0100e 	mov	r1, lr
801612bc:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801612c0:	eb000471 	bl	8016248c <_RME_Cpt_Add>
801612c4:	e50b0010 	str	r0, [fp, #-16]
            break;
801612c8:	ea000101 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        }
        case RME_SVC_CPT_REM:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Cpt_Rem(Cpt,
801612cc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801612d0:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt_Rem */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Rem */
801612d4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Cpt_Rem(Cpt,
801612d8:	e1a02003 	mov	r2, r3
801612dc:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801612e0:	eb000681 	bl	80162cec <_RME_Cpt_Rem>
801612e4:	e50b0010 	str	r0, [fp, #-16]
            break;
801612e8:	ea0000f9 	b	801616d4 <_RME_Svc_Handler+0x8b8>
#if(RME_PGT_RAW_ENABLE==0U)
        case RME_SVC_PGT_CRT:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Pgt_Crt(Cpt,
801612ec:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801612f0:	e1a04003 	mov	r4, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)RME_PARAM_D1(Param[0]),          /* rme_cid_t Cap_Kom */
801612f4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801612f8:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Pgt_Crt(Cpt,
801612fc:	e1a05003 	mov	r5, r3
                                (rme_cid_t)RME_PARAM_Q1(Param[0]),          /* rme_cid_t Cap_Pgt */
80161300:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80161304:	e1a03423 	lsr	r3, r3, #8
            Retval=_RME_Pgt_Crt(Cpt,
80161308:	e6efe073 	uxtb	lr, r3
8016130c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
                                Param[1],                                   /* rme_ptr_t Raddr */
                                Param[2]&RME_MASK_BEGIN(1U),                /* rme_ptr_t Base */
80161310:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
            Retval=_RME_Pgt_Crt(Cpt,
80161314:	e3c22001 	bic	r2, r2, #1
                                RME_PARAM_PT(Param[2]),                     /* rme_ptr_t Is_Top */
80161318:	e51b102c 	ldr	r1, [fp, #-44]	@ 0xffffffd4
            Retval=_RME_Pgt_Crt(Cpt,
8016131c:	e2011001 	and	r1, r1, #1
                                RME_PARAM_Q0(Param[0]),                     /* rme_ptr_t Size_Order */
80161320:	e51b0034 	ldr	r0, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Pgt_Crt(Cpt,
80161324:	e6ef0070 	uxtb	r0, r0
80161328:	e51bc024 	ldr	ip, [fp, #-36]	@ 0xffffffdc
8016132c:	e1a0c42c 	lsr	ip, ip, #8
80161330:	e58dc010 	str	ip, [sp, #16]
80161334:	e58d000c 	str	r0, [sp, #12]
80161338:	e58d1008 	str	r1, [sp, #8]
8016133c:	e58d2004 	str	r2, [sp, #4]
80161340:	e58d3000 	str	r3, [sp]
80161344:	e1a0300e 	mov	r3, lr
80161348:	e1a02005 	mov	r2, r5
8016134c:	e1a01004 	mov	r1, r4
80161350:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161354:	eb000896 	bl	801635b4 <_RME_Pgt_Crt>
80161358:	e50b0010 	str	r0, [fp, #-16]
                                RME_PARAM_PC(Svc));                         /* rme_ptr_t Num_Order */
            break;
8016135c:	ea0000dc 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        }
        case RME_SVC_PGT_DEL:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Pgt_Del(Cpt,
80161360:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161364:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Pgt */
80161368:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Pgt_Del(Cpt,
8016136c:	e1a02003 	mov	r2, r3
80161370:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161374:	eb0009f5 	bl	80163b50 <_RME_Pgt_Del>
80161378:	e50b0010 	str	r0, [fp, #-16]
            break;
8016137c:	ea0000d4 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        case RME_SVC_PGT_ADD:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Pgt_Add(Cpt,
                                (rme_cid_t)RME_PARAM_D1(Param[0]),          /* rme_cid_t Cap_Pgt_Dst */
80161380:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80161384:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Pgt_Add(Cpt,
80161388:	e1a0e003 	mov	lr, r3
                                RME_PARAM_D0(Param[0]),                     /* rme_ptr_t Pos_Dst */
8016138c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Pgt_Add(Cpt,
80161390:	e6ff1073 	uxth	r1, r3
80161394:	e51b0028 	ldr	r0, [fp, #-40]	@ 0xffffffd8
                                Cid,                                        /* rme_ptr_t Flag_Dst */
                                (rme_cid_t)RME_PARAM_D1(Param[1]),          /* rme_cid_t Cap_Pgt_Src */
80161398:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016139c:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Pgt_Add(Cpt,
801613a0:	e1a0c003 	mov	ip, r3
                                RME_PARAM_D0(Param[1]),                     /* rme_ptr_t Pos_Src */
801613a4:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Pgt_Add(Cpt,
801613a8:	e6ff3073 	uxth	r3, r3
801613ac:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
801613b0:	e58d2008 	str	r2, [sp, #8]
801613b4:	e58d3004 	str	r3, [sp, #4]
801613b8:	e58dc000 	str	ip, [sp]
801613bc:	e1a03000 	mov	r3, r0
801613c0:	e1a02001 	mov	r2, r1
801613c4:	e1a0100e 	mov	r1, lr
801613c8:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801613cc:	eb000ac6 	bl	80163eec <_RME_Pgt_Add>
801613d0:	e50b0010 	str	r0, [fp, #-16]
                                Param[2]);                                  /* rme_ptr_t Index */
            break;
801613d4:	ea0000be 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        case RME_SVC_PGT_REM:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Pgt_Rem(Cpt,
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Pgt */
801613d8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Pgt_Rem(Cpt,
801613dc:	e1a01003 	mov	r1, r3
801613e0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801613e4:	e1a02003 	mov	r2, r3
801613e8:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801613ec:	eb000bfa 	bl	801643dc <_RME_Pgt_Rem>
801613f0:	e50b0010 	str	r0, [fp, #-16]
                                Param[1]);                                  /* rme_ptr_t Pos */
            break;
801613f4:	ea0000b6 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        case RME_SVC_PGT_CON:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Pgt_Con(Cpt,
                                (rme_cid_t)RME_PARAM_D1(Param[0]),          /* rme_cid_t Cap_Pgt_Parent */
801613f8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801613fc:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Pgt_Con(Cpt,
80161400:	e1a00003 	mov	r0, r3
80161404:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
                                Param[1],                                   /* rme_ptr_t Pos */
                                (rme_cid_t)RME_PARAM_D0(Param[0]),          /* rme_cid_t Cap_Pgt_Child */
80161408:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Pgt_Con(Cpt,
8016140c:	e6ff1073 	uxth	r1, r3
80161410:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161414:	e58d3000 	str	r3, [sp]
80161418:	e1a03001 	mov	r3, r1
8016141c:	e1a01000 	mov	r1, r0
80161420:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161424:	eb000c77 	bl	80164608 <_RME_Pgt_Con>
80161428:	e50b0010 	str	r0, [fp, #-16]
                                Param[2]);                                  /* rme_ptr_t Flag_Child */
            break;
8016142c:	ea0000a8 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        case RME_SVC_PGT_DES:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Pgt_Des(Cpt,
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Pgt_Parent */
80161430:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Pgt_Des(Cpt,
80161434:	e1a01003 	mov	r1, r3
80161438:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
                                Param[1],                                   /* rme_ptr_t Pos */
                                (rme_cid_t)Param[2]);                       /* rme_cid_t Cap_Pgt_Child */
8016143c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
            Retval=_RME_Pgt_Des(Cpt,
80161440:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161444:	eb000d99 	bl	80164ab0 <_RME_Pgt_Des>
80161448:	e50b0010 	str	r0, [fp, #-16]
            break;
8016144c:	ea0000a0 	b	801616d4 <_RME_Svc_Handler+0x8b8>
#endif
        /* Process */
        case RME_SVC_PRC_CRT:
        {
#if(RME_PGT_RAW_ENABLE==0U)
            Retval=_RME_Prc_Crt(Cpt,
80161450:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161454:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt_Crt */
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Prc */
80161458:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Prc_Crt(Cpt,
8016145c:	e1a02003 	mov	r2, r3
                                (rme_cid_t)Param[1],                        /* rme_cid_t Cap_Cpt */
80161460:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Prc_Crt(Cpt,
80161464:	e1a00003 	mov	r0, r3
                                (rme_cid_t)Param[2]);                       /* rme_cid_t Cap_Pgt */
80161468:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
            Retval=_RME_Prc_Crt(Cpt,
8016146c:	e58d3000 	str	r3, [sp]
80161470:	e1a03000 	mov	r3, r0
80161474:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161478:	eb0013bf 	bl	8016637c <_RME_Prc_Crt>
8016147c:	e50b0010 	str	r0, [fp, #-16]
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt_Crt */
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Prc */
                                (rme_cid_t)Param[1],                        /* rme_cid_t Cap_Cpt */
                                (rme_ptr_t)Param[2]);                       /* rme_ptr_t Raw_Pgt */
#endif
            break;
80161480:	ea000093 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        }
        case RME_SVC_PRC_DEL:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Prc_Del(Cpt,
80161484:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161488:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Prc */
8016148c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Prc_Del(Cpt,
80161490:	e1a02003 	mov	r2, r3
80161494:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161498:	eb001541 	bl	801669a4 <_RME_Prc_Del>
8016149c:	e50b0010 	str	r0, [fp, #-16]
            break;
801614a0:	ea00008b 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        case RME_SVC_PRC_CPT:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Prc_Cpt(Cpt,
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Prc */
801614a4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Prc_Cpt(Cpt,
801614a8:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Param[1]);                       /* rme_cid_t Cap_Cpt */
801614ac:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Prc_Cpt(Cpt,
801614b0:	e1a02003 	mov	r2, r3
801614b4:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801614b8:	eb00160a 	bl	80166ce8 <_RME_Prc_Cpt>
801614bc:	e50b0010 	str	r0, [fp, #-16]
            break;
801614c0:	ea000083 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        case RME_SVC_PRC_PGT:
        {
            RME_COV_MARKER();
#if(RME_PGT_RAW_ENABLE==0U)
            Retval=_RME_Prc_Pgt(Cpt,
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Prc */
801614c4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Prc_Pgt(Cpt,
801614c8:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Param[1]);                       /* rme_cid_t Cap_Pgt */
801614cc:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Prc_Pgt(Cpt,
801614d0:	e1a02003 	mov	r2, r3
801614d4:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801614d8:	eb0016fa 	bl	801670c8 <_RME_Prc_Pgt>
801614dc:	e50b0010 	str	r0, [fp, #-16]
#else
            Retval=_RME_Prc_Pgt(Cpt,
                                (rme_cid_t)Param[0],                        /* rme_cid_t Cap_Prc */
                                Param[1]);                                  /* rme_ptr_t Raw_Pgt */
#endif
            break;
801614e0:	ea00007b 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        /* Thread */
        case RME_SVC_THD_CRT:
        {
            RME_COV_MARKER();

            Retval=_RME_Thd_Crt(Cpt,
801614e4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801614e8:	e1a04003 	mov	r4, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)RME_PARAM_D1(Param[0]),          /* rme_cid_t Cap_Kom */
801614ec:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801614f0:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Thd_Crt(Cpt,
801614f4:	e1a05003 	mov	r5, r3
                                (rme_cid_t)RME_PARAM_D0(Param[0]),          /* rme_cid_t Cap_Thd */
801614f8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Crt(Cpt,
801614fc:	e6ffc073 	uxth	ip, r3
                                (rme_cid_t)RME_PARAM_D1(Param[1]),          /* rme_cid_t Cap_Prc */
80161500:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80161504:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Thd_Crt(Cpt,
80161508:	e1a0e003 	mov	lr, r3
                                RME_PARAM_D0(Param[1]),                     /* rme_ptr_t Prio_Max */
8016150c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Thd_Crt(Cpt,
80161510:	e6ff3073 	uxth	r3, r3
80161514:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
80161518:	e51b1024 	ldr	r1, [fp, #-36]	@ 0xffffffdc
8016151c:	e1a013a1 	lsr	r1, r1, #7
80161520:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
80161524:	e2000040 	and	r0, r0, #64	@ 0x40
80161528:	e58d0010 	str	r0, [sp, #16]
8016152c:	e58d100c 	str	r1, [sp, #12]
80161530:	e58d2008 	str	r2, [sp, #8]
80161534:	e58d3004 	str	r3, [sp, #4]
80161538:	e58de000 	str	lr, [sp]
8016153c:	e1a0300c 	mov	r3, ip
80161540:	e1a02005 	mov	r2, r5
80161544:	e1a01004 	mov	r1, r4
80161548:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016154c:	eb001931 	bl	80167a18 <_RME_Thd_Crt>
80161550:	e50b0010 	str	r0, [fp, #-16]
                                Param[2],                                   /* rme_ptr_t Raddr */
                                Svc>>7,                                     /* rme_ptr_t Attr */
                                Svc&0x40U);                                 /* rme_ptr_t Is_Hyp */
            break;
80161554:	ea00005e 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        }
        case RME_SVC_THD_DEL:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Del(Cpt,
80161558:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016155c:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Thd */
80161560:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Del(Cpt,
80161564:	e1a02003 	mov	r2, r3
80161568:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016156c:	eb001b2a 	bl	8016821c <_RME_Thd_Del>
80161570:	e50b0010 	str	r0, [fp, #-16]
            break;
80161574:	ea000056 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        }
        case RME_SVC_THD_SCHED_BIND:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Sched_Bind(Cpt,
80161578:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016157c:	e1a0c003 	mov	ip, r3
                                       (rme_cid_t)Cid,                      /* rme_cid_t Cap_Thd */
                                       (rme_cid_t)RME_PARAM_D1(Param[0]),   /* rme_cid_t Cap_Thd_Sched */
80161580:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80161584:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Thd_Sched_Bind(Cpt,
80161588:	e1a0e003 	mov	lr, r3
                                       (rme_cid_t)RME_PARAM_D0(Param[0]),   /* rme_cid_t Cap_Sig */
8016158c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Sched_Bind(Cpt,
80161590:	e6ff1073 	uxth	r1, r3
                                       (rme_tid_t)RME_PARAM_D1(Param[1]),   /* rme_tid_t TID */
80161594:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80161598:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Thd_Sched_Bind(Cpt,
8016159c:	e1a00003 	mov	r0, r3
                                       RME_PARAM_D0(Param[1]),              /* rme_ptr_t Prio */
801615a0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Thd_Sched_Bind(Cpt,
801615a4:	e6ff3073 	uxth	r3, r3
801615a8:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
801615ac:	e58d2008 	str	r2, [sp, #8]
801615b0:	e58d3004 	str	r3, [sp, #4]
801615b4:	e58d0000 	str	r0, [sp]
801615b8:	e1a03001 	mov	r3, r1
801615bc:	e1a0200e 	mov	r2, lr
801615c0:	e1a0100c 	mov	r1, ip
801615c4:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801615c8:	eb001c32 	bl	80168698 <_RME_Thd_Sched_Bind>
801615cc:	e50b0010 	str	r0, [fp, #-16]
                                       Param[2]);                           /* rme_ptr_t Haddr */
            break;
801615d0:	ea00003f 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        case RME_SVC_THD_SCHED_RCV:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Thd_Sched_Rcv(Cpt,
                                      (rme_cid_t)Param[0]);                 /* rme_cid_t Cap_Thd */
801615d4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Thd_Sched_Rcv(Cpt,
801615d8:	e1a01003 	mov	r1, r3
801615dc:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801615e0:	eb0020e6 	bl	80169980 <_RME_Thd_Sched_Rcv>
801615e4:	e50b0010 	str	r0, [fp, #-16]
            break;
801615e8:	ea000039 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        /* Signal */
        case RME_SVC_SIG_CRT:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Sig_Crt(Cpt,
801615ec:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801615f0:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Sig */
801615f4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Sig_Crt(Cpt,
801615f8:	e1a02003 	mov	r2, r3
801615fc:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161600:	eb0024be 	bl	8016a900 <_RME_Sig_Crt>
80161604:	e50b0010 	str	r0, [fp, #-16]
            break;
80161608:	ea000031 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        }
        case RME_SVC_SIG_DEL:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Sig_Del(Cpt,
8016160c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161610:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Sig */
80161614:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Sig_Del(Cpt,
80161618:	e1a02003 	mov	r2, r3
8016161c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80161620:	eb002555 	bl	8016ab7c <_RME_Sig_Del>
80161624:	e50b0010 	str	r0, [fp, #-16]
            break;
80161628:	ea000029 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        /* Invocation */
        case RME_SVC_INV_CRT:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Inv_Crt(Cpt,
8016162c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161630:	e1a00003 	mov	r0, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)RME_PARAM_D1(Param[0]),          /* rme_cid_t Cap_Kom */
80161634:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80161638:	e1a03823 	lsr	r3, r3, #16
            Retval=_RME_Inv_Crt(Cpt,
8016163c:	e1a0c003 	mov	ip, r3
                                (rme_cid_t)RME_PARAM_D0(Param[0]),          /* rme_cid_t Cap_Inv */
80161640:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Inv_Crt(Cpt,
80161644:	e6ff2073 	uxth	r2, r3
                                (rme_cid_t)Param[1],                        /* rme_cid_t Cap_Prc */
80161648:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
            Retval=_RME_Inv_Crt(Cpt,
8016164c:	e1a01003 	mov	r1, r3
80161650:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161654:	e58d3004 	str	r3, [sp, #4]
80161658:	e58d1000 	str	r1, [sp]
8016165c:	e1a03002 	mov	r3, r2
80161660:	e1a0200c 	mov	r2, ip
80161664:	e1a01000 	mov	r1, r0
80161668:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016166c:	eb002866 	bl	8016b80c <_RME_Inv_Crt>
80161670:	e50b0010 	str	r0, [fp, #-16]
                                Param[2]);                                  /* rme_ptr_t Raddr */
            break;
80161674:	ea000016 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        }
        case RME_SVC_INV_DEL:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Inv_Del(Cpt,
80161678:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016167c:	e1a01003 	mov	r1, r3
                                (rme_cid_t)Cid,                             /* rme_cid_t Cap_Cpt */
                                (rme_cid_t)Param[0]);                       /* rme_cid_t Cap_Inv */
80161680:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Inv_Del(Cpt,
80161684:	e1a02003 	mov	r2, r3
80161688:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016168c:	eb002a09 	bl	8016beb8 <_RME_Inv_Del>
80161690:	e50b0010 	str	r0, [fp, #-16]
            break;
80161694:	ea00000e 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        case RME_SVC_INV_SET:
        {
            RME_COV_MARKER();
            
            Retval=_RME_Inv_Set(Cpt,
                                (rme_cid_t)RME_PARAM_D0(Param[0]),          /* rme_cid_t Cap_Inv */
80161698:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Inv_Set(Cpt,
8016169c:	e6ff1073 	uxth	r1, r3
801616a0:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
801616a4:	e51b002c 	ldr	r0, [fp, #-44]	@ 0xffffffd4
                                Param[1],                                   /* rme_ptr_t Entry */
                                Param[2],                                   /* rme_ptr_t Stack */
                                RME_PARAM_D1(Param[0]));                    /* rme_ptr_t Is_Exc_Ret */
801616a8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
            Retval=_RME_Inv_Set(Cpt,
801616ac:	e1a03823 	lsr	r3, r3, #16
801616b0:	e58d3000 	str	r3, [sp]
801616b4:	e1a03000 	mov	r3, r0
801616b8:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801616bc:	eb002ae3 	bl	8016c250 <_RME_Inv_Set>
801616c0:	e50b0010 	str	r0, [fp, #-16]
            break;
801616c4:	ea000002 	b	801616d4 <_RME_Svc_Handler+0x8b8>
        /* This is an error */
        default: 
        {
            RME_COV_MARKER();
            
            Retval=RME_ERR_CPT_NULL;
801616c8:	e3e03000 	mvn	r3, #0
801616cc:	e50b3010 	str	r3, [fp, #-16]
            break;
801616d0:	e320f000 	nop	{0}
        }
    }
    
    /* We set the registers and return */
    __RME_Svc_Retval_Set(Reg,Retval);
801616d4:	e51b1010 	ldr	r1, [fp, #-16]
801616d8:	e51b0038 	ldr	r0, [fp, #-56]	@ 0xffffffc8
801616dc:	eb00307f 	bl	8016d8e0 <__RME_Svc_Retval_Set>
}
801616e0:	e24bd00c 	sub	sp, fp, #12
801616e4:	e8bd8830 	pop	{r4, r5, fp, pc}
801616e8:	8016e9e8 	.word	0x8016e9e8
801616ec:	8016ea08 	.word	0x8016ea08

801616f0 <_RME_Tim_Handler>:
Output      : struct RME_Reg_Struct* Reg - The updated register set.
Return      : None.
******************************************************************************/
void _RME_Tim_Handler(struct RME_Reg_Struct* Reg,
                      rme_ptr_t Slice)
{
801616f0:	e92d4800 	push	{fp, lr}
801616f4:	e28db004 	add	fp, sp, #4
801616f8:	e24dd010 	sub	sp, sp, #16
801616fc:	e50b0010 	str	r0, [fp, #-16]
80161700:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
    struct RME_CPU_Local* Local;
    struct RME_Thd_Struct* Thd_Cur;
    
    Local=RME_CPU_LOCAL();
80161704:	e3003004 	movw	r3, #4
80161708:	e3483017 	movt	r3, #32791	@ 0x8017
8016170c:	e50b3008 	str	r3, [fp, #-8]
    Thd_Cur=Local->Thd_Cur;
80161710:	e51b3008 	ldr	r3, [fp, #-8]
80161714:	e5933004 	ldr	r3, [r3, #4]
80161718:	e50b300c 	str	r3, [fp, #-12]
    if(Thd_Cur->Sched.Slice<RME_THD_INF_TIME)
8016171c:	e51b300c 	ldr	r3, [fp, #-12]
80161720:	e5933018 	ldr	r3, [r3, #24]
80161724:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
80161728:	8a000015 	bhi	80161784 <_RME_Tim_Handler+0x94>
    {
        RME_COV_MARKER();

        /* Decrease timeslice count, and see if the timeslice is used up */
        if(Slice<Thd_Cur->Sched.Slice)
8016172c:	e51b300c 	ldr	r3, [fp, #-12]
80161730:	e5933018 	ldr	r3, [r3, #24]
80161734:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80161738:	e1520003 	cmp	r2, r3
8016173c:	2a000006 	bcs	8016175c <_RME_Tim_Handler+0x6c>
        {
            RME_COV_MARKER();
            
            Thd_Cur->Sched.Slice-=Slice;
80161740:	e51b300c 	ldr	r3, [fp, #-12]
80161744:	e5932018 	ldr	r2, [r3, #24]
80161748:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016174c:	e0422003 	sub	r2, r2, r3
80161750:	e51b300c 	ldr	r3, [fp, #-12]
80161754:	e5832018 	str	r2, [r3, #24]
80161758:	ea000009 	b	80161784 <_RME_Tim_Handler+0x94>
        else
        {
            RME_COV_MARKER();

            /* Deprive all timeslices and remove from runqueue */
            Thd_Cur->Sched.Slice=0U;
8016175c:	e51b300c 	ldr	r3, [fp, #-12]
80161760:	e3a02000 	mov	r2, #0
80161764:	e5832018 	str	r2, [r3, #24]
            _RME_Run_Del(Thd_Cur);
80161768:	e51b000c 	ldr	r0, [fp, #-12]
8016176c:	eb001087 	bl	80165990 <_RME_Run_Del>
            
            /* Timeout and notify parent */
            Thd_Cur->Sched.State=RME_THD_TIMEOUT;
80161770:	e51b300c 	ldr	r3, [fp, #-12]
80161774:	e3a02002 	mov	r2, #2
80161778:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Notif(Thd_Cur);
8016177c:	e51b000c 	ldr	r0, [fp, #-12]
80161780:	eb0010f6 	bl	80165b60 <_RME_Run_Notif>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Send to the system tick timer endpoint. This endpoint is per-core */
    _RME_Kern_Snd(Local->Sig_Tim);
80161784:	e51b3008 	ldr	r3, [fp, #-8]
80161788:	e5933008 	ldr	r3, [r3, #8]
8016178c:	e1a00003 	mov	r0, r3
80161790:	eb002605 	bl	8016afac <_RME_Kern_Snd>

    /* All kernel send complete, now pick the highest priority thread to run */
    _RME_Kern_High(Reg,Local);
80161794:	e51b1008 	ldr	r1, [fp, #-8]
80161798:	e51b0010 	ldr	r0, [fp, #-16]
8016179c:	eb0025c3 	bl	8016aeb0 <_RME_Kern_High>
}
801617a0:	e320f000 	nop	{0}
801617a4:	e24bd004 	sub	sp, fp, #4
801617a8:	e8bd8800 	pop	{fp, pc}

801617ac <_RME_Cpt_Boot_Init>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
rme_ret_t _RME_Cpt_Boot_Init(rme_cid_t Cap_Cpt,
                             rme_ptr_t Vaddr,
                             rme_ptr_t Entry_Num)
{
801617ac:	e92d4800 	push	{fp, lr}
801617b0:	e28db004 	add	fp, sp, #4
801617b4:	e24dd018 	sub	sp, sp, #24
801617b8:	e50b0010 	str	r0, [fp, #-16]
801617bc:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
801617c0:	e50b2018 	str	r2, [fp, #-24]	@ 0xffffffe8
    rme_ptr_t Count;
    struct RME_Cap_Cpt* Cpt;

    /* See if the entry number is too big */
    if((Entry_Num==0U)||(Entry_Num>RME_CID_2L))
801617c4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801617c8:	e3530000 	cmp	r3, #0
801617cc:	0a000002 	beq	801617dc <_RME_Cpt_Boot_Init+0x30>
801617d0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801617d4:	e3530080 	cmp	r3, #128	@ 0x80
801617d8:	9a000001 	bls	801617e4 <_RME_Cpt_Boot_Init+0x38>
    {
        RME_COV_MARKER();
        
        return RME_ERR_CPT_RANGE;
801617dc:	e3e03002 	mvn	r3, #2
801617e0:	ea000030 	b	801618a8 <_RME_Cpt_Boot_Init+0xfc>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Try to populate the area */
    if(_RME_Kot_Mark(Vaddr,RME_CPT_SIZE(Entry_Num))!=0)
801617e4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801617e8:	e1a03283 	lsl	r3, r3, #5
801617ec:	e1a01003 	mov	r1, r3
801617f0:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801617f4:	eb000de0 	bl	80164f7c <_RME_Kot_Mark>
801617f8:	e1a03000 	mov	r3, r0
801617fc:	e3530000 	cmp	r3, #0
80161800:	0a000001 	beq	8016180c <_RME_Cpt_Boot_Init+0x60>
    {
        RME_COV_MARKER();
        
        return RME_ERR_CPT_KOT;
80161804:	e3e03003 	mvn	r3, #3
80161808:	ea000026 	b	801618a8 <_RME_Cpt_Boot_Init+0xfc>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Object init */
    for(Count=0U;Count<Entry_Num;Count++)
8016180c:	e3a03000 	mov	r3, #0
80161810:	e50b3008 	str	r3, [fp, #-8]
80161814:	ea000009 	b	80161840 <_RME_Cpt_Boot_Init+0x94>
    {
        RME_CAP_CLEAR(&(((struct RME_Cap_Struct*)Vaddr)[Count]));
80161818:	e51b3008 	ldr	r3, [fp, #-8]
8016181c:	e1a02283 	lsl	r2, r3, #5
80161820:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161824:	e0823003 	add	r3, r2, r3
80161828:	e1a02003 	mov	r2, r3
8016182c:	e3a03000 	mov	r3, #0
80161830:	e5823000 	str	r3, [r2]
    for(Count=0U;Count<Entry_Num;Count++)
80161834:	e51b3008 	ldr	r3, [fp, #-8]
80161838:	e2833001 	add	r3, r3, #1
8016183c:	e50b3008 	str	r3, [fp, #-8]
80161840:	e51b2008 	ldr	r2, [fp, #-8]
80161844:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80161848:	e1520003 	cmp	r2, r3
8016184c:	3afffff1 	bcc	80161818 <_RME_Cpt_Boot_Init+0x6c>
    }

    Cpt=&(((struct RME_Cap_Cpt*)Vaddr)[Cap_Cpt]);
80161850:	e51b3010 	ldr	r3, [fp, #-16]
80161854:	e1a02283 	lsl	r2, r3, #5
80161858:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016185c:	e0823003 	add	r3, r2, r3
80161860:	e50b300c 	str	r3, [fp, #-12]
    
    /* Header init */
    Cpt->Head.Root_Ref=1U;
80161864:	e51b300c 	ldr	r3, [fp, #-12]
80161868:	e3a02001 	mov	r2, #1
8016186c:	e5832004 	str	r2, [r3, #4]
    Cpt->Head.Object=Vaddr;
80161870:	e51b300c 	ldr	r3, [fp, #-12]
80161874:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80161878:	e583200c 	str	r2, [r3, #12]
    Cpt->Head.Flag=RME_CPT_FLAG_ALL;
8016187c:	e51b300c 	ldr	r3, [fp, #-12]
80161880:	e3a020ff 	mov	r2, #255	@ 0xff
80161884:	e5832008 	str	r2, [r3, #8]
    
    /* Info init */
    Cpt->Entry_Num=Entry_Num;
80161888:	e51b300c 	ldr	r3, [fp, #-12]
8016188c:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80161890:	e5832014 	str	r2, [r3, #20]

    /* At last, write into slot the correct information, and set status to VALID */
    RME_WRITE_RELEASE(&(Cpt->Head.Type_Stat),
80161894:	e51b300c 	ldr	r3, [fp, #-12]
80161898:	e3a01403 	mov	r1, #50331648	@ 0x3000000
8016189c:	e1a00003 	mov	r0, r3
801618a0:	ebfffb99 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_CPT,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return Cap_Cpt;
801618a4:	e51b3010 	ldr	r3, [fp, #-16]
}
801618a8:	e1a00003 	mov	r0, r3
801618ac:	e24bd004 	sub	sp, fp, #4
801618b0:	e8bd8800 	pop	{fp, pc}

801618b4 <_RME_Cpt_Crt>:
                              rme_cid_t Cap_Cpt_Crt,
                              rme_cid_t Cap_Kom,
                              rme_cid_t Cap_Crt,
                              rme_ptr_t Raddr,
                              rme_ptr_t Entry_Num)
{
801618b4:	e92d4800 	push	{fp, lr}
801618b8:	e28db004 	add	fp, sp, #4
801618bc:	e24dd028 	sub	sp, sp, #40	@ 0x28
801618c0:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
801618c4:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
801618c8:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
801618cc:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
    volatile struct RME_Cap_Cpt* Cpt_Crt;
    rme_ptr_t Type_Stat;
    rme_ptr_t Vaddr;

    /* See if the entry number is too big */
    if((Entry_Num==0U)||(Entry_Num>RME_CID_2L))
801618d0:	e59b3008 	ldr	r3, [fp, #8]
801618d4:	e3530000 	cmp	r3, #0
801618d8:	0a000002 	beq	801618e8 <_RME_Cpt_Crt+0x34>
801618dc:	e59b3008 	ldr	r3, [fp, #8]
801618e0:	e3530080 	cmp	r3, #128	@ 0x80
801618e4:	9a000001 	bls	801618f0 <_RME_Cpt_Crt+0x3c>
    {
        RME_COV_MARKER();
        
        return RME_ERR_CPT_RANGE;
801618e8:	e3e03002 	mvn	r3, #2
801618ec:	ea00013d 	b	80161de8 <_RME_Cpt_Crt+0x534>
        /* No action required */
    }
#endif

    /* Get the cap location that we care about */
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Crt,RME_CAP_TYPE_CPT,
801618f0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801618f4:	e2033080 	and	r3, r3, #128	@ 0x80
801618f8:	e3530000 	cmp	r3, #0
801618fc:	1a00001c 	bne	80161974 <_RME_Cpt_Crt+0xc0>
80161900:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80161904:	e5932014 	ldr	r2, [r3, #20]
80161908:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016190c:	e1520003 	cmp	r2, r3
80161910:	8a000001 	bhi	8016191c <_RME_Cpt_Crt+0x68>
80161914:	e3e03002 	mvn	r3, #2
80161918:	ea000132 	b	80161de8 <_RME_Cpt_Crt+0x534>
8016191c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80161920:	e1a02283 	lsl	r2, r3, #5
80161924:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80161928:	e593300c 	ldr	r3, [r3, #12]
8016192c:	e0823003 	add	r3, r2, r3
80161930:	e50b300c 	str	r3, [fp, #-12]
80161934:	e51b300c 	ldr	r3, [fp, #-12]
80161938:	e1a00003 	mov	r0, r3
8016193c:	ebfffb6f 	bl	80160700 <__RME_A7A_Read_Acquire>
80161940:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80161944:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161948:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016194c:	e3530802 	cmp	r3, #131072	@ 0x20000
80161950:	1a000001 	bne	8016195c <_RME_Cpt_Crt+0xa8>
80161954:	e3e03008 	mvn	r3, #8
80161958:	ea000122 	b	80161de8 <_RME_Cpt_Crt+0x534>
8016195c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161960:	e1a03c23 	lsr	r3, r3, #24
80161964:	e3530003 	cmp	r3, #3
80161968:	0a00003f 	beq	80161a6c <_RME_Cpt_Crt+0x1b8>
8016196c:	e3e03001 	mvn	r3, #1
80161970:	ea00011c 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161974:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80161978:	e1a02423 	lsr	r2, r3, #8
8016197c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80161980:	e5933014 	ldr	r3, [r3, #20]
80161984:	e1520003 	cmp	r2, r3
80161988:	3a000001 	bcc	80161994 <_RME_Cpt_Crt+0xe0>
8016198c:	e3e03002 	mvn	r3, #2
80161990:	ea000114 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161994:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80161998:	e1a03423 	lsr	r3, r3, #8
8016199c:	e1a02283 	lsl	r2, r3, #5
801619a0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801619a4:	e593300c 	ldr	r3, [r3, #12]
801619a8:	e0823003 	add	r3, r2, r3
801619ac:	e50b300c 	str	r3, [fp, #-12]
801619b0:	e51b300c 	ldr	r3, [fp, #-12]
801619b4:	e1a00003 	mov	r0, r3
801619b8:	ebfffb50 	bl	80160700 <__RME_A7A_Read_Acquire>
801619bc:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801619c0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801619c4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801619c8:	e3530802 	cmp	r3, #131072	@ 0x20000
801619cc:	1a000001 	bne	801619d8 <_RME_Cpt_Crt+0x124>
801619d0:	e3e03008 	mvn	r3, #8
801619d4:	ea000103 	b	80161de8 <_RME_Cpt_Crt+0x534>
801619d8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801619dc:	e1a03c23 	lsr	r3, r3, #24
801619e0:	e3530003 	cmp	r3, #3
801619e4:	0a000001 	beq	801619f0 <_RME_Cpt_Crt+0x13c>
801619e8:	e3e03001 	mvn	r3, #1
801619ec:	ea0000fd 	b	80161de8 <_RME_Cpt_Crt+0x534>
801619f0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801619f4:	e203207f 	and	r2, r3, #127	@ 0x7f
801619f8:	e51b300c 	ldr	r3, [fp, #-12]
801619fc:	e5933014 	ldr	r3, [r3, #20]
80161a00:	e1520003 	cmp	r2, r3
80161a04:	3a000001 	bcc	80161a10 <_RME_Cpt_Crt+0x15c>
80161a08:	e3e03002 	mvn	r3, #2
80161a0c:	ea0000f5 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161a10:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80161a14:	e203307f 	and	r3, r3, #127	@ 0x7f
80161a18:	e1a02283 	lsl	r2, r3, #5
80161a1c:	e51b300c 	ldr	r3, [fp, #-12]
80161a20:	e593300c 	ldr	r3, [r3, #12]
80161a24:	e0823003 	add	r3, r2, r3
80161a28:	e50b300c 	str	r3, [fp, #-12]
80161a2c:	e51b300c 	ldr	r3, [fp, #-12]
80161a30:	e1a00003 	mov	r0, r3
80161a34:	ebfffb31 	bl	80160700 <__RME_A7A_Read_Acquire>
80161a38:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80161a3c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161a40:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80161a44:	e3530802 	cmp	r3, #131072	@ 0x20000
80161a48:	1a000001 	bne	80161a54 <_RME_Cpt_Crt+0x1a0>
80161a4c:	e3e03008 	mvn	r3, #8
80161a50:	ea0000e4 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161a54:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161a58:	e1a03c23 	lsr	r3, r3, #24
80161a5c:	e3530003 	cmp	r3, #3
80161a60:	0a000001 	beq	80161a6c <_RME_Cpt_Crt+0x1b8>
80161a64:	e3e03001 	mvn	r3, #1
80161a68:	ea0000de 	b	80161de8 <_RME_Cpt_Crt+0x534>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Kom,RME_CAP_TYPE_KOM,
80161a6c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161a70:	e2033080 	and	r3, r3, #128	@ 0x80
80161a74:	e3530000 	cmp	r3, #0
80161a78:	1a00001c 	bne	80161af0 <_RME_Cpt_Crt+0x23c>
80161a7c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80161a80:	e5932014 	ldr	r2, [r3, #20]
80161a84:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161a88:	e1520003 	cmp	r2, r3
80161a8c:	8a000001 	bhi	80161a98 <_RME_Cpt_Crt+0x1e4>
80161a90:	e3e03002 	mvn	r3, #2
80161a94:	ea0000d3 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161a98:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161a9c:	e1a02283 	lsl	r2, r3, #5
80161aa0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80161aa4:	e593300c 	ldr	r3, [r3, #12]
80161aa8:	e0823003 	add	r3, r2, r3
80161aac:	e50b3010 	str	r3, [fp, #-16]
80161ab0:	e51b3010 	ldr	r3, [fp, #-16]
80161ab4:	e1a00003 	mov	r0, r3
80161ab8:	ebfffb10 	bl	80160700 <__RME_A7A_Read_Acquire>
80161abc:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80161ac0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161ac4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80161ac8:	e3530802 	cmp	r3, #131072	@ 0x20000
80161acc:	1a000001 	bne	80161ad8 <_RME_Cpt_Crt+0x224>
80161ad0:	e3e03008 	mvn	r3, #8
80161ad4:	ea0000c3 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161ad8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161adc:	e1a03c23 	lsr	r3, r3, #24
80161ae0:	e3530002 	cmp	r3, #2
80161ae4:	0a00003f 	beq	80161be8 <_RME_Cpt_Crt+0x334>
80161ae8:	e3e03001 	mvn	r3, #1
80161aec:	ea0000bd 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161af0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161af4:	e1a02423 	lsr	r2, r3, #8
80161af8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80161afc:	e5933014 	ldr	r3, [r3, #20]
80161b00:	e1520003 	cmp	r2, r3
80161b04:	3a000001 	bcc	80161b10 <_RME_Cpt_Crt+0x25c>
80161b08:	e3e03002 	mvn	r3, #2
80161b0c:	ea0000b5 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161b10:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161b14:	e1a03423 	lsr	r3, r3, #8
80161b18:	e1a02283 	lsl	r2, r3, #5
80161b1c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80161b20:	e593300c 	ldr	r3, [r3, #12]
80161b24:	e0823003 	add	r3, r2, r3
80161b28:	e50b3010 	str	r3, [fp, #-16]
80161b2c:	e51b3010 	ldr	r3, [fp, #-16]
80161b30:	e1a00003 	mov	r0, r3
80161b34:	ebfffaf1 	bl	80160700 <__RME_A7A_Read_Acquire>
80161b38:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80161b3c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161b40:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80161b44:	e3530802 	cmp	r3, #131072	@ 0x20000
80161b48:	1a000001 	bne	80161b54 <_RME_Cpt_Crt+0x2a0>
80161b4c:	e3e03008 	mvn	r3, #8
80161b50:	ea0000a4 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161b54:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161b58:	e1a03c23 	lsr	r3, r3, #24
80161b5c:	e3530003 	cmp	r3, #3
80161b60:	0a000001 	beq	80161b6c <_RME_Cpt_Crt+0x2b8>
80161b64:	e3e03001 	mvn	r3, #1
80161b68:	ea00009e 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161b6c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161b70:	e203207f 	and	r2, r3, #127	@ 0x7f
80161b74:	e51b3010 	ldr	r3, [fp, #-16]
80161b78:	e5933014 	ldr	r3, [r3, #20]
80161b7c:	e1520003 	cmp	r2, r3
80161b80:	3a000001 	bcc	80161b8c <_RME_Cpt_Crt+0x2d8>
80161b84:	e3e03002 	mvn	r3, #2
80161b88:	ea000096 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161b8c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161b90:	e203307f 	and	r3, r3, #127	@ 0x7f
80161b94:	e1a02283 	lsl	r2, r3, #5
80161b98:	e51b3010 	ldr	r3, [fp, #-16]
80161b9c:	e593300c 	ldr	r3, [r3, #12]
80161ba0:	e0823003 	add	r3, r2, r3
80161ba4:	e50b3010 	str	r3, [fp, #-16]
80161ba8:	e51b3010 	ldr	r3, [fp, #-16]
80161bac:	e1a00003 	mov	r0, r3
80161bb0:	ebfffad2 	bl	80160700 <__RME_A7A_Read_Acquire>
80161bb4:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80161bb8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161bbc:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80161bc0:	e3530802 	cmp	r3, #131072	@ 0x20000
80161bc4:	1a000001 	bne	80161bd0 <_RME_Cpt_Crt+0x31c>
80161bc8:	e3e03008 	mvn	r3, #8
80161bcc:	ea000085 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161bd0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161bd4:	e1a03c23 	lsr	r3, r3, #24
80161bd8:	e3530002 	cmp	r3, #2
80161bdc:	0a000001 	beq	80161be8 <_RME_Cpt_Crt+0x334>
80161be0:	e3e03001 	mvn	r3, #1
80161be4:	ea00007f 	b	80161de8 <_RME_Cpt_Crt+0x534>
                   struct RME_Cap_Kom*,Kom_Op,Type_Stat);
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_CRT);
80161be8:	e51b300c 	ldr	r3, [fp, #-12]
80161bec:	e5933008 	ldr	r3, [r3, #8]
80161bf0:	e2033001 	and	r3, r3, #1
80161bf4:	e3530000 	cmp	r3, #0
80161bf8:	1a000001 	bne	80161c04 <_RME_Cpt_Crt+0x350>
80161bfc:	e3e03006 	mvn	r3, #6
80161c00:	ea000078 	b	80161de8 <_RME_Cpt_Crt+0x534>
    /* See if the creation is valid for this kmem range */
    RME_KOM_CHECK(Kom_Op,RME_KOM_FLAG_CPT,Raddr,Vaddr,RME_CPT_SIZE(Entry_Num));
80161c04:	e51b3010 	ldr	r3, [fp, #-16]
80161c08:	e5933008 	ldr	r3, [r3, #8]
80161c0c:	e2033001 	and	r3, r3, #1
80161c10:	e3530000 	cmp	r3, #0
80161c14:	1a000001 	bne	80161c20 <_RME_Cpt_Crt+0x36c>
80161c18:	e3e03006 	mvn	r3, #6
80161c1c:	ea000071 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161c20:	e51b3010 	ldr	r3, [fp, #-16]
80161c24:	e5933014 	ldr	r3, [r3, #20]
80161c28:	e59b2004 	ldr	r2, [fp, #4]
80161c2c:	e0823003 	add	r3, r2, r3
80161c30:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
80161c34:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80161c38:	e59b3004 	ldr	r3, [fp, #4]
80161c3c:	e1520003 	cmp	r2, r3
80161c40:	2a000001 	bcs	80161c4c <_RME_Cpt_Crt+0x398>
80161c44:	e3e03006 	mvn	r3, #6
80161c48:	ea000066 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161c4c:	e51b3010 	ldr	r3, [fp, #-16]
80161c50:	e5933014 	ldr	r3, [r3, #20]
80161c54:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80161c58:	e1520003 	cmp	r2, r3
80161c5c:	2a000001 	bcs	80161c68 <_RME_Cpt_Crt+0x3b4>
80161c60:	e3e03006 	mvn	r3, #6
80161c64:	ea00005f 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161c68:	e59b3008 	ldr	r3, [fp, #8]
80161c6c:	e1a02283 	lsl	r2, r3, #5
80161c70:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80161c74:	e0823003 	add	r3, r2, r3
80161c78:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80161c7c:	e1520003 	cmp	r2, r3
80161c80:	9a000001 	bls	80161c8c <_RME_Cpt_Crt+0x3d8>
80161c84:	e3e03006 	mvn	r3, #6
80161c88:	ea000056 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161c8c:	e51b3010 	ldr	r3, [fp, #-16]
80161c90:	e5932018 	ldr	r2, [r3, #24]
80161c94:	e59b3008 	ldr	r3, [fp, #8]
80161c98:	e1a01283 	lsl	r1, r3, #5
80161c9c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80161ca0:	e0813003 	add	r3, r1, r3
80161ca4:	e2433001 	sub	r3, r3, #1
80161ca8:	e1520003 	cmp	r2, r3
80161cac:	2a000001 	bcs	80161cb8 <_RME_Cpt_Crt+0x404>
80161cb0:	e3e03006 	mvn	r3, #6
80161cb4:	ea00004b 	b	80161de8 <_RME_Cpt_Crt+0x534>

    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Crt,struct RME_Cap_Cpt*,Cpt_Crt);
80161cb8:	e51b300c 	ldr	r3, [fp, #-12]
80161cbc:	e5932014 	ldr	r2, [r3, #20]
80161cc0:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161cc4:	e1520003 	cmp	r2, r3
80161cc8:	8a000001 	bhi	80161cd4 <_RME_Cpt_Crt+0x420>
80161ccc:	e3e03002 	mvn	r3, #2
80161cd0:	ea000044 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161cd4:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161cd8:	e1a02283 	lsl	r2, r3, #5
80161cdc:	e51b300c 	ldr	r3, [fp, #-12]
80161ce0:	e593300c 	ldr	r3, [r3, #12]
80161ce4:	e0823003 	add	r3, r2, r3
80161ce8:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Cpt_Crt);
80161cec:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161cf0:	e3a02801 	mov	r2, #65536	@ 0x10000
80161cf4:	e3a01000 	mov	r1, #0
80161cf8:	e1a00003 	mov	r0, r3
80161cfc:	ebfffbae 	bl	80160bbc <_RME_Comp_Swap_Single>
80161d00:	e1a03000 	mov	r3, r0
80161d04:	e3530000 	cmp	r3, #0
80161d08:	1a000001 	bne	80161d14 <_RME_Cpt_Crt+0x460>
80161d0c:	e3e03004 	mvn	r3, #4
80161d10:	ea000034 	b	80161de8 <_RME_Cpt_Crt+0x534>
80161d14:	e3003000 	movw	r3, #0
80161d18:	e3483017 	movt	r3, #32791	@ 0x8017
80161d1c:	e5932000 	ldr	r2, [r3]
80161d20:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161d24:	e5832010 	str	r2, [r3, #16]

    /* Try to mark this area as populated */
    if(_RME_Kot_Mark(Vaddr,RME_CPT_SIZE(Entry_Num))<0)
80161d28:	e59b3008 	ldr	r3, [fp, #8]
80161d2c:	e1a03283 	lsl	r3, r3, #5
80161d30:	e1a01003 	mov	r1, r3
80161d34:	e51b0018 	ldr	r0, [fp, #-24]	@ 0xffffffe8
80161d38:	eb000c8f 	bl	80164f7c <_RME_Kot_Mark>
80161d3c:	e1a03000 	mov	r3, r0
80161d40:	e3530000 	cmp	r3, #0
80161d44:	aa000005 	bge	80161d60 <_RME_Cpt_Crt+0x4ac>
    {
        RME_COV_MARKER();
        
        /* Failure. Set the Type_Stat back to 0 and abort the creation process */
        RME_WRITE_RELEASE(&(Cpt_Crt->Head.Type_Stat),0U);
80161d48:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161d4c:	e3a01000 	mov	r1, #0
80161d50:	e1a00003 	mov	r0, r3
80161d54:	ebfffa6c 	bl	8016070c <__RME_A7A_Write_Release>
        return RME_ERR_CPT_KOT;
80161d58:	e3e03003 	mvn	r3, #3
80161d5c:	ea000021 	b	80161de8 <_RME_Cpt_Crt+0x534>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Object init */
    for(Count=0U;Count<Entry_Num;Count++)
80161d60:	e3a03000 	mov	r3, #0
80161d64:	e50b3008 	str	r3, [fp, #-8]
80161d68:	ea000009 	b	80161d94 <_RME_Cpt_Crt+0x4e0>
    {
        RME_CAP_CLEAR(&(((struct RME_Cap_Struct*)Vaddr)[Count]));
80161d6c:	e51b3008 	ldr	r3, [fp, #-8]
80161d70:	e1a02283 	lsl	r2, r3, #5
80161d74:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80161d78:	e0823003 	add	r3, r2, r3
80161d7c:	e1a02003 	mov	r2, r3
80161d80:	e3a03000 	mov	r3, #0
80161d84:	e5823000 	str	r3, [r2]
    for(Count=0U;Count<Entry_Num;Count++)
80161d88:	e51b3008 	ldr	r3, [fp, #-8]
80161d8c:	e2833001 	add	r3, r3, #1
80161d90:	e50b3008 	str	r3, [fp, #-8]
80161d94:	e51b2008 	ldr	r2, [fp, #-8]
80161d98:	e59b3008 	ldr	r3, [fp, #8]
80161d9c:	e1520003 	cmp	r2, r3
80161da0:	3afffff1 	bcc	80161d6c <_RME_Cpt_Crt+0x4b8>
    }

    /* Header init */
    Cpt_Crt->Head.Root_Ref=0U;
80161da4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161da8:	e3a02000 	mov	r2, #0
80161dac:	e5832004 	str	r2, [r3, #4]
    Cpt_Crt->Head.Object=Vaddr;
80161db0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161db4:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80161db8:	e583200c 	str	r2, [r3, #12]
    Cpt_Crt->Head.Flag=RME_CPT_FLAG_ALL;
80161dbc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161dc0:	e3a020ff 	mov	r2, #255	@ 0xff
80161dc4:	e5832008 	str	r2, [r3, #8]
    
    /* Info init */
    Cpt_Crt->Entry_Num=Entry_Num;
80161dc8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161dcc:	e59b2008 	ldr	r2, [fp, #8]
80161dd0:	e5832014 	str	r2, [r3, #20]

    /* Establish cap */
    RME_WRITE_RELEASE(&(Cpt_Crt->Head.Type_Stat),
80161dd4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80161dd8:	e3a01403 	mov	r1, #50331648	@ 0x3000000
80161ddc:	e1a00003 	mov	r0, r3
80161de0:	ebfffa49 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_CPT,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
80161de4:	e3a03000 	mov	r3, #0
}
80161de8:	e1a00003 	mov	r0, r3
80161dec:	e24bd004 	sub	sp, fp, #4
80161df0:	e8bd8800 	pop	{fp, pc}

80161df4 <_RME_Cpt_Del>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Cpt_Del(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt_Del,
                              rme_cid_t Cap_Del)
{
80161df4:	e92d4800 	push	{fp, lr}
80161df8:	e28db004 	add	fp, sp, #4
80161dfc:	e24dd030 	sub	sp, sp, #48	@ 0x30
80161e00:	e50b0028 	str	r0, [fp, #-40]	@ 0xffffffd8
80161e04:	e50b102c 	str	r1, [fp, #-44]	@ 0xffffffd4
80161e08:	e50b2030 	str	r2, [fp, #-48]	@ 0xffffffd0
    /* These are used for deletion */
    rme_ptr_t Object;
    rme_ptr_t Size;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Del,RME_CAP_TYPE_CPT,
80161e0c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161e10:	e2033080 	and	r3, r3, #128	@ 0x80
80161e14:	e3530000 	cmp	r3, #0
80161e18:	1a00001c 	bne	80161e90 <_RME_Cpt_Del+0x9c>
80161e1c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161e20:	e5932014 	ldr	r2, [r3, #20]
80161e24:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161e28:	e1520003 	cmp	r2, r3
80161e2c:	8a000001 	bhi	80161e38 <_RME_Cpt_Del+0x44>
80161e30:	e3e03002 	mvn	r3, #2
80161e34:	ea0000e1 	b	801621c0 <_RME_Cpt_Del+0x3cc>
80161e38:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161e3c:	e1a02283 	lsl	r2, r3, #5
80161e40:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161e44:	e593300c 	ldr	r3, [r3, #12]
80161e48:	e0823003 	add	r3, r2, r3
80161e4c:	e50b300c 	str	r3, [fp, #-12]
80161e50:	e51b300c 	ldr	r3, [fp, #-12]
80161e54:	e1a00003 	mov	r0, r3
80161e58:	ebfffa28 	bl	80160700 <__RME_A7A_Read_Acquire>
80161e5c:	e50b0010 	str	r0, [fp, #-16]
80161e60:	e51b3010 	ldr	r3, [fp, #-16]
80161e64:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80161e68:	e3530802 	cmp	r3, #131072	@ 0x20000
80161e6c:	1a000001 	bne	80161e78 <_RME_Cpt_Del+0x84>
80161e70:	e3e03008 	mvn	r3, #8
80161e74:	ea0000d1 	b	801621c0 <_RME_Cpt_Del+0x3cc>
80161e78:	e51b3010 	ldr	r3, [fp, #-16]
80161e7c:	e1a03c23 	lsr	r3, r3, #24
80161e80:	e3530003 	cmp	r3, #3
80161e84:	0a00003f 	beq	80161f88 <_RME_Cpt_Del+0x194>
80161e88:	e3e03001 	mvn	r3, #1
80161e8c:	ea0000cb 	b	801621c0 <_RME_Cpt_Del+0x3cc>
80161e90:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161e94:	e1a02423 	lsr	r2, r3, #8
80161e98:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161e9c:	e5933014 	ldr	r3, [r3, #20]
80161ea0:	e1520003 	cmp	r2, r3
80161ea4:	3a000001 	bcc	80161eb0 <_RME_Cpt_Del+0xbc>
80161ea8:	e3e03002 	mvn	r3, #2
80161eac:	ea0000c3 	b	801621c0 <_RME_Cpt_Del+0x3cc>
80161eb0:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161eb4:	e1a03423 	lsr	r3, r3, #8
80161eb8:	e1a02283 	lsl	r2, r3, #5
80161ebc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80161ec0:	e593300c 	ldr	r3, [r3, #12]
80161ec4:	e0823003 	add	r3, r2, r3
80161ec8:	e50b300c 	str	r3, [fp, #-12]
80161ecc:	e51b300c 	ldr	r3, [fp, #-12]
80161ed0:	e1a00003 	mov	r0, r3
80161ed4:	ebfffa09 	bl	80160700 <__RME_A7A_Read_Acquire>
80161ed8:	e50b0010 	str	r0, [fp, #-16]
80161edc:	e51b3010 	ldr	r3, [fp, #-16]
80161ee0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80161ee4:	e3530802 	cmp	r3, #131072	@ 0x20000
80161ee8:	1a000001 	bne	80161ef4 <_RME_Cpt_Del+0x100>
80161eec:	e3e03008 	mvn	r3, #8
80161ef0:	ea0000b2 	b	801621c0 <_RME_Cpt_Del+0x3cc>
80161ef4:	e51b3010 	ldr	r3, [fp, #-16]
80161ef8:	e1a03c23 	lsr	r3, r3, #24
80161efc:	e3530003 	cmp	r3, #3
80161f00:	0a000001 	beq	80161f0c <_RME_Cpt_Del+0x118>
80161f04:	e3e03001 	mvn	r3, #1
80161f08:	ea0000ac 	b	801621c0 <_RME_Cpt_Del+0x3cc>
80161f0c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161f10:	e203207f 	and	r2, r3, #127	@ 0x7f
80161f14:	e51b300c 	ldr	r3, [fp, #-12]
80161f18:	e5933014 	ldr	r3, [r3, #20]
80161f1c:	e1520003 	cmp	r2, r3
80161f20:	3a000001 	bcc	80161f2c <_RME_Cpt_Del+0x138>
80161f24:	e3e03002 	mvn	r3, #2
80161f28:	ea0000a4 	b	801621c0 <_RME_Cpt_Del+0x3cc>
80161f2c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80161f30:	e203307f 	and	r3, r3, #127	@ 0x7f
80161f34:	e1a02283 	lsl	r2, r3, #5
80161f38:	e51b300c 	ldr	r3, [fp, #-12]
80161f3c:	e593300c 	ldr	r3, [r3, #12]
80161f40:	e0823003 	add	r3, r2, r3
80161f44:	e50b300c 	str	r3, [fp, #-12]
80161f48:	e51b300c 	ldr	r3, [fp, #-12]
80161f4c:	e1a00003 	mov	r0, r3
80161f50:	ebfff9ea 	bl	80160700 <__RME_A7A_Read_Acquire>
80161f54:	e50b0010 	str	r0, [fp, #-16]
80161f58:	e51b3010 	ldr	r3, [fp, #-16]
80161f5c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80161f60:	e3530802 	cmp	r3, #131072	@ 0x20000
80161f64:	1a000001 	bne	80161f70 <_RME_Cpt_Del+0x17c>
80161f68:	e3e03008 	mvn	r3, #8
80161f6c:	ea000093 	b	801621c0 <_RME_Cpt_Del+0x3cc>
80161f70:	e51b3010 	ldr	r3, [fp, #-16]
80161f74:	e1a03c23 	lsr	r3, r3, #24
80161f78:	e3530003 	cmp	r3, #3
80161f7c:	0a000001 	beq	80161f88 <_RME_Cpt_Del+0x194>
80161f80:	e3e03001 	mvn	r3, #1
80161f84:	ea00008d 	b	801621c0 <_RME_Cpt_Del+0x3cc>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_DEL);
80161f88:	e51b300c 	ldr	r3, [fp, #-12]
80161f8c:	e5933008 	ldr	r3, [r3, #8]
80161f90:	e2033002 	and	r3, r3, #2
80161f94:	e3530000 	cmp	r3, #0
80161f98:	1a000001 	bne	80161fa4 <_RME_Cpt_Del+0x1b0>
80161f9c:	e3e03006 	mvn	r3, #6
80161fa0:	ea000086 	b	801621c0 <_RME_Cpt_Del+0x3cc>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Del,struct RME_Cap_Cpt*,Cpt_Del);
80161fa4:	e51b300c 	ldr	r3, [fp, #-12]
80161fa8:	e5932014 	ldr	r2, [r3, #20]
80161fac:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80161fb0:	e1520003 	cmp	r2, r3
80161fb4:	8a000001 	bhi	80161fc0 <_RME_Cpt_Del+0x1cc>
80161fb8:	e3e03002 	mvn	r3, #2
80161fbc:	ea00007f 	b	801621c0 <_RME_Cpt_Del+0x3cc>
80161fc0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80161fc4:	e1a02283 	lsl	r2, r3, #5
80161fc8:	e51b300c 	ldr	r3, [fp, #-12]
80161fcc:	e593300c 	ldr	r3, [r3, #12]
80161fd0:	e0823003 	add	r3, r2, r3
80161fd4:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    /* Delete check */
    RME_CAP_DEL_CHECK(Cpt_Del,Type_Stat,RME_CAP_TYPE_CPT);
80161fd8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80161fdc:	e1a00003 	mov	r0, r3
80161fe0:	ebfff9c6 	bl	80160700 <__RME_A7A_Read_Acquire>
80161fe4:	e50b0010 	str	r0, [fp, #-16]
80161fe8:	e51b3010 	ldr	r3, [fp, #-16]
80161fec:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80161ff0:	e3530802 	cmp	r3, #131072	@ 0x20000
80161ff4:	0a000001 	beq	80162000 <_RME_Cpt_Del+0x20c>
80161ff8:	e3e03008 	mvn	r3, #8
80161ffc:	ea00006f 	b	801621c0 <_RME_Cpt_Del+0x3cc>
80162000:	e51b3010 	ldr	r3, [fp, #-16]
80162004:	e1a03c23 	lsr	r3, r3, #24
80162008:	e3530003 	cmp	r3, #3
8016200c:	0a000001 	beq	80162018 <_RME_Cpt_Del+0x224>
80162010:	e3e03001 	mvn	r3, #1
80162014:	ea000069 	b	801621c0 <_RME_Cpt_Del+0x3cc>
80162018:	e3003000 	movw	r3, #0
8016201c:	e3483017 	movt	r3, #32791	@ 0x8017
80162020:	e5932000 	ldr	r2, [r3]
80162024:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162028:	e5933010 	ldr	r3, [r3, #16]
8016202c:	e1a01003 	mov	r1, r3
80162030:	e1a00002 	mov	r0, r2
80162034:	ebfffb4d 	bl	80160d70 <_RME_Diff>
80162038:	e1a03000 	mov	r3, r0
8016203c:	e353000a 	cmp	r3, #10
80162040:	8a000001 	bhi	8016204c <_RME_Cpt_Del+0x258>
80162044:	e3e03007 	mvn	r3, #7
80162048:	ea00005c 	b	801621c0 <_RME_Cpt_Del+0x3cc>
8016204c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162050:	e5933004 	ldr	r3, [r3, #4]
80162054:	e3530000 	cmp	r3, #0
80162058:	0a00000b 	beq	8016208c <_RME_Cpt_Del+0x298>
8016205c:	e51b3010 	ldr	r3, [fp, #-16]
80162060:	e6ff3073 	uxth	r3, r3
80162064:	e3530000 	cmp	r3, #0
80162068:	1a000005 	bne	80162084 <_RME_Cpt_Del+0x290>
8016206c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80162070:	e51b3010 	ldr	r3, [fp, #-16]
80162074:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
80162078:	e1a02003 	mov	r2, r3
8016207c:	e51b1010 	ldr	r1, [fp, #-16]
80162080:	ebfffacd 	bl	80160bbc <_RME_Comp_Swap_Single>
80162084:	e3e03005 	mvn	r3, #5
80162088:	ea00004c 	b	801621c0 <_RME_Cpt_Del+0x3cc>
8016208c:	e51b3010 	ldr	r3, [fp, #-16]
80162090:	e6ff3073 	uxth	r3, r3
80162094:	e3530000 	cmp	r3, #0
80162098:	0a000008 	beq	801620c0 <_RME_Cpt_Del+0x2cc>
8016209c:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
801620a0:	e3483016 	movt	r3, #32790	@ 0x8016
801620a4:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
801620a8:	e3482016 	movt	r2, #32790	@ 0x8016
801620ac:	e30017f8 	movw	r1, #2040	@ 0x7f8
801620b0:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
801620b4:	e3480016 	movt	r0, #32790	@ 0x8016
801620b8:	ebfffab4 	bl	80160b90 <RME_Log>
801620bc:	eafffffe 	b	801620bc <_RME_Cpt_Del+0x2c8>
    /* Is there any capability in this capability table? If yes, we cannot destroy it.
     * We will check every slot to make sure nothing is there. This is surely,
     * predictable but not so perfect. So, if the time of such operations is to be 
     * bounded, the user must control the maximum number of entries in the table
     * by configuring RME_CPT_ENTRY_MAX to a non-zero value. */
    Table=RME_CAP_GETOBJ(Cpt_Del,struct RME_Cap_Struct*);
801620c0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801620c4:	e593300c 	ldr	r3, [r3, #12]
801620c8:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Entry_Num=Cpt_Del->Entry_Num;
801620cc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801620d0:	e5933014 	ldr	r3, [r3, #20]
801620d4:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    for(Count=0U;Count<Entry_Num;Count++)
801620d8:	e3a03000 	mov	r3, #0
801620dc:	e50b3008 	str	r3, [fp, #-8]
801620e0:	ea000011 	b	8016212c <_RME_Cpt_Del+0x338>
    {
        if(Table[Count].Head.Type_Stat!=0U)
801620e4:	e51b3008 	ldr	r3, [fp, #-8]
801620e8:	e1a03283 	lsl	r3, r3, #5
801620ec:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
801620f0:	e0823003 	add	r3, r2, r3
801620f4:	e5933000 	ldr	r3, [r3]
801620f8:	e3530000 	cmp	r3, #0
801620fc:	0a000007 	beq	80162120 <_RME_Cpt_Del+0x32c>
        {
            RME_COV_MARKER();
            
            RME_CAP_DEFROST(Cpt_Del,Type_Stat);
80162100:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80162104:	e51b3010 	ldr	r3, [fp, #-16]
80162108:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
8016210c:	e1a02003 	mov	r2, r3
80162110:	e51b1010 	ldr	r1, [fp, #-16]
80162114:	ebfffaa8 	bl	80160bbc <_RME_Comp_Swap_Single>
            return RME_ERR_CPT_EXIST;
80162118:	e3e03004 	mvn	r3, #4
8016211c:	ea000027 	b	801621c0 <_RME_Cpt_Del+0x3cc>
    for(Count=0U;Count<Entry_Num;Count++)
80162120:	e51b3008 	ldr	r3, [fp, #-8]
80162124:	e2833001 	add	r3, r3, #1
80162128:	e50b3008 	str	r3, [fp, #-8]
8016212c:	e51b2008 	ldr	r2, [fp, #-8]
80162130:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162134:	e1520003 	cmp	r2, r3
80162138:	3affffe9 	bcc	801620e4 <_RME_Cpt_Del+0x2f0>
            /* No action required */
        }
    }
    
    /* Remember these two variables for deletion */
    Object=RME_CAP_GETOBJ(Cpt_Del,rme_ptr_t);
8016213c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162140:	e593300c 	ldr	r3, [r3, #12]
80162144:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
    Size=RME_CPT_SIZE(Cpt_Del->Entry_Num);
80162148:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016214c:	e5933014 	ldr	r3, [r3, #20]
80162150:	e1a03283 	lsl	r3, r3, #5
80162154:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc

    /* Now we can safely delete the cap */
    RME_CAP_DELETE(Cpt_Del,Type_Stat);
80162158:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016215c:	e3a02000 	mov	r2, #0
80162160:	e51b1010 	ldr	r1, [fp, #-16]
80162164:	e1a00003 	mov	r0, r3
80162168:	ebfffa93 	bl	80160bbc <_RME_Comp_Swap_Single>
8016216c:	e1a03000 	mov	r3, r0
80162170:	e3530000 	cmp	r3, #0
80162174:	1a000001 	bne	80162180 <_RME_Cpt_Del+0x38c>
80162178:	e3e03000 	mvn	r3, #0
8016217c:	ea00000f 	b	801621c0 <_RME_Cpt_Del+0x3cc>

    /* Try to depopulate the area - this must be successful */
    RME_ASSERT(_RME_Kot_Erase(Object,Size)==0);
80162180:	e51b1024 	ldr	r1, [fp, #-36]	@ 0xffffffdc
80162184:	e51b0020 	ldr	r0, [fp, #-32]	@ 0xffffffe0
80162188:	eb000c4f 	bl	801652cc <_RME_Kot_Erase>
8016218c:	e1a03000 	mov	r3, r0
80162190:	e3530000 	cmp	r3, #0
80162194:	0a000008 	beq	801621bc <_RME_Cpt_Del+0x3c8>
80162198:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
8016219c:	e3483016 	movt	r3, #32790	@ 0x8016
801621a0:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
801621a4:	e3482016 	movt	r2, #32790	@ 0x8016
801621a8:	e3001819 	movw	r1, #2073	@ 0x819
801621ac:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
801621b0:	e3480016 	movt	r0, #32790	@ 0x8016
801621b4:	ebfffa75 	bl	80160b90 <RME_Log>
801621b8:	eafffffe 	b	801621b8 <_RME_Cpt_Del+0x3c4>
    
    return 0;
801621bc:	e3a03000 	mov	r3, #0
}
801621c0:	e1a00003 	mov	r0, r3
801621c4:	e24bd004 	sub	sp, fp, #4
801621c8:	e8bd8800 	pop	{fp, pc}

801621cc <_RME_Cpt_Frz>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Cpt_Frz(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt_Frz,
                              rme_cid_t Cap_Frz)
{
801621cc:	e92d4800 	push	{fp, lr}
801621d0:	e28db004 	add	fp, sp, #4
801621d4:	e24dd020 	sub	sp, sp, #32
801621d8:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
801621dc:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
801621e0:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    struct RME_Cap_Cpt* Cpt_Op;
    volatile struct RME_Cap_Struct* Capobj_Frz;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Frz,RME_CAP_TYPE_CPT,
801621e4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801621e8:	e2033080 	and	r3, r3, #128	@ 0x80
801621ec:	e3530000 	cmp	r3, #0
801621f0:	1a00001c 	bne	80162268 <_RME_Cpt_Frz+0x9c>
801621f4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801621f8:	e5932014 	ldr	r2, [r3, #20]
801621fc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162200:	e1520003 	cmp	r2, r3
80162204:	8a000001 	bhi	80162210 <_RME_Cpt_Frz+0x44>
80162208:	e3e03002 	mvn	r3, #2
8016220c:	ea00009b 	b	80162480 <_RME_Cpt_Frz+0x2b4>
80162210:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162214:	e1a02283 	lsl	r2, r3, #5
80162218:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016221c:	e593300c 	ldr	r3, [r3, #12]
80162220:	e0823003 	add	r3, r2, r3
80162224:	e50b3008 	str	r3, [fp, #-8]
80162228:	e51b3008 	ldr	r3, [fp, #-8]
8016222c:	e1a00003 	mov	r0, r3
80162230:	ebfff932 	bl	80160700 <__RME_A7A_Read_Acquire>
80162234:	e50b000c 	str	r0, [fp, #-12]
80162238:	e51b300c 	ldr	r3, [fp, #-12]
8016223c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80162240:	e3530802 	cmp	r3, #131072	@ 0x20000
80162244:	1a000001 	bne	80162250 <_RME_Cpt_Frz+0x84>
80162248:	e3e03008 	mvn	r3, #8
8016224c:	ea00008b 	b	80162480 <_RME_Cpt_Frz+0x2b4>
80162250:	e51b300c 	ldr	r3, [fp, #-12]
80162254:	e1a03c23 	lsr	r3, r3, #24
80162258:	e3530003 	cmp	r3, #3
8016225c:	0a00003f 	beq	80162360 <_RME_Cpt_Frz+0x194>
80162260:	e3e03001 	mvn	r3, #1
80162264:	ea000085 	b	80162480 <_RME_Cpt_Frz+0x2b4>
80162268:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016226c:	e1a02423 	lsr	r2, r3, #8
80162270:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80162274:	e5933014 	ldr	r3, [r3, #20]
80162278:	e1520003 	cmp	r2, r3
8016227c:	3a000001 	bcc	80162288 <_RME_Cpt_Frz+0xbc>
80162280:	e3e03002 	mvn	r3, #2
80162284:	ea00007d 	b	80162480 <_RME_Cpt_Frz+0x2b4>
80162288:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016228c:	e1a03423 	lsr	r3, r3, #8
80162290:	e1a02283 	lsl	r2, r3, #5
80162294:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80162298:	e593300c 	ldr	r3, [r3, #12]
8016229c:	e0823003 	add	r3, r2, r3
801622a0:	e50b3008 	str	r3, [fp, #-8]
801622a4:	e51b3008 	ldr	r3, [fp, #-8]
801622a8:	e1a00003 	mov	r0, r3
801622ac:	ebfff913 	bl	80160700 <__RME_A7A_Read_Acquire>
801622b0:	e50b000c 	str	r0, [fp, #-12]
801622b4:	e51b300c 	ldr	r3, [fp, #-12]
801622b8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801622bc:	e3530802 	cmp	r3, #131072	@ 0x20000
801622c0:	1a000001 	bne	801622cc <_RME_Cpt_Frz+0x100>
801622c4:	e3e03008 	mvn	r3, #8
801622c8:	ea00006c 	b	80162480 <_RME_Cpt_Frz+0x2b4>
801622cc:	e51b300c 	ldr	r3, [fp, #-12]
801622d0:	e1a03c23 	lsr	r3, r3, #24
801622d4:	e3530003 	cmp	r3, #3
801622d8:	0a000001 	beq	801622e4 <_RME_Cpt_Frz+0x118>
801622dc:	e3e03001 	mvn	r3, #1
801622e0:	ea000066 	b	80162480 <_RME_Cpt_Frz+0x2b4>
801622e4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801622e8:	e203207f 	and	r2, r3, #127	@ 0x7f
801622ec:	e51b3008 	ldr	r3, [fp, #-8]
801622f0:	e5933014 	ldr	r3, [r3, #20]
801622f4:	e1520003 	cmp	r2, r3
801622f8:	3a000001 	bcc	80162304 <_RME_Cpt_Frz+0x138>
801622fc:	e3e03002 	mvn	r3, #2
80162300:	ea00005e 	b	80162480 <_RME_Cpt_Frz+0x2b4>
80162304:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162308:	e203307f 	and	r3, r3, #127	@ 0x7f
8016230c:	e1a02283 	lsl	r2, r3, #5
80162310:	e51b3008 	ldr	r3, [fp, #-8]
80162314:	e593300c 	ldr	r3, [r3, #12]
80162318:	e0823003 	add	r3, r2, r3
8016231c:	e50b3008 	str	r3, [fp, #-8]
80162320:	e51b3008 	ldr	r3, [fp, #-8]
80162324:	e1a00003 	mov	r0, r3
80162328:	ebfff8f4 	bl	80160700 <__RME_A7A_Read_Acquire>
8016232c:	e50b000c 	str	r0, [fp, #-12]
80162330:	e51b300c 	ldr	r3, [fp, #-12]
80162334:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80162338:	e3530802 	cmp	r3, #131072	@ 0x20000
8016233c:	1a000001 	bne	80162348 <_RME_Cpt_Frz+0x17c>
80162340:	e3e03008 	mvn	r3, #8
80162344:	ea00004d 	b	80162480 <_RME_Cpt_Frz+0x2b4>
80162348:	e51b300c 	ldr	r3, [fp, #-12]
8016234c:	e1a03c23 	lsr	r3, r3, #24
80162350:	e3530003 	cmp	r3, #3
80162354:	0a000001 	beq	80162360 <_RME_Cpt_Frz+0x194>
80162358:	e3e03001 	mvn	r3, #1
8016235c:	ea000047 	b	80162480 <_RME_Cpt_Frz+0x2b4>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_FRZ);
80162360:	e51b3008 	ldr	r3, [fp, #-8]
80162364:	e5933008 	ldr	r3, [r3, #8]
80162368:	e2033004 	and	r3, r3, #4
8016236c:	e3530000 	cmp	r3, #0
80162370:	1a000001 	bne	8016237c <_RME_Cpt_Frz+0x1b0>
80162374:	e3e03006 	mvn	r3, #6
80162378:	ea000040 	b	80162480 <_RME_Cpt_Frz+0x2b4>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Frz,struct RME_Cap_Struct*,Capobj_Frz);
8016237c:	e51b3008 	ldr	r3, [fp, #-8]
80162380:	e5932014 	ldr	r2, [r3, #20]
80162384:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162388:	e1520003 	cmp	r2, r3
8016238c:	8a000001 	bhi	80162398 <_RME_Cpt_Frz+0x1cc>
80162390:	e3e03002 	mvn	r3, #2
80162394:	ea000039 	b	80162480 <_RME_Cpt_Frz+0x2b4>
80162398:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016239c:	e1a02283 	lsl	r2, r3, #5
801623a0:	e51b3008 	ldr	r3, [fp, #-8]
801623a4:	e593300c 	ldr	r3, [r3, #12]
801623a8:	e0823003 	add	r3, r2, r3
801623ac:	e50b3010 	str	r3, [fp, #-16]
    
    /* Check if anything is there. If nothing there, the Type_Stat must be 0. 
     * Need a read acquire barrier here to avoid stale reads below. */
    Type_Stat=RME_READ_ACQUIRE(&(Capobj_Frz->Head.Type_Stat));
801623b0:	e51b3010 	ldr	r3, [fp, #-16]
801623b4:	e1a00003 	mov	r0, r3
801623b8:	ebfff8d0 	bl	80160700 <__RME_A7A_Read_Acquire>
801623bc:	e50b000c 	str	r0, [fp, #-12]
    /* See if there is a cap */
    if(RME_CAP_TYPE(Type_Stat)==RME_CAP_TYPE_NOP)
801623c0:	e51b300c 	ldr	r3, [fp, #-12]
801623c4:	e1a03c23 	lsr	r3, r3, #24
801623c8:	e3530000 	cmp	r3, #0
801623cc:	1a000001 	bne	801623d8 <_RME_Cpt_Frz+0x20c>
    {
        RME_COV_MARKER();
        
        return RME_ERR_CPT_NULL;
801623d0:	e3e03000 	mvn	r3, #0
801623d4:	ea000029 	b	80162480 <_RME_Cpt_Frz+0x2b4>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* If this is a root capability, check if the reference count allows freezing */
    if(RME_CAP_ATTR(Type_Stat)==RME_CAP_ATTR_ROOT)
801623d8:	e51b300c 	ldr	r3, [fp, #-12]
801623dc:	e6ff3073 	uxth	r3, r3
801623e0:	e3530000 	cmp	r3, #0
801623e4:	1a000005 	bne	80162400 <_RME_Cpt_Frz+0x234>
    {
        if(Capobj_Frz->Head.Root_Ref!=0U)
801623e8:	e51b3010 	ldr	r3, [fp, #-16]
801623ec:	e5933004 	ldr	r3, [r3, #4]
801623f0:	e3530000 	cmp	r3, #0
801623f4:	0a000001 	beq	80162400 <_RME_Cpt_Frz+0x234>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_REFCNT;
801623f8:	e3e03005 	mvn	r3, #5
801623fc:	ea00001f 	b	80162480 <_RME_Cpt_Frz+0x2b4>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* The capability is already frozen - why do it again? */
    if(RME_CAP_STAT(Type_Stat)==RME_CAP_STAT_FROZEN)
80162400:	e51b300c 	ldr	r3, [fp, #-12]
80162404:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80162408:	e3530802 	cmp	r3, #131072	@ 0x20000
8016240c:	1a000001 	bne	80162418 <_RME_Cpt_Frz+0x24c>
    {
        RME_COV_MARKER();
        
        return RME_ERR_CPT_FROZEN;
80162410:	e3e03008 	mvn	r3, #8
80162414:	ea000019 	b	80162480 <_RME_Cpt_Frz+0x2b4>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* See if the slot is quiescent */
    if(RME_UNLIKELY(RME_CAP_QUIE(Capobj_Frz->Head.Timestamp)==0U))
80162418:	e3003000 	movw	r3, #0
8016241c:	e3483017 	movt	r3, #32791	@ 0x8017
80162420:	e5932000 	ldr	r2, [r3]
80162424:	e51b3010 	ldr	r3, [fp, #-16]
80162428:	e5933010 	ldr	r3, [r3, #16]
8016242c:	e1a01003 	mov	r1, r3
80162430:	e1a00002 	mov	r0, r2
80162434:	ebfffa4d 	bl	80160d70 <_RME_Diff>
80162438:	e1a03000 	mov	r3, r0
8016243c:	e353000a 	cmp	r3, #10
80162440:	8a000001 	bhi	8016244c <_RME_Cpt_Frz+0x280>
    {
        RME_COV_MARKER();
        
        return RME_ERR_CPT_QUIE;
80162444:	e3e03007 	mvn	r3, #7
80162448:	ea00000c 	b	80162480 <_RME_Cpt_Frz+0x2b4>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Update the timestamp */
    Capobj_Frz->Head.Timestamp=RME_TIMESTAMP;
8016244c:	e3003000 	movw	r3, #0
80162450:	e3483017 	movt	r3, #32791	@ 0x8017
80162454:	e5932000 	ldr	r2, [r3]
80162458:	e51b3010 	ldr	r3, [fp, #-16]
8016245c:	e5832010 	str	r2, [r3, #16]
    
    /* Finally, freeze it. We do not report error here because if we CASFAIL someone must have helped us */
    RME_COMP_SWAP(&(Capobj_Frz->Head.Type_Stat),Type_Stat,
80162460:	e51b0010 	ldr	r0, [fp, #-16]
80162464:	e51b300c 	ldr	r3, [fp, #-12]
80162468:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
8016246c:	e3833802 	orr	r3, r3, #131072	@ 0x20000
80162470:	e1a02003 	mov	r2, r3
80162474:	e51b100c 	ldr	r1, [fp, #-12]
80162478:	ebfff9cf 	bl	80160bbc <_RME_Comp_Swap_Single>
                  RME_CAP_TYPE_STAT(RME_CAP_TYPE(Type_Stat),
                                    RME_CAP_STAT_FROZEN,
                                    RME_CAP_ATTR(Type_Stat)));

    return 0;
8016247c:	e3a03000 	mov	r3, #0
}
80162480:	e1a00003 	mov	r0, r3
80162484:	e24bd004 	sub	sp, fp, #4
80162488:	e8bd8800 	pop	{fp, pc}

8016248c <_RME_Cpt_Add>:
                              rme_cid_t Cap_Dst, 
                              rme_cid_t Cap_Cpt_Src,
                              rme_cid_t Cap_Src,
                              rme_ptr_t Flag,
                              rme_ptr_t Ext_Flag)
{
8016248c:	e92d4800 	push	{fp, lr}
80162490:	e28db004 	add	fp, sp, #4
80162494:	e24dd038 	sub	sp, sp, #56	@ 0x38
80162498:	e50b0030 	str	r0, [fp, #-48]	@ 0xffffffd0
8016249c:	e50b1034 	str	r1, [fp, #-52]	@ 0xffffffcc
801624a0:	e50b2038 	str	r2, [fp, #-56]	@ 0xffffffc8
801624a4:	e50b303c 	str	r3, [fp, #-60]	@ 0xffffffc4
    rme_ptr_t Kom_Begin;
    rme_ptr_t Kom_End;
    rme_ptr_t Kom_Flag;

    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Dst,RME_CAP_TYPE_CPT,
801624a8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801624ac:	e2033080 	and	r3, r3, #128	@ 0x80
801624b0:	e3530000 	cmp	r3, #0
801624b4:	1a00001c 	bne	8016252c <_RME_Cpt_Add+0xa0>
801624b8:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801624bc:	e5932014 	ldr	r2, [r3, #20]
801624c0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801624c4:	e1520003 	cmp	r2, r3
801624c8:	8a000001 	bhi	801624d4 <_RME_Cpt_Add+0x48>
801624cc:	e3e03002 	mvn	r3, #2
801624d0:	ea000202 	b	80162ce0 <_RME_Cpt_Add+0x854>
801624d4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801624d8:	e1a02283 	lsl	r2, r3, #5
801624dc:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801624e0:	e593300c 	ldr	r3, [r3, #12]
801624e4:	e0823003 	add	r3, r2, r3
801624e8:	e50b3008 	str	r3, [fp, #-8]
801624ec:	e51b3008 	ldr	r3, [fp, #-8]
801624f0:	e1a00003 	mov	r0, r3
801624f4:	ebfff881 	bl	80160700 <__RME_A7A_Read_Acquire>
801624f8:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
801624fc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162500:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80162504:	e3530802 	cmp	r3, #131072	@ 0x20000
80162508:	1a000001 	bne	80162514 <_RME_Cpt_Add+0x88>
8016250c:	e3e03008 	mvn	r3, #8
80162510:	ea0001f2 	b	80162ce0 <_RME_Cpt_Add+0x854>
80162514:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162518:	e1a03c23 	lsr	r3, r3, #24
8016251c:	e3530003 	cmp	r3, #3
80162520:	0a00003f 	beq	80162624 <_RME_Cpt_Add+0x198>
80162524:	e3e03001 	mvn	r3, #1
80162528:	ea0001ec 	b	80162ce0 <_RME_Cpt_Add+0x854>
8016252c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80162530:	e1a02423 	lsr	r2, r3, #8
80162534:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80162538:	e5933014 	ldr	r3, [r3, #20]
8016253c:	e1520003 	cmp	r2, r3
80162540:	3a000001 	bcc	8016254c <_RME_Cpt_Add+0xc0>
80162544:	e3e03002 	mvn	r3, #2
80162548:	ea0001e4 	b	80162ce0 <_RME_Cpt_Add+0x854>
8016254c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80162550:	e1a03423 	lsr	r3, r3, #8
80162554:	e1a02283 	lsl	r2, r3, #5
80162558:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016255c:	e593300c 	ldr	r3, [r3, #12]
80162560:	e0823003 	add	r3, r2, r3
80162564:	e50b3008 	str	r3, [fp, #-8]
80162568:	e51b3008 	ldr	r3, [fp, #-8]
8016256c:	e1a00003 	mov	r0, r3
80162570:	ebfff862 	bl	80160700 <__RME_A7A_Read_Acquire>
80162574:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
80162578:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016257c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80162580:	e3530802 	cmp	r3, #131072	@ 0x20000
80162584:	1a000001 	bne	80162590 <_RME_Cpt_Add+0x104>
80162588:	e3e03008 	mvn	r3, #8
8016258c:	ea0001d3 	b	80162ce0 <_RME_Cpt_Add+0x854>
80162590:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162594:	e1a03c23 	lsr	r3, r3, #24
80162598:	e3530003 	cmp	r3, #3
8016259c:	0a000001 	beq	801625a8 <_RME_Cpt_Add+0x11c>
801625a0:	e3e03001 	mvn	r3, #1
801625a4:	ea0001cd 	b	80162ce0 <_RME_Cpt_Add+0x854>
801625a8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801625ac:	e203207f 	and	r2, r3, #127	@ 0x7f
801625b0:	e51b3008 	ldr	r3, [fp, #-8]
801625b4:	e5933014 	ldr	r3, [r3, #20]
801625b8:	e1520003 	cmp	r2, r3
801625bc:	3a000001 	bcc	801625c8 <_RME_Cpt_Add+0x13c>
801625c0:	e3e03002 	mvn	r3, #2
801625c4:	ea0001c5 	b	80162ce0 <_RME_Cpt_Add+0x854>
801625c8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801625cc:	e203307f 	and	r3, r3, #127	@ 0x7f
801625d0:	e1a02283 	lsl	r2, r3, #5
801625d4:	e51b3008 	ldr	r3, [fp, #-8]
801625d8:	e593300c 	ldr	r3, [r3, #12]
801625dc:	e0823003 	add	r3, r2, r3
801625e0:	e50b3008 	str	r3, [fp, #-8]
801625e4:	e51b3008 	ldr	r3, [fp, #-8]
801625e8:	e1a00003 	mov	r0, r3
801625ec:	ebfff843 	bl	80160700 <__RME_A7A_Read_Acquire>
801625f0:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
801625f4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801625f8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801625fc:	e3530802 	cmp	r3, #131072	@ 0x20000
80162600:	1a000001 	bne	8016260c <_RME_Cpt_Add+0x180>
80162604:	e3e03008 	mvn	r3, #8
80162608:	ea0001b4 	b	80162ce0 <_RME_Cpt_Add+0x854>
8016260c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162610:	e1a03c23 	lsr	r3, r3, #24
80162614:	e3530003 	cmp	r3, #3
80162618:	0a000001 	beq	80162624 <_RME_Cpt_Add+0x198>
8016261c:	e3e03001 	mvn	r3, #1
80162620:	ea0001ae 	b	80162ce0 <_RME_Cpt_Add+0x854>
                   struct RME_Cap_Cpt*,Cpt_Dst,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Src,RME_CAP_TYPE_CPT,
80162624:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80162628:	e2033080 	and	r3, r3, #128	@ 0x80
8016262c:	e3530000 	cmp	r3, #0
80162630:	1a00001c 	bne	801626a8 <_RME_Cpt_Add+0x21c>
80162634:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80162638:	e5932014 	ldr	r2, [r3, #20]
8016263c:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80162640:	e1520003 	cmp	r2, r3
80162644:	8a000001 	bhi	80162650 <_RME_Cpt_Add+0x1c4>
80162648:	e3e03002 	mvn	r3, #2
8016264c:	ea0001a3 	b	80162ce0 <_RME_Cpt_Add+0x854>
80162650:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80162654:	e1a02283 	lsl	r2, r3, #5
80162658:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016265c:	e593300c 	ldr	r3, [r3, #12]
80162660:	e0823003 	add	r3, r2, r3
80162664:	e50b300c 	str	r3, [fp, #-12]
80162668:	e51b300c 	ldr	r3, [fp, #-12]
8016266c:	e1a00003 	mov	r0, r3
80162670:	ebfff822 	bl	80160700 <__RME_A7A_Read_Acquire>
80162674:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
80162678:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016267c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80162680:	e3530802 	cmp	r3, #131072	@ 0x20000
80162684:	1a000001 	bne	80162690 <_RME_Cpt_Add+0x204>
80162688:	e3e03008 	mvn	r3, #8
8016268c:	ea000193 	b	80162ce0 <_RME_Cpt_Add+0x854>
80162690:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162694:	e1a03c23 	lsr	r3, r3, #24
80162698:	e3530003 	cmp	r3, #3
8016269c:	0a00003f 	beq	801627a0 <_RME_Cpt_Add+0x314>
801626a0:	e3e03001 	mvn	r3, #1
801626a4:	ea00018d 	b	80162ce0 <_RME_Cpt_Add+0x854>
801626a8:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
801626ac:	e1a02423 	lsr	r2, r3, #8
801626b0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801626b4:	e5933014 	ldr	r3, [r3, #20]
801626b8:	e1520003 	cmp	r2, r3
801626bc:	3a000001 	bcc	801626c8 <_RME_Cpt_Add+0x23c>
801626c0:	e3e03002 	mvn	r3, #2
801626c4:	ea000185 	b	80162ce0 <_RME_Cpt_Add+0x854>
801626c8:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
801626cc:	e1a03423 	lsr	r3, r3, #8
801626d0:	e1a02283 	lsl	r2, r3, #5
801626d4:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801626d8:	e593300c 	ldr	r3, [r3, #12]
801626dc:	e0823003 	add	r3, r2, r3
801626e0:	e50b300c 	str	r3, [fp, #-12]
801626e4:	e51b300c 	ldr	r3, [fp, #-12]
801626e8:	e1a00003 	mov	r0, r3
801626ec:	ebfff803 	bl	80160700 <__RME_A7A_Read_Acquire>
801626f0:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
801626f4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801626f8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801626fc:	e3530802 	cmp	r3, #131072	@ 0x20000
80162700:	1a000001 	bne	8016270c <_RME_Cpt_Add+0x280>
80162704:	e3e03008 	mvn	r3, #8
80162708:	ea000174 	b	80162ce0 <_RME_Cpt_Add+0x854>
8016270c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162710:	e1a03c23 	lsr	r3, r3, #24
80162714:	e3530003 	cmp	r3, #3
80162718:	0a000001 	beq	80162724 <_RME_Cpt_Add+0x298>
8016271c:	e3e03001 	mvn	r3, #1
80162720:	ea00016e 	b	80162ce0 <_RME_Cpt_Add+0x854>
80162724:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80162728:	e203207f 	and	r2, r3, #127	@ 0x7f
8016272c:	e51b300c 	ldr	r3, [fp, #-12]
80162730:	e5933014 	ldr	r3, [r3, #20]
80162734:	e1520003 	cmp	r2, r3
80162738:	3a000001 	bcc	80162744 <_RME_Cpt_Add+0x2b8>
8016273c:	e3e03002 	mvn	r3, #2
80162740:	ea000166 	b	80162ce0 <_RME_Cpt_Add+0x854>
80162744:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80162748:	e203307f 	and	r3, r3, #127	@ 0x7f
8016274c:	e1a02283 	lsl	r2, r3, #5
80162750:	e51b300c 	ldr	r3, [fp, #-12]
80162754:	e593300c 	ldr	r3, [r3, #12]
80162758:	e0823003 	add	r3, r2, r3
8016275c:	e50b300c 	str	r3, [fp, #-12]
80162760:	e51b300c 	ldr	r3, [fp, #-12]
80162764:	e1a00003 	mov	r0, r3
80162768:	ebfff7e4 	bl	80160700 <__RME_A7A_Read_Acquire>
8016276c:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
80162770:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162774:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80162778:	e3530802 	cmp	r3, #131072	@ 0x20000
8016277c:	1a000001 	bne	80162788 <_RME_Cpt_Add+0x2fc>
80162780:	e3e03008 	mvn	r3, #8
80162784:	ea000155 	b	80162ce0 <_RME_Cpt_Add+0x854>
80162788:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016278c:	e1a03c23 	lsr	r3, r3, #24
80162790:	e3530003 	cmp	r3, #3
80162794:	0a000001 	beq	801627a0 <_RME_Cpt_Add+0x314>
80162798:	e3e03001 	mvn	r3, #1
8016279c:	ea00014f 	b	80162ce0 <_RME_Cpt_Add+0x854>
                   struct RME_Cap_Cpt*,Cpt_Src,Type_Stat);
    /* Check if both captbls are not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Dst,RME_CPT_FLAG_ADD_DST);
801627a0:	e51b3008 	ldr	r3, [fp, #-8]
801627a4:	e5933008 	ldr	r3, [r3, #8]
801627a8:	e2033010 	and	r3, r3, #16
801627ac:	e3530000 	cmp	r3, #0
801627b0:	1a000001 	bne	801627bc <_RME_Cpt_Add+0x330>
801627b4:	e3e03006 	mvn	r3, #6
801627b8:	ea000148 	b	80162ce0 <_RME_Cpt_Add+0x854>
    RME_CAP_CHECK(Cpt_Src,RME_CPT_FLAG_ADD_SRC);
801627bc:	e51b300c 	ldr	r3, [fp, #-12]
801627c0:	e5933008 	ldr	r3, [r3, #8]
801627c4:	e2033008 	and	r3, r3, #8
801627c8:	e3530000 	cmp	r3, #0
801627cc:	1a000001 	bne	801627d8 <_RME_Cpt_Add+0x34c>
801627d0:	e3e03006 	mvn	r3, #6
801627d4:	ea000141 	b	80162ce0 <_RME_Cpt_Add+0x854>
    
    /* Get the cap slots */
    RME_CPT_GETSLOT(Cpt_Dst,Cap_Dst,struct RME_Cap_Struct*,Capobj_Dst);
801627d8:	e51b3008 	ldr	r3, [fp, #-8]
801627dc:	e5932014 	ldr	r2, [r3, #20]
801627e0:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
801627e4:	e1520003 	cmp	r2, r3
801627e8:	8a000001 	bhi	801627f4 <_RME_Cpt_Add+0x368>
801627ec:	e3e03002 	mvn	r3, #2
801627f0:	ea00013a 	b	80162ce0 <_RME_Cpt_Add+0x854>
801627f4:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
801627f8:	e1a02283 	lsl	r2, r3, #5
801627fc:	e51b3008 	ldr	r3, [fp, #-8]
80162800:	e593300c 	ldr	r3, [r3, #12]
80162804:	e0823003 	add	r3, r2, r3
80162808:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
    RME_CPT_GETSLOT(Cpt_Src,Cap_Src,struct RME_Cap_Struct*,Capobj_Src);
8016280c:	e51b300c 	ldr	r3, [fp, #-12]
80162810:	e5932014 	ldr	r2, [r3, #20]
80162814:	e59b3004 	ldr	r3, [fp, #4]
80162818:	e1520003 	cmp	r2, r3
8016281c:	8a000001 	bhi	80162828 <_RME_Cpt_Add+0x39c>
80162820:	e3e03002 	mvn	r3, #2
80162824:	ea00012d 	b	80162ce0 <_RME_Cpt_Add+0x854>
80162828:	e59b3004 	ldr	r3, [fp, #4]
8016282c:	e1a02283 	lsl	r2, r3, #5
80162830:	e51b300c 	ldr	r3, [fp, #-12]
80162834:	e593300c 	ldr	r3, [r3, #12]
80162838:	e0823003 	add	r3, r2, r3
8016283c:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    
    /* Atomic read - Read barrier to avoid premature checking of the rest */
    Type_Stat=RME_READ_ACQUIRE(&(Capobj_Src->Head.Type_Stat));
80162840:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162844:	e1a00003 	mov	r0, r3
80162848:	ebfff7ac 	bl	80160700 <__RME_A7A_Read_Acquire>
8016284c:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
    /* Is the source cap frozen? */
    if(RME_CAP_STAT(Type_Stat)==RME_CAP_STAT_FROZEN)
80162850:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162854:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80162858:	e3530802 	cmp	r3, #131072	@ 0x20000
8016285c:	1a000001 	bne	80162868 <_RME_Cpt_Add+0x3dc>
    {
        RME_COV_MARKER();
        
        return RME_ERR_CPT_FROZEN;
80162860:	e3e03008 	mvn	r3, #8
80162864:	ea00011d 	b	80162ce0 <_RME_Cpt_Add+0x854>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Does the source cap exist at all? */
    if(Type_Stat==0U)
80162868:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016286c:	e3530000 	cmp	r3, #0
80162870:	1a000001 	bne	8016287c <_RME_Cpt_Add+0x3f0>
    {
        RME_COV_MARKER();
        
        return RME_ERR_CPT_NULL;
80162874:	e3e03000 	mvn	r3, #0
80162878:	ea000118 	b	80162ce0 <_RME_Cpt_Add+0x854>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Dewarn some compilers that complain about uninitialized variables */
    Kom_Begin=0U;
8016287c:	e3a03000 	mov	r3, #0
80162880:	e50b3010 	str	r3, [fp, #-16]
    Kom_End=0U;
80162884:	e3a03000 	mov	r3, #0
80162888:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Kom_Flag=0U;
8016288c:	e3a03000 	mov	r3, #0
80162890:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    
    /* Is there a flag conflict? - For page tables, we have different checking mechanisms */
    Src_Type=RME_CAP_TYPE(Type_Stat);
80162894:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80162898:	e1a03c23 	lsr	r3, r3, #24
8016289c:	e50b3028 	str	r3, [fp, #-40]	@ 0xffffffd8
    if(Src_Type==RME_CAP_TYPE_PGT)
801628a0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801628a4:	e3530004 	cmp	r3, #4
801628a8:	1a00002d 	bne	80162964 <_RME_Cpt_Add+0x4d8>
    {
        RME_COV_MARKER();
        
        /* Check the delegation range */
        if(RME_PGT_FLAG_HIGH(Flag)>RME_PGT_FLAG_HIGH(Capobj_Src->Head.Flag))
801628ac:	e59b3008 	ldr	r3, [fp, #8]
801628b0:	e1a02a23 	lsr	r2, r3, #20
801628b4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801628b8:	e5933008 	ldr	r3, [r3, #8]
801628bc:	e1a03a23 	lsr	r3, r3, #20
801628c0:	e1520003 	cmp	r2, r3
801628c4:	9a000001 	bls	801628d0 <_RME_Cpt_Add+0x444>
        {
            RME_COV_MARKER();
        
            return RME_ERR_CPT_FLAG;
801628c8:	e3e03006 	mvn	r3, #6
801628cc:	ea000103 	b	80162ce0 <_RME_Cpt_Add+0x854>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        if(RME_PGT_FLAG_LOW(Flag)<RME_PGT_FLAG_LOW(Capobj_Src->Head.Flag))
801628d0:	e59b3008 	ldr	r3, [fp, #8]
801628d4:	e1a03423 	lsr	r3, r3, #8
801628d8:	e7eb2053 	ubfx	r2, r3, #0, #12
801628dc:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801628e0:	e5933008 	ldr	r3, [r3, #8]
801628e4:	e1a03423 	lsr	r3, r3, #8
801628e8:	e7eb3053 	ubfx	r3, r3, #0, #12
801628ec:	e1520003 	cmp	r2, r3
801628f0:	2a000001 	bcs	801628fc <_RME_Cpt_Add+0x470>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
801628f4:	e3e03006 	mvn	r3, #6
801628f8:	ea0000f8 	b	80162ce0 <_RME_Cpt_Add+0x854>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        if(RME_PGT_FLAG_HIGH(Flag)<RME_PGT_FLAG_LOW(Flag))
801628fc:	e59b3008 	ldr	r3, [fp, #8]
80162900:	e1a02a23 	lsr	r2, r3, #20
80162904:	e59b3008 	ldr	r3, [fp, #8]
80162908:	e1a03423 	lsr	r3, r3, #8
8016290c:	e7eb3053 	ubfx	r3, r3, #0, #12
80162910:	e1520003 	cmp	r2, r3
80162914:	2a000001 	bcs	80162920 <_RME_Cpt_Add+0x494>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162918:	e3e03006 	mvn	r3, #6
8016291c:	ea0000ef 	b	80162ce0 <_RME_Cpt_Add+0x854>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Check the flags - if there are extra ones, or all zero */
        if(RME_PGT_FLAG_FLAG(Flag)==0U)
80162920:	e59b3008 	ldr	r3, [fp, #8]
80162924:	e6ef3073 	uxtb	r3, r3
80162928:	e3530000 	cmp	r3, #0
8016292c:	1a000001 	bne	80162938 <_RME_Cpt_Add+0x4ac>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162930:	e3e03006 	mvn	r3, #6
80162934:	ea0000e9 	b	80162ce0 <_RME_Cpt_Add+0x854>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        if((RME_PGT_FLAG_FLAG(Flag)&(~RME_PGT_FLAG_FLAG(Capobj_Src->Head.Flag)))!=0U)
80162938:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016293c:	e5933008 	ldr	r3, [r3, #8]
80162940:	e6ef3073 	uxtb	r3, r3
80162944:	e1e02003 	mvn	r2, r3
80162948:	e59b3008 	ldr	r3, [fp, #8]
8016294c:	e0033002 	and	r3, r3, r2
80162950:	e6ef3073 	uxtb	r3, r3
80162954:	e3530000 	cmp	r3, #0
80162958:	0a000077 	beq	80162b3c <_RME_Cpt_Add+0x6b0>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
8016295c:	e3e03006 	mvn	r3, #6
80162960:	ea0000de 	b	80162ce0 <_RME_Cpt_Add+0x854>
        {
            RME_COV_MARKER();
            /* No action required */
        }
    }
    else if(Src_Type==RME_CAP_TYPE_KFN)
80162964:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162968:	e3530001 	cmp	r3, #1
8016296c:	1a000019 	bne	801629d8 <_RME_Cpt_Add+0x54c>
    {
        RME_COV_MARKER();
        
        /* Kernel funcrions only have ranges, no flags - check the delegation range */
        if(RME_KFN_FLAG_HIGH(Flag)>RME_KFN_FLAG_HIGH(Capobj_Src->Head.Flag))
80162970:	e59b3008 	ldr	r3, [fp, #8]
80162974:	e1a02823 	lsr	r2, r3, #16
80162978:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016297c:	e5933008 	ldr	r3, [r3, #8]
80162980:	e1a03823 	lsr	r3, r3, #16
80162984:	e1520003 	cmp	r2, r3
80162988:	9a000001 	bls	80162994 <_RME_Cpt_Add+0x508>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
8016298c:	e3e03006 	mvn	r3, #6
80162990:	ea0000d2 	b	80162ce0 <_RME_Cpt_Add+0x854>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        if(RME_KFN_FLAG_LOW(Flag)<RME_KFN_FLAG_LOW(Capobj_Src->Head.Flag))
80162994:	e59b3008 	ldr	r3, [fp, #8]
80162998:	e6ff2073 	uxth	r2, r3
8016299c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801629a0:	e5933008 	ldr	r3, [r3, #8]
801629a4:	e6ff3073 	uxth	r3, r3
801629a8:	e1520003 	cmp	r2, r3
801629ac:	2a000001 	bcs	801629b8 <_RME_Cpt_Add+0x52c>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
801629b0:	e3e03006 	mvn	r3, #6
801629b4:	ea0000c9 	b	80162ce0 <_RME_Cpt_Add+0x854>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        if(RME_KFN_FLAG_HIGH(Flag)<RME_KFN_FLAG_LOW(Flag))
801629b8:	e59b3008 	ldr	r3, [fp, #8]
801629bc:	e1a02823 	lsr	r2, r3, #16
801629c0:	e59b3008 	ldr	r3, [fp, #8]
801629c4:	e6ff3073 	uxth	r3, r3
801629c8:	e1520003 	cmp	r2, r3
801629cc:	2a00005a 	bcs	80162b3c <_RME_Cpt_Add+0x6b0>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
801629d0:	e3e03006 	mvn	r3, #6
801629d4:	ea0000c1 	b	80162ce0 <_RME_Cpt_Add+0x854>
        {
            RME_COV_MARKER();
            /* No action required */
        }
    }
    else if(Src_Type==RME_CAP_TYPE_KOM)
801629d8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801629dc:	e3530002 	cmp	r3, #2
801629e0:	1a000047 	bne	80162b04 <_RME_Cpt_Add+0x678>
    {
        RME_COV_MARKER();
        
        /* The Kom_End here is exclusive */
        Kom_Begin=RME_KOM_FLAG_LOW(Flag,Ext_Flag);
801629e4:	e59b3008 	ldr	r3, [fp, #8]
801629e8:	e1a03803 	lsl	r3, r3, #16
801629ec:	e50b3010 	str	r3, [fp, #-16]
        Kom_End=RME_KOM_FLAG_HIGH(Flag,Ext_Flag);
801629f0:	e59b3008 	ldr	r3, [fp, #8]
801629f4:	e1a03823 	lsr	r3, r3, #16
801629f8:	e1a03803 	lsl	r3, r3, #16
801629fc:	e59b200c 	ldr	r2, [fp, #12]
80162a00:	e1a02822 	lsr	r2, r2, #16
80162a04:	e3c2203f 	bic	r2, r2, #63	@ 0x3f
80162a08:	e1833002 	orr	r3, r3, r2
80162a0c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
        Kom_Flag=RME_KOM_FLAG_KOM(Ext_Flag);
80162a10:	e3a03000 	mov	r3, #0
80162a14:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
        /* Round start and end to the slot boundary, if we are using slots bigger than 64 bytes */
#if(RME_KOM_SLOT_ORDER>6U)
        Kom_End=RME_ROUND_DOWN(Kom_End,RME_KOM_SLOT_ORDER);
        Kom_Begin=RME_ROUND_UP(Kom_Begin,RME_KOM_SLOT_ORDER);
#endif
        if(Kom_End<=Kom_Begin)
80162a18:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80162a1c:	e51b3010 	ldr	r3, [fp, #-16]
80162a20:	e1520003 	cmp	r2, r3
80162a24:	8a000001 	bhi	80162a30 <_RME_Cpt_Add+0x5a4>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162a28:	e3e03006 	mvn	r3, #6
80162a2c:	ea0000ab 	b	80162ce0 <_RME_Cpt_Add+0x854>
            RME_COV_MARKER();
            /* No action required */
        }

        /* Convert relative addresses to absolute addresses and check for overflow */
        Kom_Begin+=((volatile struct RME_Cap_Kom*)Capobj_Src)->Begin;
80162a30:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162a34:	e5933014 	ldr	r3, [r3, #20]
80162a38:	e51b2010 	ldr	r2, [fp, #-16]
80162a3c:	e0823003 	add	r3, r2, r3
80162a40:	e50b3010 	str	r3, [fp, #-16]
        if(Kom_Begin<((volatile struct RME_Cap_Kom*)Capobj_Src)->Begin)
80162a44:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162a48:	e5933014 	ldr	r3, [r3, #20]
80162a4c:	e51b2010 	ldr	r2, [fp, #-16]
80162a50:	e1520003 	cmp	r2, r3
80162a54:	2a000001 	bcs	80162a60 <_RME_Cpt_Add+0x5d4>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162a58:	e3e03006 	mvn	r3, #6
80162a5c:	ea00009f 	b	80162ce0 <_RME_Cpt_Add+0x854>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        Kom_End+=((volatile struct RME_Cap_Kom*)Capobj_Src)->Begin;
80162a60:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162a64:	e5933014 	ldr	r3, [r3, #20]
80162a68:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80162a6c:	e0823003 	add	r3, r2, r3
80162a70:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
        if(Kom_End<((volatile struct RME_Cap_Kom*)Capobj_Src)->Begin)
80162a74:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162a78:	e5933014 	ldr	r3, [r3, #20]
80162a7c:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80162a80:	e1520003 	cmp	r2, r3
80162a84:	2a000001 	bcs	80162a90 <_RME_Cpt_Add+0x604>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162a88:	e3e03006 	mvn	r3, #6
80162a8c:	ea000093 	b	80162ce0 <_RME_Cpt_Add+0x854>
            RME_COV_MARKER();
            /* No action required */
        }

        /* Check the ranges of kernel memory */
        if(((volatile struct RME_Cap_Kom*)Capobj_Src)->Begin>Kom_Begin)
80162a90:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162a94:	e5933014 	ldr	r3, [r3, #20]
80162a98:	e51b2010 	ldr	r2, [fp, #-16]
80162a9c:	e1520003 	cmp	r2, r3
80162aa0:	2a000001 	bcs	80162aac <_RME_Cpt_Add+0x620>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162aa4:	e3e03006 	mvn	r3, #6
80162aa8:	ea00008c 	b	80162ce0 <_RME_Cpt_Add+0x854>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Internal encoding of 'end' is inclusive */
        if(((volatile struct RME_Cap_Kom*)Capobj_Src)->End<(Kom_End-1U))
80162aac:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162ab0:	e5932018 	ldr	r2, [r3, #24]
80162ab4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162ab8:	e2433001 	sub	r3, r3, #1
80162abc:	e1520003 	cmp	r2, r3
80162ac0:	2a000001 	bcs	80162acc <_RME_Cpt_Add+0x640>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162ac4:	e3e03006 	mvn	r3, #6
80162ac8:	ea000084 	b	80162ce0 <_RME_Cpt_Add+0x854>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Check the flags - if there are extra ones, or all zero */
        if(Kom_Flag==0U)
80162acc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80162ad0:	e3530000 	cmp	r3, #0
80162ad4:	1a000001 	bne	80162ae0 <_RME_Cpt_Add+0x654>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162ad8:	e3e03006 	mvn	r3, #6
80162adc:	ea00007f 	b	80162ce0 <_RME_Cpt_Add+0x854>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        if((Kom_Flag&(~(Capobj_Src->Head.Flag)))!=0U)
80162ae0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162ae4:	e5933008 	ldr	r3, [r3, #8]
80162ae8:	e1e02003 	mvn	r2, r3
80162aec:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80162af0:	e0033002 	and	r3, r3, r2
80162af4:	e3530000 	cmp	r3, #0
80162af8:	0a00000f 	beq	80162b3c <_RME_Cpt_Add+0x6b0>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162afc:	e3e03006 	mvn	r3, #6
80162b00:	ea000076 	b	80162ce0 <_RME_Cpt_Add+0x854>
    else
    {
        RME_COV_MARKER();
        
        /* Check the flags - if there are extra ones, or all zero */
        if(Flag==0U)
80162b04:	e59b3008 	ldr	r3, [fp, #8]
80162b08:	e3530000 	cmp	r3, #0
80162b0c:	1a000001 	bne	80162b18 <_RME_Cpt_Add+0x68c>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162b10:	e3e03006 	mvn	r3, #6
80162b14:	ea000071 	b	80162ce0 <_RME_Cpt_Add+0x854>
        else
        {
            RME_COV_MARKER();
            /* No action required */
        }
        if((Flag&(~(Capobj_Src->Head.Flag)))!=0U)
80162b18:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162b1c:	e5933008 	ldr	r3, [r3, #8]
80162b20:	e1e02003 	mvn	r2, r3
80162b24:	e59b3008 	ldr	r3, [fp, #8]
80162b28:	e0033002 	and	r3, r3, r2
80162b2c:	e3530000 	cmp	r3, #0
80162b30:	0a000001 	beq	80162b3c <_RME_Cpt_Add+0x6b0>
        {
            RME_COV_MARKER();
            
            return RME_ERR_CPT_FLAG;
80162b34:	e3e03006 	mvn	r3, #6
80162b38:	ea000068 	b	80162ce0 <_RME_Cpt_Add+0x854>
            /* No action required */
        }
    }
    
    /* Is the destination slot unoccupied? */
    if(Capobj_Dst->Head.Type_Stat!=0U)
80162b3c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162b40:	e5933000 	ldr	r3, [r3]
80162b44:	e3530000 	cmp	r3, #0
80162b48:	0a000001 	beq	80162b54 <_RME_Cpt_Add+0x6c8>
    {
        RME_COV_MARKER();
            
        return RME_ERR_CPT_EXIST;
80162b4c:	e3e03004 	mvn	r3, #4
80162b50:	ea000062 	b	80162ce0 <_RME_Cpt_Add+0x854>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Try to take the empty slot */
    RME_CPT_OCCUPY(Capobj_Dst);
80162b54:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162b58:	e3a02801 	mov	r2, #65536	@ 0x10000
80162b5c:	e3a01000 	mov	r1, #0
80162b60:	e1a00003 	mov	r0, r3
80162b64:	ebfff814 	bl	80160bbc <_RME_Comp_Swap_Single>
80162b68:	e1a03000 	mov	r3, r0
80162b6c:	e3530000 	cmp	r3, #0
80162b70:	1a000001 	bne	80162b7c <_RME_Cpt_Add+0x6f0>
80162b74:	e3e03004 	mvn	r3, #4
80162b78:	ea000058 	b	80162ce0 <_RME_Cpt_Add+0x854>
80162b7c:	e3003000 	movw	r3, #0
80162b80:	e3483017 	movt	r3, #32791	@ 0x8017
80162b84:	e5932000 	ldr	r2, [r3]
80162b88:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162b8c:	e5832010 	str	r2, [r3, #16]
    
    /* All done, we replicate the cap with flags */
    if(Src_Type==RME_CAP_TYPE_KOM)
80162b90:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162b94:	e3530002 	cmp	r3, #2
80162b98:	1a00001a 	bne	80162c08 <_RME_Cpt_Add+0x77c>
    {
        RME_COV_MARKER();
            
        RME_CAP_COPY(Capobj_Dst,Capobj_Src,Kom_Flag);
80162b9c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162ba0:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80162ba4:	e5832008 	str	r2, [r3, #8]
80162ba8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162bac:	e593200c 	ldr	r2, [r3, #12]
80162bb0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162bb4:	e583200c 	str	r2, [r3, #12]
80162bb8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162bbc:	e5932014 	ldr	r2, [r3, #20]
80162bc0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162bc4:	e5832014 	str	r2, [r3, #20]
80162bc8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162bcc:	e5932018 	ldr	r2, [r3, #24]
80162bd0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162bd4:	e5832018 	str	r2, [r3, #24]
80162bd8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162bdc:	e593201c 	ldr	r2, [r3, #28]
80162be0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162be4:	e583201c 	str	r2, [r3, #28]
        /* Write absolute range information for kernel memory caps */
        ((volatile struct RME_Cap_Kom*)Capobj_Dst)->Begin=Kom_Begin;
80162be8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162bec:	e51b2010 	ldr	r2, [fp, #-16]
80162bf0:	e5832014 	str	r2, [r3, #20]
        /* The Kom_End encoded inclusively to avoid overflow at max address */
        ((volatile struct RME_Cap_Kom*)Capobj_Dst)->End=Kom_End-1U;
80162bf4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162bf8:	e2432001 	sub	r2, r3, #1
80162bfc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162c00:	e5832018 	str	r2, [r3, #24]
80162c04:	ea000012 	b	80162c54 <_RME_Cpt_Add+0x7c8>
    }
    else
    {
        RME_COV_MARKER();
        
        RME_CAP_COPY(Capobj_Dst,Capobj_Src,Flag);
80162c08:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162c0c:	e59b2008 	ldr	r2, [fp, #8]
80162c10:	e5832008 	str	r2, [r3, #8]
80162c14:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162c18:	e593200c 	ldr	r2, [r3, #12]
80162c1c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162c20:	e583200c 	str	r2, [r3, #12]
80162c24:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162c28:	e5932014 	ldr	r2, [r3, #20]
80162c2c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162c30:	e5832014 	str	r2, [r3, #20]
80162c34:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162c38:	e5932018 	ldr	r2, [r3, #24]
80162c3c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162c40:	e5832018 	str	r2, [r3, #24]
80162c44:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162c48:	e593201c 	ldr	r2, [r3, #28]
80162c4c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162c50:	e583201c 	str	r2, [r3, #28]
     * their parent, nor will they update the parent's reference count. This
     * design decision comes from the fact that these two capability types are
     * always created on boot and delegated everywhere, and they don't actually
     * have an object. If we use refcnt on these, we may cause scalability 
     * issues. The parent cap can't be deleted anyway, so this is fine. */
    if((Src_Type!=RME_CAP_TYPE_KOM)&&(Src_Type!=RME_CAP_TYPE_KFN))
80162c54:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162c58:	e3530002 	cmp	r3, #2
80162c5c:	0a000014 	beq	80162cb4 <_RME_Cpt_Add+0x828>
80162c60:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162c64:	e3530001 	cmp	r3, #1
80162c68:	0a000011 	beq	80162cb4 <_RME_Cpt_Add+0x828>
    {
        RME_COV_MARKER();
        
        /* Register root */
        Capobj_Dst->Head.Root_Ref=RME_CAP_CONV_ROOT(Capobj_Src,rme_ptr_t);
80162c6c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162c70:	e5933000 	ldr	r3, [r3]
80162c74:	e6ff3073 	uxth	r3, r3
80162c78:	e3530000 	cmp	r3, #0
80162c7c:	0a000002 	beq	80162c8c <_RME_Cpt_Add+0x800>
80162c80:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162c84:	e5933004 	ldr	r3, [r3, #4]
80162c88:	ea000000 	b	80162c90 <_RME_Cpt_Add+0x804>
80162c8c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162c90:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80162c94:	e5823004 	str	r3, [r2, #4]
    
        /* Increase the parent's refcnt - never overflows, guaranteed by field size */
        RME_FETCH_ADD(&(((volatile struct RME_Cap_Struct*)
80162c98:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162c9c:	e5933004 	ldr	r3, [r3, #4]
80162ca0:	e2833004 	add	r3, r3, #4
80162ca4:	e3a01001 	mov	r1, #1
80162ca8:	e1a00003 	mov	r0, r3
80162cac:	ebfff7d7 	bl	80160c10 <_RME_Fetch_Add_Single>
80162cb0:	ea000002 	b	80162cc0 <_RME_Cpt_Add+0x834>
    else
    {
        RME_COV_MARKER();
        
        /* No root for KOM and KFN */
        Capobj_Dst->Head.Root_Ref=0U;
80162cb4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162cb8:	e3a02000 	mov	r2, #0
80162cbc:	e5832004 	str	r2, [r3, #4]
    }

    /* Establish cap */
    RME_WRITE_RELEASE(&(Capobj_Dst->Head.Type_Stat),
80162cc0:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80162cc4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162cc8:	e1a03c03 	lsl	r3, r3, #24
80162ccc:	e3833001 	orr	r3, r3, #1
80162cd0:	e1a01003 	mov	r1, r3
80162cd4:	e1a00002 	mov	r0, r2
80162cd8:	ebfff68b 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(Src_Type,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_LEAF));

    return 0;
80162cdc:	e3a03000 	mov	r3, #0
}
80162ce0:	e1a00003 	mov	r0, r3
80162ce4:	e24bd004 	sub	sp, fp, #4
80162ce8:	e8bd8800 	pop	{fp, pc}

80162cec <_RME_Cpt_Rem>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Cpt_Rem(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt_Rem,
                              rme_cid_t Cap_Rem)
{
80162cec:	e92d4800 	push	{fp, lr}
80162cf0:	e28db004 	add	fp, sp, #4
80162cf4:	e24dd028 	sub	sp, sp, #40	@ 0x28
80162cf8:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
80162cfc:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
80162d00:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
    rme_ptr_t Rem_Type;
    /* This is used for removal */
    volatile struct RME_Cap_Struct* Capobj_Root;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Rem,RME_CAP_TYPE_CPT,
80162d04:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162d08:	e2033080 	and	r3, r3, #128	@ 0x80
80162d0c:	e3530000 	cmp	r3, #0
80162d10:	1a00001c 	bne	80162d88 <_RME_Cpt_Rem+0x9c>
80162d14:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162d18:	e5932014 	ldr	r2, [r3, #20]
80162d1c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162d20:	e1520003 	cmp	r2, r3
80162d24:	8a000001 	bhi	80162d30 <_RME_Cpt_Rem+0x44>
80162d28:	e3e03002 	mvn	r3, #2
80162d2c:	ea0000ab 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
80162d30:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162d34:	e1a02283 	lsl	r2, r3, #5
80162d38:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162d3c:	e593300c 	ldr	r3, [r3, #12]
80162d40:	e0823003 	add	r3, r2, r3
80162d44:	e50b3008 	str	r3, [fp, #-8]
80162d48:	e51b3008 	ldr	r3, [fp, #-8]
80162d4c:	e1a00003 	mov	r0, r3
80162d50:	ebfff66a 	bl	80160700 <__RME_A7A_Read_Acquire>
80162d54:	e50b000c 	str	r0, [fp, #-12]
80162d58:	e51b300c 	ldr	r3, [fp, #-12]
80162d5c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80162d60:	e3530802 	cmp	r3, #131072	@ 0x20000
80162d64:	1a000001 	bne	80162d70 <_RME_Cpt_Rem+0x84>
80162d68:	e3e03008 	mvn	r3, #8
80162d6c:	ea00009b 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
80162d70:	e51b300c 	ldr	r3, [fp, #-12]
80162d74:	e1a03c23 	lsr	r3, r3, #24
80162d78:	e3530003 	cmp	r3, #3
80162d7c:	0a00003f 	beq	80162e80 <_RME_Cpt_Rem+0x194>
80162d80:	e3e03001 	mvn	r3, #1
80162d84:	ea000095 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
80162d88:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162d8c:	e1a02423 	lsr	r2, r3, #8
80162d90:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162d94:	e5933014 	ldr	r3, [r3, #20]
80162d98:	e1520003 	cmp	r2, r3
80162d9c:	3a000001 	bcc	80162da8 <_RME_Cpt_Rem+0xbc>
80162da0:	e3e03002 	mvn	r3, #2
80162da4:	ea00008d 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
80162da8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162dac:	e1a03423 	lsr	r3, r3, #8
80162db0:	e1a02283 	lsl	r2, r3, #5
80162db4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80162db8:	e593300c 	ldr	r3, [r3, #12]
80162dbc:	e0823003 	add	r3, r2, r3
80162dc0:	e50b3008 	str	r3, [fp, #-8]
80162dc4:	e51b3008 	ldr	r3, [fp, #-8]
80162dc8:	e1a00003 	mov	r0, r3
80162dcc:	ebfff64b 	bl	80160700 <__RME_A7A_Read_Acquire>
80162dd0:	e50b000c 	str	r0, [fp, #-12]
80162dd4:	e51b300c 	ldr	r3, [fp, #-12]
80162dd8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80162ddc:	e3530802 	cmp	r3, #131072	@ 0x20000
80162de0:	1a000001 	bne	80162dec <_RME_Cpt_Rem+0x100>
80162de4:	e3e03008 	mvn	r3, #8
80162de8:	ea00007c 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
80162dec:	e51b300c 	ldr	r3, [fp, #-12]
80162df0:	e1a03c23 	lsr	r3, r3, #24
80162df4:	e3530003 	cmp	r3, #3
80162df8:	0a000001 	beq	80162e04 <_RME_Cpt_Rem+0x118>
80162dfc:	e3e03001 	mvn	r3, #1
80162e00:	ea000076 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
80162e04:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162e08:	e203207f 	and	r2, r3, #127	@ 0x7f
80162e0c:	e51b3008 	ldr	r3, [fp, #-8]
80162e10:	e5933014 	ldr	r3, [r3, #20]
80162e14:	e1520003 	cmp	r2, r3
80162e18:	3a000001 	bcc	80162e24 <_RME_Cpt_Rem+0x138>
80162e1c:	e3e03002 	mvn	r3, #2
80162e20:	ea00006e 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
80162e24:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80162e28:	e203307f 	and	r3, r3, #127	@ 0x7f
80162e2c:	e1a02283 	lsl	r2, r3, #5
80162e30:	e51b3008 	ldr	r3, [fp, #-8]
80162e34:	e593300c 	ldr	r3, [r3, #12]
80162e38:	e0823003 	add	r3, r2, r3
80162e3c:	e50b3008 	str	r3, [fp, #-8]
80162e40:	e51b3008 	ldr	r3, [fp, #-8]
80162e44:	e1a00003 	mov	r0, r3
80162e48:	ebfff62c 	bl	80160700 <__RME_A7A_Read_Acquire>
80162e4c:	e50b000c 	str	r0, [fp, #-12]
80162e50:	e51b300c 	ldr	r3, [fp, #-12]
80162e54:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80162e58:	e3530802 	cmp	r3, #131072	@ 0x20000
80162e5c:	1a000001 	bne	80162e68 <_RME_Cpt_Rem+0x17c>
80162e60:	e3e03008 	mvn	r3, #8
80162e64:	ea00005d 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
80162e68:	e51b300c 	ldr	r3, [fp, #-12]
80162e6c:	e1a03c23 	lsr	r3, r3, #24
80162e70:	e3530003 	cmp	r3, #3
80162e74:	0a000001 	beq	80162e80 <_RME_Cpt_Rem+0x194>
80162e78:	e3e03001 	mvn	r3, #1
80162e7c:	ea000057 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_REM);
80162e80:	e51b3008 	ldr	r3, [fp, #-8]
80162e84:	e5933008 	ldr	r3, [r3, #8]
80162e88:	e2033020 	and	r3, r3, #32
80162e8c:	e3530000 	cmp	r3, #0
80162e90:	1a000001 	bne	80162e9c <_RME_Cpt_Rem+0x1b0>
80162e94:	e3e03006 	mvn	r3, #6
80162e98:	ea000050 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Rem,struct RME_Cap_Struct*,Capobj_Rem);
80162e9c:	e51b3008 	ldr	r3, [fp, #-8]
80162ea0:	e5932014 	ldr	r2, [r3, #20]
80162ea4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162ea8:	e1520003 	cmp	r2, r3
80162eac:	8a000001 	bhi	80162eb8 <_RME_Cpt_Rem+0x1cc>
80162eb0:	e3e03002 	mvn	r3, #2
80162eb4:	ea000049 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
80162eb8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80162ebc:	e1a02283 	lsl	r2, r3, #5
80162ec0:	e51b3008 	ldr	r3, [fp, #-8]
80162ec4:	e593300c 	ldr	r3, [r3, #12]
80162ec8:	e0823003 	add	r3, r2, r3
80162ecc:	e50b3010 	str	r3, [fp, #-16]
    /* Removal check */
    RME_CAP_REM_CHECK(Capobj_Rem,Type_Stat);
80162ed0:	e51b3010 	ldr	r3, [fp, #-16]
80162ed4:	e1a00003 	mov	r0, r3
80162ed8:	ebfff608 	bl	80160700 <__RME_A7A_Read_Acquire>
80162edc:	e50b000c 	str	r0, [fp, #-12]
80162ee0:	e51b300c 	ldr	r3, [fp, #-12]
80162ee4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80162ee8:	e3530802 	cmp	r3, #131072	@ 0x20000
80162eec:	0a000001 	beq	80162ef8 <_RME_Cpt_Rem+0x20c>
80162ef0:	e3e03008 	mvn	r3, #8
80162ef4:	ea000039 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
80162ef8:	e3003000 	movw	r3, #0
80162efc:	e3483017 	movt	r3, #32791	@ 0x8017
80162f00:	e5932000 	ldr	r2, [r3]
80162f04:	e51b3010 	ldr	r3, [fp, #-16]
80162f08:	e5933010 	ldr	r3, [r3, #16]
80162f0c:	e1a01003 	mov	r1, r3
80162f10:	e1a00002 	mov	r0, r2
80162f14:	ebfff795 	bl	80160d70 <_RME_Diff>
80162f18:	e1a03000 	mov	r3, r0
80162f1c:	e353000a 	cmp	r3, #10
80162f20:	8a000001 	bhi	80162f2c <_RME_Cpt_Rem+0x240>
80162f24:	e3e03007 	mvn	r3, #7
80162f28:	ea00002c 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
80162f2c:	e51b300c 	ldr	r3, [fp, #-12]
80162f30:	e6ff3073 	uxth	r3, r3
80162f34:	e3530000 	cmp	r3, #0
80162f38:	1a000001 	bne	80162f44 <_RME_Cpt_Rem+0x258>
80162f3c:	e3e03009 	mvn	r3, #9
80162f40:	ea000026 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
    
    /* If we are KFN or KOM, we don't care about parent or refcnt */
    Rem_Type=RME_CAP_TYPE(Type_Stat);
80162f44:	e51b300c 	ldr	r3, [fp, #-12]
80162f48:	e1a03c23 	lsr	r3, r3, #24
80162f4c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    if((Rem_Type!=RME_CAP_TYPE_KOM)&&(Rem_Type!=RME_CAP_TYPE_KFN))
80162f50:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162f54:	e3530002 	cmp	r3, #2
80162f58:	0a000015 	beq	80162fb4 <_RME_Cpt_Rem+0x2c8>
80162f5c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80162f60:	e3530001 	cmp	r3, #1
80162f64:	0a000012 	beq	80162fb4 <_RME_Cpt_Rem+0x2c8>
    {
        RME_COV_MARKER();
        
        /* Remember this for refcnt operations */
        Capobj_Root=(struct RME_Cap_Struct*)(Capobj_Rem->Head.Root_Ref);
80162f68:	e51b3010 	ldr	r3, [fp, #-16]
80162f6c:	e5933004 	ldr	r3, [r3, #4]
80162f70:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
        
        RME_CAP_DELETE(Capobj_Rem,Type_Stat);
80162f74:	e51b3010 	ldr	r3, [fp, #-16]
80162f78:	e3a02000 	mov	r2, #0
80162f7c:	e51b100c 	ldr	r1, [fp, #-12]
80162f80:	e1a00003 	mov	r0, r3
80162f84:	ebfff70c 	bl	80160bbc <_RME_Comp_Swap_Single>
80162f88:	e1a03000 	mov	r3, r0
80162f8c:	e3530000 	cmp	r3, #0
80162f90:	1a000001 	bne	80162f9c <_RME_Cpt_Rem+0x2b0>
80162f94:	e3e03000 	mvn	r3, #0
80162f98:	ea000010 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>

        /* Check done, decrease its parent's refcnt. This must be done at last */
        RME_FETCH_ADD(&(Capobj_Root->Head.Root_Ref),-1);
80162f9c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80162fa0:	e2833004 	add	r3, r3, #4
80162fa4:	e3e01000 	mvn	r1, #0
80162fa8:	e1a00003 	mov	r0, r3
80162fac:	ebfff717 	bl	80160c10 <_RME_Fetch_Add_Single>
80162fb0:	ea000009 	b	80162fdc <_RME_Cpt_Rem+0x2f0>
    else
    {
        RME_COV_MARKER();

        /* Helping also applies here */
        RME_CAP_DELETE(Capobj_Rem,Type_Stat);
80162fb4:	e51b3010 	ldr	r3, [fp, #-16]
80162fb8:	e3a02000 	mov	r2, #0
80162fbc:	e51b100c 	ldr	r1, [fp, #-12]
80162fc0:	e1a00003 	mov	r0, r3
80162fc4:	ebfff6fc 	bl	80160bbc <_RME_Comp_Swap_Single>
80162fc8:	e1a03000 	mov	r3, r0
80162fcc:	e3530000 	cmp	r3, #0
80162fd0:	1a000001 	bne	80162fdc <_RME_Cpt_Rem+0x2f0>
80162fd4:	e3e03000 	mvn	r3, #0
80162fd8:	ea000000 	b	80162fe0 <_RME_Cpt_Rem+0x2f4>
    }
    
    return 0;
80162fdc:	e3a03000 	mov	r3, #0
}
80162fe0:	e1a00003 	mov	r0, r3
80162fe4:	e24bd004 	sub	sp, fp, #4
80162fe8:	e8bd8800 	pop	{fp, pc}

80162fec <_RME_Pgt_Boot_Crt>:
                            rme_ptr_t Vaddr,
                            rme_ptr_t Base,
                            rme_ptr_t Is_Top,
                            rme_ptr_t Size_Order,
                            rme_ptr_t Num_Order)
{
80162fec:	e92d4800 	push	{fp, lr}
80162ff0:	e28db004 	add	fp, sp, #4
80162ff4:	e24dd028 	sub	sp, sp, #40	@ 0x28
80162ff8:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80162ffc:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
80163000:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
80163004:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    rme_ptr_t Type_Stat;
    rme_ptr_t Table_Size;
    
    /* Check if the total representable memory exceeds our maximum possible
     * addressible memory under the machine word length */
    if((Size_Order+Num_Order)>RME_POW2(RME_WORD_ORDER))
80163008:	e59b200c 	ldr	r2, [fp, #12]
8016300c:	e59b3010 	ldr	r3, [fp, #16]
80163010:	e0823003 	add	r3, r2, r3
80163014:	e3530020 	cmp	r3, #32
80163018:	9a000001 	bls	80163024 <_RME_Pgt_Boot_Crt+0x38>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_HW;
8016301c:	e3e03066 	mvn	r3, #102	@ 0x66
80163020:	ea0000d0 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Get the cap location that we care about */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
80163024:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163028:	e2033080 	and	r3, r3, #128	@ 0x80
8016302c:	e3530000 	cmp	r3, #0
80163030:	1a00001c 	bne	801630a8 <_RME_Pgt_Boot_Crt+0xbc>
80163034:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80163038:	e5932014 	ldr	r2, [r3, #20]
8016303c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163040:	e1520003 	cmp	r2, r3
80163044:	8a000001 	bhi	80163050 <_RME_Pgt_Boot_Crt+0x64>
80163048:	e3e03002 	mvn	r3, #2
8016304c:	ea0000c5 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
80163050:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163054:	e1a02283 	lsl	r2, r3, #5
80163058:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016305c:	e593300c 	ldr	r3, [r3, #12]
80163060:	e0823003 	add	r3, r2, r3
80163064:	e50b300c 	str	r3, [fp, #-12]
80163068:	e51b300c 	ldr	r3, [fp, #-12]
8016306c:	e1a00003 	mov	r0, r3
80163070:	ebfff5a2 	bl	80160700 <__RME_A7A_Read_Acquire>
80163074:	e50b0010 	str	r0, [fp, #-16]
80163078:	e51b3010 	ldr	r3, [fp, #-16]
8016307c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80163080:	e3530802 	cmp	r3, #131072	@ 0x20000
80163084:	1a000001 	bne	80163090 <_RME_Pgt_Boot_Crt+0xa4>
80163088:	e3e03008 	mvn	r3, #8
8016308c:	ea0000b5 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
80163090:	e51b3010 	ldr	r3, [fp, #-16]
80163094:	e1a03c23 	lsr	r3, r3, #24
80163098:	e3530003 	cmp	r3, #3
8016309c:	0a00003f 	beq	801631a0 <_RME_Pgt_Boot_Crt+0x1b4>
801630a0:	e3e03001 	mvn	r3, #1
801630a4:	ea0000af 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
801630a8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801630ac:	e1a02423 	lsr	r2, r3, #8
801630b0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801630b4:	e5933014 	ldr	r3, [r3, #20]
801630b8:	e1520003 	cmp	r2, r3
801630bc:	3a000001 	bcc	801630c8 <_RME_Pgt_Boot_Crt+0xdc>
801630c0:	e3e03002 	mvn	r3, #2
801630c4:	ea0000a7 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
801630c8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801630cc:	e1a03423 	lsr	r3, r3, #8
801630d0:	e1a02283 	lsl	r2, r3, #5
801630d4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801630d8:	e593300c 	ldr	r3, [r3, #12]
801630dc:	e0823003 	add	r3, r2, r3
801630e0:	e50b300c 	str	r3, [fp, #-12]
801630e4:	e51b300c 	ldr	r3, [fp, #-12]
801630e8:	e1a00003 	mov	r0, r3
801630ec:	ebfff583 	bl	80160700 <__RME_A7A_Read_Acquire>
801630f0:	e50b0010 	str	r0, [fp, #-16]
801630f4:	e51b3010 	ldr	r3, [fp, #-16]
801630f8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801630fc:	e3530802 	cmp	r3, #131072	@ 0x20000
80163100:	1a000001 	bne	8016310c <_RME_Pgt_Boot_Crt+0x120>
80163104:	e3e03008 	mvn	r3, #8
80163108:	ea000096 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
8016310c:	e51b3010 	ldr	r3, [fp, #-16]
80163110:	e1a03c23 	lsr	r3, r3, #24
80163114:	e3530003 	cmp	r3, #3
80163118:	0a000001 	beq	80163124 <_RME_Pgt_Boot_Crt+0x138>
8016311c:	e3e03001 	mvn	r3, #1
80163120:	ea000090 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
80163124:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163128:	e203207f 	and	r2, r3, #127	@ 0x7f
8016312c:	e51b300c 	ldr	r3, [fp, #-12]
80163130:	e5933014 	ldr	r3, [r3, #20]
80163134:	e1520003 	cmp	r2, r3
80163138:	3a000001 	bcc	80163144 <_RME_Pgt_Boot_Crt+0x158>
8016313c:	e3e03002 	mvn	r3, #2
80163140:	ea000088 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
80163144:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163148:	e203307f 	and	r3, r3, #127	@ 0x7f
8016314c:	e1a02283 	lsl	r2, r3, #5
80163150:	e51b300c 	ldr	r3, [fp, #-12]
80163154:	e593300c 	ldr	r3, [r3, #12]
80163158:	e0823003 	add	r3, r2, r3
8016315c:	e50b300c 	str	r3, [fp, #-12]
80163160:	e51b300c 	ldr	r3, [fp, #-12]
80163164:	e1a00003 	mov	r0, r3
80163168:	ebfff564 	bl	80160700 <__RME_A7A_Read_Acquire>
8016316c:	e50b0010 	str	r0, [fp, #-16]
80163170:	e51b3010 	ldr	r3, [fp, #-16]
80163174:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80163178:	e3530802 	cmp	r3, #131072	@ 0x20000
8016317c:	1a000001 	bne	80163188 <_RME_Pgt_Boot_Crt+0x19c>
80163180:	e3e03008 	mvn	r3, #8
80163184:	ea000077 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
80163188:	e51b3010 	ldr	r3, [fp, #-16]
8016318c:	e1a03c23 	lsr	r3, r3, #24
80163190:	e3530003 	cmp	r3, #3
80163194:	0a000001 	beq	801631a0 <_RME_Pgt_Boot_Crt+0x1b4>
80163198:	e3e03001 	mvn	r3, #1
8016319c:	ea000071 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_CRT);
801631a0:	e51b300c 	ldr	r3, [fp, #-12]
801631a4:	e5933008 	ldr	r3, [r3, #8]
801631a8:	e2033001 	and	r3, r3, #1
801631ac:	e3530000 	cmp	r3, #0
801631b0:	1a000001 	bne	801631bc <_RME_Pgt_Boot_Crt+0x1d0>
801631b4:	e3e03006 	mvn	r3, #6
801631b8:	ea00006a 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
    
    /* Check if these parameters are feasible */
    if(__RME_Pgt_Check(Base,Is_Top,Size_Order,Num_Order,Vaddr)!=0)
801631bc:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801631c0:	e58d3000 	str	r3, [sp]
801631c4:	e59b3010 	ldr	r3, [fp, #16]
801631c8:	e59b200c 	ldr	r2, [fp, #12]
801631cc:	e59b1008 	ldr	r1, [fp, #8]
801631d0:	e59b0004 	ldr	r0, [fp, #4]
801631d4:	eb002b45 	bl	8016def0 <__RME_Pgt_Check>
801631d8:	e1a03000 	mov	r3, r0
801631dc:	e3530000 	cmp	r3, #0
801631e0:	0a000001 	beq	801631ec <_RME_Pgt_Boot_Crt+0x200>
    {
        RME_COV_MARKER();
    
        return RME_ERR_PGT_HW;
801631e4:	e3e03066 	mvn	r3, #102	@ 0x66
801631e8:	ea00005e 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Check if the base address is properly aligned to the total order of the page table */
    if((Base&RME_MASK_END(Size_Order+Num_Order-1U))!=0U)
801631ec:	e59b200c 	ldr	r2, [fp, #12]
801631f0:	e59b3010 	ldr	r3, [fp, #16]
801631f4:	e0823003 	add	r3, r2, r3
801631f8:	e2633020 	rsb	r3, r3, #32
801631fc:	e3e02000 	mvn	r2, #0
80163200:	e1a02332 	lsr	r2, r2, r3
80163204:	e59b3004 	ldr	r3, [fp, #4]
80163208:	e0033002 	and	r3, r3, r2
8016320c:	e3530000 	cmp	r3, #0
80163210:	0a000001 	beq	8016321c <_RME_Pgt_Boot_Crt+0x230>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_HW;
80163214:	e3e03066 	mvn	r3, #102	@ 0x66
80163218:	ea000052 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Pgt,struct RME_Cap_Pgt*,Pgt_Crt);
8016321c:	e51b300c 	ldr	r3, [fp, #-12]
80163220:	e5932014 	ldr	r2, [r3, #20]
80163224:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163228:	e1520003 	cmp	r2, r3
8016322c:	8a000001 	bhi	80163238 <_RME_Pgt_Boot_Crt+0x24c>
80163230:	e3e03002 	mvn	r3, #2
80163234:	ea00004b 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
80163238:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016323c:	e1a02283 	lsl	r2, r3, #5
80163240:	e51b300c 	ldr	r3, [fp, #-12]
80163244:	e593300c 	ldr	r3, [r3, #12]
80163248:	e0823003 	add	r3, r2, r3
8016324c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Pgt_Crt);
80163250:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163254:	e3a02801 	mov	r2, #65536	@ 0x10000
80163258:	e3a01000 	mov	r1, #0
8016325c:	e1a00003 	mov	r0, r3
80163260:	ebfff655 	bl	80160bbc <_RME_Comp_Swap_Single>
80163264:	e1a03000 	mov	r3, r0
80163268:	e3530000 	cmp	r3, #0
8016326c:	1a000001 	bne	80163278 <_RME_Pgt_Boot_Crt+0x28c>
80163270:	e3e03004 	mvn	r3, #4
80163274:	ea00003b 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
80163278:	e3003000 	movw	r3, #0
8016327c:	e3483017 	movt	r3, #32791	@ 0x8017
80163280:	e5932000 	ldr	r2, [r3]
80163284:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163288:	e5832010 	str	r2, [r3, #16]

    /* Are we creating the top level? */
    if(Is_Top!=0U)
8016328c:	e59b3008 	ldr	r3, [fp, #8]
80163290:	e3530000 	cmp	r3, #0
80163294:	0a000004 	beq	801632ac <_RME_Pgt_Boot_Crt+0x2c0>
    {
        RME_COV_MARKER();
        
        Table_Size=RME_PGT_SIZE_TOP(Num_Order);
80163298:	e3a02004 	mov	r2, #4
8016329c:	e59b3010 	ldr	r3, [fp, #16]
801632a0:	e1a03312 	lsl	r3, r2, r3
801632a4:	e50b3008 	str	r3, [fp, #-8]
801632a8:	ea000003 	b	801632bc <_RME_Pgt_Boot_Crt+0x2d0>
    }
    else
    {
        RME_COV_MARKER();
        
        Table_Size=RME_PGT_SIZE_NOM(Num_Order);
801632ac:	e3a02004 	mov	r2, #4
801632b0:	e59b3010 	ldr	r3, [fp, #16]
801632b4:	e1a03312 	lsl	r3, r2, r3
801632b8:	e50b3008 	str	r3, [fp, #-8]
    }
    
    /* Try to populate the area */
    if(_RME_Kot_Mark(Vaddr, Table_Size)!=0)
801632bc:	e51b1008 	ldr	r1, [fp, #-8]
801632c0:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
801632c4:	eb00072c 	bl	80164f7c <_RME_Kot_Mark>
801632c8:	e1a03000 	mov	r3, r0
801632cc:	e3530000 	cmp	r3, #0
801632d0:	0a000005 	beq	801632ec <_RME_Pgt_Boot_Crt+0x300>
    {
        RME_COV_MARKER();
    
        RME_WRITE_RELEASE(&(Pgt_Crt->Head.Type_Stat),0U);
801632d4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801632d8:	e3a01000 	mov	r1, #0
801632dc:	e1a00003 	mov	r0, r3
801632e0:	ebfff509 	bl	8016070c <__RME_A7A_Write_Release>
        return RME_ERR_CPT_KOT;
801632e4:	e3e03003 	mvn	r3, #3
801632e8:	ea00001e 	b	80163368 <_RME_Pgt_Boot_Crt+0x37c>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Header init */
    Pgt_Crt->Head.Root_Ref=0U;
801632ec:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801632f0:	e3a02000 	mov	r2, #0
801632f4:	e5832004 	str	r2, [r3, #4]
    Pgt_Crt->Head.Object=Vaddr;
801632f8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801632fc:	e51b2024 	ldr	r2, [fp, #-36]	@ 0xffffffdc
80163300:	e583200c 	str	r2, [r3, #12]
    /* Set the property of the page table to only act as source and creating process */
    Pgt_Crt->Head.Flag=RME_PGT_FLAG_FULL_RANGE|RME_PGT_FLAG_ADD_SRC|
80163304:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80163308:	e3a030c1 	mov	r3, #193	@ 0xc1
8016330c:	e34f3ff0 	movt	r3, #65520	@ 0xfff0
80163310:	e5823008 	str	r3, [r2, #8]
                       RME_PGT_FLAG_PRC_CRT|RME_PGT_FLAG_PRC_PGT;
    
    /* Info init */
    Pgt_Crt->Base=Base|Is_Top;
80163314:	e59b2004 	ldr	r2, [fp, #4]
80163318:	e59b3008 	ldr	r3, [fp, #8]
8016331c:	e1822003 	orr	r2, r2, r3
80163320:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163324:	e5832018 	str	r2, [r3, #24]
    Pgt_Crt->Order=RME_PGT_ORDER(Size_Order,Num_Order);
80163328:	e59b300c 	ldr	r3, [fp, #12]
8016332c:	e1a02803 	lsl	r2, r3, #16
80163330:	e59b3010 	ldr	r3, [fp, #16]
80163334:	e1822003 	orr	r2, r2, r3
80163338:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016333c:	e5832014 	str	r2, [r3, #20]
    Pgt_Crt->ASID=0U;
80163340:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163344:	e3a02000 	mov	r2, #0
80163348:	e583201c 	str	r2, [r3, #28]

    /* Object init - need to add all kernel pages if they are top-level */
    if(__RME_Pgt_Init(Pgt_Crt)<0)
8016334c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80163350:	eb002b1e 	bl	8016dfd0 <__RME_Pgt_Init>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Establish cap */
    RME_WRITE_RELEASE(&(Pgt_Crt->Head.Type_Stat),
80163354:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163358:	e3a01301 	mov	r1, #67108864	@ 0x4000000
8016335c:	e1a00003 	mov	r0, r3
80163360:	ebfff4e9 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_PGT,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
80163364:	e3a03000 	mov	r3, #0
}
80163368:	e1a00003 	mov	r0, r3
8016336c:	e24bd004 	sub	sp, fp, #4
80163370:	e8bd8800 	pop	{fp, pc}

80163374 <_RME_Pgt_Boot_Add>:
rme_ret_t _RME_Pgt_Boot_Add(struct RME_Cap_Cpt* Cpt,
                            rme_cid_t Cap_Pgt, 
                            rme_ptr_t Paddr,
                            rme_ptr_t Pos,
                            rme_ptr_t Flag)
{
80163374:	e92d4800 	push	{fp, lr}
80163378:	e28db004 	add	fp, sp, #4
8016337c:	e24dd020 	sub	sp, sp, #32
80163380:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80163384:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
80163388:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
8016338c:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    struct RME_Cap_Pgt* Pgt_Op;
    rme_ptr_t Type_Stat;
    rme_ptr_t Szord;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Pgt,RME_CAP_TYPE_PGT,
80163390:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163394:	e2033080 	and	r3, r3, #128	@ 0x80
80163398:	e3530000 	cmp	r3, #0
8016339c:	1a00001c 	bne	80163414 <_RME_Pgt_Boot_Add+0xa0>
801633a0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801633a4:	e5932014 	ldr	r2, [r3, #20]
801633a8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801633ac:	e1520003 	cmp	r2, r3
801633b0:	8a000001 	bhi	801633bc <_RME_Pgt_Boot_Add+0x48>
801633b4:	e3e03002 	mvn	r3, #2
801633b8:	ea00007a 	b	801635a8 <_RME_Pgt_Boot_Add+0x234>
801633bc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801633c0:	e1a02283 	lsl	r2, r3, #5
801633c4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801633c8:	e593300c 	ldr	r3, [r3, #12]
801633cc:	e0823003 	add	r3, r2, r3
801633d0:	e50b3008 	str	r3, [fp, #-8]
801633d4:	e51b3008 	ldr	r3, [fp, #-8]
801633d8:	e1a00003 	mov	r0, r3
801633dc:	ebfff4c7 	bl	80160700 <__RME_A7A_Read_Acquire>
801633e0:	e50b000c 	str	r0, [fp, #-12]
801633e4:	e51b300c 	ldr	r3, [fp, #-12]
801633e8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801633ec:	e3530802 	cmp	r3, #131072	@ 0x20000
801633f0:	1a000001 	bne	801633fc <_RME_Pgt_Boot_Add+0x88>
801633f4:	e3e03008 	mvn	r3, #8
801633f8:	ea00006a 	b	801635a8 <_RME_Pgt_Boot_Add+0x234>
801633fc:	e51b300c 	ldr	r3, [fp, #-12]
80163400:	e1a03c23 	lsr	r3, r3, #24
80163404:	e3530004 	cmp	r3, #4
80163408:	0a00003f 	beq	8016350c <_RME_Pgt_Boot_Add+0x198>
8016340c:	e3e03001 	mvn	r3, #1
80163410:	ea000064 	b	801635a8 <_RME_Pgt_Boot_Add+0x234>
80163414:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163418:	e1a02423 	lsr	r2, r3, #8
8016341c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80163420:	e5933014 	ldr	r3, [r3, #20]
80163424:	e1520003 	cmp	r2, r3
80163428:	3a000001 	bcc	80163434 <_RME_Pgt_Boot_Add+0xc0>
8016342c:	e3e03002 	mvn	r3, #2
80163430:	ea00005c 	b	801635a8 <_RME_Pgt_Boot_Add+0x234>
80163434:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163438:	e1a03423 	lsr	r3, r3, #8
8016343c:	e1a02283 	lsl	r2, r3, #5
80163440:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80163444:	e593300c 	ldr	r3, [r3, #12]
80163448:	e0823003 	add	r3, r2, r3
8016344c:	e50b3008 	str	r3, [fp, #-8]
80163450:	e51b3008 	ldr	r3, [fp, #-8]
80163454:	e1a00003 	mov	r0, r3
80163458:	ebfff4a8 	bl	80160700 <__RME_A7A_Read_Acquire>
8016345c:	e50b000c 	str	r0, [fp, #-12]
80163460:	e51b300c 	ldr	r3, [fp, #-12]
80163464:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80163468:	e3530802 	cmp	r3, #131072	@ 0x20000
8016346c:	1a000001 	bne	80163478 <_RME_Pgt_Boot_Add+0x104>
80163470:	e3e03008 	mvn	r3, #8
80163474:	ea00004b 	b	801635a8 <_RME_Pgt_Boot_Add+0x234>
80163478:	e51b300c 	ldr	r3, [fp, #-12]
8016347c:	e1a03c23 	lsr	r3, r3, #24
80163480:	e3530003 	cmp	r3, #3
80163484:	0a000001 	beq	80163490 <_RME_Pgt_Boot_Add+0x11c>
80163488:	e3e03001 	mvn	r3, #1
8016348c:	ea000045 	b	801635a8 <_RME_Pgt_Boot_Add+0x234>
80163490:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163494:	e203207f 	and	r2, r3, #127	@ 0x7f
80163498:	e51b3008 	ldr	r3, [fp, #-8]
8016349c:	e5933014 	ldr	r3, [r3, #20]
801634a0:	e1520003 	cmp	r2, r3
801634a4:	3a000001 	bcc	801634b0 <_RME_Pgt_Boot_Add+0x13c>
801634a8:	e3e03002 	mvn	r3, #2
801634ac:	ea00003d 	b	801635a8 <_RME_Pgt_Boot_Add+0x234>
801634b0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801634b4:	e203307f 	and	r3, r3, #127	@ 0x7f
801634b8:	e1a02283 	lsl	r2, r3, #5
801634bc:	e51b3008 	ldr	r3, [fp, #-8]
801634c0:	e593300c 	ldr	r3, [r3, #12]
801634c4:	e0823003 	add	r3, r2, r3
801634c8:	e50b3008 	str	r3, [fp, #-8]
801634cc:	e51b3008 	ldr	r3, [fp, #-8]
801634d0:	e1a00003 	mov	r0, r3
801634d4:	ebfff489 	bl	80160700 <__RME_A7A_Read_Acquire>
801634d8:	e50b000c 	str	r0, [fp, #-12]
801634dc:	e51b300c 	ldr	r3, [fp, #-12]
801634e0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801634e4:	e3530802 	cmp	r3, #131072	@ 0x20000
801634e8:	1a000001 	bne	801634f4 <_RME_Pgt_Boot_Add+0x180>
801634ec:	e3e03008 	mvn	r3, #8
801634f0:	ea00002c 	b	801635a8 <_RME_Pgt_Boot_Add+0x234>
801634f4:	e51b300c 	ldr	r3, [fp, #-12]
801634f8:	e1a03c23 	lsr	r3, r3, #24
801634fc:	e3530004 	cmp	r3, #4
80163500:	0a000001 	beq	8016350c <_RME_Pgt_Boot_Add+0x198>
80163504:	e3e03001 	mvn	r3, #1
80163508:	ea000026 	b	801635a8 <_RME_Pgt_Boot_Add+0x234>
                   struct RME_Cap_Pgt*,Pgt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen, but don't check their properties */
    RME_CAP_CHECK(Pgt_Op,0U);

    Szord=RME_PGT_SZORD(Pgt_Op->Order);
8016350c:	e51b3008 	ldr	r3, [fp, #-8]
80163510:	e5933014 	ldr	r3, [r3, #20]
80163514:	e1a03823 	lsr	r3, r3, #16
80163518:	e50b3010 	str	r3, [fp, #-16]
        /* No action required */
    }
#endif

    /* See if the mapping range and the granularity is allowed */
    if(((Pos>>RME_PGT_NMORD(Pgt_Op->Order))!=0U)||
8016351c:	e51b3008 	ldr	r3, [fp, #-8]
80163520:	e5933014 	ldr	r3, [r3, #20]
80163524:	e6ff3073 	uxth	r3, r3
80163528:	e51b2024 	ldr	r2, [fp, #-36]	@ 0xffffffdc
8016352c:	e1a03332 	lsr	r3, r2, r3
80163530:	e3530000 	cmp	r3, #0
80163534:	1a000007 	bne	80163558 <_RME_Pgt_Boot_Add+0x1e4>
       ((Paddr&RME_MASK_END(Szord-1U))!=0U))
80163538:	e51b3010 	ldr	r3, [fp, #-16]
8016353c:	e2633020 	rsb	r3, r3, #32
80163540:	e3e02000 	mvn	r2, #0
80163544:	e1a02332 	lsr	r2, r2, r3
80163548:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016354c:	e0033002 	and	r3, r3, r2
    if(((Pos>>RME_PGT_NMORD(Pgt_Op->Order))!=0U)||
80163550:	e3530000 	cmp	r3, #0
80163554:	0a000001 	beq	80163560 <_RME_Pgt_Boot_Add+0x1ec>
    {
        RME_COV_MARKER();
        //RME_DBG_S("\r\nmapping range and the granularity is not allowed ");
        return RME_ERR_PGT_ADDR;
80163558:	e3e03064 	mvn	r3, #100	@ 0x64
8016355c:	ea000011 	b	801635a8 <_RME_Pgt_Boot_Add+0x234>
        /* No action required */
    }

    /* Actually do the mapping - This work is passed down to the HAL. 
     * Under multi-core, HAL should use CAS to avoid a conflict */
    if(__RME_Pgt_Page_Map(Pgt_Op,Paddr,Pos,Flag)!=0)
80163560:	e59b3004 	ldr	r3, [fp, #4]
80163564:	e51b2024 	ldr	r2, [fp, #-36]	@ 0xffffffdc
80163568:	e51b1020 	ldr	r1, [fp, #-32]	@ 0xffffffe0
8016356c:	e51b0008 	ldr	r0, [fp, #-8]
80163570:	eb002ae1 	bl	8016e0fc <__RME_Pgt_Page_Map>
80163574:	e1a03000 	mov	r3, r0
80163578:	e3530000 	cmp	r3, #0
8016357c:	0a000008 	beq	801635a4 <_RME_Pgt_Boot_Add+0x230>
    {
        RME_COV_MARKER();
        int a=__RME_Pgt_Page_Map(Pgt_Op,Paddr,Pos,Flag);
80163580:	e59b3004 	ldr	r3, [fp, #4]
80163584:	e51b2024 	ldr	r2, [fp, #-36]	@ 0xffffffdc
80163588:	e51b1020 	ldr	r1, [fp, #-32]	@ 0xffffffe0
8016358c:	e51b0008 	ldr	r0, [fp, #-8]
80163590:	eb002ad9 	bl	8016e0fc <__RME_Pgt_Page_Map>
80163594:	e1a03000 	mov	r3, r0
80163598:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
        //RME_DBG_S("\r\nThis work is not passed down to the HAL ");
        return RME_ERR_PGT_MAP;
8016359c:	e3e03065 	mvn	r3, #101	@ 0x65
801635a0:	ea000000 	b	801635a8 <_RME_Pgt_Boot_Add+0x234>
    {
        RME_COV_MARKER();
        /* No action required */
    }

    return 0;
801635a4:	e3a03000 	mov	r3, #0
}
801635a8:	e1a00003 	mov	r0, r3
801635ac:	e24bd004 	sub	sp, fp, #4
801635b0:	e8bd8800 	pop	{fp, pc}

801635b4 <_RME_Pgt_Crt>:
                              rme_ptr_t Raddr,
                              rme_ptr_t Base,
                              rme_ptr_t Is_Top,
                              rme_ptr_t Size_Order,
                              rme_ptr_t Num_Order)
{
801635b4:	e92d4800 	push	{fp, lr}
801635b8:	e28db004 	add	fp, sp, #4
801635bc:	e24dd030 	sub	sp, sp, #48	@ 0x30
801635c0:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
801635c4:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
801635c8:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
801635cc:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
    RME_DBG_S("\r\n Num_Order ");
    RME_DBG_H(Num_Order);*/
    
    /* Check if the total representable memory exceeds our maximum possible
     * addressible memory under the machine word length */
    if((Size_Order+Num_Order)>RME_POW2(RME_WORD_ORDER))
801635d0:	e59b2010 	ldr	r2, [fp, #16]
801635d4:	e59b3014 	ldr	r3, [fp, #20]
801635d8:	e0823003 	add	r3, r2, r3
801635dc:	e3530020 	cmp	r3, #32
801635e0:	9a000001 	bls	801635ec <_RME_Pgt_Crt+0x38>
    {
        RME_COV_MARKER();
        
        return RME_ERR_PGT_HW;
801635e4:	e3e03066 	mvn	r3, #102	@ 0x66
801635e8:	ea000155 	b	80163b44 <_RME_Pgt_Crt+0x590>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Get the cap location that we care about */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
801635ec:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801635f0:	e2033080 	and	r3, r3, #128	@ 0x80
801635f4:	e3530000 	cmp	r3, #0
801635f8:	1a00001c 	bne	80163670 <_RME_Pgt_Crt+0xbc>
801635fc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163600:	e5932014 	ldr	r2, [r3, #20]
80163604:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163608:	e1520003 	cmp	r2, r3
8016360c:	8a000001 	bhi	80163618 <_RME_Pgt_Crt+0x64>
80163610:	e3e03002 	mvn	r3, #2
80163614:	ea00014a 	b	80163b44 <_RME_Pgt_Crt+0x590>
80163618:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016361c:	e1a02283 	lsl	r2, r3, #5
80163620:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163624:	e593300c 	ldr	r3, [r3, #12]
80163628:	e0823003 	add	r3, r2, r3
8016362c:	e50b300c 	str	r3, [fp, #-12]
80163630:	e51b300c 	ldr	r3, [fp, #-12]
80163634:	e1a00003 	mov	r0, r3
80163638:	ebfff430 	bl	80160700 <__RME_A7A_Read_Acquire>
8016363c:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80163640:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163644:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80163648:	e3530802 	cmp	r3, #131072	@ 0x20000
8016364c:	1a000001 	bne	80163658 <_RME_Pgt_Crt+0xa4>
80163650:	e3e03008 	mvn	r3, #8
80163654:	ea00013a 	b	80163b44 <_RME_Pgt_Crt+0x590>
80163658:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016365c:	e1a03c23 	lsr	r3, r3, #24
80163660:	e3530003 	cmp	r3, #3
80163664:	0a00003f 	beq	80163768 <_RME_Pgt_Crt+0x1b4>
80163668:	e3e03001 	mvn	r3, #1
8016366c:	ea000134 	b	80163b44 <_RME_Pgt_Crt+0x590>
80163670:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163674:	e1a02423 	lsr	r2, r3, #8
80163678:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016367c:	e5933014 	ldr	r3, [r3, #20]
80163680:	e1520003 	cmp	r2, r3
80163684:	3a000001 	bcc	80163690 <_RME_Pgt_Crt+0xdc>
80163688:	e3e03002 	mvn	r3, #2
8016368c:	ea00012c 	b	80163b44 <_RME_Pgt_Crt+0x590>
80163690:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163694:	e1a03423 	lsr	r3, r3, #8
80163698:	e1a02283 	lsl	r2, r3, #5
8016369c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801636a0:	e593300c 	ldr	r3, [r3, #12]
801636a4:	e0823003 	add	r3, r2, r3
801636a8:	e50b300c 	str	r3, [fp, #-12]
801636ac:	e51b300c 	ldr	r3, [fp, #-12]
801636b0:	e1a00003 	mov	r0, r3
801636b4:	ebfff411 	bl	80160700 <__RME_A7A_Read_Acquire>
801636b8:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801636bc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801636c0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801636c4:	e3530802 	cmp	r3, #131072	@ 0x20000
801636c8:	1a000001 	bne	801636d4 <_RME_Pgt_Crt+0x120>
801636cc:	e3e03008 	mvn	r3, #8
801636d0:	ea00011b 	b	80163b44 <_RME_Pgt_Crt+0x590>
801636d4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801636d8:	e1a03c23 	lsr	r3, r3, #24
801636dc:	e3530003 	cmp	r3, #3
801636e0:	0a000001 	beq	801636ec <_RME_Pgt_Crt+0x138>
801636e4:	e3e03001 	mvn	r3, #1
801636e8:	ea000115 	b	80163b44 <_RME_Pgt_Crt+0x590>
801636ec:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801636f0:	e203207f 	and	r2, r3, #127	@ 0x7f
801636f4:	e51b300c 	ldr	r3, [fp, #-12]
801636f8:	e5933014 	ldr	r3, [r3, #20]
801636fc:	e1520003 	cmp	r2, r3
80163700:	3a000001 	bcc	8016370c <_RME_Pgt_Crt+0x158>
80163704:	e3e03002 	mvn	r3, #2
80163708:	ea00010d 	b	80163b44 <_RME_Pgt_Crt+0x590>
8016370c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163710:	e203307f 	and	r3, r3, #127	@ 0x7f
80163714:	e1a02283 	lsl	r2, r3, #5
80163718:	e51b300c 	ldr	r3, [fp, #-12]
8016371c:	e593300c 	ldr	r3, [r3, #12]
80163720:	e0823003 	add	r3, r2, r3
80163724:	e50b300c 	str	r3, [fp, #-12]
80163728:	e51b300c 	ldr	r3, [fp, #-12]
8016372c:	e1a00003 	mov	r0, r3
80163730:	ebfff3f2 	bl	80160700 <__RME_A7A_Read_Acquire>
80163734:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80163738:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016373c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80163740:	e3530802 	cmp	r3, #131072	@ 0x20000
80163744:	1a000001 	bne	80163750 <_RME_Pgt_Crt+0x19c>
80163748:	e3e03008 	mvn	r3, #8
8016374c:	ea0000fc 	b	80163b44 <_RME_Pgt_Crt+0x590>
80163750:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163754:	e1a03c23 	lsr	r3, r3, #24
80163758:	e3530003 	cmp	r3, #3
8016375c:	0a000001 	beq	80163768 <_RME_Pgt_Crt+0x1b4>
80163760:	e3e03001 	mvn	r3, #1
80163764:	ea0000f6 	b	80163b44 <_RME_Pgt_Crt+0x590>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Kom,RME_CAP_TYPE_KOM,
80163768:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016376c:	e2033080 	and	r3, r3, #128	@ 0x80
80163770:	e3530000 	cmp	r3, #0
80163774:	1a00001c 	bne	801637ec <_RME_Pgt_Crt+0x238>
80163778:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016377c:	e5932014 	ldr	r2, [r3, #20]
80163780:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163784:	e1520003 	cmp	r2, r3
80163788:	8a000001 	bhi	80163794 <_RME_Pgt_Crt+0x1e0>
8016378c:	e3e03002 	mvn	r3, #2
80163790:	ea0000eb 	b	80163b44 <_RME_Pgt_Crt+0x590>
80163794:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163798:	e1a02283 	lsl	r2, r3, #5
8016379c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801637a0:	e593300c 	ldr	r3, [r3, #12]
801637a4:	e0823003 	add	r3, r2, r3
801637a8:	e50b3008 	str	r3, [fp, #-8]
801637ac:	e51b3008 	ldr	r3, [fp, #-8]
801637b0:	e1a00003 	mov	r0, r3
801637b4:	ebfff3d1 	bl	80160700 <__RME_A7A_Read_Acquire>
801637b8:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801637bc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801637c0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801637c4:	e3530802 	cmp	r3, #131072	@ 0x20000
801637c8:	1a000001 	bne	801637d4 <_RME_Pgt_Crt+0x220>
801637cc:	e3e03008 	mvn	r3, #8
801637d0:	ea0000db 	b	80163b44 <_RME_Pgt_Crt+0x590>
801637d4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801637d8:	e1a03c23 	lsr	r3, r3, #24
801637dc:	e3530002 	cmp	r3, #2
801637e0:	0a00003f 	beq	801638e4 <_RME_Pgt_Crt+0x330>
801637e4:	e3e03001 	mvn	r3, #1
801637e8:	ea0000d5 	b	80163b44 <_RME_Pgt_Crt+0x590>
801637ec:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801637f0:	e1a02423 	lsr	r2, r3, #8
801637f4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801637f8:	e5933014 	ldr	r3, [r3, #20]
801637fc:	e1520003 	cmp	r2, r3
80163800:	3a000001 	bcc	8016380c <_RME_Pgt_Crt+0x258>
80163804:	e3e03002 	mvn	r3, #2
80163808:	ea0000cd 	b	80163b44 <_RME_Pgt_Crt+0x590>
8016380c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163810:	e1a03423 	lsr	r3, r3, #8
80163814:	e1a02283 	lsl	r2, r3, #5
80163818:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016381c:	e593300c 	ldr	r3, [r3, #12]
80163820:	e0823003 	add	r3, r2, r3
80163824:	e50b3008 	str	r3, [fp, #-8]
80163828:	e51b3008 	ldr	r3, [fp, #-8]
8016382c:	e1a00003 	mov	r0, r3
80163830:	ebfff3b2 	bl	80160700 <__RME_A7A_Read_Acquire>
80163834:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80163838:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016383c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80163840:	e3530802 	cmp	r3, #131072	@ 0x20000
80163844:	1a000001 	bne	80163850 <_RME_Pgt_Crt+0x29c>
80163848:	e3e03008 	mvn	r3, #8
8016384c:	ea0000bc 	b	80163b44 <_RME_Pgt_Crt+0x590>
80163850:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163854:	e1a03c23 	lsr	r3, r3, #24
80163858:	e3530003 	cmp	r3, #3
8016385c:	0a000001 	beq	80163868 <_RME_Pgt_Crt+0x2b4>
80163860:	e3e03001 	mvn	r3, #1
80163864:	ea0000b6 	b	80163b44 <_RME_Pgt_Crt+0x590>
80163868:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016386c:	e203207f 	and	r2, r3, #127	@ 0x7f
80163870:	e51b3008 	ldr	r3, [fp, #-8]
80163874:	e5933014 	ldr	r3, [r3, #20]
80163878:	e1520003 	cmp	r2, r3
8016387c:	3a000001 	bcc	80163888 <_RME_Pgt_Crt+0x2d4>
80163880:	e3e03002 	mvn	r3, #2
80163884:	ea0000ae 	b	80163b44 <_RME_Pgt_Crt+0x590>
80163888:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016388c:	e203307f 	and	r3, r3, #127	@ 0x7f
80163890:	e1a02283 	lsl	r2, r3, #5
80163894:	e51b3008 	ldr	r3, [fp, #-8]
80163898:	e593300c 	ldr	r3, [r3, #12]
8016389c:	e0823003 	add	r3, r2, r3
801638a0:	e50b3008 	str	r3, [fp, #-8]
801638a4:	e51b3008 	ldr	r3, [fp, #-8]
801638a8:	e1a00003 	mov	r0, r3
801638ac:	ebfff393 	bl	80160700 <__RME_A7A_Read_Acquire>
801638b0:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801638b4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801638b8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801638bc:	e3530802 	cmp	r3, #131072	@ 0x20000
801638c0:	1a000001 	bne	801638cc <_RME_Pgt_Crt+0x318>
801638c4:	e3e03008 	mvn	r3, #8
801638c8:	ea00009d 	b	80163b44 <_RME_Pgt_Crt+0x590>
801638cc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801638d0:	e1a03c23 	lsr	r3, r3, #24
801638d4:	e3530002 	cmp	r3, #2
801638d8:	0a000001 	beq	801638e4 <_RME_Pgt_Crt+0x330>
801638dc:	e3e03001 	mvn	r3, #1
801638e0:	ea000097 	b	80163b44 <_RME_Pgt_Crt+0x590>
                   struct RME_Cap_Kom*,Kom_Op,Type_Stat);
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op, RME_CPT_FLAG_CRT);
801638e4:	e51b300c 	ldr	r3, [fp, #-12]
801638e8:	e5933008 	ldr	r3, [r3, #8]
801638ec:	e2033001 	and	r3, r3, #1
801638f0:	e3530000 	cmp	r3, #0
801638f4:	1a000001 	bne	80163900 <_RME_Pgt_Crt+0x34c>
801638f8:	e3e03006 	mvn	r3, #6
801638fc:	ea000090 	b	80163b44 <_RME_Pgt_Crt+0x590>
    
    /* Are we creating the top-level? */
    if(Is_Top!=0U)
80163900:	e59b300c 	ldr	r3, [fp, #12]
80163904:	e3530000 	cmp	r3, #0
80163908:	0a000004 	beq	80163920 <_RME_Pgt_Crt+0x36c>
    {
        RME_COV_MARKER();

        Table_Size=RME_PGT_SIZE_TOP(Num_Order);
8016390c:	e3a02004 	mov	r2, #4
80163910:	e59b3014 	ldr	r3, [fp, #20]
80163914:	e1a03312 	lsl	r3, r2, r3
80163918:	e50b3010 	str	r3, [fp, #-16]
8016391c:	ea000003 	b	80163930 <_RME_Pgt_Crt+0x37c>
    }
    else
    {
        RME_COV_MARKER();

        Table_Size=RME_PGT_SIZE_NOM(Num_Order);
80163920:	e3a02004 	mov	r2, #4
80163924:	e59b3014 	ldr	r3, [fp, #20]
80163928:	e1a03312 	lsl	r3, r2, r3
8016392c:	e50b3010 	str	r3, [fp, #-16]
    }
    
    /* See if the creation is valid for this kmem range */
    RME_KOM_CHECK(Kom_Op,RME_KOM_FLAG_PGT,Raddr,Vaddr,Table_Size);
80163930:	e51b3008 	ldr	r3, [fp, #-8]
80163934:	e5933008 	ldr	r3, [r3, #8]
80163938:	e2033002 	and	r3, r3, #2
8016393c:	e3530000 	cmp	r3, #0
80163940:	1a000001 	bne	8016394c <_RME_Pgt_Crt+0x398>
80163944:	e3e03006 	mvn	r3, #6
80163948:	ea00007d 	b	80163b44 <_RME_Pgt_Crt+0x590>
8016394c:	e51b3008 	ldr	r3, [fp, #-8]
80163950:	e5933014 	ldr	r3, [r3, #20]
80163954:	e59b2004 	ldr	r2, [fp, #4]
80163958:	e0823003 	add	r3, r2, r3
8016395c:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
80163960:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80163964:	e59b3004 	ldr	r3, [fp, #4]
80163968:	e1520003 	cmp	r2, r3
8016396c:	2a000001 	bcs	80163978 <_RME_Pgt_Crt+0x3c4>
80163970:	e3e03006 	mvn	r3, #6
80163974:	ea000072 	b	80163b44 <_RME_Pgt_Crt+0x590>
80163978:	e51b3008 	ldr	r3, [fp, #-8]
8016397c:	e5933014 	ldr	r3, [r3, #20]
80163980:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80163984:	e1520003 	cmp	r2, r3
80163988:	2a000001 	bcs	80163994 <_RME_Pgt_Crt+0x3e0>
8016398c:	e3e03006 	mvn	r3, #6
80163990:	ea00006b 	b	80163b44 <_RME_Pgt_Crt+0x590>
80163994:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80163998:	e51b3010 	ldr	r3, [fp, #-16]
8016399c:	e0823003 	add	r3, r2, r3
801639a0:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
801639a4:	e1520003 	cmp	r2, r3
801639a8:	9a000001 	bls	801639b4 <_RME_Pgt_Crt+0x400>
801639ac:	e3e03006 	mvn	r3, #6
801639b0:	ea000063 	b	80163b44 <_RME_Pgt_Crt+0x590>
801639b4:	e51b3008 	ldr	r3, [fp, #-8]
801639b8:	e5932018 	ldr	r2, [r3, #24]
801639bc:	e51b1018 	ldr	r1, [fp, #-24]	@ 0xffffffe8
801639c0:	e51b3010 	ldr	r3, [fp, #-16]
801639c4:	e0813003 	add	r3, r1, r3
801639c8:	e2433001 	sub	r3, r3, #1
801639cc:	e1520003 	cmp	r2, r3
801639d0:	2a000001 	bcs	801639dc <_RME_Pgt_Crt+0x428>
801639d4:	e3e03006 	mvn	r3, #6
801639d8:	ea000059 	b	80163b44 <_RME_Pgt_Crt+0x590>

    /* Check if these parameters are feasible */
    if(__RME_Pgt_Check(Base,Is_Top,Size_Order,Num_Order,Vaddr)<0)
801639dc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801639e0:	e58d3000 	str	r3, [sp]
801639e4:	e59b3014 	ldr	r3, [fp, #20]
801639e8:	e59b2010 	ldr	r2, [fp, #16]
801639ec:	e59b100c 	ldr	r1, [fp, #12]
801639f0:	e59b0008 	ldr	r0, [fp, #8]
801639f4:	eb00293d 	bl	8016def0 <__RME_Pgt_Check>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Check if the start address is properly aligned to the total order of the page table */
    if((Base&RME_MASK_END(Size_Order+Num_Order-1U))!=0U)
801639f8:	e59b2010 	ldr	r2, [fp, #16]
801639fc:	e59b3014 	ldr	r3, [fp, #20]
80163a00:	e0823003 	add	r3, r2, r3
80163a04:	e2633020 	rsb	r3, r3, #32
80163a08:	e3e02000 	mvn	r2, #0
80163a0c:	e1a02332 	lsr	r2, r2, r3
80163a10:	e59b3008 	ldr	r3, [fp, #8]
80163a14:	e0033002 	and	r3, r3, r2
80163a18:	e3530000 	cmp	r3, #0
80163a1c:	0a000001 	beq	80163a28 <_RME_Pgt_Crt+0x474>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_HW;
80163a20:	e3e03066 	mvn	r3, #102	@ 0x66
80163a24:	ea000046 	b	80163b44 <_RME_Pgt_Crt+0x590>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Pgt,struct RME_Cap_Pgt*,Pgt_Crt);
80163a28:	e51b300c 	ldr	r3, [fp, #-12]
80163a2c:	e5932014 	ldr	r2, [r3, #20]
80163a30:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80163a34:	e1520003 	cmp	r2, r3
80163a38:	8a000001 	bhi	80163a44 <_RME_Pgt_Crt+0x490>
80163a3c:	e3e03002 	mvn	r3, #2
80163a40:	ea00003f 	b	80163b44 <_RME_Pgt_Crt+0x590>
80163a44:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80163a48:	e1a02283 	lsl	r2, r3, #5
80163a4c:	e51b300c 	ldr	r3, [fp, #-12]
80163a50:	e593300c 	ldr	r3, [r3, #12]
80163a54:	e0823003 	add	r3, r2, r3
80163a58:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Pgt_Crt);
80163a5c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163a60:	e3a02801 	mov	r2, #65536	@ 0x10000
80163a64:	e3a01000 	mov	r1, #0
80163a68:	e1a00003 	mov	r0, r3
80163a6c:	ebfff452 	bl	80160bbc <_RME_Comp_Swap_Single>
80163a70:	e1a03000 	mov	r3, r0
80163a74:	e3530000 	cmp	r3, #0
80163a78:	1a000001 	bne	80163a84 <_RME_Pgt_Crt+0x4d0>
80163a7c:	e3e03004 	mvn	r3, #4
80163a80:	ea00002f 	b	80163b44 <_RME_Pgt_Crt+0x590>
80163a84:	e3003000 	movw	r3, #0
80163a88:	e3483017 	movt	r3, #32791	@ 0x8017
80163a8c:	e5932000 	ldr	r2, [r3]
80163a90:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163a94:	e5832010 	str	r2, [r3, #16]

    /* Try to populate the area */
    if(_RME_Kot_Mark(Vaddr,Table_Size)!=0)
80163a98:	e51b1010 	ldr	r1, [fp, #-16]
80163a9c:	e51b0018 	ldr	r0, [fp, #-24]	@ 0xffffffe8
80163aa0:	eb000535 	bl	80164f7c <_RME_Kot_Mark>
80163aa4:	e1a03000 	mov	r3, r0
80163aa8:	e3530000 	cmp	r3, #0
80163aac:	0a000005 	beq	80163ac8 <_RME_Pgt_Crt+0x514>
    {
        RME_COV_MARKER();

        RME_WRITE_RELEASE(&(Pgt_Crt->Head.Type_Stat),0U);
80163ab0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163ab4:	e3a01000 	mov	r1, #0
80163ab8:	e1a00003 	mov	r0, r3
80163abc:	ebfff312 	bl	8016070c <__RME_A7A_Write_Release>
        return RME_ERR_CPT_KOT;
80163ac0:	e3e03003 	mvn	r3, #3
80163ac4:	ea00001e 	b	80163b44 <_RME_Pgt_Crt+0x590>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Header init */
    Pgt_Crt->Head.Root_Ref=0U;
80163ac8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163acc:	e3a02000 	mov	r2, #0
80163ad0:	e5832004 	str	r2, [r3, #4]
    Pgt_Crt->Head.Object=Vaddr;
80163ad4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163ad8:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80163adc:	e583200c 	str	r2, [r3, #12]
    Pgt_Crt->Head.Flag=RME_PGT_FLAG_FULL_RANGE|RME_PGT_FLAG_ALL;
80163ae0:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
80163ae4:	e3a030ff 	mov	r3, #255	@ 0xff
80163ae8:	e34f3ff0 	movt	r3, #65520	@ 0xfff0
80163aec:	e5823008 	str	r3, [r2, #8]
    
    /* Info init */
    Pgt_Crt->Base=Base|Is_Top;
80163af0:	e59b2008 	ldr	r2, [fp, #8]
80163af4:	e59b300c 	ldr	r3, [fp, #12]
80163af8:	e1822003 	orr	r2, r2, r3
80163afc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163b00:	e5832018 	str	r2, [r3, #24]
    Pgt_Crt->Order=RME_PGT_ORDER(Size_Order,Num_Order);
80163b04:	e59b3010 	ldr	r3, [fp, #16]
80163b08:	e1a02803 	lsl	r2, r3, #16
80163b0c:	e59b3014 	ldr	r3, [fp, #20]
80163b10:	e1822003 	orr	r2, r2, r3
80163b14:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163b18:	e5832014 	str	r2, [r3, #20]
    Pgt_Crt->ASID=0U;
80163b1c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163b20:	e3a02000 	mov	r2, #0
80163b24:	e583201c 	str	r2, [r3, #28]
    
    /* Object init - need to add all kernel pages if they are top-level */
    if(__RME_Pgt_Init(Pgt_Crt)<0)
80163b28:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80163b2c:	eb002927 	bl	8016dfd0 <__RME_Pgt_Init>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Creation complete */
    RME_WRITE_RELEASE(&(Pgt_Crt->Head.Type_Stat),
80163b30:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80163b34:	e3a01301 	mov	r1, #67108864	@ 0x4000000
80163b38:	e1a00003 	mov	r0, r3
80163b3c:	ebfff2f2 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_PGT,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
80163b40:	e3a03000 	mov	r3, #0
}
80163b44:	e1a00003 	mov	r0, r3
80163b48:	e24bd004 	sub	sp, fp, #4
80163b4c:	e8bd8800 	pop	{fp, pc}

80163b50 <_RME_Pgt_Del>:
******************************************************************************/
#if(RME_PGT_RAW_ENABLE==0U)
static rme_ret_t _RME_Pgt_Del(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt,
                              rme_cid_t Cap_Pgt)
{
80163b50:	e92d4800 	push	{fp, lr}
80163b54:	e28db004 	add	fp, sp, #4
80163b58:	e24dd028 	sub	sp, sp, #40	@ 0x28
80163b5c:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
80163b60:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
80163b64:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
    /* These are used for deletion */
    rme_ptr_t Object;
    rme_ptr_t Table_Size;
    
    /* Get the cap location that we care about */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
80163b68:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163b6c:	e2033080 	and	r3, r3, #128	@ 0x80
80163b70:	e3530000 	cmp	r3, #0
80163b74:	1a00001c 	bne	80163bec <_RME_Pgt_Del+0x9c>
80163b78:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163b7c:	e5932014 	ldr	r2, [r3, #20]
80163b80:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163b84:	e1520003 	cmp	r2, r3
80163b88:	8a000001 	bhi	80163b94 <_RME_Pgt_Del+0x44>
80163b8c:	e3e03002 	mvn	r3, #2
80163b90:	ea0000d2 	b	80163ee0 <_RME_Pgt_Del+0x390>
80163b94:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163b98:	e1a02283 	lsl	r2, r3, #5
80163b9c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163ba0:	e593300c 	ldr	r3, [r3, #12]
80163ba4:	e0823003 	add	r3, r2, r3
80163ba8:	e50b3008 	str	r3, [fp, #-8]
80163bac:	e51b3008 	ldr	r3, [fp, #-8]
80163bb0:	e1a00003 	mov	r0, r3
80163bb4:	ebfff2d1 	bl	80160700 <__RME_A7A_Read_Acquire>
80163bb8:	e50b0010 	str	r0, [fp, #-16]
80163bbc:	e51b3010 	ldr	r3, [fp, #-16]
80163bc0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80163bc4:	e3530802 	cmp	r3, #131072	@ 0x20000
80163bc8:	1a000001 	bne	80163bd4 <_RME_Pgt_Del+0x84>
80163bcc:	e3e03008 	mvn	r3, #8
80163bd0:	ea0000c2 	b	80163ee0 <_RME_Pgt_Del+0x390>
80163bd4:	e51b3010 	ldr	r3, [fp, #-16]
80163bd8:	e1a03c23 	lsr	r3, r3, #24
80163bdc:	e3530003 	cmp	r3, #3
80163be0:	0a00003f 	beq	80163ce4 <_RME_Pgt_Del+0x194>
80163be4:	e3e03001 	mvn	r3, #1
80163be8:	ea0000bc 	b	80163ee0 <_RME_Pgt_Del+0x390>
80163bec:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163bf0:	e1a02423 	lsr	r2, r3, #8
80163bf4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163bf8:	e5933014 	ldr	r3, [r3, #20]
80163bfc:	e1520003 	cmp	r2, r3
80163c00:	3a000001 	bcc	80163c0c <_RME_Pgt_Del+0xbc>
80163c04:	e3e03002 	mvn	r3, #2
80163c08:	ea0000b4 	b	80163ee0 <_RME_Pgt_Del+0x390>
80163c0c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163c10:	e1a03423 	lsr	r3, r3, #8
80163c14:	e1a02283 	lsl	r2, r3, #5
80163c18:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80163c1c:	e593300c 	ldr	r3, [r3, #12]
80163c20:	e0823003 	add	r3, r2, r3
80163c24:	e50b3008 	str	r3, [fp, #-8]
80163c28:	e51b3008 	ldr	r3, [fp, #-8]
80163c2c:	e1a00003 	mov	r0, r3
80163c30:	ebfff2b2 	bl	80160700 <__RME_A7A_Read_Acquire>
80163c34:	e50b0010 	str	r0, [fp, #-16]
80163c38:	e51b3010 	ldr	r3, [fp, #-16]
80163c3c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80163c40:	e3530802 	cmp	r3, #131072	@ 0x20000
80163c44:	1a000001 	bne	80163c50 <_RME_Pgt_Del+0x100>
80163c48:	e3e03008 	mvn	r3, #8
80163c4c:	ea0000a3 	b	80163ee0 <_RME_Pgt_Del+0x390>
80163c50:	e51b3010 	ldr	r3, [fp, #-16]
80163c54:	e1a03c23 	lsr	r3, r3, #24
80163c58:	e3530003 	cmp	r3, #3
80163c5c:	0a000001 	beq	80163c68 <_RME_Pgt_Del+0x118>
80163c60:	e3e03001 	mvn	r3, #1
80163c64:	ea00009d 	b	80163ee0 <_RME_Pgt_Del+0x390>
80163c68:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163c6c:	e203207f 	and	r2, r3, #127	@ 0x7f
80163c70:	e51b3008 	ldr	r3, [fp, #-8]
80163c74:	e5933014 	ldr	r3, [r3, #20]
80163c78:	e1520003 	cmp	r2, r3
80163c7c:	3a000001 	bcc	80163c88 <_RME_Pgt_Del+0x138>
80163c80:	e3e03002 	mvn	r3, #2
80163c84:	ea000095 	b	80163ee0 <_RME_Pgt_Del+0x390>
80163c88:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80163c8c:	e203307f 	and	r3, r3, #127	@ 0x7f
80163c90:	e1a02283 	lsl	r2, r3, #5
80163c94:	e51b3008 	ldr	r3, [fp, #-8]
80163c98:	e593300c 	ldr	r3, [r3, #12]
80163c9c:	e0823003 	add	r3, r2, r3
80163ca0:	e50b3008 	str	r3, [fp, #-8]
80163ca4:	e51b3008 	ldr	r3, [fp, #-8]
80163ca8:	e1a00003 	mov	r0, r3
80163cac:	ebfff293 	bl	80160700 <__RME_A7A_Read_Acquire>
80163cb0:	e50b0010 	str	r0, [fp, #-16]
80163cb4:	e51b3010 	ldr	r3, [fp, #-16]
80163cb8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80163cbc:	e3530802 	cmp	r3, #131072	@ 0x20000
80163cc0:	1a000001 	bne	80163ccc <_RME_Pgt_Del+0x17c>
80163cc4:	e3e03008 	mvn	r3, #8
80163cc8:	ea000084 	b	80163ee0 <_RME_Pgt_Del+0x390>
80163ccc:	e51b3010 	ldr	r3, [fp, #-16]
80163cd0:	e1a03c23 	lsr	r3, r3, #24
80163cd4:	e3530003 	cmp	r3, #3
80163cd8:	0a000001 	beq	80163ce4 <_RME_Pgt_Del+0x194>
80163cdc:	e3e03001 	mvn	r3, #1
80163ce0:	ea00007e 	b	80163ee0 <_RME_Pgt_Del+0x390>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_DEL);
80163ce4:	e51b3008 	ldr	r3, [fp, #-8]
80163ce8:	e5933008 	ldr	r3, [r3, #8]
80163cec:	e2033002 	and	r3, r3, #2
80163cf0:	e3530000 	cmp	r3, #0
80163cf4:	1a000001 	bne	80163d00 <_RME_Pgt_Del+0x1b0>
80163cf8:	e3e03006 	mvn	r3, #6
80163cfc:	ea000077 	b	80163ee0 <_RME_Pgt_Del+0x390>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Pgt,struct RME_Cap_Pgt*,Pgt_Del);
80163d00:	e51b3008 	ldr	r3, [fp, #-8]
80163d04:	e5932014 	ldr	r2, [r3, #20]
80163d08:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163d0c:	e1520003 	cmp	r2, r3
80163d10:	8a000001 	bhi	80163d1c <_RME_Pgt_Del+0x1cc>
80163d14:	e3e03002 	mvn	r3, #2
80163d18:	ea000070 	b	80163ee0 <_RME_Pgt_Del+0x390>
80163d1c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163d20:	e1a02283 	lsl	r2, r3, #5
80163d24:	e51b3008 	ldr	r3, [fp, #-8]
80163d28:	e593300c 	ldr	r3, [r3, #12]
80163d2c:	e0823003 	add	r3, r2, r3
80163d30:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    /* Delete check */
    RME_CAP_DEL_CHECK(Pgt_Del,Type_Stat,RME_CAP_TYPE_PGT);
80163d34:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163d38:	e1a00003 	mov	r0, r3
80163d3c:	ebfff26f 	bl	80160700 <__RME_A7A_Read_Acquire>
80163d40:	e50b0010 	str	r0, [fp, #-16]
80163d44:	e51b3010 	ldr	r3, [fp, #-16]
80163d48:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80163d4c:	e3530802 	cmp	r3, #131072	@ 0x20000
80163d50:	0a000001 	beq	80163d5c <_RME_Pgt_Del+0x20c>
80163d54:	e3e03008 	mvn	r3, #8
80163d58:	ea000060 	b	80163ee0 <_RME_Pgt_Del+0x390>
80163d5c:	e51b3010 	ldr	r3, [fp, #-16]
80163d60:	e1a03c23 	lsr	r3, r3, #24
80163d64:	e3530004 	cmp	r3, #4
80163d68:	0a000001 	beq	80163d74 <_RME_Pgt_Del+0x224>
80163d6c:	e3e03001 	mvn	r3, #1
80163d70:	ea00005a 	b	80163ee0 <_RME_Pgt_Del+0x390>
80163d74:	e3003000 	movw	r3, #0
80163d78:	e3483017 	movt	r3, #32791	@ 0x8017
80163d7c:	e5932000 	ldr	r2, [r3]
80163d80:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163d84:	e5933010 	ldr	r3, [r3, #16]
80163d88:	e1a01003 	mov	r1, r3
80163d8c:	e1a00002 	mov	r0, r2
80163d90:	ebfff3f6 	bl	80160d70 <_RME_Diff>
80163d94:	e1a03000 	mov	r3, r0
80163d98:	e353000a 	cmp	r3, #10
80163d9c:	8a000001 	bhi	80163da8 <_RME_Pgt_Del+0x258>
80163da0:	e3e03007 	mvn	r3, #7
80163da4:	ea00004d 	b	80163ee0 <_RME_Pgt_Del+0x390>
80163da8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163dac:	e5933004 	ldr	r3, [r3, #4]
80163db0:	e3530000 	cmp	r3, #0
80163db4:	0a00000b 	beq	80163de8 <_RME_Pgt_Del+0x298>
80163db8:	e51b3010 	ldr	r3, [fp, #-16]
80163dbc:	e6ff3073 	uxth	r3, r3
80163dc0:	e3530000 	cmp	r3, #0
80163dc4:	1a000005 	bne	80163de0 <_RME_Pgt_Del+0x290>
80163dc8:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80163dcc:	e51b3010 	ldr	r3, [fp, #-16]
80163dd0:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
80163dd4:	e1a02003 	mov	r2, r3
80163dd8:	e51b1010 	ldr	r1, [fp, #-16]
80163ddc:	ebfff376 	bl	80160bbc <_RME_Comp_Swap_Single>
80163de0:	e3e03005 	mvn	r3, #5
80163de4:	ea00003d 	b	80163ee0 <_RME_Pgt_Del+0x390>
80163de8:	e51b3010 	ldr	r3, [fp, #-16]
80163dec:	e6ff3073 	uxth	r3, r3
80163df0:	e3530000 	cmp	r3, #0
80163df4:	0a000008 	beq	80163e1c <_RME_Pgt_Del+0x2cc>
80163df8:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
80163dfc:	e3483016 	movt	r3, #32790	@ 0x8016
80163e00:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
80163e04:	e3482016 	movt	r2, #32790	@ 0x8016
80163e08:	e3001cd4 	movw	r1, #3284	@ 0xcd4
80163e0c:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
80163e10:	e3480016 	movt	r0, #32790	@ 0x8016
80163e14:	ebfff35d 	bl	80160b90 <RME_Log>
80163e18:	eafffffe 	b	80163e18 <_RME_Pgt_Del+0x2c8>
    /* Hardware related deletion check passed down to the HAL. The driver should make
     * sure that it does not reference any lower level tables. If the driver layer does
     * not conform to this, the deletion of page table is not guaranteed to main kernel
     * consistency, and such consistency must be maintained by the user-level. It is 
     * recommended that the driver layer enforce such consistency. */
    if(__RME_Pgt_Del_Check(Pgt_Del)<0)
80163e1c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80163e20:	eb0028ac 	bl	8016e0d8 <__RME_Pgt_Del_Check>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Remember these two variables for deletion */
    Object=RME_CAP_GETOBJ(Pgt_Del,rme_ptr_t);
80163e24:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163e28:	e593300c 	ldr	r3, [r3, #12]
80163e2c:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    if(((Pgt_Del->Base)&RME_PGT_TOP)!=0U)
80163e30:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163e34:	e5933018 	ldr	r3, [r3, #24]
80163e38:	e2033001 	and	r3, r3, #1
80163e3c:	e3530000 	cmp	r3, #0
80163e40:	0a000006 	beq	80163e60 <_RME_Pgt_Del+0x310>
    {
        RME_COV_MARKER();

        Table_Size=RME_PGT_SIZE_TOP(RME_PGT_NMORD(Pgt_Del->Order));
80163e44:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163e48:	e5933014 	ldr	r3, [r3, #20]
80163e4c:	e6ff3073 	uxth	r3, r3
80163e50:	e3a02004 	mov	r2, #4
80163e54:	e1a03312 	lsl	r3, r2, r3
80163e58:	e50b300c 	str	r3, [fp, #-12]
80163e5c:	ea000005 	b	80163e78 <_RME_Pgt_Del+0x328>
    }
    else
    {
        RME_COV_MARKER();

        Table_Size=RME_PGT_SIZE_NOM(RME_PGT_NMORD(Pgt_Del->Order));
80163e60:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163e64:	e5933014 	ldr	r3, [r3, #20]
80163e68:	e6ff3073 	uxth	r3, r3
80163e6c:	e3a02004 	mov	r2, #4
80163e70:	e1a03312 	lsl	r3, r2, r3
80163e74:	e50b300c 	str	r3, [fp, #-12]
    }
    
    /* Now we can safely delete the cap */
    RME_CAP_DELETE(Pgt_Del,Type_Stat);
80163e78:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163e7c:	e3a02000 	mov	r2, #0
80163e80:	e51b1010 	ldr	r1, [fp, #-16]
80163e84:	e1a00003 	mov	r0, r3
80163e88:	ebfff34b 	bl	80160bbc <_RME_Comp_Swap_Single>
80163e8c:	e1a03000 	mov	r3, r0
80163e90:	e3530000 	cmp	r3, #0
80163e94:	1a000001 	bne	80163ea0 <_RME_Pgt_Del+0x350>
80163e98:	e3e03000 	mvn	r3, #0
80163e9c:	ea00000f 	b	80163ee0 <_RME_Pgt_Del+0x390>

    /* Try to erase the area - This must be successful */
    RME_ASSERT(_RME_Kot_Erase(Object,Table_Size)==0);
80163ea0:	e51b100c 	ldr	r1, [fp, #-12]
80163ea4:	e51b0018 	ldr	r0, [fp, #-24]	@ 0xffffffe8
80163ea8:	eb000507 	bl	801652cc <_RME_Kot_Erase>
80163eac:	e1a03000 	mov	r3, r0
80163eb0:	e3530000 	cmp	r3, #0
80163eb4:	0a000008 	beq	80163edc <_RME_Pgt_Del+0x38c>
80163eb8:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
80163ebc:	e3483016 	movt	r3, #32790	@ 0x8016
80163ec0:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
80163ec4:	e3482016 	movt	r2, #32790	@ 0x8016
80163ec8:	e3001cfb 	movw	r1, #3323	@ 0xcfb
80163ecc:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
80163ed0:	e3480016 	movt	r0, #32790	@ 0x8016
80163ed4:	ebfff32d 	bl	80160b90 <RME_Log>
80163ed8:	eafffffe 	b	80163ed8 <_RME_Pgt_Del+0x388>

    return 0;
80163edc:	e3a03000 	mov	r3, #0
}
80163ee0:	e1a00003 	mov	r0, r3
80163ee4:	e24bd004 	sub	sp, fp, #4
80163ee8:	e8bd8800 	pop	{fp, pc}

80163eec <_RME_Pgt_Add>:
                              rme_ptr_t Pos_Dst,
                              rme_ptr_t Flag_Dst,
                              rme_cid_t Cap_Pgt_Src,
                              rme_ptr_t Pos_Src,
                              rme_ptr_t Index)
{
80163eec:	e92d4800 	push	{fp, lr}
80163ef0:	e28db004 	add	fp, sp, #4
80163ef4:	e24dd030 	sub	sp, sp, #48	@ 0x30
80163ef8:	e50b0028 	str	r0, [fp, #-40]	@ 0xffffffd8
80163efc:	e50b102c 	str	r1, [fp, #-44]	@ 0xffffffd4
80163f00:	e50b2030 	str	r2, [fp, #-48]	@ 0xffffffd0
80163f04:	e50b3034 	str	r3, [fp, #-52]	@ 0xffffffcc
        RME_DBG_H(Pos_Src);
        RME_DBG_S("\r\n Index ");
        RME_DBG_H(Index);*/

    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Pgt_Dst,RME_CAP_TYPE_PGT,
80163f08:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80163f0c:	e2033080 	and	r3, r3, #128	@ 0x80
80163f10:	e3530000 	cmp	r3, #0
80163f14:	1a00001c 	bne	80163f8c <_RME_Pgt_Add+0xa0>
80163f18:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163f1c:	e5932014 	ldr	r2, [r3, #20]
80163f20:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80163f24:	e1520003 	cmp	r2, r3
80163f28:	8a000001 	bhi	80163f34 <_RME_Pgt_Add+0x48>
80163f2c:	e3e03002 	mvn	r3, #2
80163f30:	ea000126 	b	801643d0 <_RME_Pgt_Add+0x4e4>
80163f34:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80163f38:	e1a02283 	lsl	r2, r3, #5
80163f3c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163f40:	e593300c 	ldr	r3, [r3, #12]
80163f44:	e0823003 	add	r3, r2, r3
80163f48:	e50b300c 	str	r3, [fp, #-12]
80163f4c:	e51b300c 	ldr	r3, [fp, #-12]
80163f50:	e1a00003 	mov	r0, r3
80163f54:	ebfff1e9 	bl	80160700 <__RME_A7A_Read_Acquire>
80163f58:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80163f5c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163f60:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80163f64:	e3530802 	cmp	r3, #131072	@ 0x20000
80163f68:	1a000001 	bne	80163f74 <_RME_Pgt_Add+0x88>
80163f6c:	e3e03008 	mvn	r3, #8
80163f70:	ea000116 	b	801643d0 <_RME_Pgt_Add+0x4e4>
80163f74:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163f78:	e1a03c23 	lsr	r3, r3, #24
80163f7c:	e3530004 	cmp	r3, #4
80163f80:	0a00003f 	beq	80164084 <_RME_Pgt_Add+0x198>
80163f84:	e3e03001 	mvn	r3, #1
80163f88:	ea000110 	b	801643d0 <_RME_Pgt_Add+0x4e4>
80163f8c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80163f90:	e1a02423 	lsr	r2, r3, #8
80163f94:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163f98:	e5933014 	ldr	r3, [r3, #20]
80163f9c:	e1520003 	cmp	r2, r3
80163fa0:	3a000001 	bcc	80163fac <_RME_Pgt_Add+0xc0>
80163fa4:	e3e03002 	mvn	r3, #2
80163fa8:	ea000108 	b	801643d0 <_RME_Pgt_Add+0x4e4>
80163fac:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80163fb0:	e1a03423 	lsr	r3, r3, #8
80163fb4:	e1a02283 	lsl	r2, r3, #5
80163fb8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80163fbc:	e593300c 	ldr	r3, [r3, #12]
80163fc0:	e0823003 	add	r3, r2, r3
80163fc4:	e50b300c 	str	r3, [fp, #-12]
80163fc8:	e51b300c 	ldr	r3, [fp, #-12]
80163fcc:	e1a00003 	mov	r0, r3
80163fd0:	ebfff1ca 	bl	80160700 <__RME_A7A_Read_Acquire>
80163fd4:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80163fd8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163fdc:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80163fe0:	e3530802 	cmp	r3, #131072	@ 0x20000
80163fe4:	1a000001 	bne	80163ff0 <_RME_Pgt_Add+0x104>
80163fe8:	e3e03008 	mvn	r3, #8
80163fec:	ea0000f7 	b	801643d0 <_RME_Pgt_Add+0x4e4>
80163ff0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80163ff4:	e1a03c23 	lsr	r3, r3, #24
80163ff8:	e3530003 	cmp	r3, #3
80163ffc:	0a000001 	beq	80164008 <_RME_Pgt_Add+0x11c>
80164000:	e3e03001 	mvn	r3, #1
80164004:	ea0000f1 	b	801643d0 <_RME_Pgt_Add+0x4e4>
80164008:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016400c:	e203207f 	and	r2, r3, #127	@ 0x7f
80164010:	e51b300c 	ldr	r3, [fp, #-12]
80164014:	e5933014 	ldr	r3, [r3, #20]
80164018:	e1520003 	cmp	r2, r3
8016401c:	3a000001 	bcc	80164028 <_RME_Pgt_Add+0x13c>
80164020:	e3e03002 	mvn	r3, #2
80164024:	ea0000e9 	b	801643d0 <_RME_Pgt_Add+0x4e4>
80164028:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016402c:	e203307f 	and	r3, r3, #127	@ 0x7f
80164030:	e1a02283 	lsl	r2, r3, #5
80164034:	e51b300c 	ldr	r3, [fp, #-12]
80164038:	e593300c 	ldr	r3, [r3, #12]
8016403c:	e0823003 	add	r3, r2, r3
80164040:	e50b300c 	str	r3, [fp, #-12]
80164044:	e51b300c 	ldr	r3, [fp, #-12]
80164048:	e1a00003 	mov	r0, r3
8016404c:	ebfff1ab 	bl	80160700 <__RME_A7A_Read_Acquire>
80164050:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80164054:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164058:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016405c:	e3530802 	cmp	r3, #131072	@ 0x20000
80164060:	1a000001 	bne	8016406c <_RME_Pgt_Add+0x180>
80164064:	e3e03008 	mvn	r3, #8
80164068:	ea0000d8 	b	801643d0 <_RME_Pgt_Add+0x4e4>
8016406c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164070:	e1a03c23 	lsr	r3, r3, #24
80164074:	e3530004 	cmp	r3, #4
80164078:	0a000001 	beq	80164084 <_RME_Pgt_Add+0x198>
8016407c:	e3e03001 	mvn	r3, #1
80164080:	ea0000d2 	b	801643d0 <_RME_Pgt_Add+0x4e4>
                   struct RME_Cap_Pgt*,Pgt_Dst,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Pgt_Src,RME_CAP_TYPE_PGT,
80164084:	e59b3004 	ldr	r3, [fp, #4]
80164088:	e2033080 	and	r3, r3, #128	@ 0x80
8016408c:	e3530000 	cmp	r3, #0
80164090:	1a00001c 	bne	80164108 <_RME_Pgt_Add+0x21c>
80164094:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80164098:	e5932014 	ldr	r2, [r3, #20]
8016409c:	e59b3004 	ldr	r3, [fp, #4]
801640a0:	e1520003 	cmp	r2, r3
801640a4:	8a000001 	bhi	801640b0 <_RME_Pgt_Add+0x1c4>
801640a8:	e3e03002 	mvn	r3, #2
801640ac:	ea0000c7 	b	801643d0 <_RME_Pgt_Add+0x4e4>
801640b0:	e59b3004 	ldr	r3, [fp, #4]
801640b4:	e1a02283 	lsl	r2, r3, #5
801640b8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801640bc:	e593300c 	ldr	r3, [r3, #12]
801640c0:	e0823003 	add	r3, r2, r3
801640c4:	e50b3008 	str	r3, [fp, #-8]
801640c8:	e51b3008 	ldr	r3, [fp, #-8]
801640cc:	e1a00003 	mov	r0, r3
801640d0:	ebfff18a 	bl	80160700 <__RME_A7A_Read_Acquire>
801640d4:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801640d8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801640dc:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801640e0:	e3530802 	cmp	r3, #131072	@ 0x20000
801640e4:	1a000001 	bne	801640f0 <_RME_Pgt_Add+0x204>
801640e8:	e3e03008 	mvn	r3, #8
801640ec:	ea0000b7 	b	801643d0 <_RME_Pgt_Add+0x4e4>
801640f0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801640f4:	e1a03c23 	lsr	r3, r3, #24
801640f8:	e3530004 	cmp	r3, #4
801640fc:	0a00003f 	beq	80164200 <_RME_Pgt_Add+0x314>
80164100:	e3e03001 	mvn	r3, #1
80164104:	ea0000b1 	b	801643d0 <_RME_Pgt_Add+0x4e4>
80164108:	e59b3004 	ldr	r3, [fp, #4]
8016410c:	e1a02423 	lsr	r2, r3, #8
80164110:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80164114:	e5933014 	ldr	r3, [r3, #20]
80164118:	e1520003 	cmp	r2, r3
8016411c:	3a000001 	bcc	80164128 <_RME_Pgt_Add+0x23c>
80164120:	e3e03002 	mvn	r3, #2
80164124:	ea0000a9 	b	801643d0 <_RME_Pgt_Add+0x4e4>
80164128:	e59b3004 	ldr	r3, [fp, #4]
8016412c:	e1a03423 	lsr	r3, r3, #8
80164130:	e1a02283 	lsl	r2, r3, #5
80164134:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80164138:	e593300c 	ldr	r3, [r3, #12]
8016413c:	e0823003 	add	r3, r2, r3
80164140:	e50b3008 	str	r3, [fp, #-8]
80164144:	e51b3008 	ldr	r3, [fp, #-8]
80164148:	e1a00003 	mov	r0, r3
8016414c:	ebfff16b 	bl	80160700 <__RME_A7A_Read_Acquire>
80164150:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80164154:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164158:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016415c:	e3530802 	cmp	r3, #131072	@ 0x20000
80164160:	1a000001 	bne	8016416c <_RME_Pgt_Add+0x280>
80164164:	e3e03008 	mvn	r3, #8
80164168:	ea000098 	b	801643d0 <_RME_Pgt_Add+0x4e4>
8016416c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164170:	e1a03c23 	lsr	r3, r3, #24
80164174:	e3530003 	cmp	r3, #3
80164178:	0a000001 	beq	80164184 <_RME_Pgt_Add+0x298>
8016417c:	e3e03001 	mvn	r3, #1
80164180:	ea000092 	b	801643d0 <_RME_Pgt_Add+0x4e4>
80164184:	e59b3004 	ldr	r3, [fp, #4]
80164188:	e203207f 	and	r2, r3, #127	@ 0x7f
8016418c:	e51b3008 	ldr	r3, [fp, #-8]
80164190:	e5933014 	ldr	r3, [r3, #20]
80164194:	e1520003 	cmp	r2, r3
80164198:	3a000001 	bcc	801641a4 <_RME_Pgt_Add+0x2b8>
8016419c:	e3e03002 	mvn	r3, #2
801641a0:	ea00008a 	b	801643d0 <_RME_Pgt_Add+0x4e4>
801641a4:	e59b3004 	ldr	r3, [fp, #4]
801641a8:	e203307f 	and	r3, r3, #127	@ 0x7f
801641ac:	e1a02283 	lsl	r2, r3, #5
801641b0:	e51b3008 	ldr	r3, [fp, #-8]
801641b4:	e593300c 	ldr	r3, [r3, #12]
801641b8:	e0823003 	add	r3, r2, r3
801641bc:	e50b3008 	str	r3, [fp, #-8]
801641c0:	e51b3008 	ldr	r3, [fp, #-8]
801641c4:	e1a00003 	mov	r0, r3
801641c8:	ebfff14c 	bl	80160700 <__RME_A7A_Read_Acquire>
801641cc:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801641d0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801641d4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801641d8:	e3530802 	cmp	r3, #131072	@ 0x20000
801641dc:	1a000001 	bne	801641e8 <_RME_Pgt_Add+0x2fc>
801641e0:	e3e03008 	mvn	r3, #8
801641e4:	ea000079 	b	801643d0 <_RME_Pgt_Add+0x4e4>
801641e8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801641ec:	e1a03c23 	lsr	r3, r3, #24
801641f0:	e3530004 	cmp	r3, #4
801641f4:	0a000001 	beq	80164200 <_RME_Pgt_Add+0x314>
801641f8:	e3e03001 	mvn	r3, #1
801641fc:	ea000073 	b	801643d0 <_RME_Pgt_Add+0x4e4>
                   struct RME_Cap_Pgt*,Pgt_Src,Type_Stat);
    /* Check if both page table caps are not frozen and allows such operations */
    RME_CAP_CHECK(Pgt_Dst,RME_PGT_FLAG_ADD_DST);
80164200:	e51b300c 	ldr	r3, [fp, #-12]
80164204:	e5933008 	ldr	r3, [r3, #8]
80164208:	e2033002 	and	r3, r3, #2
8016420c:	e3530000 	cmp	r3, #0
80164210:	1a000001 	bne	8016421c <_RME_Pgt_Add+0x330>
80164214:	e3e03006 	mvn	r3, #6
80164218:	ea00006c 	b	801643d0 <_RME_Pgt_Add+0x4e4>
    RME_CAP_CHECK(Pgt_Src,RME_PGT_FLAG_ADD_SRC);
8016421c:	e51b3008 	ldr	r3, [fp, #-8]
80164220:	e5933008 	ldr	r3, [r3, #8]
80164224:	e2033001 	and	r3, r3, #1
80164228:	e3530000 	cmp	r3, #0
8016422c:	1a000001 	bne	80164238 <_RME_Pgt_Add+0x34c>
80164230:	e3e03006 	mvn	r3, #6
80164234:	ea000065 	b	801643d0 <_RME_Pgt_Add+0x4e4>
    /* Check the operation range - This is page table specific */
    if((Pos_Dst>RME_PGT_FLAG_HIGH(Pgt_Dst->Head.Flag))||
80164238:	e51b300c 	ldr	r3, [fp, #-12]
8016423c:	e5933008 	ldr	r3, [r3, #8]
80164240:	e1a03a23 	lsr	r3, r3, #20
80164244:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
80164248:	e1520003 	cmp	r2, r3
8016424c:	8a000013 	bhi	801642a0 <_RME_Pgt_Add+0x3b4>
       (Pos_Dst<RME_PGT_FLAG_LOW(Pgt_Dst->Head.Flag))||
80164250:	e51b300c 	ldr	r3, [fp, #-12]
80164254:	e5933008 	ldr	r3, [r3, #8]
80164258:	e1a03423 	lsr	r3, r3, #8
8016425c:	e7eb3053 	ubfx	r3, r3, #0, #12
    if((Pos_Dst>RME_PGT_FLAG_HIGH(Pgt_Dst->Head.Flag))||
80164260:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
80164264:	e1520003 	cmp	r2, r3
80164268:	3a00000c 	bcc	801642a0 <_RME_Pgt_Add+0x3b4>
       (Pos_Src>RME_PGT_FLAG_HIGH(Pgt_Src->Head.Flag))||
8016426c:	e51b3008 	ldr	r3, [fp, #-8]
80164270:	e5933008 	ldr	r3, [r3, #8]
80164274:	e1a03a23 	lsr	r3, r3, #20
       (Pos_Dst<RME_PGT_FLAG_LOW(Pgt_Dst->Head.Flag))||
80164278:	e59b2008 	ldr	r2, [fp, #8]
8016427c:	e1520003 	cmp	r2, r3
80164280:	8a000006 	bhi	801642a0 <_RME_Pgt_Add+0x3b4>
       (Pos_Src<RME_PGT_FLAG_LOW(Pgt_Src->Head.Flag)))
80164284:	e51b3008 	ldr	r3, [fp, #-8]
80164288:	e5933008 	ldr	r3, [r3, #8]
8016428c:	e1a03423 	lsr	r3, r3, #8
80164290:	e7eb3053 	ubfx	r3, r3, #0, #12
       (Pos_Src>RME_PGT_FLAG_HIGH(Pgt_Src->Head.Flag))||
80164294:	e59b2008 	ldr	r2, [fp, #8]
80164298:	e1520003 	cmp	r2, r3
8016429c:	2a000001 	bcs	801642a8 <_RME_Pgt_Add+0x3bc>
    {
        RME_COV_MARKER();

        return RME_ERR_CPT_FLAG;
801642a0:	e3e03006 	mvn	r3, #6
801642a4:	ea000049 	b	801643d0 <_RME_Pgt_Add+0x4e4>
        RME_COV_MARKER();
        /* No action required */
    }

    /* See if the size order relationship is correct */
    Szord_Dst=RME_PGT_SZORD(Pgt_Dst->Order);
801642a8:	e51b300c 	ldr	r3, [fp, #-12]
801642ac:	e5933014 	ldr	r3, [r3, #20]
801642b0:	e1a03823 	lsr	r3, r3, #16
801642b4:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Szord_Src=RME_PGT_SZORD(Pgt_Src->Order);
801642b8:	e51b3008 	ldr	r3, [fp, #-8]
801642bc:	e5933014 	ldr	r3, [r3, #20]
801642c0:	e1a03823 	lsr	r3, r3, #16
801642c4:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    if(Szord_Dst>Szord_Src)
801642c8:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
801642cc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801642d0:	e1520003 	cmp	r2, r3
801642d4:	9a000001 	bls	801642e0 <_RME_Pgt_Add+0x3f4>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_ADDR;
801642d8:	e3e03064 	mvn	r3, #100	@ 0x64
801642dc:	ea00003b 	b	801643d0 <_RME_Pgt_Add+0x4e4>
        RME_COV_MARKER();
        /* No action required */
    }

    /* See if the positions are out of range - NMORD is restricted, no UB */
    if(((Pos_Dst>>RME_PGT_NMORD(Pgt_Dst->Order))!=0U)||
801642e0:	e51b300c 	ldr	r3, [fp, #-12]
801642e4:	e5933014 	ldr	r3, [r3, #20]
801642e8:	e6ff3073 	uxth	r3, r3
801642ec:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
801642f0:	e1a03332 	lsr	r3, r2, r3
801642f4:	e3530000 	cmp	r3, #0
801642f8:	1a000006 	bne	80164318 <_RME_Pgt_Add+0x42c>
       ((Pos_Src>>RME_PGT_NMORD(Pgt_Src->Order))!=0U))
801642fc:	e51b3008 	ldr	r3, [fp, #-8]
80164300:	e5933014 	ldr	r3, [r3, #20]
80164304:	e6ff3073 	uxth	r3, r3
80164308:	e59b2008 	ldr	r2, [fp, #8]
8016430c:	e1a03332 	lsr	r3, r2, r3
    if(((Pos_Dst>>RME_PGT_NMORD(Pgt_Dst->Order))!=0U)||
80164310:	e3530000 	cmp	r3, #0
80164314:	0a000001 	beq	80164320 <_RME_Pgt_Add+0x434>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_ADDR;
80164318:	e3e03064 	mvn	r3, #100	@ 0x64
8016431c:	ea00002b 	b	801643d0 <_RME_Pgt_Add+0x4e4>
        RME_COV_MARKER();
        /* No action required */
    }

    /* See if the source subposition is out of range - avoid UB */
    if(Szord_Src<RME_WORD_BIT)
80164320:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164324:	e353001f 	cmp	r3, #31
80164328:	8a000009 	bhi	80164354 <_RME_Pgt_Add+0x468>
    {
        RME_COV_MARKER();
        
        /* No UB because Szord_Dst<=Szord_Src */
        if(RME_POW2(Szord_Src)<=(Index<<Szord_Dst))
8016432c:	e3a02001 	mov	r2, #1
80164330:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164334:	e1a02312 	lsl	r2, r2, r3
80164338:	e59b100c 	ldr	r1, [fp, #12]
8016433c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164340:	e1a03311 	lsl	r3, r1, r3
80164344:	e1520003 	cmp	r2, r3
80164348:	8a000001 	bhi	80164354 <_RME_Pgt_Add+0x468>
        {
            RME_COV_MARKER();

            return RME_ERR_PGT_ADDR;
8016434c:	e3e03064 	mvn	r3, #100	@ 0x64
80164350:	ea00001e 	b	801643d0 <_RME_Pgt_Add+0x4e4>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Get the physical address and RME standard flags of that source page */
    if(__RME_Pgt_Lookup(Pgt_Src,Pos_Src,&Paddr_Src,&Flag_Src)<0)
80164354:	e24b3024 	sub	r3, fp, #36	@ 0x24
80164358:	e24b2020 	sub	r2, fp, #32
8016435c:	e59b1008 	ldr	r1, [fp, #8]
80164360:	e51b0008 	ldr	r0, [fp, #-8]
80164364:	eb00283e 	bl	8016e464 <__RME_Pgt_Lookup>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Calculate the destination physical address - avoid UB */
    if(Szord_Dst<RME_WORD_BIT)
80164368:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016436c:	e353001f 	cmp	r3, #31
80164370:	8a000006 	bhi	80164390 <_RME_Pgt_Add+0x4a4>
    {
        RME_COV_MARKER();
        
        Paddr_Dst=Paddr_Src+(Index<<Szord_Dst);
80164374:	e59b200c 	ldr	r2, [fp, #12]
80164378:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016437c:	e1a02312 	lsl	r2, r2, r3
80164380:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80164384:	e0823003 	add	r3, r2, r3
80164388:	e50b3010 	str	r3, [fp, #-16]
8016438c:	ea000001 	b	80164398 <_RME_Pgt_Add+0x4ac>
    /* The destination is also full range */
    else
    {
        RME_COV_MARKER();
        
        Paddr_Dst=Paddr_Src;
80164390:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80164394:	e50b3010 	str	r3, [fp, #-16]
        }
#endif
    }
    
    /* Analyze the flags - we do not allow expansion of access permissions */
    if(((Flag_Dst)&(~Flag_Src))!=0U)
80164398:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016439c:	e1e02003 	mvn	r2, r3
801643a0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801643a4:	e0033002 	and	r3, r3, r2
801643a8:	e3530000 	cmp	r3, #0
801643ac:	0a000001 	beq	801643b8 <_RME_Pgt_Add+0x4cc>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_PERM;
801643b0:	e3e03067 	mvn	r3, #103	@ 0x67
801643b4:	ea000005 	b	801643d0 <_RME_Pgt_Add+0x4e4>
        /* No action required */
    }

    /* Actually do the mapping - This work is passed down to the HAL. 
     * Under multi-core, HAL should use CAS to avoid a conflict */
    if(__RME_Pgt_Page_Map(Pgt_Dst,Paddr_Dst,Pos_Dst,Flag_Dst)<0)
801643b8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801643bc:	e51b2030 	ldr	r2, [fp, #-48]	@ 0xffffffd0
801643c0:	e51b1010 	ldr	r1, [fp, #-16]
801643c4:	e51b000c 	ldr	r0, [fp, #-12]
801643c8:	eb00274b 	bl	8016e0fc <__RME_Pgt_Page_Map>
    else
    {
        RME_COV_MARKER();
        /* No action required */
    }
    return 0;
801643cc:	e3a03000 	mov	r3, #0
}
801643d0:	e1a00003 	mov	r0, r3
801643d4:	e24bd004 	sub	sp, fp, #4
801643d8:	e8bd8800 	pop	{fp, pc}

801643dc <_RME_Pgt_Rem>:
******************************************************************************/
#if(RME_PGT_RAW_ENABLE==0U)
static rme_ret_t _RME_Pgt_Rem(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Pgt,
                              rme_ptr_t Pos)
{
801643dc:	e92d4800 	push	{fp, lr}
801643e0:	e28db004 	add	fp, sp, #4
801643e4:	e24dd018 	sub	sp, sp, #24
801643e8:	e50b0010 	str	r0, [fp, #-16]
801643ec:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
801643f0:	e50b2018 	str	r2, [fp, #-24]	@ 0xffffffe8
    struct RME_Cap_Pgt* Pgt_Rem;
    rme_ptr_t Type_Stat;
    
    /* Get the cap location that we care about */
    RME_CPT_GETCAP(Cpt,Cap_Pgt,RME_CAP_TYPE_CPT,
801643f4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801643f8:	e2033080 	and	r3, r3, #128	@ 0x80
801643fc:	e3530000 	cmp	r3, #0
80164400:	1a00001c 	bne	80164478 <_RME_Pgt_Rem+0x9c>
80164404:	e51b3010 	ldr	r3, [fp, #-16]
80164408:	e5932014 	ldr	r2, [r3, #20]
8016440c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164410:	e1520003 	cmp	r2, r3
80164414:	8a000001 	bhi	80164420 <_RME_Pgt_Rem+0x44>
80164418:	e3e03002 	mvn	r3, #2
8016441c:	ea000076 	b	801645fc <_RME_Pgt_Rem+0x220>
80164420:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164424:	e1a02283 	lsl	r2, r3, #5
80164428:	e51b3010 	ldr	r3, [fp, #-16]
8016442c:	e593300c 	ldr	r3, [r3, #12]
80164430:	e0823003 	add	r3, r2, r3
80164434:	e50b3008 	str	r3, [fp, #-8]
80164438:	e51b3008 	ldr	r3, [fp, #-8]
8016443c:	e1a00003 	mov	r0, r3
80164440:	ebfff0ae 	bl	80160700 <__RME_A7A_Read_Acquire>
80164444:	e50b000c 	str	r0, [fp, #-12]
80164448:	e51b300c 	ldr	r3, [fp, #-12]
8016444c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80164450:	e3530802 	cmp	r3, #131072	@ 0x20000
80164454:	1a000001 	bne	80164460 <_RME_Pgt_Rem+0x84>
80164458:	e3e03008 	mvn	r3, #8
8016445c:	ea000066 	b	801645fc <_RME_Pgt_Rem+0x220>
80164460:	e51b300c 	ldr	r3, [fp, #-12]
80164464:	e1a03c23 	lsr	r3, r3, #24
80164468:	e3530003 	cmp	r3, #3
8016446c:	0a00003f 	beq	80164570 <_RME_Pgt_Rem+0x194>
80164470:	e3e03001 	mvn	r3, #1
80164474:	ea000060 	b	801645fc <_RME_Pgt_Rem+0x220>
80164478:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016447c:	e1a02423 	lsr	r2, r3, #8
80164480:	e51b3010 	ldr	r3, [fp, #-16]
80164484:	e5933014 	ldr	r3, [r3, #20]
80164488:	e1520003 	cmp	r2, r3
8016448c:	3a000001 	bcc	80164498 <_RME_Pgt_Rem+0xbc>
80164490:	e3e03002 	mvn	r3, #2
80164494:	ea000058 	b	801645fc <_RME_Pgt_Rem+0x220>
80164498:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016449c:	e1a03423 	lsr	r3, r3, #8
801644a0:	e1a02283 	lsl	r2, r3, #5
801644a4:	e51b3010 	ldr	r3, [fp, #-16]
801644a8:	e593300c 	ldr	r3, [r3, #12]
801644ac:	e0823003 	add	r3, r2, r3
801644b0:	e50b3008 	str	r3, [fp, #-8]
801644b4:	e51b3008 	ldr	r3, [fp, #-8]
801644b8:	e1a00003 	mov	r0, r3
801644bc:	ebfff08f 	bl	80160700 <__RME_A7A_Read_Acquire>
801644c0:	e50b000c 	str	r0, [fp, #-12]
801644c4:	e51b300c 	ldr	r3, [fp, #-12]
801644c8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801644cc:	e3530802 	cmp	r3, #131072	@ 0x20000
801644d0:	1a000001 	bne	801644dc <_RME_Pgt_Rem+0x100>
801644d4:	e3e03008 	mvn	r3, #8
801644d8:	ea000047 	b	801645fc <_RME_Pgt_Rem+0x220>
801644dc:	e51b300c 	ldr	r3, [fp, #-12]
801644e0:	e1a03c23 	lsr	r3, r3, #24
801644e4:	e3530003 	cmp	r3, #3
801644e8:	0a000001 	beq	801644f4 <_RME_Pgt_Rem+0x118>
801644ec:	e3e03001 	mvn	r3, #1
801644f0:	ea000041 	b	801645fc <_RME_Pgt_Rem+0x220>
801644f4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801644f8:	e203207f 	and	r2, r3, #127	@ 0x7f
801644fc:	e51b3008 	ldr	r3, [fp, #-8]
80164500:	e5933014 	ldr	r3, [r3, #20]
80164504:	e1520003 	cmp	r2, r3
80164508:	3a000001 	bcc	80164514 <_RME_Pgt_Rem+0x138>
8016450c:	e3e03002 	mvn	r3, #2
80164510:	ea000039 	b	801645fc <_RME_Pgt_Rem+0x220>
80164514:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164518:	e203307f 	and	r3, r3, #127	@ 0x7f
8016451c:	e1a02283 	lsl	r2, r3, #5
80164520:	e51b3008 	ldr	r3, [fp, #-8]
80164524:	e593300c 	ldr	r3, [r3, #12]
80164528:	e0823003 	add	r3, r2, r3
8016452c:	e50b3008 	str	r3, [fp, #-8]
80164530:	e51b3008 	ldr	r3, [fp, #-8]
80164534:	e1a00003 	mov	r0, r3
80164538:	ebfff070 	bl	80160700 <__RME_A7A_Read_Acquire>
8016453c:	e50b000c 	str	r0, [fp, #-12]
80164540:	e51b300c 	ldr	r3, [fp, #-12]
80164544:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80164548:	e3530802 	cmp	r3, #131072	@ 0x20000
8016454c:	1a000001 	bne	80164558 <_RME_Pgt_Rem+0x17c>
80164550:	e3e03008 	mvn	r3, #8
80164554:	ea000028 	b	801645fc <_RME_Pgt_Rem+0x220>
80164558:	e51b300c 	ldr	r3, [fp, #-12]
8016455c:	e1a03c23 	lsr	r3, r3, #24
80164560:	e3530003 	cmp	r3, #3
80164564:	0a000001 	beq	80164570 <_RME_Pgt_Rem+0x194>
80164568:	e3e03001 	mvn	r3, #1
8016456c:	ea000022 	b	801645fc <_RME_Pgt_Rem+0x220>
                   struct RME_Cap_Pgt*,Pgt_Rem,Type_Stat);
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Pgt_Rem,RME_PGT_FLAG_REM);
80164570:	e51b3008 	ldr	r3, [fp, #-8]
80164574:	e5933008 	ldr	r3, [r3, #8]
80164578:	e2033004 	and	r3, r3, #4
8016457c:	e3530000 	cmp	r3, #0
80164580:	1a000001 	bne	8016458c <_RME_Pgt_Rem+0x1b0>
80164584:	e3e03006 	mvn	r3, #6
80164588:	ea00001b 	b	801645fc <_RME_Pgt_Rem+0x220>
    /* Check the operation range - This is page table specific */
    if((Pos>RME_PGT_FLAG_HIGH(Pgt_Rem->Head.Flag))||
8016458c:	e51b3008 	ldr	r3, [fp, #-8]
80164590:	e5933008 	ldr	r3, [r3, #8]
80164594:	e1a03a23 	lsr	r3, r3, #20
80164598:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016459c:	e1520003 	cmp	r2, r3
801645a0:	8a000006 	bhi	801645c0 <_RME_Pgt_Rem+0x1e4>
       (Pos<RME_PGT_FLAG_LOW(Pgt_Rem->Head.Flag)))
801645a4:	e51b3008 	ldr	r3, [fp, #-8]
801645a8:	e5933008 	ldr	r3, [r3, #8]
801645ac:	e1a03423 	lsr	r3, r3, #8
801645b0:	e7eb3053 	ubfx	r3, r3, #0, #12
    if((Pos>RME_PGT_FLAG_HIGH(Pgt_Rem->Head.Flag))||
801645b4:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
801645b8:	e1520003 	cmp	r2, r3
801645bc:	2a000001 	bcs	801645c8 <_RME_Pgt_Rem+0x1ec>
    {
        RME_COV_MARKER();

        return RME_ERR_CPT_FLAG;
801645c0:	e3e03006 	mvn	r3, #6
801645c4:	ea00000c 	b	801645fc <_RME_Pgt_Rem+0x220>
        RME_COV_MARKER();
        /* No action required */
    }

    /* See if the unmapping range is allowed */
    if((Pos>>RME_PGT_NMORD(Pgt_Rem->Order))!=0U)
801645c8:	e51b3008 	ldr	r3, [fp, #-8]
801645cc:	e5933014 	ldr	r3, [r3, #20]
801645d0:	e6ff3073 	uxth	r3, r3
801645d4:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
801645d8:	e1a03332 	lsr	r3, r2, r3
801645dc:	e3530000 	cmp	r3, #0
801645e0:	0a000001 	beq	801645ec <_RME_Pgt_Rem+0x210>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_ADDR;
801645e4:	e3e03064 	mvn	r3, #100	@ 0x64
801645e8:	ea000003 	b	801645fc <_RME_Pgt_Rem+0x220>
        /* No action required */
    }

    /* Actually do the mapping - This work is passed down to the HAL. 
     * Under multi-core, HAL should use CAS to avoid a conflict */
    if(__RME_Pgt_Page_Unmap(Pgt_Rem,Pos)<0)
801645ec:	e51b1018 	ldr	r1, [fp, #-24]	@ 0xffffffe8
801645f0:	e51b0008 	ldr	r0, [fp, #-8]
801645f4:	eb002722 	bl	8016e284 <__RME_Pgt_Page_Unmap>
    {
        RME_COV_MARKER();
        /* No action required */
    }

    return 0;
801645f8:	e3a03000 	mov	r3, #0
}
801645fc:	e1a00003 	mov	r0, r3
80164600:	e24bd004 	sub	sp, fp, #4
80164604:	e8bd8800 	pop	{fp, pc}

80164608 <_RME_Pgt_Con>:
static rme_ret_t _RME_Pgt_Con(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Pgt_Parent,
                              rme_ptr_t Pos,
                              rme_cid_t Cap_Pgt_Child,
                              rme_ptr_t Flag_Child)
{
80164608:	e92d4800 	push	{fp, lr}
8016460c:	e28db004 	add	fp, sp, #4
80164610:	e24dd028 	sub	sp, sp, #40	@ 0x28
80164614:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
80164618:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
8016461c:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
80164620:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
    rme_ptr_t End_Parent;
#endif
    rme_ptr_t Type_Stat;
    
    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Pgt_Parent,RME_CAP_TYPE_PGT,
80164624:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164628:	e2033080 	and	r3, r3, #128	@ 0x80
8016462c:	e3530000 	cmp	r3, #0
80164630:	1a00001c 	bne	801646a8 <_RME_Pgt_Con+0xa0>
80164634:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80164638:	e5932014 	ldr	r2, [r3, #20]
8016463c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164640:	e1520003 	cmp	r2, r3
80164644:	8a000001 	bhi	80164650 <_RME_Pgt_Con+0x48>
80164648:	e3e03002 	mvn	r3, #2
8016464c:	ea000114 	b	80164aa4 <_RME_Pgt_Con+0x49c>
80164650:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164654:	e1a02283 	lsl	r2, r3, #5
80164658:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016465c:	e593300c 	ldr	r3, [r3, #12]
80164660:	e0823003 	add	r3, r2, r3
80164664:	e50b3008 	str	r3, [fp, #-8]
80164668:	e51b3008 	ldr	r3, [fp, #-8]
8016466c:	e1a00003 	mov	r0, r3
80164670:	ebfff022 	bl	80160700 <__RME_A7A_Read_Acquire>
80164674:	e50b0010 	str	r0, [fp, #-16]
80164678:	e51b3010 	ldr	r3, [fp, #-16]
8016467c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80164680:	e3530802 	cmp	r3, #131072	@ 0x20000
80164684:	1a000001 	bne	80164690 <_RME_Pgt_Con+0x88>
80164688:	e3e03008 	mvn	r3, #8
8016468c:	ea000104 	b	80164aa4 <_RME_Pgt_Con+0x49c>
80164690:	e51b3010 	ldr	r3, [fp, #-16]
80164694:	e1a03c23 	lsr	r3, r3, #24
80164698:	e3530004 	cmp	r3, #4
8016469c:	0a00003f 	beq	801647a0 <_RME_Pgt_Con+0x198>
801646a0:	e3e03001 	mvn	r3, #1
801646a4:	ea0000fe 	b	80164aa4 <_RME_Pgt_Con+0x49c>
801646a8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801646ac:	e1a02423 	lsr	r2, r3, #8
801646b0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801646b4:	e5933014 	ldr	r3, [r3, #20]
801646b8:	e1520003 	cmp	r2, r3
801646bc:	3a000001 	bcc	801646c8 <_RME_Pgt_Con+0xc0>
801646c0:	e3e03002 	mvn	r3, #2
801646c4:	ea0000f6 	b	80164aa4 <_RME_Pgt_Con+0x49c>
801646c8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801646cc:	e1a03423 	lsr	r3, r3, #8
801646d0:	e1a02283 	lsl	r2, r3, #5
801646d4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801646d8:	e593300c 	ldr	r3, [r3, #12]
801646dc:	e0823003 	add	r3, r2, r3
801646e0:	e50b3008 	str	r3, [fp, #-8]
801646e4:	e51b3008 	ldr	r3, [fp, #-8]
801646e8:	e1a00003 	mov	r0, r3
801646ec:	ebfff003 	bl	80160700 <__RME_A7A_Read_Acquire>
801646f0:	e50b0010 	str	r0, [fp, #-16]
801646f4:	e51b3010 	ldr	r3, [fp, #-16]
801646f8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801646fc:	e3530802 	cmp	r3, #131072	@ 0x20000
80164700:	1a000001 	bne	8016470c <_RME_Pgt_Con+0x104>
80164704:	e3e03008 	mvn	r3, #8
80164708:	ea0000e5 	b	80164aa4 <_RME_Pgt_Con+0x49c>
8016470c:	e51b3010 	ldr	r3, [fp, #-16]
80164710:	e1a03c23 	lsr	r3, r3, #24
80164714:	e3530003 	cmp	r3, #3
80164718:	0a000001 	beq	80164724 <_RME_Pgt_Con+0x11c>
8016471c:	e3e03001 	mvn	r3, #1
80164720:	ea0000df 	b	80164aa4 <_RME_Pgt_Con+0x49c>
80164724:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164728:	e203207f 	and	r2, r3, #127	@ 0x7f
8016472c:	e51b3008 	ldr	r3, [fp, #-8]
80164730:	e5933014 	ldr	r3, [r3, #20]
80164734:	e1520003 	cmp	r2, r3
80164738:	3a000001 	bcc	80164744 <_RME_Pgt_Con+0x13c>
8016473c:	e3e03002 	mvn	r3, #2
80164740:	ea0000d7 	b	80164aa4 <_RME_Pgt_Con+0x49c>
80164744:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164748:	e203307f 	and	r3, r3, #127	@ 0x7f
8016474c:	e1a02283 	lsl	r2, r3, #5
80164750:	e51b3008 	ldr	r3, [fp, #-8]
80164754:	e593300c 	ldr	r3, [r3, #12]
80164758:	e0823003 	add	r3, r2, r3
8016475c:	e50b3008 	str	r3, [fp, #-8]
80164760:	e51b3008 	ldr	r3, [fp, #-8]
80164764:	e1a00003 	mov	r0, r3
80164768:	ebffefe4 	bl	80160700 <__RME_A7A_Read_Acquire>
8016476c:	e50b0010 	str	r0, [fp, #-16]
80164770:	e51b3010 	ldr	r3, [fp, #-16]
80164774:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80164778:	e3530802 	cmp	r3, #131072	@ 0x20000
8016477c:	1a000001 	bne	80164788 <_RME_Pgt_Con+0x180>
80164780:	e3e03008 	mvn	r3, #8
80164784:	ea0000c6 	b	80164aa4 <_RME_Pgt_Con+0x49c>
80164788:	e51b3010 	ldr	r3, [fp, #-16]
8016478c:	e1a03c23 	lsr	r3, r3, #24
80164790:	e3530004 	cmp	r3, #4
80164794:	0a000001 	beq	801647a0 <_RME_Pgt_Con+0x198>
80164798:	e3e03001 	mvn	r3, #1
8016479c:	ea0000c0 	b	80164aa4 <_RME_Pgt_Con+0x49c>
                   struct RME_Cap_Pgt*,Pgt_Parent,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Pgt_Child,RME_CAP_TYPE_PGT,
801647a0:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801647a4:	e2033080 	and	r3, r3, #128	@ 0x80
801647a8:	e3530000 	cmp	r3, #0
801647ac:	1a00001c 	bne	80164824 <_RME_Pgt_Con+0x21c>
801647b0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801647b4:	e5932014 	ldr	r2, [r3, #20]
801647b8:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801647bc:	e1520003 	cmp	r2, r3
801647c0:	8a000001 	bhi	801647cc <_RME_Pgt_Con+0x1c4>
801647c4:	e3e03002 	mvn	r3, #2
801647c8:	ea0000b5 	b	80164aa4 <_RME_Pgt_Con+0x49c>
801647cc:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801647d0:	e1a02283 	lsl	r2, r3, #5
801647d4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801647d8:	e593300c 	ldr	r3, [r3, #12]
801647dc:	e0823003 	add	r3, r2, r3
801647e0:	e50b300c 	str	r3, [fp, #-12]
801647e4:	e51b300c 	ldr	r3, [fp, #-12]
801647e8:	e1a00003 	mov	r0, r3
801647ec:	ebffefc3 	bl	80160700 <__RME_A7A_Read_Acquire>
801647f0:	e50b0010 	str	r0, [fp, #-16]
801647f4:	e51b3010 	ldr	r3, [fp, #-16]
801647f8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801647fc:	e3530802 	cmp	r3, #131072	@ 0x20000
80164800:	1a000001 	bne	8016480c <_RME_Pgt_Con+0x204>
80164804:	e3e03008 	mvn	r3, #8
80164808:	ea0000a5 	b	80164aa4 <_RME_Pgt_Con+0x49c>
8016480c:	e51b3010 	ldr	r3, [fp, #-16]
80164810:	e1a03c23 	lsr	r3, r3, #24
80164814:	e3530004 	cmp	r3, #4
80164818:	0a00003f 	beq	8016491c <_RME_Pgt_Con+0x314>
8016481c:	e3e03001 	mvn	r3, #1
80164820:	ea00009f 	b	80164aa4 <_RME_Pgt_Con+0x49c>
80164824:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80164828:	e1a02423 	lsr	r2, r3, #8
8016482c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80164830:	e5933014 	ldr	r3, [r3, #20]
80164834:	e1520003 	cmp	r2, r3
80164838:	3a000001 	bcc	80164844 <_RME_Pgt_Con+0x23c>
8016483c:	e3e03002 	mvn	r3, #2
80164840:	ea000097 	b	80164aa4 <_RME_Pgt_Con+0x49c>
80164844:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80164848:	e1a03423 	lsr	r3, r3, #8
8016484c:	e1a02283 	lsl	r2, r3, #5
80164850:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80164854:	e593300c 	ldr	r3, [r3, #12]
80164858:	e0823003 	add	r3, r2, r3
8016485c:	e50b300c 	str	r3, [fp, #-12]
80164860:	e51b300c 	ldr	r3, [fp, #-12]
80164864:	e1a00003 	mov	r0, r3
80164868:	ebffefa4 	bl	80160700 <__RME_A7A_Read_Acquire>
8016486c:	e50b0010 	str	r0, [fp, #-16]
80164870:	e51b3010 	ldr	r3, [fp, #-16]
80164874:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80164878:	e3530802 	cmp	r3, #131072	@ 0x20000
8016487c:	1a000001 	bne	80164888 <_RME_Pgt_Con+0x280>
80164880:	e3e03008 	mvn	r3, #8
80164884:	ea000086 	b	80164aa4 <_RME_Pgt_Con+0x49c>
80164888:	e51b3010 	ldr	r3, [fp, #-16]
8016488c:	e1a03c23 	lsr	r3, r3, #24
80164890:	e3530003 	cmp	r3, #3
80164894:	0a000001 	beq	801648a0 <_RME_Pgt_Con+0x298>
80164898:	e3e03001 	mvn	r3, #1
8016489c:	ea000080 	b	80164aa4 <_RME_Pgt_Con+0x49c>
801648a0:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801648a4:	e203207f 	and	r2, r3, #127	@ 0x7f
801648a8:	e51b300c 	ldr	r3, [fp, #-12]
801648ac:	e5933014 	ldr	r3, [r3, #20]
801648b0:	e1520003 	cmp	r2, r3
801648b4:	3a000001 	bcc	801648c0 <_RME_Pgt_Con+0x2b8>
801648b8:	e3e03002 	mvn	r3, #2
801648bc:	ea000078 	b	80164aa4 <_RME_Pgt_Con+0x49c>
801648c0:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801648c4:	e203307f 	and	r3, r3, #127	@ 0x7f
801648c8:	e1a02283 	lsl	r2, r3, #5
801648cc:	e51b300c 	ldr	r3, [fp, #-12]
801648d0:	e593300c 	ldr	r3, [r3, #12]
801648d4:	e0823003 	add	r3, r2, r3
801648d8:	e50b300c 	str	r3, [fp, #-12]
801648dc:	e51b300c 	ldr	r3, [fp, #-12]
801648e0:	e1a00003 	mov	r0, r3
801648e4:	ebffef85 	bl	80160700 <__RME_A7A_Read_Acquire>
801648e8:	e50b0010 	str	r0, [fp, #-16]
801648ec:	e51b3010 	ldr	r3, [fp, #-16]
801648f0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801648f4:	e3530802 	cmp	r3, #131072	@ 0x20000
801648f8:	1a000001 	bne	80164904 <_RME_Pgt_Con+0x2fc>
801648fc:	e3e03008 	mvn	r3, #8
80164900:	ea000067 	b	80164aa4 <_RME_Pgt_Con+0x49c>
80164904:	e51b3010 	ldr	r3, [fp, #-16]
80164908:	e1a03c23 	lsr	r3, r3, #24
8016490c:	e3530004 	cmp	r3, #4
80164910:	0a000001 	beq	8016491c <_RME_Pgt_Con+0x314>
80164914:	e3e03001 	mvn	r3, #1
80164918:	ea000061 	b	80164aa4 <_RME_Pgt_Con+0x49c>
                   struct RME_Cap_Pgt*,Pgt_Child,Type_Stat);
    /* Check if both page table caps are not frozen and allows such operations */
    RME_CAP_CHECK(Pgt_Parent, RME_PGT_FLAG_CON_PARENT);
8016491c:	e51b3008 	ldr	r3, [fp, #-8]
80164920:	e5933008 	ldr	r3, [r3, #8]
80164924:	e2033010 	and	r3, r3, #16
80164928:	e3530000 	cmp	r3, #0
8016492c:	1a000001 	bne	80164938 <_RME_Pgt_Con+0x330>
80164930:	e3e03006 	mvn	r3, #6
80164934:	ea00005a 	b	80164aa4 <_RME_Pgt_Con+0x49c>
    RME_CAP_CHECK(Pgt_Child, RME_PGT_FLAG_CHILD);
80164938:	e51b300c 	ldr	r3, [fp, #-12]
8016493c:	e5933008 	ldr	r3, [r3, #8]
80164940:	e2033008 	and	r3, r3, #8
80164944:	e3530000 	cmp	r3, #0
80164948:	1a000001 	bne	80164954 <_RME_Pgt_Con+0x34c>
8016494c:	e3e03006 	mvn	r3, #6
80164950:	ea000053 	b	80164aa4 <_RME_Pgt_Con+0x49c>
    /* Check the operation range - This is page table specific */
    if((Pos>RME_PGT_FLAG_HIGH(Pgt_Parent->Head.Flag))||
80164954:	e51b3008 	ldr	r3, [fp, #-8]
80164958:	e5933008 	ldr	r3, [r3, #8]
8016495c:	e1a03a23 	lsr	r3, r3, #20
80164960:	e51b2028 	ldr	r2, [fp, #-40]	@ 0xffffffd8
80164964:	e1520003 	cmp	r2, r3
80164968:	8a000006 	bhi	80164988 <_RME_Pgt_Con+0x380>
       (Pos<RME_PGT_FLAG_LOW(Pgt_Parent->Head.Flag)))
8016496c:	e51b3008 	ldr	r3, [fp, #-8]
80164970:	e5933008 	ldr	r3, [r3, #8]
80164974:	e1a03423 	lsr	r3, r3, #8
80164978:	e7eb3053 	ubfx	r3, r3, #0, #12
    if((Pos>RME_PGT_FLAG_HIGH(Pgt_Parent->Head.Flag))||
8016497c:	e51b2028 	ldr	r2, [fp, #-40]	@ 0xffffffd8
80164980:	e1520003 	cmp	r2, r3
80164984:	2a000001 	bcs	80164990 <_RME_Pgt_Con+0x388>
    {
        RME_COV_MARKER();

        return RME_ERR_CPT_FLAG;
80164988:	e3e03006 	mvn	r3, #6
8016498c:	ea000044 	b	80164aa4 <_RME_Pgt_Con+0x49c>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* See if the mapping range is allowed */
    if((Pos>>RME_PGT_NMORD(Pgt_Parent->Order))!=0U)
80164990:	e51b3008 	ldr	r3, [fp, #-8]
80164994:	e5933014 	ldr	r3, [r3, #20]
80164998:	e6ff3073 	uxth	r3, r3
8016499c:	e51b2028 	ldr	r2, [fp, #-40]	@ 0xffffffd8
801649a0:	e1a03332 	lsr	r3, r2, r3
801649a4:	e3530000 	cmp	r3, #0
801649a8:	0a000001 	beq	801649b4 <_RME_Pgt_Con+0x3ac>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_ADDR;
801649ac:	e3e03064 	mvn	r3, #100	@ 0x64
801649b0:	ea00003b 	b	80164aa4 <_RME_Pgt_Con+0x49c>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* See if the child table falls within one slot of the parent table */
    Order_Child=RME_PGT_NMORD(Pgt_Child->Order)+RME_PGT_SZORD(Pgt_Child->Order);
801649b4:	e51b300c 	ldr	r3, [fp, #-12]
801649b8:	e5933014 	ldr	r3, [r3, #20]
801649bc:	e6ff2073 	uxth	r2, r3
801649c0:	e51b300c 	ldr	r3, [fp, #-12]
801649c4:	e5933014 	ldr	r3, [r3, #20]
801649c8:	e1a03823 	lsr	r3, r3, #16
801649cc:	e0823003 	add	r3, r2, r3
801649d0:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Szord_Parent=RME_PGT_SZORD(Pgt_Parent->Order);
801649d4:	e51b3008 	ldr	r3, [fp, #-8]
801649d8:	e5933014 	ldr	r3, [r3, #20]
801649dc:	e1a03823 	lsr	r3, r3, #16
801649e0:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    if(Szord_Parent<Order_Child)
801649e4:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
801649e8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801649ec:	e1520003 	cmp	r2, r3
801649f0:	2a000001 	bcs	801649fc <_RME_Pgt_Con+0x3f4>
    {
        RME_COV_MARKER();
        
        return RME_ERR_PGT_ADDR;
801649f4:	e3e03064 	mvn	r3, #100	@ 0x64
801649f8:	ea000029 	b	80164aa4 <_RME_Pgt_Con+0x49c>
        RME_COV_MARKER();
        /* No action required */
    }
#else
    /* Force no path compression when virtual mappings are enabled */
    if(Szord_Parent!=Order_Child)
801649fc:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80164a00:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164a04:	e1520003 	cmp	r2, r3
80164a08:	0a000001 	beq	80164a14 <_RME_Pgt_Con+0x40c>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_ADDR;
80164a0c:	e3e03064 	mvn	r3, #100	@ 0x64
80164a10:	ea000023 	b	80164aa4 <_RME_Pgt_Con+0x49c>
    }
#endif

    /* Actually do the mapping - This work is passed down to the HAL. 
     * Under multi-core, HAL should use CAS to avoid a conflict */
    if(__RME_Pgt_Pgdir_Map(Pgt_Parent,Pos,Pgt_Child,Flag_Child)<0)
80164a14:	e59b3004 	ldr	r3, [fp, #4]
80164a18:	e51b200c 	ldr	r2, [fp, #-12]
80164a1c:	e51b1028 	ldr	r1, [fp, #-40]	@ 0xffffffd8
80164a20:	e51b0008 	ldr	r0, [fp, #-8]
80164a24:	eb00264f 	bl	8016e368 <__RME_Pgt_Pgdir_Map>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Increase refcnt for both parent/child */
    Pgt_Root=RME_CAP_CONV_ROOT(Pgt_Parent,struct RME_Cap_Pgt*);
80164a28:	e51b3008 	ldr	r3, [fp, #-8]
80164a2c:	e5933000 	ldr	r3, [r3]
80164a30:	e6ff3073 	uxth	r3, r3
80164a34:	e3530000 	cmp	r3, #0
80164a38:	0a000002 	beq	80164a48 <_RME_Pgt_Con+0x440>
80164a3c:	e51b3008 	ldr	r3, [fp, #-8]
80164a40:	e5933004 	ldr	r3, [r3, #4]
80164a44:	ea000000 	b	80164a4c <_RME_Pgt_Con+0x444>
80164a48:	e51b3008 	ldr	r3, [fp, #-8]
80164a4c:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    RME_FETCH_ADD(&(Pgt_Root->Head.Root_Ref),1);
80164a50:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164a54:	e2833004 	add	r3, r3, #4
80164a58:	e3a01001 	mov	r1, #1
80164a5c:	e1a00003 	mov	r0, r3
80164a60:	ebfff06a 	bl	80160c10 <_RME_Fetch_Add_Single>
    Pgt_Root=RME_CAP_CONV_ROOT(Pgt_Child,struct RME_Cap_Pgt*);
80164a64:	e51b300c 	ldr	r3, [fp, #-12]
80164a68:	e5933000 	ldr	r3, [r3]
80164a6c:	e6ff3073 	uxth	r3, r3
80164a70:	e3530000 	cmp	r3, #0
80164a74:	0a000002 	beq	80164a84 <_RME_Pgt_Con+0x47c>
80164a78:	e51b300c 	ldr	r3, [fp, #-12]
80164a7c:	e5933004 	ldr	r3, [r3, #4]
80164a80:	ea000000 	b	80164a88 <_RME_Pgt_Con+0x480>
80164a84:	e51b300c 	ldr	r3, [fp, #-12]
80164a88:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    RME_FETCH_ADD(&(Pgt_Root->Head.Root_Ref),1);
80164a8c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164a90:	e2833004 	add	r3, r3, #4
80164a94:	e3a01001 	mov	r1, #1
80164a98:	e1a00003 	mov	r0, r3
80164a9c:	ebfff05b 	bl	80160c10 <_RME_Fetch_Add_Single>

    return 0;
80164aa0:	e3a03000 	mov	r3, #0
}
80164aa4:	e1a00003 	mov	r0, r3
80164aa8:	e24bd004 	sub	sp, fp, #4
80164aac:	e8bd8800 	pop	{fp, pc}

80164ab0 <_RME_Pgt_Des>:
#if(RME_PGT_RAW_ENABLE==0U)
static rme_ret_t _RME_Pgt_Des(struct RME_Cap_Cpt* Cpt, 
                              rme_cid_t Cap_Pgt_Parent,
                              rme_ptr_t Pos,
                              rme_cid_t Cap_Pgt_Child)
{
80164ab0:	e92d4800 	push	{fp, lr}
80164ab4:	e28db004 	add	fp, sp, #4
80164ab8:	e24dd020 	sub	sp, sp, #32
80164abc:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80164ac0:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
80164ac4:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
80164ac8:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    struct RME_Cap_Pgt* Pgt_Child;
    struct RME_Cap_Pgt* Pgt_Root;
    rme_ptr_t Type_Stat;
    
    /* Get the cap location that we care about */
    RME_CPT_GETCAP(Cpt,Cap_Pgt_Parent,RME_CAP_TYPE_CPT,
80164acc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164ad0:	e2033080 	and	r3, r3, #128	@ 0x80
80164ad4:	e3530000 	cmp	r3, #0
80164ad8:	1a00001c 	bne	80164b50 <_RME_Pgt_Des+0xa0>
80164adc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164ae0:	e5932014 	ldr	r2, [r3, #20]
80164ae4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164ae8:	e1520003 	cmp	r2, r3
80164aec:	8a000001 	bhi	80164af8 <_RME_Pgt_Des+0x48>
80164af0:	e3e03002 	mvn	r3, #2
80164af4:	ea000100 	b	80164efc <_RME_Pgt_Des+0x44c>
80164af8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164afc:	e1a02283 	lsl	r2, r3, #5
80164b00:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164b04:	e593300c 	ldr	r3, [r3, #12]
80164b08:	e0823003 	add	r3, r2, r3
80164b0c:	e50b3008 	str	r3, [fp, #-8]
80164b10:	e51b3008 	ldr	r3, [fp, #-8]
80164b14:	e1a00003 	mov	r0, r3
80164b18:	ebffeef8 	bl	80160700 <__RME_A7A_Read_Acquire>
80164b1c:	e50b0010 	str	r0, [fp, #-16]
80164b20:	e51b3010 	ldr	r3, [fp, #-16]
80164b24:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80164b28:	e3530802 	cmp	r3, #131072	@ 0x20000
80164b2c:	1a000001 	bne	80164b38 <_RME_Pgt_Des+0x88>
80164b30:	e3e03008 	mvn	r3, #8
80164b34:	ea0000f0 	b	80164efc <_RME_Pgt_Des+0x44c>
80164b38:	e51b3010 	ldr	r3, [fp, #-16]
80164b3c:	e1a03c23 	lsr	r3, r3, #24
80164b40:	e3530003 	cmp	r3, #3
80164b44:	0a00003f 	beq	80164c48 <_RME_Pgt_Des+0x198>
80164b48:	e3e03001 	mvn	r3, #1
80164b4c:	ea0000ea 	b	80164efc <_RME_Pgt_Des+0x44c>
80164b50:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164b54:	e1a02423 	lsr	r2, r3, #8
80164b58:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164b5c:	e5933014 	ldr	r3, [r3, #20]
80164b60:	e1520003 	cmp	r2, r3
80164b64:	3a000001 	bcc	80164b70 <_RME_Pgt_Des+0xc0>
80164b68:	e3e03002 	mvn	r3, #2
80164b6c:	ea0000e2 	b	80164efc <_RME_Pgt_Des+0x44c>
80164b70:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164b74:	e1a03423 	lsr	r3, r3, #8
80164b78:	e1a02283 	lsl	r2, r3, #5
80164b7c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164b80:	e593300c 	ldr	r3, [r3, #12]
80164b84:	e0823003 	add	r3, r2, r3
80164b88:	e50b3008 	str	r3, [fp, #-8]
80164b8c:	e51b3008 	ldr	r3, [fp, #-8]
80164b90:	e1a00003 	mov	r0, r3
80164b94:	ebffeed9 	bl	80160700 <__RME_A7A_Read_Acquire>
80164b98:	e50b0010 	str	r0, [fp, #-16]
80164b9c:	e51b3010 	ldr	r3, [fp, #-16]
80164ba0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80164ba4:	e3530802 	cmp	r3, #131072	@ 0x20000
80164ba8:	1a000001 	bne	80164bb4 <_RME_Pgt_Des+0x104>
80164bac:	e3e03008 	mvn	r3, #8
80164bb0:	ea0000d1 	b	80164efc <_RME_Pgt_Des+0x44c>
80164bb4:	e51b3010 	ldr	r3, [fp, #-16]
80164bb8:	e1a03c23 	lsr	r3, r3, #24
80164bbc:	e3530003 	cmp	r3, #3
80164bc0:	0a000001 	beq	80164bcc <_RME_Pgt_Des+0x11c>
80164bc4:	e3e03001 	mvn	r3, #1
80164bc8:	ea0000cb 	b	80164efc <_RME_Pgt_Des+0x44c>
80164bcc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164bd0:	e203207f 	and	r2, r3, #127	@ 0x7f
80164bd4:	e51b3008 	ldr	r3, [fp, #-8]
80164bd8:	e5933014 	ldr	r3, [r3, #20]
80164bdc:	e1520003 	cmp	r2, r3
80164be0:	3a000001 	bcc	80164bec <_RME_Pgt_Des+0x13c>
80164be4:	e3e03002 	mvn	r3, #2
80164be8:	ea0000c3 	b	80164efc <_RME_Pgt_Des+0x44c>
80164bec:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80164bf0:	e203307f 	and	r3, r3, #127	@ 0x7f
80164bf4:	e1a02283 	lsl	r2, r3, #5
80164bf8:	e51b3008 	ldr	r3, [fp, #-8]
80164bfc:	e593300c 	ldr	r3, [r3, #12]
80164c00:	e0823003 	add	r3, r2, r3
80164c04:	e50b3008 	str	r3, [fp, #-8]
80164c08:	e51b3008 	ldr	r3, [fp, #-8]
80164c0c:	e1a00003 	mov	r0, r3
80164c10:	ebffeeba 	bl	80160700 <__RME_A7A_Read_Acquire>
80164c14:	e50b0010 	str	r0, [fp, #-16]
80164c18:	e51b3010 	ldr	r3, [fp, #-16]
80164c1c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80164c20:	e3530802 	cmp	r3, #131072	@ 0x20000
80164c24:	1a000001 	bne	80164c30 <_RME_Pgt_Des+0x180>
80164c28:	e3e03008 	mvn	r3, #8
80164c2c:	ea0000b2 	b	80164efc <_RME_Pgt_Des+0x44c>
80164c30:	e51b3010 	ldr	r3, [fp, #-16]
80164c34:	e1a03c23 	lsr	r3, r3, #24
80164c38:	e3530003 	cmp	r3, #3
80164c3c:	0a000001 	beq	80164c48 <_RME_Pgt_Des+0x198>
80164c40:	e3e03001 	mvn	r3, #1
80164c44:	ea0000ac 	b	80164efc <_RME_Pgt_Des+0x44c>
                   struct RME_Cap_Pgt*,Pgt_Parent,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Pgt_Child,RME_CAP_TYPE_CPT,
80164c48:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164c4c:	e2033080 	and	r3, r3, #128	@ 0x80
80164c50:	e3530000 	cmp	r3, #0
80164c54:	1a00001c 	bne	80164ccc <_RME_Pgt_Des+0x21c>
80164c58:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164c5c:	e5932014 	ldr	r2, [r3, #20]
80164c60:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164c64:	e1520003 	cmp	r2, r3
80164c68:	8a000001 	bhi	80164c74 <_RME_Pgt_Des+0x1c4>
80164c6c:	e3e03002 	mvn	r3, #2
80164c70:	ea0000a1 	b	80164efc <_RME_Pgt_Des+0x44c>
80164c74:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164c78:	e1a02283 	lsl	r2, r3, #5
80164c7c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164c80:	e593300c 	ldr	r3, [r3, #12]
80164c84:	e0823003 	add	r3, r2, r3
80164c88:	e50b300c 	str	r3, [fp, #-12]
80164c8c:	e51b300c 	ldr	r3, [fp, #-12]
80164c90:	e1a00003 	mov	r0, r3
80164c94:	ebffee99 	bl	80160700 <__RME_A7A_Read_Acquire>
80164c98:	e50b0010 	str	r0, [fp, #-16]
80164c9c:	e51b3010 	ldr	r3, [fp, #-16]
80164ca0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80164ca4:	e3530802 	cmp	r3, #131072	@ 0x20000
80164ca8:	1a000001 	bne	80164cb4 <_RME_Pgt_Des+0x204>
80164cac:	e3e03008 	mvn	r3, #8
80164cb0:	ea000091 	b	80164efc <_RME_Pgt_Des+0x44c>
80164cb4:	e51b3010 	ldr	r3, [fp, #-16]
80164cb8:	e1a03c23 	lsr	r3, r3, #24
80164cbc:	e3530003 	cmp	r3, #3
80164cc0:	0a00003f 	beq	80164dc4 <_RME_Pgt_Des+0x314>
80164cc4:	e3e03001 	mvn	r3, #1
80164cc8:	ea00008b 	b	80164efc <_RME_Pgt_Des+0x44c>
80164ccc:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164cd0:	e1a02423 	lsr	r2, r3, #8
80164cd4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164cd8:	e5933014 	ldr	r3, [r3, #20]
80164cdc:	e1520003 	cmp	r2, r3
80164ce0:	3a000001 	bcc	80164cec <_RME_Pgt_Des+0x23c>
80164ce4:	e3e03002 	mvn	r3, #2
80164ce8:	ea000083 	b	80164efc <_RME_Pgt_Des+0x44c>
80164cec:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164cf0:	e1a03423 	lsr	r3, r3, #8
80164cf4:	e1a02283 	lsl	r2, r3, #5
80164cf8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164cfc:	e593300c 	ldr	r3, [r3, #12]
80164d00:	e0823003 	add	r3, r2, r3
80164d04:	e50b300c 	str	r3, [fp, #-12]
80164d08:	e51b300c 	ldr	r3, [fp, #-12]
80164d0c:	e1a00003 	mov	r0, r3
80164d10:	ebffee7a 	bl	80160700 <__RME_A7A_Read_Acquire>
80164d14:	e50b0010 	str	r0, [fp, #-16]
80164d18:	e51b3010 	ldr	r3, [fp, #-16]
80164d1c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80164d20:	e3530802 	cmp	r3, #131072	@ 0x20000
80164d24:	1a000001 	bne	80164d30 <_RME_Pgt_Des+0x280>
80164d28:	e3e03008 	mvn	r3, #8
80164d2c:	ea000072 	b	80164efc <_RME_Pgt_Des+0x44c>
80164d30:	e51b3010 	ldr	r3, [fp, #-16]
80164d34:	e1a03c23 	lsr	r3, r3, #24
80164d38:	e3530003 	cmp	r3, #3
80164d3c:	0a000001 	beq	80164d48 <_RME_Pgt_Des+0x298>
80164d40:	e3e03001 	mvn	r3, #1
80164d44:	ea00006c 	b	80164efc <_RME_Pgt_Des+0x44c>
80164d48:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164d4c:	e203207f 	and	r2, r3, #127	@ 0x7f
80164d50:	e51b300c 	ldr	r3, [fp, #-12]
80164d54:	e5933014 	ldr	r3, [r3, #20]
80164d58:	e1520003 	cmp	r2, r3
80164d5c:	3a000001 	bcc	80164d68 <_RME_Pgt_Des+0x2b8>
80164d60:	e3e03002 	mvn	r3, #2
80164d64:	ea000064 	b	80164efc <_RME_Pgt_Des+0x44c>
80164d68:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80164d6c:	e203307f 	and	r3, r3, #127	@ 0x7f
80164d70:	e1a02283 	lsl	r2, r3, #5
80164d74:	e51b300c 	ldr	r3, [fp, #-12]
80164d78:	e593300c 	ldr	r3, [r3, #12]
80164d7c:	e0823003 	add	r3, r2, r3
80164d80:	e50b300c 	str	r3, [fp, #-12]
80164d84:	e51b300c 	ldr	r3, [fp, #-12]
80164d88:	e1a00003 	mov	r0, r3
80164d8c:	ebffee5b 	bl	80160700 <__RME_A7A_Read_Acquire>
80164d90:	e50b0010 	str	r0, [fp, #-16]
80164d94:	e51b3010 	ldr	r3, [fp, #-16]
80164d98:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80164d9c:	e3530802 	cmp	r3, #131072	@ 0x20000
80164da0:	1a000001 	bne	80164dac <_RME_Pgt_Des+0x2fc>
80164da4:	e3e03008 	mvn	r3, #8
80164da8:	ea000053 	b	80164efc <_RME_Pgt_Des+0x44c>
80164dac:	e51b3010 	ldr	r3, [fp, #-16]
80164db0:	e1a03c23 	lsr	r3, r3, #24
80164db4:	e3530003 	cmp	r3, #3
80164db8:	0a000001 	beq	80164dc4 <_RME_Pgt_Des+0x314>
80164dbc:	e3e03001 	mvn	r3, #1
80164dc0:	ea00004d 	b	80164efc <_RME_Pgt_Des+0x44c>
                   struct RME_Cap_Pgt*,Pgt_Child,Type_Stat);
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Pgt_Parent, RME_PGT_FLAG_DES_PARENT);
80164dc4:	e51b3008 	ldr	r3, [fp, #-8]
80164dc8:	e5933008 	ldr	r3, [r3, #8]
80164dcc:	e2033020 	and	r3, r3, #32
80164dd0:	e3530000 	cmp	r3, #0
80164dd4:	1a000001 	bne	80164de0 <_RME_Pgt_Des+0x330>
80164dd8:	e3e03006 	mvn	r3, #6
80164ddc:	ea000046 	b	80164efc <_RME_Pgt_Des+0x44c>
    RME_CAP_CHECK(Pgt_Child, RME_PGT_FLAG_CHILD);
80164de0:	e51b300c 	ldr	r3, [fp, #-12]
80164de4:	e5933008 	ldr	r3, [r3, #8]
80164de8:	e2033008 	and	r3, r3, #8
80164dec:	e3530000 	cmp	r3, #0
80164df0:	1a000001 	bne	80164dfc <_RME_Pgt_Des+0x34c>
80164df4:	e3e03006 	mvn	r3, #6
80164df8:	ea00003f 	b	80164efc <_RME_Pgt_Des+0x44c>
    /* Check the operation range - This is page table specific */
    if((Pos>RME_PGT_FLAG_HIGH(Pgt_Parent->Head.Flag))||
80164dfc:	e51b3008 	ldr	r3, [fp, #-8]
80164e00:	e5933008 	ldr	r3, [r3, #8]
80164e04:	e1a03a23 	lsr	r3, r3, #20
80164e08:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80164e0c:	e1520003 	cmp	r2, r3
80164e10:	8a000006 	bhi	80164e30 <_RME_Pgt_Des+0x380>
       (Pos<RME_PGT_FLAG_LOW(Pgt_Parent->Head.Flag)))
80164e14:	e51b3008 	ldr	r3, [fp, #-8]
80164e18:	e5933008 	ldr	r3, [r3, #8]
80164e1c:	e1a03423 	lsr	r3, r3, #8
80164e20:	e7eb3053 	ubfx	r3, r3, #0, #12
    if((Pos>RME_PGT_FLAG_HIGH(Pgt_Parent->Head.Flag))||
80164e24:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80164e28:	e1520003 	cmp	r2, r3
80164e2c:	2a000001 	bcs	80164e38 <_RME_Pgt_Des+0x388>
    {
        RME_COV_MARKER();

        return RME_ERR_CPT_FLAG;
80164e30:	e3e03006 	mvn	r3, #6
80164e34:	ea000030 	b	80164efc <_RME_Pgt_Des+0x44c>
        RME_COV_MARKER();
        /* No action required */
    }

    /* See if the unmapping range is allowed */
    if((Pos>>RME_PGT_NMORD(Pgt_Parent->Order))!=0U)
80164e38:	e51b3008 	ldr	r3, [fp, #-8]
80164e3c:	e5933014 	ldr	r3, [r3, #20]
80164e40:	e6ff3073 	uxth	r3, r3
80164e44:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80164e48:	e1a03332 	lsr	r3, r2, r3
80164e4c:	e3530000 	cmp	r3, #0
80164e50:	0a000001 	beq	80164e5c <_RME_Pgt_Des+0x3ac>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_ADDR;
80164e54:	e3e03064 	mvn	r3, #100	@ 0x64
80164e58:	ea000027 	b	80164efc <_RME_Pgt_Des+0x44c>

    /* Actually do the mapping - This work is passed down to the HAL. 
     * Under multi-core, HAL should use CAS to avoid a conflict. Also,
     * the HAL needs to guarantee that the Child is actually mapped there,
     * and use that as the old value in CAS */
    if(__RME_Pgt_Pgdir_Unmap(Pgt_Parent,Pos,Pgt_Child)<0)
80164e5c:	e51b200c 	ldr	r2, [fp, #-12]
80164e60:	e51b1020 	ldr	r1, [fp, #-32]	@ 0xffffffe0
80164e64:	e51b0008 	ldr	r0, [fp, #-8]
80164e68:	eb002572 	bl	8016e438 <__RME_Pgt_Pgdir_Unmap>
80164e6c:	e1a03000 	mov	r3, r0
80164e70:	e3530000 	cmp	r3, #0
80164e74:	aa000001 	bge	80164e80 <_RME_Pgt_Des+0x3d0>
    {
        RME_COV_MARKER();

        return RME_ERR_PGT_MAP;
80164e78:	e3e03065 	mvn	r3, #101	@ 0x65
80164e7c:	ea00001e 	b	80164efc <_RME_Pgt_Des+0x44c>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Decrease refcnt for both parent/child */
    Pgt_Root=RME_CAP_CONV_ROOT(Pgt_Parent,struct RME_Cap_Pgt*);
80164e80:	e51b3008 	ldr	r3, [fp, #-8]
80164e84:	e5933000 	ldr	r3, [r3]
80164e88:	e6ff3073 	uxth	r3, r3
80164e8c:	e3530000 	cmp	r3, #0
80164e90:	0a000002 	beq	80164ea0 <_RME_Pgt_Des+0x3f0>
80164e94:	e51b3008 	ldr	r3, [fp, #-8]
80164e98:	e5933004 	ldr	r3, [r3, #4]
80164e9c:	ea000000 	b	80164ea4 <_RME_Pgt_Des+0x3f4>
80164ea0:	e51b3008 	ldr	r3, [fp, #-8]
80164ea4:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    RME_FETCH_ADD(&(Pgt_Root->Head.Root_Ref),-1);
80164ea8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164eac:	e2833004 	add	r3, r3, #4
80164eb0:	e3e01000 	mvn	r1, #0
80164eb4:	e1a00003 	mov	r0, r3
80164eb8:	ebffef54 	bl	80160c10 <_RME_Fetch_Add_Single>
    Pgt_Root=RME_CAP_CONV_ROOT(Pgt_Child,struct RME_Cap_Pgt*);
80164ebc:	e51b300c 	ldr	r3, [fp, #-12]
80164ec0:	e5933000 	ldr	r3, [r3]
80164ec4:	e6ff3073 	uxth	r3, r3
80164ec8:	e3530000 	cmp	r3, #0
80164ecc:	0a000002 	beq	80164edc <_RME_Pgt_Des+0x42c>
80164ed0:	e51b300c 	ldr	r3, [fp, #-12]
80164ed4:	e5933004 	ldr	r3, [r3, #4]
80164ed8:	ea000000 	b	80164ee0 <_RME_Pgt_Des+0x430>
80164edc:	e51b300c 	ldr	r3, [fp, #-12]
80164ee0:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    RME_FETCH_ADD(&(Pgt_Root->Head.Root_Ref),-1);
80164ee4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80164ee8:	e2833004 	add	r3, r3, #4
80164eec:	e3e01000 	mvn	r1, #0
80164ef0:	e1a00003 	mov	r0, r3
80164ef4:	ebffef45 	bl	80160c10 <_RME_Fetch_Add_Single>

    return 0;
80164ef8:	e3a03000 	mov	r3, #0
}
80164efc:	e1a00003 	mov	r0, r3
80164f00:	e24bd004 	sub	sp, fp, #4
80164f04:	e8bd8800 	pop	{fp, pc}

80164f08 <_RME_Kot_Init>:
Output      : None.
Return      : rme_ret_t - If the number of words are is not sufficient to hold 
                          all kernel memory, -1; else 0.
******************************************************************************/
rme_ret_t _RME_Kot_Init(rme_ptr_t Word)
{
80164f08:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80164f0c:	e28db000 	add	fp, sp, #0
80164f10:	e24dd014 	sub	sp, sp, #20
80164f14:	e50b0010 	str	r0, [fp, #-16]
    rme_ptr_t Count;
    
    if(Word<RME_KOT_WORD_NUM)
80164f18:	e51b3010 	ldr	r3, [fp, #-16]
80164f1c:	e3530902 	cmp	r3, #32768	@ 0x8000
80164f20:	2a000001 	bcs	80164f2c <_RME_Kot_Init+0x24>
    {
        RME_COV_MARKER();

        return -1;
80164f24:	e3e03000 	mvn	r3, #0
80164f28:	ea00000f 	b	80164f6c <_RME_Kot_Init+0x64>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Zero out the whole table */
    for(Count=0U;Count<Word;Count++)
80164f2c:	e3a03000 	mov	r3, #0
80164f30:	e50b3008 	str	r3, [fp, #-8]
80164f34:	ea000007 	b	80164f58 <_RME_Kot_Init+0x50>
    {
        RME_KOT_VA_BASE[Count]=0U;
80164f38:	e3003118 	movw	r3, #280	@ 0x118
80164f3c:	e3483017 	movt	r3, #32791	@ 0x8017
80164f40:	e51b2008 	ldr	r2, [fp, #-8]
80164f44:	e3a01000 	mov	r1, #0
80164f48:	e7831102 	str	r1, [r3, r2, lsl #2]
    for(Count=0U;Count<Word;Count++)
80164f4c:	e51b3008 	ldr	r3, [fp, #-8]
80164f50:	e2833001 	add	r3, r3, #1
80164f54:	e50b3008 	str	r3, [fp, #-8]
80164f58:	e51b2008 	ldr	r2, [fp, #-8]
80164f5c:	e51b3010 	ldr	r3, [fp, #-16]
80164f60:	e1520003 	cmp	r2, r3
80164f64:	3afffff3 	bcc	80164f38 <_RME_Kot_Init+0x30>
    }

    return 0;
80164f68:	e3a03000 	mov	r3, #0
}
80164f6c:	e1a00003 	mov	r0, r3
80164f70:	e28bd000 	add	sp, fp, #0
80164f74:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80164f78:	e12fff1e 	bx	lr

80164f7c <_RME_Kot_Mark>:
Output      : None.
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
rme_ret_t _RME_Kot_Mark(rme_ptr_t Kaddr,
                        rme_ptr_t Size)
{
80164f7c:	e92d4800 	push	{fp, lr}
80164f80:	e28db004 	add	fp, sp, #4
80164f84:	e24dd028 	sub	sp, sp, #40	@ 0x28
80164f88:	e50b0028 	str	r0, [fp, #-40]	@ 0xffffffd8
80164f8c:	e50b102c 	str	r1, [fp, #-44]	@ 0xffffffd4
    rme_ptr_t Mask_Begin;
    /* The mask at the end word */
    rme_ptr_t Mask_End;

    /* Check if the marking is well aligned */
    if((Kaddr&RME_MASK_END(RME_KOM_SLOT_ORDER-1U))!=0U)
80164f90:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80164f94:	e203300f 	and	r3, r3, #15
80164f98:	e3530000 	cmp	r3, #0
80164f9c:	0a000001 	beq	80164fa8 <_RME_Kot_Mark+0x2c>
    {
        RME_COV_MARKER();
        //RME_DBG_S("\r\nCheck if the marking is well aligned");
        return RME_ERR_KOT_BMP;
80164fa0:	e3e03000 	mvn	r3, #0
80164fa4:	ea0000c5 	b	801652c0 <_RME_Kot_Mark+0x344>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Round the marking to RME_KOM_SLOT_ORDER boundary, and rely on compiler for optimization */
    Start=(Kaddr-RME_KOM_VA_BASE)>>RME_KOM_SLOT_ORDER;
80164fa8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80164fac:	e283347f 	add	r3, r3, #2130706432	@ 0x7f000000
80164fb0:	e1a03223 	lsr	r3, r3, #4
80164fb4:	e50b3010 	str	r3, [fp, #-16]
    Mask_Begin=RME_MASK_BEGIN(Start&RME_MASK_END(RME_WORD_ORDER-1U));
80164fb8:	e51b3010 	ldr	r3, [fp, #-16]
80164fbc:	e203301f 	and	r3, r3, #31
80164fc0:	e3e02000 	mvn	r2, #0
80164fc4:	e1a03312 	lsl	r3, r2, r3
80164fc8:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Start=Start>>RME_WORD_ORDER;
80164fcc:	e51b3010 	ldr	r3, [fp, #-16]
80164fd0:	e1a032a3 	lsr	r3, r3, #5
80164fd4:	e50b3010 	str	r3, [fp, #-16]
    
    End=(Kaddr+Size-1U-RME_KOM_VA_BASE)>>RME_KOM_SLOT_ORDER;
80164fd8:	e51b2028 	ldr	r2, [fp, #-40]	@ 0xffffffd8
80164fdc:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80164fe0:	e0823003 	add	r3, r2, r3
80164fe4:	e283347f 	add	r3, r3, #2130706432	@ 0x7f000000
80164fe8:	e2433001 	sub	r3, r3, #1
80164fec:	e1a03223 	lsr	r3, r3, #4
80164ff0:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Mask_End=RME_MASK_END(End&RME_MASK_END(RME_WORD_ORDER-1U));
80164ff4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80164ff8:	e1e03003 	mvn	r3, r3
80164ffc:	e203301f 	and	r3, r3, #31
80165000:	e3e02000 	mvn	r2, #0
80165004:	e1a03332 	lsr	r3, r2, r3
80165008:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    End=End>>RME_WORD_ORDER;
8016500c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165010:	e1a032a3 	lsr	r3, r3, #5
80165014:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    
    /* See if the start and end are in the same word */
    if(Start==End)
80165018:	e51b2010 	ldr	r2, [fp, #-16]
8016501c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165020:	e1520003 	cmp	r2, r3
80165024:	1a00001f 	bne	801650a8 <_RME_Kot_Mark+0x12c>
    {
        RME_COV_MARKER();
        
        /* Someone already populated something here */
        Old_Val=RME_KOT_VA_BASE[Start];
80165028:	e3003118 	movw	r3, #280	@ 0x118
8016502c:	e3483017 	movt	r3, #32791	@ 0x8017
80165030:	e51b2010 	ldr	r2, [fp, #-16]
80165034:	e7933102 	ldr	r3, [r3, r2, lsl #2]
80165038:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
        if((Old_Val&(Mask_Begin&Mask_End))!=0U)
8016503c:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80165040:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80165044:	e0022003 	and	r2, r2, r3
80165048:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016504c:	e0033002 	and	r3, r3, r2
80165050:	e3530000 	cmp	r3, #0
80165054:	0a000001 	beq	80165060 <_RME_Kot_Mark+0xe4>
            RME_DBG_H(Old_Val);
            RME_DBG_S("\r\nMask_Begin ");
            RME_DBG_H(Mask_Begin);
            RME_DBG_S("\r\nMask_End ");
            RME_DBG_H(Mask_End);*/
            return RME_ERR_KOT_BMP;
80165058:	e3e03000 	mvn	r3, #0
8016505c:	ea000097 	b	801652c0 <_RME_Kot_Mark+0x344>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Check done, do the marking with CAS */
        if(RME_COMP_SWAP(&RME_KOT_VA_BASE[Start],
80165060:	e51b3010 	ldr	r3, [fp, #-16]
80165064:	e1a02103 	lsl	r2, r3, #2
80165068:	e3003118 	movw	r3, #280	@ 0x118
8016506c:	e3483017 	movt	r3, #32791	@ 0x8017
80165070:	e0820003 	add	r0, r2, r3
80165074:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80165078:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016507c:	e0022003 	and	r2, r2, r3
80165080:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165084:	e1823003 	orr	r3, r2, r3
80165088:	e1a02003 	mov	r2, r3
8016508c:	e51b1020 	ldr	r1, [fp, #-32]	@ 0xffffffe0
80165090:	ebffeec9 	bl	80160bbc <_RME_Comp_Swap_Single>
80165094:	e1a03000 	mov	r3, r0
80165098:	e3530000 	cmp	r3, #0
8016509c:	1a000086 	bne	801652bc <_RME_Kot_Mark+0x340>
                         Old_Val,
                         Old_Val|(Mask_Begin&Mask_End))==RME_CASFAIL)
        {
            RME_COV_MARKER();
            //RME_DBG_S("\r\nCheck done, do the marking with CAS");
            return RME_ERR_KOT_BMP;
801650a0:	e3e03000 	mvn	r3, #0
801650a4:	ea000085 	b	801652c0 <_RME_Kot_Mark+0x344>
    }
    else
    {
        RME_COV_MARKER();
        
        Undo=0U;
801650a8:	e3a03000 	mov	r3, #0
801650ac:	e50b300c 	str	r3, [fp, #-12]
        /* Check&Mark the start */
        Old_Val=RME_KOT_VA_BASE[Start];
801650b0:	e3003118 	movw	r3, #280	@ 0x118
801650b4:	e3483017 	movt	r3, #32791	@ 0x8017
801650b8:	e51b2010 	ldr	r2, [fp, #-16]
801650bc:	e7933102 	ldr	r3, [r3, r2, lsl #2]
801650c0:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
        if((Old_Val&Mask_Begin)!=0U)
801650c4:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
801650c8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801650cc:	e0033002 	and	r3, r3, r2
801650d0:	e3530000 	cmp	r3, #0
801650d4:	0a000004 	beq	801650ec <_RME_Kot_Mark+0x170>
        {
            RME_COV_MARKER();
            RME_DBG_S("\r\nCheck&Mark the start");
801650d8:	e30e0914 	movw	r0, #59668	@ 0xe914
801650dc:	e3480016 	movt	r0, #32790	@ 0x8016
801650e0:	ebffee8b 	bl	80160b14 <RME_Str_Print>
            return RME_ERR_KOT_BMP;
801650e4:	e3e03000 	mvn	r3, #0
801650e8:	ea000074 	b	801652c0 <_RME_Kot_Mark+0x344>
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        if(RME_COMP_SWAP(&RME_KOT_VA_BASE[Start],
801650ec:	e51b3010 	ldr	r3, [fp, #-16]
801650f0:	e1a02103 	lsl	r2, r3, #2
801650f4:	e3003118 	movw	r3, #280	@ 0x118
801650f8:	e3483017 	movt	r3, #32791	@ 0x8017
801650fc:	e0820003 	add	r0, r2, r3
80165100:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80165104:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165108:	e1823003 	orr	r3, r2, r3
8016510c:	e1a02003 	mov	r2, r3
80165110:	e51b1020 	ldr	r1, [fp, #-32]	@ 0xffffffe0
80165114:	ebffeea8 	bl	80160bbc <_RME_Comp_Swap_Single>
80165118:	e1a03000 	mov	r3, r0
8016511c:	e3530000 	cmp	r3, #0
80165120:	1a000001 	bne	8016512c <_RME_Kot_Mark+0x1b0>
                         Old_Val,
                         Old_Val|Mask_Begin)==RME_CASFAIL)
        {
            RME_COV_MARKER();
            //RME_DBG_S("\r\nRME_COMP_SWAP(&RME_KOT_VA_BASE[Start],");
            return RME_ERR_KOT_BMP;
80165124:	e3e03000 	mvn	r3, #0
80165128:	ea000064 	b	801652c0 <_RME_Kot_Mark+0x344>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Check&Mark the middle */
        for(Count=Start+1U;Count<End;Count++)
8016512c:	e51b3010 	ldr	r3, [fp, #-16]
80165130:	e2833001 	add	r3, r3, #1
80165134:	e50b3008 	str	r3, [fp, #-8]
80165138:	ea00001c 	b	801651b0 <_RME_Kot_Mark+0x234>
        {
            Old_Val=RME_KOT_VA_BASE[Count];
8016513c:	e3003118 	movw	r3, #280	@ 0x118
80165140:	e3483017 	movt	r3, #32791	@ 0x8017
80165144:	e51b2008 	ldr	r2, [fp, #-8]
80165148:	e7933102 	ldr	r3, [r3, r2, lsl #2]
8016514c:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
            if(Old_Val!=0U)
80165150:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165154:	e3530000 	cmp	r3, #0
80165158:	0a000002 	beq	80165168 <_RME_Kot_Mark+0x1ec>
            {
                RME_COV_MARKER();

                Undo=1U;
8016515c:	e3a03001 	mov	r3, #1
80165160:	e50b300c 	str	r3, [fp, #-12]
                break;
80165164:	ea000015 	b	801651c0 <_RME_Kot_Mark+0x244>
            }
            else
            {
                RME_COV_MARKER();
                
                if(RME_COMP_SWAP(&RME_KOT_VA_BASE[Count],
80165168:	e51b3008 	ldr	r3, [fp, #-8]
8016516c:	e1a02103 	lsl	r2, r3, #2
80165170:	e3003118 	movw	r3, #280	@ 0x118
80165174:	e3483017 	movt	r3, #32791	@ 0x8017
80165178:	e0823003 	add	r3, r2, r3
8016517c:	e3e02000 	mvn	r2, #0
80165180:	e51b1020 	ldr	r1, [fp, #-32]	@ 0xffffffe0
80165184:	e1a00003 	mov	r0, r3
80165188:	ebffee8b 	bl	80160bbc <_RME_Comp_Swap_Single>
8016518c:	e1a03000 	mov	r3, r0
80165190:	e3530000 	cmp	r3, #0
80165194:	1a000002 	bne	801651a4 <_RME_Kot_Mark+0x228>
                                 Old_Val,
                                 RME_MASK_FULL)==RME_CASFAIL)
                {
                    RME_COV_MARKER();
                    
                    Undo=1U;
80165198:	e3a03001 	mov	r3, #1
8016519c:	e50b300c 	str	r3, [fp, #-12]
                    break;
801651a0:	ea000006 	b	801651c0 <_RME_Kot_Mark+0x244>
        for(Count=Start+1U;Count<End;Count++)
801651a4:	e51b3008 	ldr	r3, [fp, #-8]
801651a8:	e2833001 	add	r3, r3, #1
801651ac:	e50b3008 	str	r3, [fp, #-8]
801651b0:	e51b2008 	ldr	r2, [fp, #-8]
801651b4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801651b8:	e1520003 	cmp	r2, r3
801651bc:	3affffde 	bcc	8016513c <_RME_Kot_Mark+0x1c0>
                }
            }
        }
        
        /* See if the middle part failed. If yes, we skip the end marking */
        if(Undo==0U)
801651c0:	e51b300c 	ldr	r3, [fp, #-12]
801651c4:	e3530000 	cmp	r3, #0
801651c8:	1a00001c 	bne	80165240 <_RME_Kot_Mark+0x2c4>
        {
            RME_COV_MARKER();

            /* Check&Mark the end */
            Old_Val=RME_KOT_VA_BASE[End];
801651cc:	e3003118 	movw	r3, #280	@ 0x118
801651d0:	e3483017 	movt	r3, #32791	@ 0x8017
801651d4:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
801651d8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
801651dc:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
            if((Old_Val&Mask_End)!=0U)
801651e0:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
801651e4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801651e8:	e0033002 	and	r3, r3, r2
801651ec:	e3530000 	cmp	r3, #0
801651f0:	0a000002 	beq	80165200 <_RME_Kot_Mark+0x284>
            {
                RME_COV_MARKER();

                Undo=1U;
801651f4:	e3a03001 	mov	r3, #1
801651f8:	e50b300c 	str	r3, [fp, #-12]
801651fc:	ea00000f 	b	80165240 <_RME_Kot_Mark+0x2c4>
            }
            else
            {
                RME_COV_MARKER();

                if(RME_COMP_SWAP(&RME_KOT_VA_BASE[End],
80165200:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165204:	e1a02103 	lsl	r2, r3, #2
80165208:	e3003118 	movw	r3, #280	@ 0x118
8016520c:	e3483017 	movt	r3, #32791	@ 0x8017
80165210:	e0820003 	add	r0, r2, r3
80165214:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80165218:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016521c:	e1823003 	orr	r3, r2, r3
80165220:	e1a02003 	mov	r2, r3
80165224:	e51b1020 	ldr	r1, [fp, #-32]	@ 0xffffffe0
80165228:	ebffee63 	bl	80160bbc <_RME_Comp_Swap_Single>
8016522c:	e1a03000 	mov	r3, r0
80165230:	e3530000 	cmp	r3, #0
80165234:	1a000001 	bne	80165240 <_RME_Kot_Mark+0x2c4>
                                 Old_Val,
                                 Old_Val|Mask_End)==RME_CASFAIL)
                {
                    RME_COV_MARKER();

                    Undo=1U;
80165238:	e3a03001 	mov	r3, #1
8016523c:	e50b300c 	str	r3, [fp, #-12]
        {
            RME_COV_MARKER();
        }
        
        /* See if we need to undo. If yes, proceed to unroll and return error */
        if(Undo!=0U)
80165240:	e51b300c 	ldr	r3, [fp, #-12]
80165244:	e3530000 	cmp	r3, #0
80165248:	0a00001b 	beq	801652bc <_RME_Kot_Mark+0x340>
        {
            RME_COV_MARKER();

            /* Undo the middle part - no CAS neeeded, write back is always atomic */
            for(Count--;Count>Start;Count--)
8016524c:	e51b3008 	ldr	r3, [fp, #-8]
80165250:	e2433001 	sub	r3, r3, #1
80165254:	e50b3008 	str	r3, [fp, #-8]
80165258:	ea000007 	b	8016527c <_RME_Kot_Mark+0x300>
            {
                RME_KOT_VA_BASE[Count]=0U;
8016525c:	e3003118 	movw	r3, #280	@ 0x118
80165260:	e3483017 	movt	r3, #32791	@ 0x8017
80165264:	e51b2008 	ldr	r2, [fp, #-8]
80165268:	e3a01000 	mov	r1, #0
8016526c:	e7831102 	str	r1, [r3, r2, lsl #2]
            for(Count--;Count>Start;Count--)
80165270:	e51b3008 	ldr	r3, [fp, #-8]
80165274:	e2433001 	sub	r3, r3, #1
80165278:	e50b3008 	str	r3, [fp, #-8]
8016527c:	e51b2008 	ldr	r2, [fp, #-8]
80165280:	e51b3010 	ldr	r3, [fp, #-16]
80165284:	e1520003 	cmp	r2, r3
80165288:	8afffff3 	bhi	8016525c <_RME_Kot_Mark+0x2e0>
            }
            /* Undo the first word - need atomic instructions */
            RME_FETCH_AND(&(RME_KOT_VA_BASE[Start]),~Mask_Begin);
8016528c:	e51b3010 	ldr	r3, [fp, #-16]
80165290:	e1a02103 	lsl	r2, r3, #2
80165294:	e3003118 	movw	r3, #280	@ 0x118
80165298:	e3483017 	movt	r3, #32791	@ 0x8017
8016529c:	e0822003 	add	r2, r2, r3
801652a0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801652a4:	e1e03003 	mvn	r3, r3
801652a8:	e1a01003 	mov	r1, r3
801652ac:	e1a00002 	mov	r0, r2
801652b0:	ebffee69 	bl	80160c5c <_RME_Fetch_And_Single>
            /* Return failure */
            return RME_ERR_KOT_BMP;
801652b4:	e3e03000 	mvn	r3, #0
801652b8:	ea000000 	b	801652c0 <_RME_Kot_Mark+0x344>
            RME_COV_MARKER();
            /* No action required */
        }
    }

    return 0;
801652bc:	e3a03000 	mov	r3, #0
}
801652c0:	e1a00003 	mov	r0, r3
801652c4:	e24bd004 	sub	sp, fp, #4
801652c8:	e8bd8800 	pop	{fp, pc}

801652cc <_RME_Kot_Erase>:
Output      : None.
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
rme_ret_t _RME_Kot_Erase(rme_ptr_t Kaddr,
                         rme_ptr_t Size)
{
801652cc:	e92d4800 	push	{fp, lr}
801652d0:	e28db004 	add	fp, sp, #4
801652d4:	e24dd020 	sub	sp, sp, #32
801652d8:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
801652dc:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
    /* The mask at the end word */
    rme_ptr_t Mask_End;
    rme_ptr_t Count;

    /* Check if the marking is well aligned */
    if((Kaddr&RME_MASK_END(RME_KOM_SLOT_ORDER-1U))!=0U)
801652e0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801652e4:	e203300f 	and	r3, r3, #15
801652e8:	e3530000 	cmp	r3, #0
801652ec:	0a000001 	beq	801652f8 <_RME_Kot_Erase+0x2c>
    {
        RME_COV_MARKER();

        return RME_ERR_KOT_BMP;
801652f0:	e3e03000 	mvn	r3, #0
801652f4:	ea00008a 	b	80165524 <_RME_Kot_Erase+0x258>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Round the marking to RME_KOM_SLOT_ORDER boundary, and rely on compiler for optimization */
    Start=(Kaddr-RME_KOM_VA_BASE)>>RME_KOM_SLOT_ORDER;
801652f8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801652fc:	e283347f 	add	r3, r3, #2130706432	@ 0x7f000000
80165300:	e1a03223 	lsr	r3, r3, #4
80165304:	e50b300c 	str	r3, [fp, #-12]
    Mask_Begin=RME_MASK_BEGIN(Start&RME_MASK_END(RME_WORD_ORDER-1U));
80165308:	e51b300c 	ldr	r3, [fp, #-12]
8016530c:	e203301f 	and	r3, r3, #31
80165310:	e3e02000 	mvn	r2, #0
80165314:	e1a03312 	lsl	r3, r2, r3
80165318:	e50b3010 	str	r3, [fp, #-16]
    Start=Start>>RME_WORD_ORDER;
8016531c:	e51b300c 	ldr	r3, [fp, #-12]
80165320:	e1a032a3 	lsr	r3, r3, #5
80165324:	e50b300c 	str	r3, [fp, #-12]
    
    End=(Kaddr+Size-1U-RME_KOM_VA_BASE)>>RME_KOM_SLOT_ORDER;
80165328:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
8016532c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80165330:	e0823003 	add	r3, r2, r3
80165334:	e283347f 	add	r3, r3, #2130706432	@ 0x7f000000
80165338:	e2433001 	sub	r3, r3, #1
8016533c:	e1a03223 	lsr	r3, r3, #4
80165340:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Mask_End=RME_MASK_END(End&RME_MASK_END(RME_WORD_ORDER-1U));
80165344:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165348:	e1e03003 	mvn	r3, r3
8016534c:	e203301f 	and	r3, r3, #31
80165350:	e3e02000 	mvn	r2, #0
80165354:	e1a03332 	lsr	r3, r2, r3
80165358:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    End=End>>RME_WORD_ORDER;
8016535c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165360:	e1a032a3 	lsr	r3, r3, #5
80165364:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    
    /* See if the start and end are in the same word */
    if(Start==End)
80165368:	e51b200c 	ldr	r2, [fp, #-12]
8016536c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165370:	e1520003 	cmp	r2, r3
80165374:	1a00001a 	bne	801653e4 <_RME_Kot_Erase+0x118>
    {
        RME_COV_MARKER();

        /* This address range is not fully populated */
        if((RME_KOT_VA_BASE[Start]&(Mask_Begin&Mask_End))!=(Mask_Begin&Mask_End))
80165378:	e3003118 	movw	r3, #280	@ 0x118
8016537c:	e3483017 	movt	r3, #32791	@ 0x8017
80165380:	e51b200c 	ldr	r2, [fp, #-12]
80165384:	e7932102 	ldr	r2, [r3, r2, lsl #2]
80165388:	e51b1010 	ldr	r1, [fp, #-16]
8016538c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165390:	e0033001 	and	r3, r3, r1
80165394:	e0022003 	and	r2, r2, r3
80165398:	e51b1010 	ldr	r1, [fp, #-16]
8016539c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801653a0:	e0033001 	and	r3, r3, r1
801653a4:	e1520003 	cmp	r2, r3
801653a8:	0a000001 	beq	801653b4 <_RME_Kot_Erase+0xe8>
        {
            RME_COV_MARKER();

            return RME_ERR_KOT_BMP;
801653ac:	e3e03000 	mvn	r3, #0
801653b0:	ea00005b 	b	80165524 <_RME_Kot_Erase+0x258>
            RME_COV_MARKER();
            /* No action required */
        }

        /* Check done, do the unmarking - need atomic operations */
        RME_FETCH_AND(&(RME_KOT_VA_BASE[Start]),~(Mask_Begin&Mask_End));
801653b4:	e51b300c 	ldr	r3, [fp, #-12]
801653b8:	e1a02103 	lsl	r2, r3, #2
801653bc:	e3003118 	movw	r3, #280	@ 0x118
801653c0:	e3483017 	movt	r3, #32791	@ 0x8017
801653c4:	e0820003 	add	r0, r2, r3
801653c8:	e51b2010 	ldr	r2, [fp, #-16]
801653cc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801653d0:	e0033002 	and	r3, r3, r2
801653d4:	e1e03003 	mvn	r3, r3
801653d8:	e1a01003 	mov	r1, r3
801653dc:	ebffee1e 	bl	80160c5c <_RME_Fetch_And_Single>
801653e0:	ea00004e 	b	80165520 <_RME_Kot_Erase+0x254>
    else
    {
        RME_COV_MARKER();

        /* Check the start */
        if((RME_KOT_VA_BASE[Start]&Mask_Begin)!=Mask_Begin)
801653e4:	e3003118 	movw	r3, #280	@ 0x118
801653e8:	e3483017 	movt	r3, #32791	@ 0x8017
801653ec:	e51b200c 	ldr	r2, [fp, #-12]
801653f0:	e7932102 	ldr	r2, [r3, r2, lsl #2]
801653f4:	e51b3010 	ldr	r3, [fp, #-16]
801653f8:	e0033002 	and	r3, r3, r2
801653fc:	e51b2010 	ldr	r2, [fp, #-16]
80165400:	e1520003 	cmp	r2, r3
80165404:	0a000001 	beq	80165410 <_RME_Kot_Erase+0x144>
        {
            RME_COV_MARKER();

            return RME_ERR_KOT_BMP;
80165408:	e3e03000 	mvn	r3, #0
8016540c:	ea000044 	b	80165524 <_RME_Kot_Erase+0x258>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Check the middle */
        for(Count=Start+1U;Count<End-1U;Count++)
80165410:	e51b300c 	ldr	r3, [fp, #-12]
80165414:	e2833001 	add	r3, r3, #1
80165418:	e50b3008 	str	r3, [fp, #-8]
8016541c:	ea00000a 	b	8016544c <_RME_Kot_Erase+0x180>
        {
            if(RME_KOT_VA_BASE[Count]!=RME_MASK_FULL)
80165420:	e3003118 	movw	r3, #280	@ 0x118
80165424:	e3483017 	movt	r3, #32791	@ 0x8017
80165428:	e51b2008 	ldr	r2, [fp, #-8]
8016542c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
80165430:	e3730001 	cmn	r3, #1
80165434:	0a000001 	beq	80165440 <_RME_Kot_Erase+0x174>
            {
                RME_COV_MARKER();

                return RME_ERR_KOT_BMP;
80165438:	e3e03000 	mvn	r3, #0
8016543c:	ea000038 	b	80165524 <_RME_Kot_Erase+0x258>
        for(Count=Start+1U;Count<End-1U;Count++)
80165440:	e51b3008 	ldr	r3, [fp, #-8]
80165444:	e2833001 	add	r3, r3, #1
80165448:	e50b3008 	str	r3, [fp, #-8]
8016544c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165450:	e2433001 	sub	r3, r3, #1
80165454:	e51b2008 	ldr	r2, [fp, #-8]
80165458:	e1520003 	cmp	r2, r3
8016545c:	3affffef 	bcc	80165420 <_RME_Kot_Erase+0x154>
                /* No action required */
            }
        }

        /* Check the end */
        if((RME_KOT_VA_BASE[End]&Mask_End)!=Mask_End)
80165460:	e3003118 	movw	r3, #280	@ 0x118
80165464:	e3483017 	movt	r3, #32791	@ 0x8017
80165468:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
8016546c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
80165470:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165474:	e0033002 	and	r3, r3, r2
80165478:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016547c:	e1520003 	cmp	r2, r3
80165480:	0a000001 	beq	8016548c <_RME_Kot_Erase+0x1c0>
        {
            RME_COV_MARKER();

            return RME_ERR_KOT_BMP;
80165484:	e3e03000 	mvn	r3, #0
80165488:	ea000025 	b	80165524 <_RME_Kot_Erase+0x258>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Erase the start - make it atomic */
        RME_FETCH_AND(&(RME_KOT_VA_BASE[Start]),~Mask_Begin);
8016548c:	e51b300c 	ldr	r3, [fp, #-12]
80165490:	e1a02103 	lsl	r2, r3, #2
80165494:	e3003118 	movw	r3, #280	@ 0x118
80165498:	e3483017 	movt	r3, #32791	@ 0x8017
8016549c:	e0822003 	add	r2, r2, r3
801654a0:	e51b3010 	ldr	r3, [fp, #-16]
801654a4:	e1e03003 	mvn	r3, r3
801654a8:	e1a01003 	mov	r1, r3
801654ac:	e1a00002 	mov	r0, r2
801654b0:	ebffede9 	bl	80160c5c <_RME_Fetch_And_Single>
        /* Erase the middle - do not need atomics here */
        for(Count=Start+1U;Count<End-1U;Count++)
801654b4:	e51b300c 	ldr	r3, [fp, #-12]
801654b8:	e2833001 	add	r3, r3, #1
801654bc:	e50b3008 	str	r3, [fp, #-8]
801654c0:	ea000007 	b	801654e4 <_RME_Kot_Erase+0x218>
        {
            RME_KOT_VA_BASE[Count]=0U;
801654c4:	e3003118 	movw	r3, #280	@ 0x118
801654c8:	e3483017 	movt	r3, #32791	@ 0x8017
801654cc:	e51b2008 	ldr	r2, [fp, #-8]
801654d0:	e3a01000 	mov	r1, #0
801654d4:	e7831102 	str	r1, [r3, r2, lsl #2]
        for(Count=Start+1U;Count<End-1U;Count++)
801654d8:	e51b3008 	ldr	r3, [fp, #-8]
801654dc:	e2833001 	add	r3, r3, #1
801654e0:	e50b3008 	str	r3, [fp, #-8]
801654e4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801654e8:	e2433001 	sub	r3, r3, #1
801654ec:	e51b2008 	ldr	r2, [fp, #-8]
801654f0:	e1520003 	cmp	r2, r3
801654f4:	3afffff2 	bcc	801654c4 <_RME_Kot_Erase+0x1f8>
        }
        /* Erase the end - make it atomic */
        RME_FETCH_AND(&(RME_KOT_VA_BASE[End]),~Mask_End);
801654f8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801654fc:	e1a02103 	lsl	r2, r3, #2
80165500:	e3003118 	movw	r3, #280	@ 0x118
80165504:	e3483017 	movt	r3, #32791	@ 0x8017
80165508:	e0822003 	add	r2, r2, r3
8016550c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80165510:	e1e03003 	mvn	r3, r3
80165514:	e1a01003 	mov	r1, r3
80165518:	e1a00002 	mov	r0, r2
8016551c:	ebffedce 	bl	80160c5c <_RME_Fetch_And_Single>
    }

    return 0;
80165520:	e3a03000 	mov	r3, #0
}
80165524:	e1a00003 	mov	r0, r3
80165528:	e24bd004 	sub	sp, fp, #4
8016552c:	e8bd8800 	pop	{fp, pc}

80165530 <_RME_Kom_Boot_Crt>:
                            rme_cid_t Cap_Cpt,
                            rme_cid_t Cap_Kom,
                            rme_ptr_t Begin,
                            rme_ptr_t End,
                            rme_ptr_t Flag)
{
80165530:	e92d4800 	push	{fp, lr}
80165534:	e28db004 	add	fp, sp, #4
80165538:	e24dd028 	sub	sp, sp, #40	@ 0x28
8016553c:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
80165540:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
80165544:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
80165548:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
    rme_ptr_t Kom_Begin;
    rme_ptr_t Kom_End;
    rme_ptr_t Type_Stat;
    
    /* Get the cap location that we care about */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
8016554c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80165550:	e2033080 	and	r3, r3, #128	@ 0x80
80165554:	e3530000 	cmp	r3, #0
80165558:	1a00001c 	bne	801655d0 <_RME_Kom_Boot_Crt+0xa0>
8016555c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165560:	e5932014 	ldr	r2, [r3, #20]
80165564:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80165568:	e1520003 	cmp	r2, r3
8016556c:	8a000001 	bhi	80165578 <_RME_Kom_Boot_Crt+0x48>
80165570:	e3e03002 	mvn	r3, #2
80165574:	ea00009f 	b	801657f8 <_RME_Kom_Boot_Crt+0x2c8>
80165578:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016557c:	e1a02283 	lsl	r2, r3, #5
80165580:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165584:	e593300c 	ldr	r3, [r3, #12]
80165588:	e0823003 	add	r3, r2, r3
8016558c:	e50b3008 	str	r3, [fp, #-8]
80165590:	e51b3008 	ldr	r3, [fp, #-8]
80165594:	e1a00003 	mov	r0, r3
80165598:	ebffec58 	bl	80160700 <__RME_A7A_Read_Acquire>
8016559c:	e50b000c 	str	r0, [fp, #-12]
801655a0:	e51b300c 	ldr	r3, [fp, #-12]
801655a4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801655a8:	e3530802 	cmp	r3, #131072	@ 0x20000
801655ac:	1a000001 	bne	801655b8 <_RME_Kom_Boot_Crt+0x88>
801655b0:	e3e03008 	mvn	r3, #8
801655b4:	ea00008f 	b	801657f8 <_RME_Kom_Boot_Crt+0x2c8>
801655b8:	e51b300c 	ldr	r3, [fp, #-12]
801655bc:	e1a03c23 	lsr	r3, r3, #24
801655c0:	e3530003 	cmp	r3, #3
801655c4:	0a00003f 	beq	801656c8 <_RME_Kom_Boot_Crt+0x198>
801655c8:	e3e03001 	mvn	r3, #1
801655cc:	ea000089 	b	801657f8 <_RME_Kom_Boot_Crt+0x2c8>
801655d0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801655d4:	e1a02423 	lsr	r2, r3, #8
801655d8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801655dc:	e5933014 	ldr	r3, [r3, #20]
801655e0:	e1520003 	cmp	r2, r3
801655e4:	3a000001 	bcc	801655f0 <_RME_Kom_Boot_Crt+0xc0>
801655e8:	e3e03002 	mvn	r3, #2
801655ec:	ea000081 	b	801657f8 <_RME_Kom_Boot_Crt+0x2c8>
801655f0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801655f4:	e1a03423 	lsr	r3, r3, #8
801655f8:	e1a02283 	lsl	r2, r3, #5
801655fc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165600:	e593300c 	ldr	r3, [r3, #12]
80165604:	e0823003 	add	r3, r2, r3
80165608:	e50b3008 	str	r3, [fp, #-8]
8016560c:	e51b3008 	ldr	r3, [fp, #-8]
80165610:	e1a00003 	mov	r0, r3
80165614:	ebffec39 	bl	80160700 <__RME_A7A_Read_Acquire>
80165618:	e50b000c 	str	r0, [fp, #-12]
8016561c:	e51b300c 	ldr	r3, [fp, #-12]
80165620:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80165624:	e3530802 	cmp	r3, #131072	@ 0x20000
80165628:	1a000001 	bne	80165634 <_RME_Kom_Boot_Crt+0x104>
8016562c:	e3e03008 	mvn	r3, #8
80165630:	ea000070 	b	801657f8 <_RME_Kom_Boot_Crt+0x2c8>
80165634:	e51b300c 	ldr	r3, [fp, #-12]
80165638:	e1a03c23 	lsr	r3, r3, #24
8016563c:	e3530003 	cmp	r3, #3
80165640:	0a000001 	beq	8016564c <_RME_Kom_Boot_Crt+0x11c>
80165644:	e3e03001 	mvn	r3, #1
80165648:	ea00006a 	b	801657f8 <_RME_Kom_Boot_Crt+0x2c8>
8016564c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80165650:	e203207f 	and	r2, r3, #127	@ 0x7f
80165654:	e51b3008 	ldr	r3, [fp, #-8]
80165658:	e5933014 	ldr	r3, [r3, #20]
8016565c:	e1520003 	cmp	r2, r3
80165660:	3a000001 	bcc	8016566c <_RME_Kom_Boot_Crt+0x13c>
80165664:	e3e03002 	mvn	r3, #2
80165668:	ea000062 	b	801657f8 <_RME_Kom_Boot_Crt+0x2c8>
8016566c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80165670:	e203307f 	and	r3, r3, #127	@ 0x7f
80165674:	e1a02283 	lsl	r2, r3, #5
80165678:	e51b3008 	ldr	r3, [fp, #-8]
8016567c:	e593300c 	ldr	r3, [r3, #12]
80165680:	e0823003 	add	r3, r2, r3
80165684:	e50b3008 	str	r3, [fp, #-8]
80165688:	e51b3008 	ldr	r3, [fp, #-8]
8016568c:	e1a00003 	mov	r0, r3
80165690:	ebffec1a 	bl	80160700 <__RME_A7A_Read_Acquire>
80165694:	e50b000c 	str	r0, [fp, #-12]
80165698:	e51b300c 	ldr	r3, [fp, #-12]
8016569c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801656a0:	e3530802 	cmp	r3, #131072	@ 0x20000
801656a4:	1a000001 	bne	801656b0 <_RME_Kom_Boot_Crt+0x180>
801656a8:	e3e03008 	mvn	r3, #8
801656ac:	ea000051 	b	801657f8 <_RME_Kom_Boot_Crt+0x2c8>
801656b0:	e51b300c 	ldr	r3, [fp, #-12]
801656b4:	e1a03c23 	lsr	r3, r3, #24
801656b8:	e3530003 	cmp	r3, #3
801656bc:	0a000001 	beq	801656c8 <_RME_Kom_Boot_Crt+0x198>
801656c0:	e3e03001 	mvn	r3, #1
801656c4:	ea00004b 	b	801657f8 <_RME_Kom_Boot_Crt+0x2c8>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_CRT);
801656c8:	e51b3008 	ldr	r3, [fp, #-8]
801656cc:	e5933008 	ldr	r3, [r3, #8]
801656d0:	e2033001 	and	r3, r3, #1
801656d4:	e3530000 	cmp	r3, #0
801656d8:	1a000001 	bne	801656e4 <_RME_Kom_Boot_Crt+0x1b4>
801656dc:	e3e03006 	mvn	r3, #6
801656e0:	ea000044 	b	801657f8 <_RME_Kom_Boot_Crt+0x2c8>

    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Kom,struct RME_Cap_Kom*,Kom_Crt);
801656e4:	e51b3008 	ldr	r3, [fp, #-8]
801656e8:	e5932014 	ldr	r2, [r3, #20]
801656ec:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801656f0:	e1520003 	cmp	r2, r3
801656f4:	8a000001 	bhi	80165700 <_RME_Kom_Boot_Crt+0x1d0>
801656f8:	e3e03002 	mvn	r3, #2
801656fc:	ea00003d 	b	801657f8 <_RME_Kom_Boot_Crt+0x2c8>
80165700:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165704:	e1a02283 	lsl	r2, r3, #5
80165708:	e51b3008 	ldr	r3, [fp, #-8]
8016570c:	e593300c 	ldr	r3, [r3, #12]
80165710:	e0823003 	add	r3, r2, r3
80165714:	e50b3010 	str	r3, [fp, #-16]
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Kom_Crt);
80165718:	e51b3010 	ldr	r3, [fp, #-16]
8016571c:	e3a02801 	mov	r2, #65536	@ 0x10000
80165720:	e3a01000 	mov	r1, #0
80165724:	e1a00003 	mov	r0, r3
80165728:	ebffed23 	bl	80160bbc <_RME_Comp_Swap_Single>
8016572c:	e1a03000 	mov	r3, r0
80165730:	e3530000 	cmp	r3, #0
80165734:	1a000001 	bne	80165740 <_RME_Kom_Boot_Crt+0x210>
80165738:	e3e03004 	mvn	r3, #4
8016573c:	ea00002d 	b	801657f8 <_RME_Kom_Boot_Crt+0x2c8>
80165740:	e3003000 	movw	r3, #0
80165744:	e3483017 	movt	r3, #32791	@ 0x8017
80165748:	e5932000 	ldr	r2, [r3]
8016574c:	e51b3010 	ldr	r3, [fp, #-16]
80165750:	e5832010 	str	r2, [r3, #16]
    /* Align addresses */
#if(RME_KOM_SLOT_ORDER>6U)
    Kom_End=RME_ROUND_DOWN(End+1U,RME_KOM_SLOT_ORDER);
    Kom_Begin=RME_ROUND_UP(Start,RME_KOM_SLOT_ORDER);
#else
    Kom_End=RME_ROUND_DOWN(End+1U,6U);
80165754:	e59b3004 	ldr	r3, [fp, #4]
80165758:	e2833001 	add	r3, r3, #1
8016575c:	e3c3303f 	bic	r3, r3, #63	@ 0x3f
80165760:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Kom_Begin=RME_ROUND_UP(Begin,6U);
80165764:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80165768:	e283303f 	add	r3, r3, #63	@ 0x3f
8016576c:	e3c3303f 	bic	r3, r3, #63	@ 0x3f
80165770:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
#endif

    /* Must at least allow creation of something */
    RME_ASSERT(Flag!=0U);
80165774:	e59b3008 	ldr	r3, [fp, #8]
80165778:	e3530000 	cmp	r3, #0
8016577c:	1a000008 	bne	801657a4 <_RME_Kom_Boot_Crt+0x274>
80165780:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
80165784:	e3483016 	movt	r3, #32790	@ 0x8016
80165788:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
8016578c:	e3482016 	movt	r2, #32790	@ 0x8016
80165790:	e30110d9 	movw	r1, #4313	@ 0x10d9
80165794:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
80165798:	e3480016 	movt	r0, #32790	@ 0x8016
8016579c:	ebffecfb 	bl	80160b90 <RME_Log>
801657a0:	eafffffe 	b	801657a0 <_RME_Kom_Boot_Crt+0x270>

    /* Header init */
    Kom_Crt->Head.Root_Ref=1U;
801657a4:	e51b3010 	ldr	r3, [fp, #-16]
801657a8:	e3a02001 	mov	r2, #1
801657ac:	e5832004 	str	r2, [r3, #4]
    Kom_Crt->Head.Object=0U;
801657b0:	e51b3010 	ldr	r3, [fp, #-16]
801657b4:	e3a02000 	mov	r2, #0
801657b8:	e583200c 	str	r2, [r3, #12]
    Kom_Crt->Head.Flag=Flag;
801657bc:	e51b3010 	ldr	r3, [fp, #-16]
801657c0:	e59b2008 	ldr	r2, [fp, #8]
801657c4:	e5832008 	str	r2, [r3, #8]
    
    /* Info init */
    Kom_Crt->Begin=Kom_Begin;
801657c8:	e51b3010 	ldr	r3, [fp, #-16]
801657cc:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
801657d0:	e5832014 	str	r2, [r3, #20]
    Kom_Crt->End=Kom_End-1U;
801657d4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801657d8:	e2432001 	sub	r2, r3, #1
801657dc:	e51b3010 	ldr	r3, [fp, #-16]
801657e0:	e5832018 	str	r2, [r3, #24]

    /* Establish cap */
    RME_WRITE_RELEASE(&(Kom_Crt->Head.Type_Stat),
801657e4:	e51b3010 	ldr	r3, [fp, #-16]
801657e8:	e3a01402 	mov	r1, #33554432	@ 0x2000000
801657ec:	e1a00003 	mov	r0, r3
801657f0:	ebffebc5 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_KOM,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
801657f4:	e3a03000 	mov	r3, #0
}
801657f8:	e1a00003 	mov	r0, r3
801657fc:	e24bd004 	sub	sp, fp, #4
80165800:	e8bd8800 	pop	{fp, pc}

80165804 <_RME_CPU_Local_Init>:
Output      : None.
Return      : None.
******************************************************************************/
void _RME_CPU_Local_Init(struct RME_CPU_Local* Local,
                         rme_ptr_t CPUID)
{
80165804:	e92d4800 	push	{fp, lr}
80165808:	e28db004 	add	fp, sp, #4
8016580c:	e24dd010 	sub	sp, sp, #16
80165810:	e50b0010 	str	r0, [fp, #-16]
80165814:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
    rme_ptr_t Prio_Cnt;
    
    Local->CPUID=CPUID;
80165818:	e51b3010 	ldr	r3, [fp, #-16]
8016581c:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80165820:	e5832000 	str	r2, [r3]
    Local->Thd_Cur=RME_NULL;
80165824:	e51b3010 	ldr	r3, [fp, #-16]
80165828:	e3a02000 	mov	r2, #0
8016582c:	e5832004 	str	r2, [r3, #4]
    Local->Sig_Vct=RME_NULL;
80165830:	e51b3010 	ldr	r3, [fp, #-16]
80165834:	e3a02000 	mov	r2, #0
80165838:	e583200c 	str	r2, [r3, #12]
    Local->Sig_Tim=RME_NULL;
8016583c:	e51b3010 	ldr	r3, [fp, #-16]
80165840:	e3a02000 	mov	r2, #0
80165844:	e5832008 	str	r2, [r3, #8]
    
    /* Initialize the run-queue and bitmap */
    for(Prio_Cnt=0U;Prio_Cnt<RME_PREEMPT_PRIO_NUM;Prio_Cnt++)
80165848:	e3a03000 	mov	r3, #0
8016584c:	e50b3008 	str	r3, [fp, #-8]
80165850:	ea000010 	b	80165898 <_RME_CPU_Local_Init+0x94>
    {
        Local->Run.Bitmap[Prio_Cnt>>RME_WORD_ORDER]=0U;
80165854:	e51b3008 	ldr	r3, [fp, #-8]
80165858:	e1a022a3 	lsr	r2, r3, #5
8016585c:	e51b3010 	ldr	r3, [fp, #-16]
80165860:	e2822004 	add	r2, r2, #4
80165864:	e3a01000 	mov	r1, #0
80165868:	e7831102 	str	r1, [r3, r2, lsl #2]
        _RME_List_Crt(&(Local->Run.List[Prio_Cnt]));
8016586c:	e51b3008 	ldr	r3, [fp, #-8]
80165870:	e2833002 	add	r3, r3, #2
80165874:	e1a03183 	lsl	r3, r3, #3
80165878:	e51b2010 	ldr	r2, [fp, #-16]
8016587c:	e0823003 	add	r3, r2, r3
80165880:	e2833004 	add	r3, r3, #4
80165884:	e1a00003 	mov	r0, r3
80165888:	ebffed05 	bl	80160ca4 <_RME_List_Crt>
    for(Prio_Cnt=0U;Prio_Cnt<RME_PREEMPT_PRIO_NUM;Prio_Cnt++)
8016588c:	e51b3008 	ldr	r3, [fp, #-8]
80165890:	e2833001 	add	r3, r3, #1
80165894:	e50b3008 	str	r3, [fp, #-8]
80165898:	e51b3008 	ldr	r3, [fp, #-8]
8016589c:	e353001f 	cmp	r3, #31
801658a0:	9affffeb 	bls	80165854 <_RME_CPU_Local_Init+0x50>
    }
}
801658a4:	e320f000 	nop	{0}
801658a8:	e320f000 	nop	{0}
801658ac:	e24bd004 	sub	sp, fp, #4
801658b0:	e8bd8800 	pop	{fp, pc}

801658b4 <_RME_Run_Ins>:
              rme_ptr_t CPUID - The cpu to consult.
Output      : None.
Return      : None.
******************************************************************************/
static void _RME_Run_Ins(struct RME_Thd_Struct* Thd)
{
801658b4:	e92d4800 	push	{fp, lr}
801658b8:	e28db004 	add	fp, sp, #4
801658bc:	e24dd010 	sub	sp, sp, #16
801658c0:	e50b0010 	str	r0, [fp, #-16]
    rme_ptr_t Prio;
    struct RME_CPU_Local* Local;
    
    Prio=Thd->Sched.Prio;
801658c4:	e51b3010 	ldr	r3, [fp, #-16]
801658c8:	e5933020 	ldr	r3, [r3, #32]
801658cc:	e50b3008 	str	r3, [fp, #-8]
    Local=Thd->Sched.Local;
801658d0:	e51b3010 	ldr	r3, [fp, #-16]
801658d4:	e5933014 	ldr	r3, [r3, #20]
801658d8:	e50b300c 	str	r3, [fp, #-12]
    
    /* It can't be free or there must be an error */
    RME_ASSERT(Local!=RME_THD_FREE);
801658dc:	e51b300c 	ldr	r3, [fp, #-12]
801658e0:	e3730001 	cmn	r3, #1
801658e4:	1a000008 	bne	8016590c <_RME_Run_Ins+0x58>
801658e8:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
801658ec:	e3483016 	movt	r3, #32790	@ 0x8016
801658f0:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
801658f4:	e3482016 	movt	r2, #32790	@ 0x8016
801658f8:	e3011160 	movw	r1, #4448	@ 0x1160
801658fc:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
80165900:	e3480016 	movt	r0, #32790	@ 0x8016
80165904:	ebffeca1 	bl	80160b90 <RME_Log>
80165908:	eafffffe 	b	80165908 <_RME_Run_Ins+0x54>
    
    /* Insert this thread into the runqueue */
    _RME_List_Ins(&(Thd->Sched.Run),
8016590c:	e51b0010 	ldr	r0, [fp, #-16]
80165910:	e51b200c 	ldr	r2, [fp, #-12]
80165914:	e51b3008 	ldr	r3, [fp, #-8]
80165918:	e2833002 	add	r3, r3, #2
8016591c:	e1a03183 	lsl	r3, r3, #3
80165920:	e0823003 	add	r3, r2, r3
80165924:	e5931008 	ldr	r1, [r3, #8]
80165928:	e51b3008 	ldr	r3, [fp, #-8]
8016592c:	e2833002 	add	r3, r3, #2
80165930:	e1a03183 	lsl	r3, r3, #3
80165934:	e51b200c 	ldr	r2, [fp, #-12]
80165938:	e0823003 	add	r3, r2, r3
8016593c:	e2833004 	add	r3, r3, #4
80165940:	e1a02003 	mov	r2, r3
80165944:	ebffecf3 	bl	80160d18 <_RME_List_Ins>
                  Local->Run.List[Prio].Prev,
                  &(Local->Run.List[Prio]));
    
    /* Set the bit in the bitmap */
    RME_BITMAP_SET(Local->Run.Bitmap,Prio);
80165948:	e51b3008 	ldr	r3, [fp, #-8]
8016594c:	e1a022a3 	lsr	r2, r3, #5
80165950:	e51b300c 	ldr	r3, [fp, #-12]
80165954:	e2822004 	add	r2, r2, #4
80165958:	e7931102 	ldr	r1, [r3, r2, lsl #2]
8016595c:	e51b3008 	ldr	r3, [fp, #-8]
80165960:	e203301f 	and	r3, r3, #31
80165964:	e3a02001 	mov	r2, #1
80165968:	e1a03312 	lsl	r3, r2, r3
8016596c:	e51b2008 	ldr	r2, [fp, #-8]
80165970:	e1a022a2 	lsr	r2, r2, #5
80165974:	e1811003 	orr	r1, r1, r3
80165978:	e51b300c 	ldr	r3, [fp, #-12]
8016597c:	e2822004 	add	r2, r2, #4
80165980:	e7831102 	str	r1, [r3, r2, lsl #2]
}
80165984:	e320f000 	nop	{0}
80165988:	e24bd004 	sub	sp, fp, #4
8016598c:	e8bd8800 	pop	{fp, pc}

80165990 <_RME_Run_Del>:
Input       : struct RME_Thd_Struct* Thd - The thread to delete.
Output      : None.
Return      : None.
******************************************************************************/
static void _RME_Run_Del(struct RME_Thd_Struct* Thd)
{
80165990:	e92d4800 	push	{fp, lr}
80165994:	e28db004 	add	fp, sp, #4
80165998:	e24dd010 	sub	sp, sp, #16
8016599c:	e50b0010 	str	r0, [fp, #-16]
    rme_ptr_t Prio;
    struct RME_CPU_Local* Local;
    
    Prio=Thd->Sched.Prio;
801659a0:	e51b3010 	ldr	r3, [fp, #-16]
801659a4:	e5933020 	ldr	r3, [r3, #32]
801659a8:	e50b3008 	str	r3, [fp, #-8]
    Local=Thd->Sched.Local;
801659ac:	e51b3010 	ldr	r3, [fp, #-16]
801659b0:	e5933014 	ldr	r3, [r3, #20]
801659b4:	e50b300c 	str	r3, [fp, #-12]
    /* It can't be free or there must be an error */
    RME_ASSERT(Local!=RME_THD_FREE);
801659b8:	e51b300c 	ldr	r3, [fp, #-12]
801659bc:	e3730001 	cmn	r3, #1
801659c0:	1a000008 	bne	801659e8 <_RME_Run_Del+0x58>
801659c4:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
801659c8:	e3483016 	movt	r3, #32790	@ 0x8016
801659cc:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
801659d0:	e3482016 	movt	r2, #32790	@ 0x8016
801659d4:	e301117a 	movw	r1, #4474	@ 0x117a
801659d8:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
801659dc:	e3480016 	movt	r0, #32790	@ 0x8016
801659e0:	ebffec6a 	bl	80160b90 <RME_Log>
801659e4:	eafffffe 	b	801659e4 <_RME_Run_Del+0x54>
    
    /* Delete this thread from the runqueue */
    _RME_List_Del(Thd->Sched.Run.Prev,Thd->Sched.Run.Next);
801659e8:	e51b3010 	ldr	r3, [fp, #-16]
801659ec:	e5932004 	ldr	r2, [r3, #4]
801659f0:	e51b3010 	ldr	r3, [fp, #-16]
801659f4:	e5933000 	ldr	r3, [r3]
801659f8:	e1a01003 	mov	r1, r3
801659fc:	e1a00002 	mov	r0, r2
80165a00:	ebffecb5 	bl	80160cdc <_RME_List_Del>
    
    /* See if there are any thread on this priority level */
    if(Local->Run.List[Prio].Next==&(Local->Run.List[Prio]))
80165a04:	e51b200c 	ldr	r2, [fp, #-12]
80165a08:	e51b3008 	ldr	r3, [fp, #-8]
80165a0c:	e2833002 	add	r3, r3, #2
80165a10:	e1a03183 	lsl	r3, r3, #3
80165a14:	e0823003 	add	r3, r2, r3
80165a18:	e5932004 	ldr	r2, [r3, #4]
80165a1c:	e51b3008 	ldr	r3, [fp, #-8]
80165a20:	e2833002 	add	r3, r3, #2
80165a24:	e1a03183 	lsl	r3, r3, #3
80165a28:	e51b100c 	ldr	r1, [fp, #-12]
80165a2c:	e0813003 	add	r3, r1, r3
80165a30:	e2833004 	add	r3, r3, #4
80165a34:	e1520003 	cmp	r2, r3
80165a38:	1a00000f 	bne	80165a7c <_RME_Run_Del+0xec>
    {
        RME_COV_MARKER();

        /* Nothing running, clear the bit in the bitmap */
        RME_BITMAP_CLR(Local->Run.Bitmap,Prio);
80165a3c:	e51b3008 	ldr	r3, [fp, #-8]
80165a40:	e1a022a3 	lsr	r2, r3, #5
80165a44:	e51b300c 	ldr	r3, [fp, #-12]
80165a48:	e2822004 	add	r2, r2, #4
80165a4c:	e7931102 	ldr	r1, [r3, r2, lsl #2]
80165a50:	e51b3008 	ldr	r3, [fp, #-8]
80165a54:	e203301f 	and	r3, r3, #31
80165a58:	e3a02001 	mov	r2, #1
80165a5c:	e1a03312 	lsl	r3, r2, r3
80165a60:	e1e03003 	mvn	r3, r3
80165a64:	e51b2008 	ldr	r2, [fp, #-8]
80165a68:	e1a022a2 	lsr	r2, r2, #5
80165a6c:	e0011003 	and	r1, r1, r3
80165a70:	e51b300c 	ldr	r3, [fp, #-12]
80165a74:	e2822004 	add	r2, r2, #4
80165a78:	e7831102 	str	r1, [r3, r2, lsl #2]
    else
    {
        RME_COV_MARKER();
        /* No action required */
    }
}
80165a7c:	e320f000 	nop	{0}
80165a80:	e24bd004 	sub	sp, fp, #4
80165a84:	e8bd8800 	pop	{fp, pc}

80165a88 <_RME_Run_High>:
Input       : struct RME_CPU_Local* Local - The CPU-local data structure.
Output      : None.
Return      : struct RME_Thd_Struct* - The thread returned.
******************************************************************************/
static struct RME_Thd_Struct* _RME_Run_High(struct RME_CPU_Local* Local)
{
80165a88:	e92d4800 	push	{fp, lr}
80165a8c:	e28db004 	add	fp, sp, #4
80165a90:	e24dd010 	sub	sp, sp, #16
80165a94:	e50b0010 	str	r0, [fp, #-16]
    rme_cnt_t Count;
    rme_ptr_t Prio;
    
    /* We start looking for preemption priority levels from the highest */
    for(Count=(rme_cnt_t)(RME_PRIO_WORD_NUM-1U);Count>=0;Count--)
80165a98:	e3a03000 	mov	r3, #0
80165a9c:	e50b3008 	str	r3, [fp, #-8]
80165aa0:	ea000008 	b	80165ac8 <_RME_Run_High+0x40>
    {
        if(Local->Run.Bitmap[Count]!=0U)
80165aa4:	e51b3010 	ldr	r3, [fp, #-16]
80165aa8:	e51b2008 	ldr	r2, [fp, #-8]
80165aac:	e2822004 	add	r2, r2, #4
80165ab0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
80165ab4:	e3530000 	cmp	r3, #0
80165ab8:	1a000006 	bne	80165ad8 <_RME_Run_High+0x50>
    for(Count=(rme_cnt_t)(RME_PRIO_WORD_NUM-1U);Count>=0;Count--)
80165abc:	e51b3008 	ldr	r3, [fp, #-8]
80165ac0:	e2433001 	sub	r3, r3, #1
80165ac4:	e50b3008 	str	r3, [fp, #-8]
80165ac8:	e51b3008 	ldr	r3, [fp, #-8]
80165acc:	e3530000 	cmp	r3, #0
80165ad0:	aafffff3 	bge	80165aa4 <_RME_Run_High+0x1c>
80165ad4:	ea000000 	b	80165adc <_RME_Run_High+0x54>
        {
            RME_COV_MARKER();
            
            break;
80165ad8:	e320f000 	nop	{0}
            /* No action required */
        }
    }
    
    /* It must be possible to find one thread per core */
    RME_ASSERT(Count>=0);
80165adc:	e51b3008 	ldr	r3, [fp, #-8]
80165ae0:	e3530000 	cmp	r3, #0
80165ae4:	aa000008 	bge	80165b0c <_RME_Run_High+0x84>
80165ae8:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
80165aec:	e3483016 	movt	r3, #32790	@ 0x8016
80165af0:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
80165af4:	e3482016 	movt	r2, #32790	@ 0x8016
80165af8:	e30111ab 	movw	r1, #4523	@ 0x11ab
80165afc:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
80165b00:	e3480016 	movt	r0, #32790	@ 0x8016
80165b04:	ebffec21 	bl	80160b90 <RME_Log>
80165b08:	eafffffe 	b	80165b08 <_RME_Run_High+0x80>

    /* Get the first "1"'s position in the word */
    Prio=RME_MSB_GET(Local->Run.Bitmap[Count]);
80165b0c:	e51b3010 	ldr	r3, [fp, #-16]
80165b10:	e51b2008 	ldr	r2, [fp, #-8]
80165b14:	e2822004 	add	r2, r2, #4
80165b18:	e7933102 	ldr	r3, [r3, r2, lsl #2]
80165b1c:	e1a00003 	mov	r0, r3
80165b20:	ebffeb04 	bl	80160738 <__RME_A7A_MSB_Get>
80165b24:	e50b000c 	str	r0, [fp, #-12]
    Prio+=((rme_ptr_t)Count)<<RME_WORD_ORDER;
80165b28:	e51b3008 	ldr	r3, [fp, #-8]
80165b2c:	e1a03283 	lsl	r3, r3, #5
80165b30:	e51b200c 	ldr	r2, [fp, #-12]
80165b34:	e0823003 	add	r3, r2, r3
80165b38:	e50b300c 	str	r3, [fp, #-12]

    /* Now there is something at this priority level. Get it and start to run */
    return (struct RME_Thd_Struct*)(Local->Run.List[Prio].Next);
80165b3c:	e51b2010 	ldr	r2, [fp, #-16]
80165b40:	e51b300c 	ldr	r3, [fp, #-12]
80165b44:	e2833002 	add	r3, r3, #2
80165b48:	e1a03183 	lsl	r3, r3, #3
80165b4c:	e0823003 	add	r3, r2, r3
80165b50:	e5933004 	ldr	r3, [r3, #4]
}
80165b54:	e1a00003 	mov	r0, r3
80165b58:	e24bd004 	sub	sp, fp, #4
80165b5c:	e8bd8800 	pop	{fp, pc}

80165b60 <_RME_Run_Notif>:
Input       : struct RME_Thd_Struct* Thd - The thread to send notification for.
Output      : None.
Return      : None.
******************************************************************************/
static void _RME_Run_Notif(struct RME_Thd_Struct* Thd)
{
80165b60:	e92d4800 	push	{fp, lr}
80165b64:	e28db004 	add	fp, sp, #4
80165b68:	e24dd010 	sub	sp, sp, #16
80165b6c:	e50b0010 	str	r0, [fp, #-16]
    struct RME_Thd_Struct* Sched_Thd;
    
    Sched_Thd=Thd->Sched.Sched_Thd;
80165b70:	e51b3010 	ldr	r3, [fp, #-16]
80165b74:	e5933034 	ldr	r3, [r3, #52]	@ 0x34
80165b78:	e50b3008 	str	r3, [fp, #-8]
    
    /* See if there is already a notification. If yes, do not do the send again */
    if(Thd->Sched.Notif.Next==&(Thd->Sched.Notif))
80165b7c:	e51b3010 	ldr	r3, [fp, #-16]
80165b80:	e5932008 	ldr	r2, [r3, #8]
80165b84:	e51b3010 	ldr	r3, [fp, #-16]
80165b88:	e2833008 	add	r3, r3, #8
80165b8c:	e1520003 	cmp	r2, r3
80165b90:	1a000007 	bne	80165bb4 <_RME_Run_Notif+0x54>
    {
        RME_COV_MARKER();

        _RME_List_Ins(&(Thd->Sched.Notif), 
80165b94:	e51b3010 	ldr	r3, [fp, #-16]
80165b98:	e2830008 	add	r0, r3, #8
80165b9c:	e51b3008 	ldr	r3, [fp, #-8]
80165ba0:	e5931040 	ldr	r1, [r3, #64]	@ 0x40
80165ba4:	e51b3008 	ldr	r3, [fp, #-8]
80165ba8:	e283303c 	add	r3, r3, #60	@ 0x3c
80165bac:	e1a02003 	mov	r2, r3
80165bb0:	ebffec58 	bl	80160d18 <_RME_List_Ins>
        RME_COV_MARKER();
        /* No action required */
    }

    /* If this guy have an endpoint, send to it */
    if(Thd->Sched.Sched_Sig!=0U)
80165bb4:	e51b3010 	ldr	r3, [fp, #-16]
80165bb8:	e5933038 	ldr	r3, [r3, #56]	@ 0x38
80165bbc:	e3530000 	cmp	r3, #0
80165bc0:	0a000003 	beq	80165bd4 <_RME_Run_Notif+0x74>
    {
        RME_COV_MARKER();
        _RME_Kern_Snd(Thd->Sched.Sched_Sig);
80165bc4:	e51b3010 	ldr	r3, [fp, #-16]
80165bc8:	e5933038 	ldr	r3, [r3, #56]	@ 0x38
80165bcc:	e1a00003 	mov	r0, r3
80165bd0:	eb0014f5 	bl	8016afac <_RME_Kern_Snd>
    else
    {
        RME_COV_MARKER();
        /* No action required */
    }
}
80165bd4:	e320f000 	nop	{0}
80165bd8:	e24bd004 	sub	sp, fp, #4
80165bdc:	e8bd8800 	pop	{fp, pc}

80165be0 <_RME_Thd_Pgt>:
#if(RME_PGT_RAW_ENABLE==0U)
struct RME_Cap_Pgt* _RME_Thd_Pgt(struct RME_Thd_Struct* Thd)
#else
rme_ptr_t _RME_Thd_Pgt(struct RME_Thd_Struct* Thd)
#endif
{
80165be0:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
80165be4:	e28db000 	add	fp, sp, #0
80165be8:	e24dd014 	sub	sp, sp, #20
80165bec:	e50b0010 	str	r0, [fp, #-16]
    struct RME_Inv_Struct* Inv_Top;
    
    Inv_Top=RME_INVSTK_TOP(Thd);
80165bf0:	e51b3010 	ldr	r3, [fp, #-16]
80165bf4:	e593204c 	ldr	r2, [r3, #76]	@ 0x4c
80165bf8:	e51b3010 	ldr	r3, [fp, #-16]
80165bfc:	e283304c 	add	r3, r3, #76	@ 0x4c
80165c00:	e1520003 	cmp	r2, r3
80165c04:	0a000002 	beq	80165c14 <_RME_Thd_Pgt+0x34>
80165c08:	e51b3010 	ldr	r3, [fp, #-16]
80165c0c:	e593304c 	ldr	r3, [r3, #76]	@ 0x4c
80165c10:	ea000000 	b	80165c18 <_RME_Thd_Pgt+0x38>
80165c14:	e3a03000 	mov	r3, #0
80165c18:	e50b3008 	str	r3, [fp, #-8]
    
    if(Inv_Top==RME_NULL)
80165c1c:	e51b3008 	ldr	r3, [fp, #-8]
80165c20:	e3530000 	cmp	r3, #0
80165c24:	1a000003 	bne	80165c38 <_RME_Thd_Pgt+0x58>
    {
        RME_COV_MARKER();

        return Thd->Sched.Prc->Pgt;
80165c28:	e51b3010 	ldr	r3, [fp, #-16]
80165c2c:	e593302c 	ldr	r3, [r3, #44]	@ 0x2c
80165c30:	e5933018 	ldr	r3, [r3, #24]
80165c34:	ea000002 	b	80165c44 <_RME_Thd_Pgt+0x64>
    }
    else
    {
        RME_COV_MARKER();

        return Inv_Top->Prc->Pgt;
80165c38:	e51b3008 	ldr	r3, [fp, #-8]
80165c3c:	e5933008 	ldr	r3, [r3, #8]
80165c40:	e5933018 	ldr	r3, [r3, #24]
    }
}
80165c44:	e1a00003 	mov	r0, r3
80165c48:	e28bd000 	add	sp, fp, #0
80165c4c:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
80165c50:	e12fff1e 	bx	lr

80165c54 <_RME_Run_Swt>:
Return      : rme_ret_t - Always 0.
******************************************************************************/
static rme_ret_t _RME_Run_Swt(struct RME_Reg_Struct* Reg,
                              struct RME_Thd_Struct* Thd_Cur, 
                              struct RME_Thd_Struct* Thd_New)
{
80165c54:	e92d4800 	push	{fp, lr}
80165c58:	e28db004 	add	fp, sp, #4
80165c5c:	e24dd020 	sub	sp, sp, #32
80165c60:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80165c64:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
80165c68:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    rme_ptr_t Pgt_New;
#endif
    struct RME_Reg_Struct* Reg_Cur;
    struct RME_Reg_Struct* Reg_New;
    
    Reg_Cur=&(Thd_Cur->Ctx.Reg->Reg);
80165c6c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80165c70:	e5933048 	ldr	r3, [r3, #72]	@ 0x48
80165c74:	e50b3008 	str	r3, [fp, #-8]
    Reg_New=&(Thd_New->Ctx.Reg->Reg);
80165c78:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80165c7c:	e5933048 	ldr	r3, [r3, #72]	@ 0x48
80165c80:	e50b300c 	str	r3, [fp, #-12]
    
    /* Save register context */
    __RME_Thd_Reg_Copy(Reg_Cur,Reg);
80165c84:	e51b1018 	ldr	r1, [fp, #-24]	@ 0xffffffe8
80165c88:	e51b0008 	ldr	r0, [fp, #-8]
80165c8c:	eb001f39 	bl	8016d978 <__RME_Thd_Reg_Copy>
                       RME_THD_IS_HYP(Thd_Cur->Ctx.Hyp_Attr),
                       Reg_Cur,Thd_Cur->Ctx.Reg->Cop);
#endif

    /* Load register context */
    __RME_Thd_Reg_Copy(Reg,Reg_New);
80165c90:	e51b100c 	ldr	r1, [fp, #-12]
80165c94:	e51b0018 	ldr	r0, [fp, #-24]	@ 0xffffffe8
80165c98:	eb001f36 	bl	8016d978 <__RME_Thd_Reg_Copy>

    /* Are we going to switch page tables? If yes, we change it now */
    Pgt_Cur=_RME_Thd_Pgt(Thd_Cur);
80165c9c:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80165ca0:	ebffffce 	bl	80165be0 <_RME_Thd_Pgt>
80165ca4:	e50b0010 	str	r0, [fp, #-16]
    Pgt_New=_RME_Thd_Pgt(Thd_New);
80165ca8:	e51b0020 	ldr	r0, [fp, #-32]	@ 0xffffffe0
80165cac:	ebffffcb 	bl	80165be0 <_RME_Thd_Pgt>
80165cb0:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec

#if(RME_PGT_RAW_ENABLE==0U)
    /* The page tables here must be root cap */
    RME_ASSERT(RME_CAP_IS_ROOT(Pgt_Cur)!=0U);
80165cb4:	e51b3010 	ldr	r3, [fp, #-16]
80165cb8:	e5933000 	ldr	r3, [r3]
80165cbc:	e6ff3073 	uxth	r3, r3
80165cc0:	e3530000 	cmp	r3, #0
80165cc4:	0a000008 	beq	80165cec <_RME_Run_Swt+0x98>
80165cc8:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
80165ccc:	e3483016 	movt	r3, #32790	@ 0x8016
80165cd0:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
80165cd4:	e3482016 	movt	r2, #32790	@ 0x8016
80165cd8:	e3011230 	movw	r1, #4656	@ 0x1230
80165cdc:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
80165ce0:	e3480016 	movt	r0, #32790	@ 0x8016
80165ce4:	ebffeba9 	bl	80160b90 <RME_Log>
80165ce8:	eafffffe 	b	80165ce8 <_RME_Run_Swt+0x94>
    RME_ASSERT(RME_CAP_IS_ROOT(Pgt_New)!=0U);
80165cec:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165cf0:	e5933000 	ldr	r3, [r3]
80165cf4:	e6ff3073 	uxth	r3, r3
80165cf8:	e3530000 	cmp	r3, #0
80165cfc:	0a000008 	beq	80165d24 <_RME_Run_Swt+0xd0>
80165d00:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
80165d04:	e3483016 	movt	r3, #32790	@ 0x8016
80165d08:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
80165d0c:	e3482016 	movt	r2, #32790	@ 0x8016
80165d10:	e3011231 	movw	r1, #4657	@ 0x1231
80165d14:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
80165d18:	e3480016 	movt	r0, #32790	@ 0x8016
80165d1c:	ebffeb9b 	bl	80160b90 <RME_Log>
80165d20:	eafffffe 	b	80165d20 <_RME_Run_Swt+0xcc>
#endif
    
#if(RME_PGT_RAW_ENABLE==0U)
    if(RME_CAP_GETOBJ(Pgt_Cur,rme_ptr_t)!=RME_CAP_GETOBJ(Pgt_New,rme_ptr_t))
80165d24:	e51b3010 	ldr	r3, [fp, #-16]
80165d28:	e593200c 	ldr	r2, [r3, #12]
80165d2c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165d30:	e593300c 	ldr	r3, [r3, #12]
80165d34:	e1520003 	cmp	r2, r3
80165d38:	0a000001 	beq	80165d44 <_RME_Run_Swt+0xf0>
        RME_DBG_H(Pgt_Cur);
        RME_DBG_S("\r\n");;
        RME_DBG_S("New - ");
        RME_DBG_H(Pgt_New);
        RME_DBG_S("\r\n");*/
        __RME_Pgt_Set(Pgt_New);
80165d3c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
80165d40:	eb002059 	bl	8016deac <__RME_Pgt_Set>
    {
        RME_COV_MARKER();
        /* No action required */
    }

    return 0;
80165d44:	e3a03000 	mov	r3, #0
}
80165d48:	e1a00003 	mov	r0, r3
80165d4c:	e24bd004 	sub	sp, fp, #4
80165d50:	e8bd8800 	pop	{fp, pc}

80165d54 <_RME_Prc_Boot_Crt>:
                            rme_cid_t Cap_Cpt_Crt,
                            rme_cid_t Cap_Prc,
                            rme_cid_t Cap_Cpt,
                            rme_ptr_t Raw_Pgt)
#endif
{
80165d54:	e92d4800 	push	{fp, lr}
80165d58:	e28db004 	add	fp, sp, #4
80165d5c:	e24dd030 	sub	sp, sp, #48	@ 0x30
80165d60:	e50b0028 	str	r0, [fp, #-40]	@ 0xffffffd8
80165d64:	e50b102c 	str	r1, [fp, #-44]	@ 0xffffffd4
80165d68:	e50b2030 	str	r2, [fp, #-48]	@ 0xffffffd0
80165d6c:	e50b3034 	str	r3, [fp, #-52]	@ 0xffffffcc
    struct RME_Cap_Pgt* Prc_Pgt;
#endif
    rme_ptr_t Type_Stat;
    
    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Crt,RME_CAP_TYPE_CPT,
80165d70:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80165d74:	e2033080 	and	r3, r3, #128	@ 0x80
80165d78:	e3530000 	cmp	r3, #0
80165d7c:	1a00001c 	bne	80165df4 <_RME_Prc_Boot_Crt+0xa0>
80165d80:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165d84:	e5932014 	ldr	r2, [r3, #20]
80165d88:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80165d8c:	e1520003 	cmp	r2, r3
80165d90:	8a000001 	bhi	80165d9c <_RME_Prc_Boot_Crt+0x48>
80165d94:	e3e03002 	mvn	r3, #2
80165d98:	ea000174 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80165d9c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80165da0:	e1a02283 	lsl	r2, r3, #5
80165da4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165da8:	e593300c 	ldr	r3, [r3, #12]
80165dac:	e0823003 	add	r3, r2, r3
80165db0:	e50b3008 	str	r3, [fp, #-8]
80165db4:	e51b3008 	ldr	r3, [fp, #-8]
80165db8:	e1a00003 	mov	r0, r3
80165dbc:	ebffea4f 	bl	80160700 <__RME_A7A_Read_Acquire>
80165dc0:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80165dc4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165dc8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80165dcc:	e3530802 	cmp	r3, #131072	@ 0x20000
80165dd0:	1a000001 	bne	80165ddc <_RME_Prc_Boot_Crt+0x88>
80165dd4:	e3e03008 	mvn	r3, #8
80165dd8:	ea000164 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80165ddc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165de0:	e1a03c23 	lsr	r3, r3, #24
80165de4:	e3530003 	cmp	r3, #3
80165de8:	0a00003f 	beq	80165eec <_RME_Prc_Boot_Crt+0x198>
80165dec:	e3e03001 	mvn	r3, #1
80165df0:	ea00015e 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80165df4:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80165df8:	e1a02423 	lsr	r2, r3, #8
80165dfc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165e00:	e5933014 	ldr	r3, [r3, #20]
80165e04:	e1520003 	cmp	r2, r3
80165e08:	3a000001 	bcc	80165e14 <_RME_Prc_Boot_Crt+0xc0>
80165e0c:	e3e03002 	mvn	r3, #2
80165e10:	ea000156 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80165e14:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80165e18:	e1a03423 	lsr	r3, r3, #8
80165e1c:	e1a02283 	lsl	r2, r3, #5
80165e20:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165e24:	e593300c 	ldr	r3, [r3, #12]
80165e28:	e0823003 	add	r3, r2, r3
80165e2c:	e50b3008 	str	r3, [fp, #-8]
80165e30:	e51b3008 	ldr	r3, [fp, #-8]
80165e34:	e1a00003 	mov	r0, r3
80165e38:	ebffea30 	bl	80160700 <__RME_A7A_Read_Acquire>
80165e3c:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80165e40:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165e44:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80165e48:	e3530802 	cmp	r3, #131072	@ 0x20000
80165e4c:	1a000001 	bne	80165e58 <_RME_Prc_Boot_Crt+0x104>
80165e50:	e3e03008 	mvn	r3, #8
80165e54:	ea000145 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80165e58:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165e5c:	e1a03c23 	lsr	r3, r3, #24
80165e60:	e3530003 	cmp	r3, #3
80165e64:	0a000001 	beq	80165e70 <_RME_Prc_Boot_Crt+0x11c>
80165e68:	e3e03001 	mvn	r3, #1
80165e6c:	ea00013f 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80165e70:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80165e74:	e203207f 	and	r2, r3, #127	@ 0x7f
80165e78:	e51b3008 	ldr	r3, [fp, #-8]
80165e7c:	e5933014 	ldr	r3, [r3, #20]
80165e80:	e1520003 	cmp	r2, r3
80165e84:	3a000001 	bcc	80165e90 <_RME_Prc_Boot_Crt+0x13c>
80165e88:	e3e03002 	mvn	r3, #2
80165e8c:	ea000137 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80165e90:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80165e94:	e203307f 	and	r3, r3, #127	@ 0x7f
80165e98:	e1a02283 	lsl	r2, r3, #5
80165e9c:	e51b3008 	ldr	r3, [fp, #-8]
80165ea0:	e593300c 	ldr	r3, [r3, #12]
80165ea4:	e0823003 	add	r3, r2, r3
80165ea8:	e50b3008 	str	r3, [fp, #-8]
80165eac:	e51b3008 	ldr	r3, [fp, #-8]
80165eb0:	e1a00003 	mov	r0, r3
80165eb4:	ebffea11 	bl	80160700 <__RME_A7A_Read_Acquire>
80165eb8:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80165ebc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165ec0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80165ec4:	e3530802 	cmp	r3, #131072	@ 0x20000
80165ec8:	1a000001 	bne	80165ed4 <_RME_Prc_Boot_Crt+0x180>
80165ecc:	e3e03008 	mvn	r3, #8
80165ed0:	ea000126 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80165ed4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165ed8:	e1a03c23 	lsr	r3, r3, #24
80165edc:	e3530003 	cmp	r3, #3
80165ee0:	0a000001 	beq	80165eec <_RME_Prc_Boot_Crt+0x198>
80165ee4:	e3e03001 	mvn	r3, #1
80165ee8:	ea000120 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
                   struct RME_Cap_Cpt*,Cpt_Crt,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
80165eec:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80165ef0:	e2033080 	and	r3, r3, #128	@ 0x80
80165ef4:	e3530000 	cmp	r3, #0
80165ef8:	1a00001c 	bne	80165f70 <_RME_Prc_Boot_Crt+0x21c>
80165efc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165f00:	e5932014 	ldr	r2, [r3, #20]
80165f04:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80165f08:	e1520003 	cmp	r2, r3
80165f0c:	8a000001 	bhi	80165f18 <_RME_Prc_Boot_Crt+0x1c4>
80165f10:	e3e03002 	mvn	r3, #2
80165f14:	ea000115 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80165f18:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80165f1c:	e1a02283 	lsl	r2, r3, #5
80165f20:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165f24:	e593300c 	ldr	r3, [r3, #12]
80165f28:	e0823003 	add	r3, r2, r3
80165f2c:	e50b300c 	str	r3, [fp, #-12]
80165f30:	e51b300c 	ldr	r3, [fp, #-12]
80165f34:	e1a00003 	mov	r0, r3
80165f38:	ebffe9f0 	bl	80160700 <__RME_A7A_Read_Acquire>
80165f3c:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80165f40:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165f44:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80165f48:	e3530802 	cmp	r3, #131072	@ 0x20000
80165f4c:	1a000001 	bne	80165f58 <_RME_Prc_Boot_Crt+0x204>
80165f50:	e3e03008 	mvn	r3, #8
80165f54:	ea000105 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80165f58:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165f5c:	e1a03c23 	lsr	r3, r3, #24
80165f60:	e3530003 	cmp	r3, #3
80165f64:	0a00003f 	beq	80166068 <_RME_Prc_Boot_Crt+0x314>
80165f68:	e3e03001 	mvn	r3, #1
80165f6c:	ea0000ff 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80165f70:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80165f74:	e1a02423 	lsr	r2, r3, #8
80165f78:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165f7c:	e5933014 	ldr	r3, [r3, #20]
80165f80:	e1520003 	cmp	r2, r3
80165f84:	3a000001 	bcc	80165f90 <_RME_Prc_Boot_Crt+0x23c>
80165f88:	e3e03002 	mvn	r3, #2
80165f8c:	ea0000f7 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80165f90:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80165f94:	e1a03423 	lsr	r3, r3, #8
80165f98:	e1a02283 	lsl	r2, r3, #5
80165f9c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80165fa0:	e593300c 	ldr	r3, [r3, #12]
80165fa4:	e0823003 	add	r3, r2, r3
80165fa8:	e50b300c 	str	r3, [fp, #-12]
80165fac:	e51b300c 	ldr	r3, [fp, #-12]
80165fb0:	e1a00003 	mov	r0, r3
80165fb4:	ebffe9d1 	bl	80160700 <__RME_A7A_Read_Acquire>
80165fb8:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80165fbc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165fc0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80165fc4:	e3530802 	cmp	r3, #131072	@ 0x20000
80165fc8:	1a000001 	bne	80165fd4 <_RME_Prc_Boot_Crt+0x280>
80165fcc:	e3e03008 	mvn	r3, #8
80165fd0:	ea0000e6 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80165fd4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80165fd8:	e1a03c23 	lsr	r3, r3, #24
80165fdc:	e3530003 	cmp	r3, #3
80165fe0:	0a000001 	beq	80165fec <_RME_Prc_Boot_Crt+0x298>
80165fe4:	e3e03001 	mvn	r3, #1
80165fe8:	ea0000e0 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80165fec:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80165ff0:	e203207f 	and	r2, r3, #127	@ 0x7f
80165ff4:	e51b300c 	ldr	r3, [fp, #-12]
80165ff8:	e5933014 	ldr	r3, [r3, #20]
80165ffc:	e1520003 	cmp	r2, r3
80166000:	3a000001 	bcc	8016600c <_RME_Prc_Boot_Crt+0x2b8>
80166004:	e3e03002 	mvn	r3, #2
80166008:	ea0000d8 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
8016600c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80166010:	e203307f 	and	r3, r3, #127	@ 0x7f
80166014:	e1a02283 	lsl	r2, r3, #5
80166018:	e51b300c 	ldr	r3, [fp, #-12]
8016601c:	e593300c 	ldr	r3, [r3, #12]
80166020:	e0823003 	add	r3, r2, r3
80166024:	e50b300c 	str	r3, [fp, #-12]
80166028:	e51b300c 	ldr	r3, [fp, #-12]
8016602c:	e1a00003 	mov	r0, r3
80166030:	ebffe9b2 	bl	80160700 <__RME_A7A_Read_Acquire>
80166034:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80166038:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016603c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166040:	e3530802 	cmp	r3, #131072	@ 0x20000
80166044:	1a000001 	bne	80166050 <_RME_Prc_Boot_Crt+0x2fc>
80166048:	e3e03008 	mvn	r3, #8
8016604c:	ea0000c7 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80166050:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80166054:	e1a03c23 	lsr	r3, r3, #24
80166058:	e3530003 	cmp	r3, #3
8016605c:	0a000001 	beq	80166068 <_RME_Prc_Boot_Crt+0x314>
80166060:	e3e03001 	mvn	r3, #1
80166064:	ea0000c1 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
#if(RME_PGT_RAW_ENABLE==0U)
    RME_CPT_GETCAP(Cpt,Cap_Pgt,RME_CAP_TYPE_PGT,
80166068:	e59b3004 	ldr	r3, [fp, #4]
8016606c:	e2033080 	and	r3, r3, #128	@ 0x80
80166070:	e3530000 	cmp	r3, #0
80166074:	1a00001c 	bne	801660ec <_RME_Prc_Boot_Crt+0x398>
80166078:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016607c:	e5932014 	ldr	r2, [r3, #20]
80166080:	e59b3004 	ldr	r3, [fp, #4]
80166084:	e1520003 	cmp	r2, r3
80166088:	8a000001 	bhi	80166094 <_RME_Prc_Boot_Crt+0x340>
8016608c:	e3e03002 	mvn	r3, #2
80166090:	ea0000b6 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80166094:	e59b3004 	ldr	r3, [fp, #4]
80166098:	e1a02283 	lsl	r2, r3, #5
8016609c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801660a0:	e593300c 	ldr	r3, [r3, #12]
801660a4:	e0823003 	add	r3, r2, r3
801660a8:	e50b3010 	str	r3, [fp, #-16]
801660ac:	e51b3010 	ldr	r3, [fp, #-16]
801660b0:	e1a00003 	mov	r0, r3
801660b4:	ebffe991 	bl	80160700 <__RME_A7A_Read_Acquire>
801660b8:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801660bc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801660c0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801660c4:	e3530802 	cmp	r3, #131072	@ 0x20000
801660c8:	1a000001 	bne	801660d4 <_RME_Prc_Boot_Crt+0x380>
801660cc:	e3e03008 	mvn	r3, #8
801660d0:	ea0000a6 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
801660d4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801660d8:	e1a03c23 	lsr	r3, r3, #24
801660dc:	e3530004 	cmp	r3, #4
801660e0:	0a00003f 	beq	801661e4 <_RME_Prc_Boot_Crt+0x490>
801660e4:	e3e03001 	mvn	r3, #1
801660e8:	ea0000a0 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
801660ec:	e59b3004 	ldr	r3, [fp, #4]
801660f0:	e1a02423 	lsr	r2, r3, #8
801660f4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801660f8:	e5933014 	ldr	r3, [r3, #20]
801660fc:	e1520003 	cmp	r2, r3
80166100:	3a000001 	bcc	8016610c <_RME_Prc_Boot_Crt+0x3b8>
80166104:	e3e03002 	mvn	r3, #2
80166108:	ea000098 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
8016610c:	e59b3004 	ldr	r3, [fp, #4]
80166110:	e1a03423 	lsr	r3, r3, #8
80166114:	e1a02283 	lsl	r2, r3, #5
80166118:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016611c:	e593300c 	ldr	r3, [r3, #12]
80166120:	e0823003 	add	r3, r2, r3
80166124:	e50b3010 	str	r3, [fp, #-16]
80166128:	e51b3010 	ldr	r3, [fp, #-16]
8016612c:	e1a00003 	mov	r0, r3
80166130:	ebffe972 	bl	80160700 <__RME_A7A_Read_Acquire>
80166134:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80166138:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016613c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166140:	e3530802 	cmp	r3, #131072	@ 0x20000
80166144:	1a000001 	bne	80166150 <_RME_Prc_Boot_Crt+0x3fc>
80166148:	e3e03008 	mvn	r3, #8
8016614c:	ea000087 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80166150:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80166154:	e1a03c23 	lsr	r3, r3, #24
80166158:	e3530003 	cmp	r3, #3
8016615c:	0a000001 	beq	80166168 <_RME_Prc_Boot_Crt+0x414>
80166160:	e3e03001 	mvn	r3, #1
80166164:	ea000081 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80166168:	e59b3004 	ldr	r3, [fp, #4]
8016616c:	e203207f 	and	r2, r3, #127	@ 0x7f
80166170:	e51b3010 	ldr	r3, [fp, #-16]
80166174:	e5933014 	ldr	r3, [r3, #20]
80166178:	e1520003 	cmp	r2, r3
8016617c:	3a000001 	bcc	80166188 <_RME_Prc_Boot_Crt+0x434>
80166180:	e3e03002 	mvn	r3, #2
80166184:	ea000079 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80166188:	e59b3004 	ldr	r3, [fp, #4]
8016618c:	e203307f 	and	r3, r3, #127	@ 0x7f
80166190:	e1a02283 	lsl	r2, r3, #5
80166194:	e51b3010 	ldr	r3, [fp, #-16]
80166198:	e593300c 	ldr	r3, [r3, #12]
8016619c:	e0823003 	add	r3, r2, r3
801661a0:	e50b3010 	str	r3, [fp, #-16]
801661a4:	e51b3010 	ldr	r3, [fp, #-16]
801661a8:	e1a00003 	mov	r0, r3
801661ac:	ebffe953 	bl	80160700 <__RME_A7A_Read_Acquire>
801661b0:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801661b4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801661b8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801661bc:	e3530802 	cmp	r3, #131072	@ 0x20000
801661c0:	1a000001 	bne	801661cc <_RME_Prc_Boot_Crt+0x478>
801661c4:	e3e03008 	mvn	r3, #8
801661c8:	ea000068 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
801661cc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801661d0:	e1a03c23 	lsr	r3, r3, #24
801661d4:	e3530004 	cmp	r3, #4
801661d8:	0a000001 	beq	801661e4 <_RME_Prc_Boot_Crt+0x490>
801661dc:	e3e03001 	mvn	r3, #1
801661e0:	ea000062 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
                   struct RME_Cap_Pgt*,Pgt_Op,Type_Stat);
#endif
    /* Check if the captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Crt,RME_CPT_FLAG_CRT);
801661e4:	e51b3008 	ldr	r3, [fp, #-8]
801661e8:	e5933008 	ldr	r3, [r3, #8]
801661ec:	e2033001 	and	r3, r3, #1
801661f0:	e3530000 	cmp	r3, #0
801661f4:	1a000001 	bne	80166200 <_RME_Prc_Boot_Crt+0x4ac>
801661f8:	e3e03006 	mvn	r3, #6
801661fc:	ea00005b 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_PRC_CRT);
80166200:	e51b300c 	ldr	r3, [fp, #-12]
80166204:	e5933008 	ldr	r3, [r3, #8]
80166208:	e2033040 	and	r3, r3, #64	@ 0x40
8016620c:	e3530000 	cmp	r3, #0
80166210:	1a000001 	bne	8016621c <_RME_Prc_Boot_Crt+0x4c8>
80166214:	e3e03006 	mvn	r3, #6
80166218:	ea000054 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
#if(RME_PGT_RAW_ENABLE==0U)
    RME_CAP_CHECK(Pgt_Op,RME_PGT_FLAG_PRC_CRT);
8016621c:	e51b3010 	ldr	r3, [fp, #-16]
80166220:	e5933008 	ldr	r3, [r3, #8]
80166224:	e2033040 	and	r3, r3, #64	@ 0x40
80166228:	e3530000 	cmp	r3, #0
8016622c:	1a000001 	bne	80166238 <_RME_Prc_Boot_Crt+0x4e4>
80166230:	e3e03006 	mvn	r3, #6
80166234:	ea00004d 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
#endif
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Crt,Cap_Prc,struct RME_Cap_Prc*,Prc_Crt);
80166238:	e51b3008 	ldr	r3, [fp, #-8]
8016623c:	e5932014 	ldr	r2, [r3, #20]
80166240:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80166244:	e1520003 	cmp	r2, r3
80166248:	8a000001 	bhi	80166254 <_RME_Prc_Boot_Crt+0x500>
8016624c:	e3e03002 	mvn	r3, #2
80166250:	ea000046 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80166254:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80166258:	e1a02283 	lsl	r2, r3, #5
8016625c:	e51b3008 	ldr	r3, [fp, #-8]
80166260:	e593300c 	ldr	r3, [r3, #12]
80166264:	e0823003 	add	r3, r2, r3
80166268:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Prc_Crt);
8016626c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166270:	e3a02801 	mov	r2, #65536	@ 0x10000
80166274:	e3a01000 	mov	r1, #0
80166278:	e1a00003 	mov	r0, r3
8016627c:	ebffea4e 	bl	80160bbc <_RME_Comp_Swap_Single>
80166280:	e1a03000 	mov	r3, r0
80166284:	e3530000 	cmp	r3, #0
80166288:	1a000001 	bne	80166294 <_RME_Prc_Boot_Crt+0x540>
8016628c:	e3e03004 	mvn	r3, #4
80166290:	ea000036 	b	80166370 <_RME_Prc_Boot_Crt+0x61c>
80166294:	e3003000 	movw	r3, #0
80166298:	e3483017 	movt	r3, #32791	@ 0x8017
8016629c:	e5932000 	ldr	r2, [r3]
801662a0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801662a4:	e5832010 	str	r2, [r3, #16]

    /* Header init */
    Prc_Crt->Head.Root_Ref=1U;
801662a8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801662ac:	e3a02001 	mov	r2, #1
801662b0:	e5832004 	str	r2, [r3, #4]
    Prc_Crt->Head.Object=0U;
801662b4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801662b8:	e3a02000 	mov	r2, #0
801662bc:	e583200c 	str	r2, [r3, #12]
    Prc_Crt->Head.Flag=RME_PRC_FLAG_INV|RME_PRC_FLAG_THD;
801662c0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801662c4:	e3a02003 	mov	r2, #3
801662c8:	e5832008 	str	r2, [r3, #8]

    /* Info init */
    Prc_Cpt=RME_CAP_CONV_ROOT(Cpt_Op,struct RME_Cap_Cpt*);
801662cc:	e51b300c 	ldr	r3, [fp, #-12]
801662d0:	e5933000 	ldr	r3, [r3]
801662d4:	e6ff3073 	uxth	r3, r3
801662d8:	e3530000 	cmp	r3, #0
801662dc:	0a000002 	beq	801662ec <_RME_Prc_Boot_Crt+0x598>
801662e0:	e51b300c 	ldr	r3, [fp, #-12]
801662e4:	e5933004 	ldr	r3, [r3, #4]
801662e8:	ea000000 	b	801662f0 <_RME_Prc_Boot_Crt+0x59c>
801662ec:	e51b300c 	ldr	r3, [fp, #-12]
801662f0:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
#if(RME_PGT_RAW_ENABLE==0U)
    Prc_Pgt=RME_CAP_CONV_ROOT(Pgt_Op,struct RME_Cap_Pgt*);
801662f4:	e51b3010 	ldr	r3, [fp, #-16]
801662f8:	e5933000 	ldr	r3, [r3]
801662fc:	e6ff3073 	uxth	r3, r3
80166300:	e3530000 	cmp	r3, #0
80166304:	0a000002 	beq	80166314 <_RME_Prc_Boot_Crt+0x5c0>
80166308:	e51b3010 	ldr	r3, [fp, #-16]
8016630c:	e5933004 	ldr	r3, [r3, #4]
80166310:	ea000000 	b	80166318 <_RME_Prc_Boot_Crt+0x5c4>
80166314:	e51b3010 	ldr	r3, [fp, #-16]
80166318:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
#endif
    Prc_Crt->Cpt=Prc_Cpt;
8016631c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166320:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
80166324:	e5832014 	str	r2, [r3, #20]
#if(RME_PGT_RAW_ENABLE==0U)
    Prc_Crt->Pgt=Prc_Pgt;
80166328:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016632c:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80166330:	e5832018 	str	r2, [r3, #24]
#else
    Prc_Crt->Pgt=Raw_Pgt;
#endif
    
    /* Reference objects */
    RME_FETCH_ADD(&(Prc_Cpt->Head.Root_Ref),1U);
80166334:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80166338:	e2833004 	add	r3, r3, #4
8016633c:	e3a01001 	mov	r1, #1
80166340:	e1a00003 	mov	r0, r3
80166344:	ebffea31 	bl	80160c10 <_RME_Fetch_Add_Single>
#if(RME_PGT_RAW_ENABLE==0U)
    RME_FETCH_ADD(&(Prc_Pgt->Head.Root_Ref),1U);
80166348:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016634c:	e2833004 	add	r3, r3, #4
80166350:	e3a01001 	mov	r1, #1
80166354:	e1a00003 	mov	r0, r3
80166358:	ebffea2c 	bl	80160c10 <_RME_Fetch_Add_Single>
#endif

    /* Establish cap */
    RME_WRITE_RELEASE(&(Prc_Crt->Head.Type_Stat),
8016635c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166360:	e3a01405 	mov	r1, #83886080	@ 0x5000000
80166364:	e1a00003 	mov	r0, r3
80166368:	ebffe8e7 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_PRC,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
8016636c:	e3a03000 	mov	r3, #0
}
80166370:	e1a00003 	mov	r0, r3
80166374:	e24bd004 	sub	sp, fp, #4
80166378:	e8bd8800 	pop	{fp, pc}

8016637c <_RME_Prc_Crt>:
                              rme_cid_t Cap_Cpt_Crt,
                              rme_cid_t Cap_Prc,
                              rme_cid_t Cap_Cpt,
                              rme_ptr_t Raw_Pgt)
#endif
{
8016637c:	e92d4800 	push	{fp, lr}
80166380:	e28db004 	add	fp, sp, #4
80166384:	e24dd030 	sub	sp, sp, #48	@ 0x30
80166388:	e50b0028 	str	r0, [fp, #-40]	@ 0xffffffd8
8016638c:	e50b102c 	str	r1, [fp, #-44]	@ 0xffffffd4
80166390:	e50b2030 	str	r2, [fp, #-48]	@ 0xffffffd0
80166394:	e50b3034 	str	r3, [fp, #-52]	@ 0xffffffcc
    struct RME_Cap_Pgt* Prc_Pgt;
#endif
    rme_ptr_t Type_Stat;
    
    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Cpt_Crt,RME_CAP_TYPE_CPT,
80166398:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016639c:	e2033080 	and	r3, r3, #128	@ 0x80
801663a0:	e3530000 	cmp	r3, #0
801663a4:	1a00001c 	bne	8016641c <_RME_Prc_Crt+0xa0>
801663a8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801663ac:	e5932014 	ldr	r2, [r3, #20]
801663b0:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801663b4:	e1520003 	cmp	r2, r3
801663b8:	8a000001 	bhi	801663c4 <_RME_Prc_Crt+0x48>
801663bc:	e3e03002 	mvn	r3, #2
801663c0:	ea000174 	b	80166998 <_RME_Prc_Crt+0x61c>
801663c4:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801663c8:	e1a02283 	lsl	r2, r3, #5
801663cc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801663d0:	e593300c 	ldr	r3, [r3, #12]
801663d4:	e0823003 	add	r3, r2, r3
801663d8:	e50b3008 	str	r3, [fp, #-8]
801663dc:	e51b3008 	ldr	r3, [fp, #-8]
801663e0:	e1a00003 	mov	r0, r3
801663e4:	ebffe8c5 	bl	80160700 <__RME_A7A_Read_Acquire>
801663e8:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801663ec:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801663f0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801663f4:	e3530802 	cmp	r3, #131072	@ 0x20000
801663f8:	1a000001 	bne	80166404 <_RME_Prc_Crt+0x88>
801663fc:	e3e03008 	mvn	r3, #8
80166400:	ea000164 	b	80166998 <_RME_Prc_Crt+0x61c>
80166404:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80166408:	e1a03c23 	lsr	r3, r3, #24
8016640c:	e3530003 	cmp	r3, #3
80166410:	0a00003f 	beq	80166514 <_RME_Prc_Crt+0x198>
80166414:	e3e03001 	mvn	r3, #1
80166418:	ea00015e 	b	80166998 <_RME_Prc_Crt+0x61c>
8016641c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80166420:	e1a02423 	lsr	r2, r3, #8
80166424:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80166428:	e5933014 	ldr	r3, [r3, #20]
8016642c:	e1520003 	cmp	r2, r3
80166430:	3a000001 	bcc	8016643c <_RME_Prc_Crt+0xc0>
80166434:	e3e03002 	mvn	r3, #2
80166438:	ea000156 	b	80166998 <_RME_Prc_Crt+0x61c>
8016643c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80166440:	e1a03423 	lsr	r3, r3, #8
80166444:	e1a02283 	lsl	r2, r3, #5
80166448:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016644c:	e593300c 	ldr	r3, [r3, #12]
80166450:	e0823003 	add	r3, r2, r3
80166454:	e50b3008 	str	r3, [fp, #-8]
80166458:	e51b3008 	ldr	r3, [fp, #-8]
8016645c:	e1a00003 	mov	r0, r3
80166460:	ebffe8a6 	bl	80160700 <__RME_A7A_Read_Acquire>
80166464:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80166468:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016646c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166470:	e3530802 	cmp	r3, #131072	@ 0x20000
80166474:	1a000001 	bne	80166480 <_RME_Prc_Crt+0x104>
80166478:	e3e03008 	mvn	r3, #8
8016647c:	ea000145 	b	80166998 <_RME_Prc_Crt+0x61c>
80166480:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80166484:	e1a03c23 	lsr	r3, r3, #24
80166488:	e3530003 	cmp	r3, #3
8016648c:	0a000001 	beq	80166498 <_RME_Prc_Crt+0x11c>
80166490:	e3e03001 	mvn	r3, #1
80166494:	ea00013f 	b	80166998 <_RME_Prc_Crt+0x61c>
80166498:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016649c:	e203207f 	and	r2, r3, #127	@ 0x7f
801664a0:	e51b3008 	ldr	r3, [fp, #-8]
801664a4:	e5933014 	ldr	r3, [r3, #20]
801664a8:	e1520003 	cmp	r2, r3
801664ac:	3a000001 	bcc	801664b8 <_RME_Prc_Crt+0x13c>
801664b0:	e3e03002 	mvn	r3, #2
801664b4:	ea000137 	b	80166998 <_RME_Prc_Crt+0x61c>
801664b8:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801664bc:	e203307f 	and	r3, r3, #127	@ 0x7f
801664c0:	e1a02283 	lsl	r2, r3, #5
801664c4:	e51b3008 	ldr	r3, [fp, #-8]
801664c8:	e593300c 	ldr	r3, [r3, #12]
801664cc:	e0823003 	add	r3, r2, r3
801664d0:	e50b3008 	str	r3, [fp, #-8]
801664d4:	e51b3008 	ldr	r3, [fp, #-8]
801664d8:	e1a00003 	mov	r0, r3
801664dc:	ebffe887 	bl	80160700 <__RME_A7A_Read_Acquire>
801664e0:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801664e4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801664e8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801664ec:	e3530802 	cmp	r3, #131072	@ 0x20000
801664f0:	1a000001 	bne	801664fc <_RME_Prc_Crt+0x180>
801664f4:	e3e03008 	mvn	r3, #8
801664f8:	ea000126 	b	80166998 <_RME_Prc_Crt+0x61c>
801664fc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80166500:	e1a03c23 	lsr	r3, r3, #24
80166504:	e3530003 	cmp	r3, #3
80166508:	0a000001 	beq	80166514 <_RME_Prc_Crt+0x198>
8016650c:	e3e03001 	mvn	r3, #1
80166510:	ea000120 	b	80166998 <_RME_Prc_Crt+0x61c>
                   struct RME_Cap_Cpt*,Cpt_Crt,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
80166514:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80166518:	e2033080 	and	r3, r3, #128	@ 0x80
8016651c:	e3530000 	cmp	r3, #0
80166520:	1a00001c 	bne	80166598 <_RME_Prc_Crt+0x21c>
80166524:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80166528:	e5932014 	ldr	r2, [r3, #20]
8016652c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80166530:	e1520003 	cmp	r2, r3
80166534:	8a000001 	bhi	80166540 <_RME_Prc_Crt+0x1c4>
80166538:	e3e03002 	mvn	r3, #2
8016653c:	ea000115 	b	80166998 <_RME_Prc_Crt+0x61c>
80166540:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80166544:	e1a02283 	lsl	r2, r3, #5
80166548:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016654c:	e593300c 	ldr	r3, [r3, #12]
80166550:	e0823003 	add	r3, r2, r3
80166554:	e50b300c 	str	r3, [fp, #-12]
80166558:	e51b300c 	ldr	r3, [fp, #-12]
8016655c:	e1a00003 	mov	r0, r3
80166560:	ebffe866 	bl	80160700 <__RME_A7A_Read_Acquire>
80166564:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80166568:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016656c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166570:	e3530802 	cmp	r3, #131072	@ 0x20000
80166574:	1a000001 	bne	80166580 <_RME_Prc_Crt+0x204>
80166578:	e3e03008 	mvn	r3, #8
8016657c:	ea000105 	b	80166998 <_RME_Prc_Crt+0x61c>
80166580:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80166584:	e1a03c23 	lsr	r3, r3, #24
80166588:	e3530003 	cmp	r3, #3
8016658c:	0a00003f 	beq	80166690 <_RME_Prc_Crt+0x314>
80166590:	e3e03001 	mvn	r3, #1
80166594:	ea0000ff 	b	80166998 <_RME_Prc_Crt+0x61c>
80166598:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
8016659c:	e1a02423 	lsr	r2, r3, #8
801665a0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801665a4:	e5933014 	ldr	r3, [r3, #20]
801665a8:	e1520003 	cmp	r2, r3
801665ac:	3a000001 	bcc	801665b8 <_RME_Prc_Crt+0x23c>
801665b0:	e3e03002 	mvn	r3, #2
801665b4:	ea0000f7 	b	80166998 <_RME_Prc_Crt+0x61c>
801665b8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801665bc:	e1a03423 	lsr	r3, r3, #8
801665c0:	e1a02283 	lsl	r2, r3, #5
801665c4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801665c8:	e593300c 	ldr	r3, [r3, #12]
801665cc:	e0823003 	add	r3, r2, r3
801665d0:	e50b300c 	str	r3, [fp, #-12]
801665d4:	e51b300c 	ldr	r3, [fp, #-12]
801665d8:	e1a00003 	mov	r0, r3
801665dc:	ebffe847 	bl	80160700 <__RME_A7A_Read_Acquire>
801665e0:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801665e4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801665e8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801665ec:	e3530802 	cmp	r3, #131072	@ 0x20000
801665f0:	1a000001 	bne	801665fc <_RME_Prc_Crt+0x280>
801665f4:	e3e03008 	mvn	r3, #8
801665f8:	ea0000e6 	b	80166998 <_RME_Prc_Crt+0x61c>
801665fc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80166600:	e1a03c23 	lsr	r3, r3, #24
80166604:	e3530003 	cmp	r3, #3
80166608:	0a000001 	beq	80166614 <_RME_Prc_Crt+0x298>
8016660c:	e3e03001 	mvn	r3, #1
80166610:	ea0000e0 	b	80166998 <_RME_Prc_Crt+0x61c>
80166614:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80166618:	e203207f 	and	r2, r3, #127	@ 0x7f
8016661c:	e51b300c 	ldr	r3, [fp, #-12]
80166620:	e5933014 	ldr	r3, [r3, #20]
80166624:	e1520003 	cmp	r2, r3
80166628:	3a000001 	bcc	80166634 <_RME_Prc_Crt+0x2b8>
8016662c:	e3e03002 	mvn	r3, #2
80166630:	ea0000d8 	b	80166998 <_RME_Prc_Crt+0x61c>
80166634:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80166638:	e203307f 	and	r3, r3, #127	@ 0x7f
8016663c:	e1a02283 	lsl	r2, r3, #5
80166640:	e51b300c 	ldr	r3, [fp, #-12]
80166644:	e593300c 	ldr	r3, [r3, #12]
80166648:	e0823003 	add	r3, r2, r3
8016664c:	e50b300c 	str	r3, [fp, #-12]
80166650:	e51b300c 	ldr	r3, [fp, #-12]
80166654:	e1a00003 	mov	r0, r3
80166658:	ebffe828 	bl	80160700 <__RME_A7A_Read_Acquire>
8016665c:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80166660:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80166664:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166668:	e3530802 	cmp	r3, #131072	@ 0x20000
8016666c:	1a000001 	bne	80166678 <_RME_Prc_Crt+0x2fc>
80166670:	e3e03008 	mvn	r3, #8
80166674:	ea0000c7 	b	80166998 <_RME_Prc_Crt+0x61c>
80166678:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016667c:	e1a03c23 	lsr	r3, r3, #24
80166680:	e3530003 	cmp	r3, #3
80166684:	0a000001 	beq	80166690 <_RME_Prc_Crt+0x314>
80166688:	e3e03001 	mvn	r3, #1
8016668c:	ea0000c1 	b	80166998 <_RME_Prc_Crt+0x61c>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
#if(RME_PGT_RAW_ENABLE==0U)
    RME_CPT_GETCAP(Cpt,Cap_Pgt,RME_CAP_TYPE_PGT,
80166690:	e59b3004 	ldr	r3, [fp, #4]
80166694:	e2033080 	and	r3, r3, #128	@ 0x80
80166698:	e3530000 	cmp	r3, #0
8016669c:	1a00001c 	bne	80166714 <_RME_Prc_Crt+0x398>
801666a0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801666a4:	e5932014 	ldr	r2, [r3, #20]
801666a8:	e59b3004 	ldr	r3, [fp, #4]
801666ac:	e1520003 	cmp	r2, r3
801666b0:	8a000001 	bhi	801666bc <_RME_Prc_Crt+0x340>
801666b4:	e3e03002 	mvn	r3, #2
801666b8:	ea0000b6 	b	80166998 <_RME_Prc_Crt+0x61c>
801666bc:	e59b3004 	ldr	r3, [fp, #4]
801666c0:	e1a02283 	lsl	r2, r3, #5
801666c4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801666c8:	e593300c 	ldr	r3, [r3, #12]
801666cc:	e0823003 	add	r3, r2, r3
801666d0:	e50b3010 	str	r3, [fp, #-16]
801666d4:	e51b3010 	ldr	r3, [fp, #-16]
801666d8:	e1a00003 	mov	r0, r3
801666dc:	ebffe807 	bl	80160700 <__RME_A7A_Read_Acquire>
801666e0:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801666e4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801666e8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801666ec:	e3530802 	cmp	r3, #131072	@ 0x20000
801666f0:	1a000001 	bne	801666fc <_RME_Prc_Crt+0x380>
801666f4:	e3e03008 	mvn	r3, #8
801666f8:	ea0000a6 	b	80166998 <_RME_Prc_Crt+0x61c>
801666fc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80166700:	e1a03c23 	lsr	r3, r3, #24
80166704:	e3530004 	cmp	r3, #4
80166708:	0a00003f 	beq	8016680c <_RME_Prc_Crt+0x490>
8016670c:	e3e03001 	mvn	r3, #1
80166710:	ea0000a0 	b	80166998 <_RME_Prc_Crt+0x61c>
80166714:	e59b3004 	ldr	r3, [fp, #4]
80166718:	e1a02423 	lsr	r2, r3, #8
8016671c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80166720:	e5933014 	ldr	r3, [r3, #20]
80166724:	e1520003 	cmp	r2, r3
80166728:	3a000001 	bcc	80166734 <_RME_Prc_Crt+0x3b8>
8016672c:	e3e03002 	mvn	r3, #2
80166730:	ea000098 	b	80166998 <_RME_Prc_Crt+0x61c>
80166734:	e59b3004 	ldr	r3, [fp, #4]
80166738:	e1a03423 	lsr	r3, r3, #8
8016673c:	e1a02283 	lsl	r2, r3, #5
80166740:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80166744:	e593300c 	ldr	r3, [r3, #12]
80166748:	e0823003 	add	r3, r2, r3
8016674c:	e50b3010 	str	r3, [fp, #-16]
80166750:	e51b3010 	ldr	r3, [fp, #-16]
80166754:	e1a00003 	mov	r0, r3
80166758:	ebffe7e8 	bl	80160700 <__RME_A7A_Read_Acquire>
8016675c:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80166760:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80166764:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166768:	e3530802 	cmp	r3, #131072	@ 0x20000
8016676c:	1a000001 	bne	80166778 <_RME_Prc_Crt+0x3fc>
80166770:	e3e03008 	mvn	r3, #8
80166774:	ea000087 	b	80166998 <_RME_Prc_Crt+0x61c>
80166778:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016677c:	e1a03c23 	lsr	r3, r3, #24
80166780:	e3530003 	cmp	r3, #3
80166784:	0a000001 	beq	80166790 <_RME_Prc_Crt+0x414>
80166788:	e3e03001 	mvn	r3, #1
8016678c:	ea000081 	b	80166998 <_RME_Prc_Crt+0x61c>
80166790:	e59b3004 	ldr	r3, [fp, #4]
80166794:	e203207f 	and	r2, r3, #127	@ 0x7f
80166798:	e51b3010 	ldr	r3, [fp, #-16]
8016679c:	e5933014 	ldr	r3, [r3, #20]
801667a0:	e1520003 	cmp	r2, r3
801667a4:	3a000001 	bcc	801667b0 <_RME_Prc_Crt+0x434>
801667a8:	e3e03002 	mvn	r3, #2
801667ac:	ea000079 	b	80166998 <_RME_Prc_Crt+0x61c>
801667b0:	e59b3004 	ldr	r3, [fp, #4]
801667b4:	e203307f 	and	r3, r3, #127	@ 0x7f
801667b8:	e1a02283 	lsl	r2, r3, #5
801667bc:	e51b3010 	ldr	r3, [fp, #-16]
801667c0:	e593300c 	ldr	r3, [r3, #12]
801667c4:	e0823003 	add	r3, r2, r3
801667c8:	e50b3010 	str	r3, [fp, #-16]
801667cc:	e51b3010 	ldr	r3, [fp, #-16]
801667d0:	e1a00003 	mov	r0, r3
801667d4:	ebffe7c9 	bl	80160700 <__RME_A7A_Read_Acquire>
801667d8:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
801667dc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801667e0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801667e4:	e3530802 	cmp	r3, #131072	@ 0x20000
801667e8:	1a000001 	bne	801667f4 <_RME_Prc_Crt+0x478>
801667ec:	e3e03008 	mvn	r3, #8
801667f0:	ea000068 	b	80166998 <_RME_Prc_Crt+0x61c>
801667f4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801667f8:	e1a03c23 	lsr	r3, r3, #24
801667fc:	e3530004 	cmp	r3, #4
80166800:	0a000001 	beq	8016680c <_RME_Prc_Crt+0x490>
80166804:	e3e03001 	mvn	r3, #1
80166808:	ea000062 	b	80166998 <_RME_Prc_Crt+0x61c>
                   struct RME_Cap_Pgt*,Pgt_Op,Type_Stat);
#endif
    /* Check if the captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Crt,RME_CPT_FLAG_CRT);
8016680c:	e51b3008 	ldr	r3, [fp, #-8]
80166810:	e5933008 	ldr	r3, [r3, #8]
80166814:	e2033001 	and	r3, r3, #1
80166818:	e3530000 	cmp	r3, #0
8016681c:	1a000001 	bne	80166828 <_RME_Prc_Crt+0x4ac>
80166820:	e3e03006 	mvn	r3, #6
80166824:	ea00005b 	b	80166998 <_RME_Prc_Crt+0x61c>
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_PRC_CRT);
80166828:	e51b300c 	ldr	r3, [fp, #-12]
8016682c:	e5933008 	ldr	r3, [r3, #8]
80166830:	e2033040 	and	r3, r3, #64	@ 0x40
80166834:	e3530000 	cmp	r3, #0
80166838:	1a000001 	bne	80166844 <_RME_Prc_Crt+0x4c8>
8016683c:	e3e03006 	mvn	r3, #6
80166840:	ea000054 	b	80166998 <_RME_Prc_Crt+0x61c>
#if(RME_PGT_RAW_ENABLE==0U)
    RME_CAP_CHECK(Pgt_Op,RME_PGT_FLAG_PRC_CRT);
80166844:	e51b3010 	ldr	r3, [fp, #-16]
80166848:	e5933008 	ldr	r3, [r3, #8]
8016684c:	e2033040 	and	r3, r3, #64	@ 0x40
80166850:	e3530000 	cmp	r3, #0
80166854:	1a000001 	bne	80166860 <_RME_Prc_Crt+0x4e4>
80166858:	e3e03006 	mvn	r3, #6
8016685c:	ea00004d 	b	80166998 <_RME_Prc_Crt+0x61c>
#endif
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Crt,Cap_Prc,struct RME_Cap_Prc*,Prc_Crt);
80166860:	e51b3008 	ldr	r3, [fp, #-8]
80166864:	e5932014 	ldr	r2, [r3, #20]
80166868:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016686c:	e1520003 	cmp	r2, r3
80166870:	8a000001 	bhi	8016687c <_RME_Prc_Crt+0x500>
80166874:	e3e03002 	mvn	r3, #2
80166878:	ea000046 	b	80166998 <_RME_Prc_Crt+0x61c>
8016687c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80166880:	e1a02283 	lsl	r2, r3, #5
80166884:	e51b3008 	ldr	r3, [fp, #-8]
80166888:	e593300c 	ldr	r3, [r3, #12]
8016688c:	e0823003 	add	r3, r2, r3
80166890:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Prc_Crt);
80166894:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166898:	e3a02801 	mov	r2, #65536	@ 0x10000
8016689c:	e3a01000 	mov	r1, #0
801668a0:	e1a00003 	mov	r0, r3
801668a4:	ebffe8c4 	bl	80160bbc <_RME_Comp_Swap_Single>
801668a8:	e1a03000 	mov	r3, r0
801668ac:	e3530000 	cmp	r3, #0
801668b0:	1a000001 	bne	801668bc <_RME_Prc_Crt+0x540>
801668b4:	e3e03004 	mvn	r3, #4
801668b8:	ea000036 	b	80166998 <_RME_Prc_Crt+0x61c>
801668bc:	e3003000 	movw	r3, #0
801668c0:	e3483017 	movt	r3, #32791	@ 0x8017
801668c4:	e5932000 	ldr	r2, [r3]
801668c8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801668cc:	e5832010 	str	r2, [r3, #16]
    
    /* Header init */
    Prc_Crt->Head.Root_Ref=0U;
801668d0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801668d4:	e3a02000 	mov	r2, #0
801668d8:	e5832004 	str	r2, [r3, #4]
    Prc_Crt->Head.Object=0U;
801668dc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801668e0:	e3a02000 	mov	r2, #0
801668e4:	e583200c 	str	r2, [r3, #12]
    Prc_Crt->Head.Flag=RME_PRC_FLAG_ALL;
801668e8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801668ec:	e3a0200f 	mov	r2, #15
801668f0:	e5832008 	str	r2, [r3, #8]
    
    /* Info init */
    Prc_Cpt=RME_CAP_CONV_ROOT(Cpt_Op,struct RME_Cap_Cpt*);
801668f4:	e51b300c 	ldr	r3, [fp, #-12]
801668f8:	e5933000 	ldr	r3, [r3]
801668fc:	e6ff3073 	uxth	r3, r3
80166900:	e3530000 	cmp	r3, #0
80166904:	0a000002 	beq	80166914 <_RME_Prc_Crt+0x598>
80166908:	e51b300c 	ldr	r3, [fp, #-12]
8016690c:	e5933004 	ldr	r3, [r3, #4]
80166910:	ea000000 	b	80166918 <_RME_Prc_Crt+0x59c>
80166914:	e51b300c 	ldr	r3, [fp, #-12]
80166918:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
#if(RME_PGT_RAW_ENABLE==0U)
    Prc_Pgt=RME_CAP_CONV_ROOT(Pgt_Op,struct RME_Cap_Pgt*);
8016691c:	e51b3010 	ldr	r3, [fp, #-16]
80166920:	e5933000 	ldr	r3, [r3]
80166924:	e6ff3073 	uxth	r3, r3
80166928:	e3530000 	cmp	r3, #0
8016692c:	0a000002 	beq	8016693c <_RME_Prc_Crt+0x5c0>
80166930:	e51b3010 	ldr	r3, [fp, #-16]
80166934:	e5933004 	ldr	r3, [r3, #4]
80166938:	ea000000 	b	80166940 <_RME_Prc_Crt+0x5c4>
8016693c:	e51b3010 	ldr	r3, [fp, #-16]
80166940:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
#endif
    Prc_Crt->Cpt=Prc_Cpt;
80166944:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166948:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
8016694c:	e5832014 	str	r2, [r3, #20]
#if(RME_PGT_RAW_ENABLE==0U)
    Prc_Crt->Pgt=Prc_Pgt;
80166950:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166954:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80166958:	e5832018 	str	r2, [r3, #24]
#else
    Prc_Crt->Pgt=Raw_Pgt;
#endif
    
    /* Reference objects */
    RME_FETCH_ADD(&(Prc_Cpt->Head.Root_Ref),1U);
8016695c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80166960:	e2833004 	add	r3, r3, #4
80166964:	e3a01001 	mov	r1, #1
80166968:	e1a00003 	mov	r0, r3
8016696c:	ebffe8a7 	bl	80160c10 <_RME_Fetch_Add_Single>
#if(RME_PGT_RAW_ENABLE==0U)
    RME_FETCH_ADD(&(Prc_Pgt->Head.Root_Ref),1U);
80166970:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166974:	e2833004 	add	r3, r3, #4
80166978:	e3a01001 	mov	r1, #1
8016697c:	e1a00003 	mov	r0, r3
80166980:	ebffe8a2 	bl	80160c10 <_RME_Fetch_Add_Single>
#endif

    /* Establish cap */
    RME_WRITE_RELEASE(&(Prc_Crt->Head.Type_Stat),
80166984:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166988:	e3a01405 	mov	r1, #83886080	@ 0x5000000
8016698c:	e1a00003 	mov	r0, r3
80166990:	ebffe75d 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_PRC,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
80166994:	e3a03000 	mov	r3, #0
}
80166998:	e1a00003 	mov	r0, r3
8016699c:	e24bd004 	sub	sp, fp, #4
801669a0:	e8bd8800 	pop	{fp, pc}

801669a4 <_RME_Prc_Del>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Prc_Del(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt,
                              rme_cid_t Cap_Prc)
{
801669a4:	e92d4800 	push	{fp, lr}
801669a8:	e28db004 	add	fp, sp, #4
801669ac:	e24dd028 	sub	sp, sp, #40	@ 0x28
801669b0:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
801669b4:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
801669b8:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
#if(RME_PGT_RAW_ENABLE==0U)
    struct RME_Cap_Pgt* Prc_Pgt;
#endif

    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
801669bc:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801669c0:	e2033080 	and	r3, r3, #128	@ 0x80
801669c4:	e3530000 	cmp	r3, #0
801669c8:	1a00001c 	bne	80166a40 <_RME_Prc_Del+0x9c>
801669cc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801669d0:	e5932014 	ldr	r2, [r3, #20]
801669d4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801669d8:	e1520003 	cmp	r2, r3
801669dc:	8a000001 	bhi	801669e8 <_RME_Prc_Del+0x44>
801669e0:	e3e03002 	mvn	r3, #2
801669e4:	ea0000bc 	b	80166cdc <_RME_Prc_Del+0x338>
801669e8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801669ec:	e1a02283 	lsl	r2, r3, #5
801669f0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801669f4:	e593300c 	ldr	r3, [r3, #12]
801669f8:	e0823003 	add	r3, r2, r3
801669fc:	e50b3008 	str	r3, [fp, #-8]
80166a00:	e51b3008 	ldr	r3, [fp, #-8]
80166a04:	e1a00003 	mov	r0, r3
80166a08:	ebffe73c 	bl	80160700 <__RME_A7A_Read_Acquire>
80166a0c:	e50b000c 	str	r0, [fp, #-12]
80166a10:	e51b300c 	ldr	r3, [fp, #-12]
80166a14:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166a18:	e3530802 	cmp	r3, #131072	@ 0x20000
80166a1c:	1a000001 	bne	80166a28 <_RME_Prc_Del+0x84>
80166a20:	e3e03008 	mvn	r3, #8
80166a24:	ea0000ac 	b	80166cdc <_RME_Prc_Del+0x338>
80166a28:	e51b300c 	ldr	r3, [fp, #-12]
80166a2c:	e1a03c23 	lsr	r3, r3, #24
80166a30:	e3530003 	cmp	r3, #3
80166a34:	0a00003f 	beq	80166b38 <_RME_Prc_Del+0x194>
80166a38:	e3e03001 	mvn	r3, #1
80166a3c:	ea0000a6 	b	80166cdc <_RME_Prc_Del+0x338>
80166a40:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166a44:	e1a02423 	lsr	r2, r3, #8
80166a48:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166a4c:	e5933014 	ldr	r3, [r3, #20]
80166a50:	e1520003 	cmp	r2, r3
80166a54:	3a000001 	bcc	80166a60 <_RME_Prc_Del+0xbc>
80166a58:	e3e03002 	mvn	r3, #2
80166a5c:	ea00009e 	b	80166cdc <_RME_Prc_Del+0x338>
80166a60:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166a64:	e1a03423 	lsr	r3, r3, #8
80166a68:	e1a02283 	lsl	r2, r3, #5
80166a6c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166a70:	e593300c 	ldr	r3, [r3, #12]
80166a74:	e0823003 	add	r3, r2, r3
80166a78:	e50b3008 	str	r3, [fp, #-8]
80166a7c:	e51b3008 	ldr	r3, [fp, #-8]
80166a80:	e1a00003 	mov	r0, r3
80166a84:	ebffe71d 	bl	80160700 <__RME_A7A_Read_Acquire>
80166a88:	e50b000c 	str	r0, [fp, #-12]
80166a8c:	e51b300c 	ldr	r3, [fp, #-12]
80166a90:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166a94:	e3530802 	cmp	r3, #131072	@ 0x20000
80166a98:	1a000001 	bne	80166aa4 <_RME_Prc_Del+0x100>
80166a9c:	e3e03008 	mvn	r3, #8
80166aa0:	ea00008d 	b	80166cdc <_RME_Prc_Del+0x338>
80166aa4:	e51b300c 	ldr	r3, [fp, #-12]
80166aa8:	e1a03c23 	lsr	r3, r3, #24
80166aac:	e3530003 	cmp	r3, #3
80166ab0:	0a000001 	beq	80166abc <_RME_Prc_Del+0x118>
80166ab4:	e3e03001 	mvn	r3, #1
80166ab8:	ea000087 	b	80166cdc <_RME_Prc_Del+0x338>
80166abc:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166ac0:	e203207f 	and	r2, r3, #127	@ 0x7f
80166ac4:	e51b3008 	ldr	r3, [fp, #-8]
80166ac8:	e5933014 	ldr	r3, [r3, #20]
80166acc:	e1520003 	cmp	r2, r3
80166ad0:	3a000001 	bcc	80166adc <_RME_Prc_Del+0x138>
80166ad4:	e3e03002 	mvn	r3, #2
80166ad8:	ea00007f 	b	80166cdc <_RME_Prc_Del+0x338>
80166adc:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80166ae0:	e203307f 	and	r3, r3, #127	@ 0x7f
80166ae4:	e1a02283 	lsl	r2, r3, #5
80166ae8:	e51b3008 	ldr	r3, [fp, #-8]
80166aec:	e593300c 	ldr	r3, [r3, #12]
80166af0:	e0823003 	add	r3, r2, r3
80166af4:	e50b3008 	str	r3, [fp, #-8]
80166af8:	e51b3008 	ldr	r3, [fp, #-8]
80166afc:	e1a00003 	mov	r0, r3
80166b00:	ebffe6fe 	bl	80160700 <__RME_A7A_Read_Acquire>
80166b04:	e50b000c 	str	r0, [fp, #-12]
80166b08:	e51b300c 	ldr	r3, [fp, #-12]
80166b0c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166b10:	e3530802 	cmp	r3, #131072	@ 0x20000
80166b14:	1a000001 	bne	80166b20 <_RME_Prc_Del+0x17c>
80166b18:	e3e03008 	mvn	r3, #8
80166b1c:	ea00006e 	b	80166cdc <_RME_Prc_Del+0x338>
80166b20:	e51b300c 	ldr	r3, [fp, #-12]
80166b24:	e1a03c23 	lsr	r3, r3, #24
80166b28:	e3530003 	cmp	r3, #3
80166b2c:	0a000001 	beq	80166b38 <_RME_Prc_Del+0x194>
80166b30:	e3e03001 	mvn	r3, #1
80166b34:	ea000068 	b	80166cdc <_RME_Prc_Del+0x338>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_DEL);
80166b38:	e51b3008 	ldr	r3, [fp, #-8]
80166b3c:	e5933008 	ldr	r3, [r3, #8]
80166b40:	e2033002 	and	r3, r3, #2
80166b44:	e3530000 	cmp	r3, #0
80166b48:	1a000001 	bne	80166b54 <_RME_Prc_Del+0x1b0>
80166b4c:	e3e03006 	mvn	r3, #6
80166b50:	ea000061 	b	80166cdc <_RME_Prc_Del+0x338>

    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Prc,struct RME_Cap_Prc*,Prc_Del);
80166b54:	e51b3008 	ldr	r3, [fp, #-8]
80166b58:	e5932014 	ldr	r2, [r3, #20]
80166b5c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80166b60:	e1520003 	cmp	r2, r3
80166b64:	8a000001 	bhi	80166b70 <_RME_Prc_Del+0x1cc>
80166b68:	e3e03002 	mvn	r3, #2
80166b6c:	ea00005a 	b	80166cdc <_RME_Prc_Del+0x338>
80166b70:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80166b74:	e1a02283 	lsl	r2, r3, #5
80166b78:	e51b3008 	ldr	r3, [fp, #-8]
80166b7c:	e593300c 	ldr	r3, [r3, #12]
80166b80:	e0823003 	add	r3, r2, r3
80166b84:	e50b3010 	str	r3, [fp, #-16]
    /* Delete check */
    RME_CAP_DEL_CHECK(Prc_Del,Type_Stat,RME_CAP_TYPE_PRC);
80166b88:	e51b3010 	ldr	r3, [fp, #-16]
80166b8c:	e1a00003 	mov	r0, r3
80166b90:	ebffe6da 	bl	80160700 <__RME_A7A_Read_Acquire>
80166b94:	e50b000c 	str	r0, [fp, #-12]
80166b98:	e51b300c 	ldr	r3, [fp, #-12]
80166b9c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166ba0:	e3530802 	cmp	r3, #131072	@ 0x20000
80166ba4:	0a000001 	beq	80166bb0 <_RME_Prc_Del+0x20c>
80166ba8:	e3e03008 	mvn	r3, #8
80166bac:	ea00004a 	b	80166cdc <_RME_Prc_Del+0x338>
80166bb0:	e51b300c 	ldr	r3, [fp, #-12]
80166bb4:	e1a03c23 	lsr	r3, r3, #24
80166bb8:	e3530005 	cmp	r3, #5
80166bbc:	0a000001 	beq	80166bc8 <_RME_Prc_Del+0x224>
80166bc0:	e3e03001 	mvn	r3, #1
80166bc4:	ea000044 	b	80166cdc <_RME_Prc_Del+0x338>
80166bc8:	e3003000 	movw	r3, #0
80166bcc:	e3483017 	movt	r3, #32791	@ 0x8017
80166bd0:	e5932000 	ldr	r2, [r3]
80166bd4:	e51b3010 	ldr	r3, [fp, #-16]
80166bd8:	e5933010 	ldr	r3, [r3, #16]
80166bdc:	e1a01003 	mov	r1, r3
80166be0:	e1a00002 	mov	r0, r2
80166be4:	ebffe861 	bl	80160d70 <_RME_Diff>
80166be8:	e1a03000 	mov	r3, r0
80166bec:	e353000a 	cmp	r3, #10
80166bf0:	8a000001 	bhi	80166bfc <_RME_Prc_Del+0x258>
80166bf4:	e3e03007 	mvn	r3, #7
80166bf8:	ea000037 	b	80166cdc <_RME_Prc_Del+0x338>
80166bfc:	e51b3010 	ldr	r3, [fp, #-16]
80166c00:	e5933004 	ldr	r3, [r3, #4]
80166c04:	e3530000 	cmp	r3, #0
80166c08:	0a00000b 	beq	80166c3c <_RME_Prc_Del+0x298>
80166c0c:	e51b300c 	ldr	r3, [fp, #-12]
80166c10:	e6ff3073 	uxth	r3, r3
80166c14:	e3530000 	cmp	r3, #0
80166c18:	1a000005 	bne	80166c34 <_RME_Prc_Del+0x290>
80166c1c:	e51b0010 	ldr	r0, [fp, #-16]
80166c20:	e51b300c 	ldr	r3, [fp, #-12]
80166c24:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
80166c28:	e1a02003 	mov	r2, r3
80166c2c:	e51b100c 	ldr	r1, [fp, #-12]
80166c30:	ebffe7e1 	bl	80160bbc <_RME_Comp_Swap_Single>
80166c34:	e3e03005 	mvn	r3, #5
80166c38:	ea000027 	b	80166cdc <_RME_Prc_Del+0x338>
80166c3c:	e51b300c 	ldr	r3, [fp, #-12]
80166c40:	e6ff3073 	uxth	r3, r3
80166c44:	e3530000 	cmp	r3, #0
80166c48:	0a000008 	beq	80166c70 <_RME_Prc_Del+0x2cc>
80166c4c:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
80166c50:	e3483016 	movt	r3, #32790	@ 0x8016
80166c54:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
80166c58:	e3482016 	movt	r2, #32790	@ 0x8016
80166c5c:	e301133a 	movw	r1, #4922	@ 0x133a
80166c60:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
80166c64:	e3480016 	movt	r0, #32790	@ 0x8016
80166c68:	ebffe7c8 	bl	80160b90 <RME_Log>
80166c6c:	eafffffe 	b	80166c6c <_RME_Prc_Del+0x2c8>

    /* Remember for deletion */
    Prc_Cpt=Prc_Del->Cpt;
80166c70:	e51b3010 	ldr	r3, [fp, #-16]
80166c74:	e5933014 	ldr	r3, [r3, #20]
80166c78:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
#if(RME_PGT_RAW_ENABLE==0U)
    Prc_Pgt=Prc_Del->Pgt;
80166c7c:	e51b3010 	ldr	r3, [fp, #-16]
80166c80:	e5933018 	ldr	r3, [r3, #24]
80166c84:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
#endif

    /* Now we can safely delete the cap */
    RME_CAP_DELETE(Prc_Del,Type_Stat);
80166c88:	e51b3010 	ldr	r3, [fp, #-16]
80166c8c:	e3a02000 	mov	r2, #0
80166c90:	e51b100c 	ldr	r1, [fp, #-12]
80166c94:	e1a00003 	mov	r0, r3
80166c98:	ebffe7c7 	bl	80160bbc <_RME_Comp_Swap_Single>
80166c9c:	e1a03000 	mov	r3, r0
80166ca0:	e3530000 	cmp	r3, #0
80166ca4:	1a000001 	bne	80166cb0 <_RME_Prc_Del+0x30c>
80166ca8:	e3e03000 	mvn	r3, #0
80166cac:	ea00000a 	b	80166cdc <_RME_Prc_Del+0x338>

    /* Dereference caps */
    RME_FETCH_ADD(&(Prc_Cpt->Head.Root_Ref),-1);
80166cb0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80166cb4:	e2833004 	add	r3, r3, #4
80166cb8:	e3e01000 	mvn	r1, #0
80166cbc:	e1a00003 	mov	r0, r3
80166cc0:	ebffe7d2 	bl	80160c10 <_RME_Fetch_Add_Single>
#if(RME_PGT_RAW_ENABLE==0U)
    RME_FETCH_ADD(&(Prc_Pgt->Head.Root_Ref),-1);
80166cc4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166cc8:	e2833004 	add	r3, r3, #4
80166ccc:	e3e01000 	mvn	r1, #0
80166cd0:	e1a00003 	mov	r0, r3
80166cd4:	ebffe7cd 	bl	80160c10 <_RME_Fetch_Add_Single>
#endif
    
    return 0;
80166cd8:	e3a03000 	mov	r3, #0
}
80166cdc:	e1a00003 	mov	r0, r3
80166ce0:	e24bd004 	sub	sp, fp, #4
80166ce4:	e8bd8800 	pop	{fp, pc}

80166ce8 <_RME_Prc_Cpt>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Prc_Cpt(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Prc,
                              rme_cid_t Cap_Cpt)
{
80166ce8:	e92d4800 	push	{fp, lr}
80166cec:	e28db004 	add	fp, sp, #4
80166cf0:	e24dd020 	sub	sp, sp, #32
80166cf4:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80166cf8:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
80166cfc:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    struct RME_Cap_Cpt* Cpt_New;
    struct RME_Cap_Cpt* Cpt_Old;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Prc,RME_CAP_TYPE_PRC,
80166d00:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80166d04:	e2033080 	and	r3, r3, #128	@ 0x80
80166d08:	e3530000 	cmp	r3, #0
80166d0c:	1a00001c 	bne	80166d84 <_RME_Prc_Cpt+0x9c>
80166d10:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166d14:	e5932014 	ldr	r2, [r3, #20]
80166d18:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80166d1c:	e1520003 	cmp	r2, r3
80166d20:	8a000001 	bhi	80166d2c <_RME_Prc_Cpt+0x44>
80166d24:	e3e03002 	mvn	r3, #2
80166d28:	ea0000e3 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166d2c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80166d30:	e1a02283 	lsl	r2, r3, #5
80166d34:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166d38:	e593300c 	ldr	r3, [r3, #12]
80166d3c:	e0823003 	add	r3, r2, r3
80166d40:	e50b3008 	str	r3, [fp, #-8]
80166d44:	e51b3008 	ldr	r3, [fp, #-8]
80166d48:	e1a00003 	mov	r0, r3
80166d4c:	ebffe66b 	bl	80160700 <__RME_A7A_Read_Acquire>
80166d50:	e50b0010 	str	r0, [fp, #-16]
80166d54:	e51b3010 	ldr	r3, [fp, #-16]
80166d58:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166d5c:	e3530802 	cmp	r3, #131072	@ 0x20000
80166d60:	1a000001 	bne	80166d6c <_RME_Prc_Cpt+0x84>
80166d64:	e3e03008 	mvn	r3, #8
80166d68:	ea0000d3 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166d6c:	e51b3010 	ldr	r3, [fp, #-16]
80166d70:	e1a03c23 	lsr	r3, r3, #24
80166d74:	e3530005 	cmp	r3, #5
80166d78:	0a00003f 	beq	80166e7c <_RME_Prc_Cpt+0x194>
80166d7c:	e3e03001 	mvn	r3, #1
80166d80:	ea0000cd 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166d84:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80166d88:	e1a02423 	lsr	r2, r3, #8
80166d8c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166d90:	e5933014 	ldr	r3, [r3, #20]
80166d94:	e1520003 	cmp	r2, r3
80166d98:	3a000001 	bcc	80166da4 <_RME_Prc_Cpt+0xbc>
80166d9c:	e3e03002 	mvn	r3, #2
80166da0:	ea0000c5 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166da4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80166da8:	e1a03423 	lsr	r3, r3, #8
80166dac:	e1a02283 	lsl	r2, r3, #5
80166db0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166db4:	e593300c 	ldr	r3, [r3, #12]
80166db8:	e0823003 	add	r3, r2, r3
80166dbc:	e50b3008 	str	r3, [fp, #-8]
80166dc0:	e51b3008 	ldr	r3, [fp, #-8]
80166dc4:	e1a00003 	mov	r0, r3
80166dc8:	ebffe64c 	bl	80160700 <__RME_A7A_Read_Acquire>
80166dcc:	e50b0010 	str	r0, [fp, #-16]
80166dd0:	e51b3010 	ldr	r3, [fp, #-16]
80166dd4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166dd8:	e3530802 	cmp	r3, #131072	@ 0x20000
80166ddc:	1a000001 	bne	80166de8 <_RME_Prc_Cpt+0x100>
80166de0:	e3e03008 	mvn	r3, #8
80166de4:	ea0000b4 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166de8:	e51b3010 	ldr	r3, [fp, #-16]
80166dec:	e1a03c23 	lsr	r3, r3, #24
80166df0:	e3530003 	cmp	r3, #3
80166df4:	0a000001 	beq	80166e00 <_RME_Prc_Cpt+0x118>
80166df8:	e3e03001 	mvn	r3, #1
80166dfc:	ea0000ae 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166e00:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80166e04:	e203207f 	and	r2, r3, #127	@ 0x7f
80166e08:	e51b3008 	ldr	r3, [fp, #-8]
80166e0c:	e5933014 	ldr	r3, [r3, #20]
80166e10:	e1520003 	cmp	r2, r3
80166e14:	3a000001 	bcc	80166e20 <_RME_Prc_Cpt+0x138>
80166e18:	e3e03002 	mvn	r3, #2
80166e1c:	ea0000a6 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166e20:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80166e24:	e203307f 	and	r3, r3, #127	@ 0x7f
80166e28:	e1a02283 	lsl	r2, r3, #5
80166e2c:	e51b3008 	ldr	r3, [fp, #-8]
80166e30:	e593300c 	ldr	r3, [r3, #12]
80166e34:	e0823003 	add	r3, r2, r3
80166e38:	e50b3008 	str	r3, [fp, #-8]
80166e3c:	e51b3008 	ldr	r3, [fp, #-8]
80166e40:	e1a00003 	mov	r0, r3
80166e44:	ebffe62d 	bl	80160700 <__RME_A7A_Read_Acquire>
80166e48:	e50b0010 	str	r0, [fp, #-16]
80166e4c:	e51b3010 	ldr	r3, [fp, #-16]
80166e50:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166e54:	e3530802 	cmp	r3, #131072	@ 0x20000
80166e58:	1a000001 	bne	80166e64 <_RME_Prc_Cpt+0x17c>
80166e5c:	e3e03008 	mvn	r3, #8
80166e60:	ea000095 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166e64:	e51b3010 	ldr	r3, [fp, #-16]
80166e68:	e1a03c23 	lsr	r3, r3, #24
80166e6c:	e3530005 	cmp	r3, #5
80166e70:	0a000001 	beq	80166e7c <_RME_Prc_Cpt+0x194>
80166e74:	e3e03001 	mvn	r3, #1
80166e78:	ea00008f 	b	801670bc <_RME_Prc_Cpt+0x3d4>
                   struct RME_Cap_Prc*,Prc_Op,Type_Stat); 
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
80166e7c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166e80:	e2033080 	and	r3, r3, #128	@ 0x80
80166e84:	e3530000 	cmp	r3, #0
80166e88:	1a00001c 	bne	80166f00 <_RME_Prc_Cpt+0x218>
80166e8c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166e90:	e5932014 	ldr	r2, [r3, #20]
80166e94:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166e98:	e1520003 	cmp	r2, r3
80166e9c:	8a000001 	bhi	80166ea8 <_RME_Prc_Cpt+0x1c0>
80166ea0:	e3e03002 	mvn	r3, #2
80166ea4:	ea000084 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166ea8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166eac:	e1a02283 	lsl	r2, r3, #5
80166eb0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166eb4:	e593300c 	ldr	r3, [r3, #12]
80166eb8:	e0823003 	add	r3, r2, r3
80166ebc:	e50b300c 	str	r3, [fp, #-12]
80166ec0:	e51b300c 	ldr	r3, [fp, #-12]
80166ec4:	e1a00003 	mov	r0, r3
80166ec8:	ebffe60c 	bl	80160700 <__RME_A7A_Read_Acquire>
80166ecc:	e50b0010 	str	r0, [fp, #-16]
80166ed0:	e51b3010 	ldr	r3, [fp, #-16]
80166ed4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166ed8:	e3530802 	cmp	r3, #131072	@ 0x20000
80166edc:	1a000001 	bne	80166ee8 <_RME_Prc_Cpt+0x200>
80166ee0:	e3e03008 	mvn	r3, #8
80166ee4:	ea000074 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166ee8:	e51b3010 	ldr	r3, [fp, #-16]
80166eec:	e1a03c23 	lsr	r3, r3, #24
80166ef0:	e3530003 	cmp	r3, #3
80166ef4:	0a00003f 	beq	80166ff8 <_RME_Prc_Cpt+0x310>
80166ef8:	e3e03001 	mvn	r3, #1
80166efc:	ea00006e 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166f00:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166f04:	e1a02423 	lsr	r2, r3, #8
80166f08:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166f0c:	e5933014 	ldr	r3, [r3, #20]
80166f10:	e1520003 	cmp	r2, r3
80166f14:	3a000001 	bcc	80166f20 <_RME_Prc_Cpt+0x238>
80166f18:	e3e03002 	mvn	r3, #2
80166f1c:	ea000066 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166f20:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166f24:	e1a03423 	lsr	r3, r3, #8
80166f28:	e1a02283 	lsl	r2, r3, #5
80166f2c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80166f30:	e593300c 	ldr	r3, [r3, #12]
80166f34:	e0823003 	add	r3, r2, r3
80166f38:	e50b300c 	str	r3, [fp, #-12]
80166f3c:	e51b300c 	ldr	r3, [fp, #-12]
80166f40:	e1a00003 	mov	r0, r3
80166f44:	ebffe5ed 	bl	80160700 <__RME_A7A_Read_Acquire>
80166f48:	e50b0010 	str	r0, [fp, #-16]
80166f4c:	e51b3010 	ldr	r3, [fp, #-16]
80166f50:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166f54:	e3530802 	cmp	r3, #131072	@ 0x20000
80166f58:	1a000001 	bne	80166f64 <_RME_Prc_Cpt+0x27c>
80166f5c:	e3e03008 	mvn	r3, #8
80166f60:	ea000055 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166f64:	e51b3010 	ldr	r3, [fp, #-16]
80166f68:	e1a03c23 	lsr	r3, r3, #24
80166f6c:	e3530003 	cmp	r3, #3
80166f70:	0a000001 	beq	80166f7c <_RME_Prc_Cpt+0x294>
80166f74:	e3e03001 	mvn	r3, #1
80166f78:	ea00004f 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166f7c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166f80:	e203207f 	and	r2, r3, #127	@ 0x7f
80166f84:	e51b300c 	ldr	r3, [fp, #-12]
80166f88:	e5933014 	ldr	r3, [r3, #20]
80166f8c:	e1520003 	cmp	r2, r3
80166f90:	3a000001 	bcc	80166f9c <_RME_Prc_Cpt+0x2b4>
80166f94:	e3e03002 	mvn	r3, #2
80166f98:	ea000047 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166f9c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80166fa0:	e203307f 	and	r3, r3, #127	@ 0x7f
80166fa4:	e1a02283 	lsl	r2, r3, #5
80166fa8:	e51b300c 	ldr	r3, [fp, #-12]
80166fac:	e593300c 	ldr	r3, [r3, #12]
80166fb0:	e0823003 	add	r3, r2, r3
80166fb4:	e50b300c 	str	r3, [fp, #-12]
80166fb8:	e51b300c 	ldr	r3, [fp, #-12]
80166fbc:	e1a00003 	mov	r0, r3
80166fc0:	ebffe5ce 	bl	80160700 <__RME_A7A_Read_Acquire>
80166fc4:	e50b0010 	str	r0, [fp, #-16]
80166fc8:	e51b3010 	ldr	r3, [fp, #-16]
80166fcc:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80166fd0:	e3530802 	cmp	r3, #131072	@ 0x20000
80166fd4:	1a000001 	bne	80166fe0 <_RME_Prc_Cpt+0x2f8>
80166fd8:	e3e03008 	mvn	r3, #8
80166fdc:	ea000036 	b	801670bc <_RME_Prc_Cpt+0x3d4>
80166fe0:	e51b3010 	ldr	r3, [fp, #-16]
80166fe4:	e1a03c23 	lsr	r3, r3, #24
80166fe8:	e3530003 	cmp	r3, #3
80166fec:	0a000001 	beq	80166ff8 <_RME_Prc_Cpt+0x310>
80166ff0:	e3e03001 	mvn	r3, #1
80166ff4:	ea000030 	b	801670bc <_RME_Prc_Cpt+0x3d4>
                   struct RME_Cap_Cpt*,Cpt_New,Type_Stat);     
    /* Check if the target caps is not frozen and allows such operations */
    RME_CAP_CHECK(Prc_Op,RME_PRC_FLAG_CPT);
80166ff8:	e51b3008 	ldr	r3, [fp, #-8]
80166ffc:	e5933008 	ldr	r3, [r3, #8]
80167000:	e2033004 	and	r3, r3, #4
80167004:	e3530000 	cmp	r3, #0
80167008:	1a000001 	bne	80167014 <_RME_Prc_Cpt+0x32c>
8016700c:	e3e03006 	mvn	r3, #6
80167010:	ea000029 	b	801670bc <_RME_Prc_Cpt+0x3d4>
    RME_CAP_CHECK(Cpt_New,RME_CPT_FLAG_PRC_CPT);
80167014:	e51b300c 	ldr	r3, [fp, #-12]
80167018:	e5933008 	ldr	r3, [r3, #8]
8016701c:	e2033080 	and	r3, r3, #128	@ 0x80
80167020:	e3530000 	cmp	r3, #0
80167024:	1a000001 	bne	80167030 <_RME_Prc_Cpt+0x348>
80167028:	e3e03006 	mvn	r3, #6
8016702c:	ea000022 	b	801670bc <_RME_Prc_Cpt+0x3d4>
    
    /* Convert to root */
    Cpt_New=RME_CAP_CONV_ROOT(Cpt_New,struct RME_Cap_Cpt*);
80167030:	e51b300c 	ldr	r3, [fp, #-12]
80167034:	e5933000 	ldr	r3, [r3]
80167038:	e6ff3073 	uxth	r3, r3
8016703c:	e3530000 	cmp	r3, #0
80167040:	0a000002 	beq	80167050 <_RME_Prc_Cpt+0x368>
80167044:	e51b300c 	ldr	r3, [fp, #-12]
80167048:	e5933004 	ldr	r3, [r3, #4]
8016704c:	ea000000 	b	80167054 <_RME_Prc_Cpt+0x36c>
80167050:	e51b300c 	ldr	r3, [fp, #-12]
80167054:	e50b300c 	str	r3, [fp, #-12]
    
    /* Commit the change */
    Cpt_Old=Prc_Op->Cpt;
80167058:	e51b3008 	ldr	r3, [fp, #-8]
8016705c:	e5933014 	ldr	r3, [r3, #20]
80167060:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    if(RME_COMP_SWAP((rme_ptr_t*)(&(Prc_Op->Cpt)),
80167064:	e51b3008 	ldr	r3, [fp, #-8]
80167068:	e2833014 	add	r3, r3, #20
8016706c:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
80167070:	e51b200c 	ldr	r2, [fp, #-12]
80167074:	e1a00003 	mov	r0, r3
80167078:	ebffe6cf 	bl	80160bbc <_RME_Comp_Swap_Single>
8016707c:	e1a03000 	mov	r3, r0
80167080:	e3530000 	cmp	r3, #0
80167084:	1a000001 	bne	80167090 <_RME_Prc_Cpt+0x3a8>
                     (rme_ptr_t)Cpt_Old,(rme_ptr_t)Cpt_New)==RME_CASFAIL)
    {
        RME_COV_MARKER();
        
        return RME_ERR_PTH_CONFLICT;
80167088:	e3e030c9 	mvn	r3, #201	@ 0xc9
8016708c:	ea00000a 	b	801670bc <_RME_Prc_Cpt+0x3d4>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Reference new table and dereference the old table */
    RME_FETCH_ADD(&(Cpt_New->Head.Root_Ref),1);
80167090:	e51b300c 	ldr	r3, [fp, #-12]
80167094:	e2833004 	add	r3, r3, #4
80167098:	e3a01001 	mov	r1, #1
8016709c:	e1a00003 	mov	r0, r3
801670a0:	ebffe6da 	bl	80160c10 <_RME_Fetch_Add_Single>
    RME_FETCH_ADD(&(Cpt_Old->Head.Root_Ref),-1);
801670a4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801670a8:	e2833004 	add	r3, r3, #4
801670ac:	e3e01000 	mvn	r1, #0
801670b0:	e1a00003 	mov	r0, r3
801670b4:	ebffe6d5 	bl	80160c10 <_RME_Fetch_Add_Single>

    return 0;
801670b8:	e3a03000 	mov	r3, #0
}
801670bc:	e1a00003 	mov	r0, r3
801670c0:	e24bd004 	sub	sp, fp, #4
801670c4:	e8bd8800 	pop	{fp, pc}

801670c8 <_RME_Prc_Pgt>:
#else
static rme_ret_t _RME_Prc_Pgt(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Prc,
                              rme_ptr_t Raw_Pgt)
#endif
{
801670c8:	e92d4800 	push	{fp, lr}
801670cc:	e28db004 	add	fp, sp, #4
801670d0:	e24dd020 	sub	sp, sp, #32
801670d4:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
801670d8:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
801670dc:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    rme_ptr_t Pgt_Old;
#endif
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Prc,RME_CAP_TYPE_PRC,
801670e0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801670e4:	e2033080 	and	r3, r3, #128	@ 0x80
801670e8:	e3530000 	cmp	r3, #0
801670ec:	1a00001c 	bne	80167164 <_RME_Prc_Pgt+0x9c>
801670f0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801670f4:	e5932014 	ldr	r2, [r3, #20]
801670f8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801670fc:	e1520003 	cmp	r2, r3
80167100:	8a000001 	bhi	8016710c <_RME_Prc_Pgt+0x44>
80167104:	e3e03002 	mvn	r3, #2
80167108:	ea0000e3 	b	8016749c <_RME_Prc_Pgt+0x3d4>
8016710c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80167110:	e1a02283 	lsl	r2, r3, #5
80167114:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167118:	e593300c 	ldr	r3, [r3, #12]
8016711c:	e0823003 	add	r3, r2, r3
80167120:	e50b3008 	str	r3, [fp, #-8]
80167124:	e51b3008 	ldr	r3, [fp, #-8]
80167128:	e1a00003 	mov	r0, r3
8016712c:	ebffe573 	bl	80160700 <__RME_A7A_Read_Acquire>
80167130:	e50b0010 	str	r0, [fp, #-16]
80167134:	e51b3010 	ldr	r3, [fp, #-16]
80167138:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016713c:	e3530802 	cmp	r3, #131072	@ 0x20000
80167140:	1a000001 	bne	8016714c <_RME_Prc_Pgt+0x84>
80167144:	e3e03008 	mvn	r3, #8
80167148:	ea0000d3 	b	8016749c <_RME_Prc_Pgt+0x3d4>
8016714c:	e51b3010 	ldr	r3, [fp, #-16]
80167150:	e1a03c23 	lsr	r3, r3, #24
80167154:	e3530005 	cmp	r3, #5
80167158:	0a00003f 	beq	8016725c <_RME_Prc_Pgt+0x194>
8016715c:	e3e03001 	mvn	r3, #1
80167160:	ea0000cd 	b	8016749c <_RME_Prc_Pgt+0x3d4>
80167164:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80167168:	e1a02423 	lsr	r2, r3, #8
8016716c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167170:	e5933014 	ldr	r3, [r3, #20]
80167174:	e1520003 	cmp	r2, r3
80167178:	3a000001 	bcc	80167184 <_RME_Prc_Pgt+0xbc>
8016717c:	e3e03002 	mvn	r3, #2
80167180:	ea0000c5 	b	8016749c <_RME_Prc_Pgt+0x3d4>
80167184:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80167188:	e1a03423 	lsr	r3, r3, #8
8016718c:	e1a02283 	lsl	r2, r3, #5
80167190:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167194:	e593300c 	ldr	r3, [r3, #12]
80167198:	e0823003 	add	r3, r2, r3
8016719c:	e50b3008 	str	r3, [fp, #-8]
801671a0:	e51b3008 	ldr	r3, [fp, #-8]
801671a4:	e1a00003 	mov	r0, r3
801671a8:	ebffe554 	bl	80160700 <__RME_A7A_Read_Acquire>
801671ac:	e50b0010 	str	r0, [fp, #-16]
801671b0:	e51b3010 	ldr	r3, [fp, #-16]
801671b4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801671b8:	e3530802 	cmp	r3, #131072	@ 0x20000
801671bc:	1a000001 	bne	801671c8 <_RME_Prc_Pgt+0x100>
801671c0:	e3e03008 	mvn	r3, #8
801671c4:	ea0000b4 	b	8016749c <_RME_Prc_Pgt+0x3d4>
801671c8:	e51b3010 	ldr	r3, [fp, #-16]
801671cc:	e1a03c23 	lsr	r3, r3, #24
801671d0:	e3530003 	cmp	r3, #3
801671d4:	0a000001 	beq	801671e0 <_RME_Prc_Pgt+0x118>
801671d8:	e3e03001 	mvn	r3, #1
801671dc:	ea0000ae 	b	8016749c <_RME_Prc_Pgt+0x3d4>
801671e0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801671e4:	e203207f 	and	r2, r3, #127	@ 0x7f
801671e8:	e51b3008 	ldr	r3, [fp, #-8]
801671ec:	e5933014 	ldr	r3, [r3, #20]
801671f0:	e1520003 	cmp	r2, r3
801671f4:	3a000001 	bcc	80167200 <_RME_Prc_Pgt+0x138>
801671f8:	e3e03002 	mvn	r3, #2
801671fc:	ea0000a6 	b	8016749c <_RME_Prc_Pgt+0x3d4>
80167200:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80167204:	e203307f 	and	r3, r3, #127	@ 0x7f
80167208:	e1a02283 	lsl	r2, r3, #5
8016720c:	e51b3008 	ldr	r3, [fp, #-8]
80167210:	e593300c 	ldr	r3, [r3, #12]
80167214:	e0823003 	add	r3, r2, r3
80167218:	e50b3008 	str	r3, [fp, #-8]
8016721c:	e51b3008 	ldr	r3, [fp, #-8]
80167220:	e1a00003 	mov	r0, r3
80167224:	ebffe535 	bl	80160700 <__RME_A7A_Read_Acquire>
80167228:	e50b0010 	str	r0, [fp, #-16]
8016722c:	e51b3010 	ldr	r3, [fp, #-16]
80167230:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80167234:	e3530802 	cmp	r3, #131072	@ 0x20000
80167238:	1a000001 	bne	80167244 <_RME_Prc_Pgt+0x17c>
8016723c:	e3e03008 	mvn	r3, #8
80167240:	ea000095 	b	8016749c <_RME_Prc_Pgt+0x3d4>
80167244:	e51b3010 	ldr	r3, [fp, #-16]
80167248:	e1a03c23 	lsr	r3, r3, #24
8016724c:	e3530005 	cmp	r3, #5
80167250:	0a000001 	beq	8016725c <_RME_Prc_Pgt+0x194>
80167254:	e3e03001 	mvn	r3, #1
80167258:	ea00008f 	b	8016749c <_RME_Prc_Pgt+0x3d4>
                   struct RME_Cap_Prc*,Prc_Op,Type_Stat); 
#if(RME_PGT_RAW_ENABLE==0U)
    RME_CPT_GETCAP(Cpt,Cap_Pgt,RME_CAP_TYPE_PGT,
8016725c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167260:	e2033080 	and	r3, r3, #128	@ 0x80
80167264:	e3530000 	cmp	r3, #0
80167268:	1a00001c 	bne	801672e0 <_RME_Prc_Pgt+0x218>
8016726c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167270:	e5932014 	ldr	r2, [r3, #20]
80167274:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167278:	e1520003 	cmp	r2, r3
8016727c:	8a000001 	bhi	80167288 <_RME_Prc_Pgt+0x1c0>
80167280:	e3e03002 	mvn	r3, #2
80167284:	ea000084 	b	8016749c <_RME_Prc_Pgt+0x3d4>
80167288:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016728c:	e1a02283 	lsl	r2, r3, #5
80167290:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167294:	e593300c 	ldr	r3, [r3, #12]
80167298:	e0823003 	add	r3, r2, r3
8016729c:	e50b300c 	str	r3, [fp, #-12]
801672a0:	e51b300c 	ldr	r3, [fp, #-12]
801672a4:	e1a00003 	mov	r0, r3
801672a8:	ebffe514 	bl	80160700 <__RME_A7A_Read_Acquire>
801672ac:	e50b0010 	str	r0, [fp, #-16]
801672b0:	e51b3010 	ldr	r3, [fp, #-16]
801672b4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801672b8:	e3530802 	cmp	r3, #131072	@ 0x20000
801672bc:	1a000001 	bne	801672c8 <_RME_Prc_Pgt+0x200>
801672c0:	e3e03008 	mvn	r3, #8
801672c4:	ea000074 	b	8016749c <_RME_Prc_Pgt+0x3d4>
801672c8:	e51b3010 	ldr	r3, [fp, #-16]
801672cc:	e1a03c23 	lsr	r3, r3, #24
801672d0:	e3530004 	cmp	r3, #4
801672d4:	0a00003f 	beq	801673d8 <_RME_Prc_Pgt+0x310>
801672d8:	e3e03001 	mvn	r3, #1
801672dc:	ea00006e 	b	8016749c <_RME_Prc_Pgt+0x3d4>
801672e0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801672e4:	e1a02423 	lsr	r2, r3, #8
801672e8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801672ec:	e5933014 	ldr	r3, [r3, #20]
801672f0:	e1520003 	cmp	r2, r3
801672f4:	3a000001 	bcc	80167300 <_RME_Prc_Pgt+0x238>
801672f8:	e3e03002 	mvn	r3, #2
801672fc:	ea000066 	b	8016749c <_RME_Prc_Pgt+0x3d4>
80167300:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167304:	e1a03423 	lsr	r3, r3, #8
80167308:	e1a02283 	lsl	r2, r3, #5
8016730c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167310:	e593300c 	ldr	r3, [r3, #12]
80167314:	e0823003 	add	r3, r2, r3
80167318:	e50b300c 	str	r3, [fp, #-12]
8016731c:	e51b300c 	ldr	r3, [fp, #-12]
80167320:	e1a00003 	mov	r0, r3
80167324:	ebffe4f5 	bl	80160700 <__RME_A7A_Read_Acquire>
80167328:	e50b0010 	str	r0, [fp, #-16]
8016732c:	e51b3010 	ldr	r3, [fp, #-16]
80167330:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80167334:	e3530802 	cmp	r3, #131072	@ 0x20000
80167338:	1a000001 	bne	80167344 <_RME_Prc_Pgt+0x27c>
8016733c:	e3e03008 	mvn	r3, #8
80167340:	ea000055 	b	8016749c <_RME_Prc_Pgt+0x3d4>
80167344:	e51b3010 	ldr	r3, [fp, #-16]
80167348:	e1a03c23 	lsr	r3, r3, #24
8016734c:	e3530003 	cmp	r3, #3
80167350:	0a000001 	beq	8016735c <_RME_Prc_Pgt+0x294>
80167354:	e3e03001 	mvn	r3, #1
80167358:	ea00004f 	b	8016749c <_RME_Prc_Pgt+0x3d4>
8016735c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167360:	e203207f 	and	r2, r3, #127	@ 0x7f
80167364:	e51b300c 	ldr	r3, [fp, #-12]
80167368:	e5933014 	ldr	r3, [r3, #20]
8016736c:	e1520003 	cmp	r2, r3
80167370:	3a000001 	bcc	8016737c <_RME_Prc_Pgt+0x2b4>
80167374:	e3e03002 	mvn	r3, #2
80167378:	ea000047 	b	8016749c <_RME_Prc_Pgt+0x3d4>
8016737c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167380:	e203307f 	and	r3, r3, #127	@ 0x7f
80167384:	e1a02283 	lsl	r2, r3, #5
80167388:	e51b300c 	ldr	r3, [fp, #-12]
8016738c:	e593300c 	ldr	r3, [r3, #12]
80167390:	e0823003 	add	r3, r2, r3
80167394:	e50b300c 	str	r3, [fp, #-12]
80167398:	e51b300c 	ldr	r3, [fp, #-12]
8016739c:	e1a00003 	mov	r0, r3
801673a0:	ebffe4d6 	bl	80160700 <__RME_A7A_Read_Acquire>
801673a4:	e50b0010 	str	r0, [fp, #-16]
801673a8:	e51b3010 	ldr	r3, [fp, #-16]
801673ac:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801673b0:	e3530802 	cmp	r3, #131072	@ 0x20000
801673b4:	1a000001 	bne	801673c0 <_RME_Prc_Pgt+0x2f8>
801673b8:	e3e03008 	mvn	r3, #8
801673bc:	ea000036 	b	8016749c <_RME_Prc_Pgt+0x3d4>
801673c0:	e51b3010 	ldr	r3, [fp, #-16]
801673c4:	e1a03c23 	lsr	r3, r3, #24
801673c8:	e3530004 	cmp	r3, #4
801673cc:	0a000001 	beq	801673d8 <_RME_Prc_Pgt+0x310>
801673d0:	e3e03001 	mvn	r3, #1
801673d4:	ea000030 	b	8016749c <_RME_Prc_Pgt+0x3d4>
                   struct RME_Cap_Pgt*,Pgt_New,Type_Stat);
#endif
    /* Check if the target caps is not frozen and allows such operations */
    RME_CAP_CHECK(Prc_Op,RME_PRC_FLAG_PGT);
801673d8:	e51b3008 	ldr	r3, [fp, #-8]
801673dc:	e5933008 	ldr	r3, [r3, #8]
801673e0:	e2033008 	and	r3, r3, #8
801673e4:	e3530000 	cmp	r3, #0
801673e8:	1a000001 	bne	801673f4 <_RME_Prc_Pgt+0x32c>
801673ec:	e3e03006 	mvn	r3, #6
801673f0:	ea000029 	b	8016749c <_RME_Prc_Pgt+0x3d4>
#if(RME_PGT_RAW_ENABLE==0U)
    RME_CAP_CHECK(Pgt_New,RME_PGT_FLAG_PRC_PGT);
801673f4:	e51b300c 	ldr	r3, [fp, #-12]
801673f8:	e5933008 	ldr	r3, [r3, #8]
801673fc:	e2033080 	and	r3, r3, #128	@ 0x80
80167400:	e3530000 	cmp	r3, #0
80167404:	1a000001 	bne	80167410 <_RME_Prc_Pgt+0x348>
80167408:	e3e03006 	mvn	r3, #6
8016740c:	ea000022 	b	8016749c <_RME_Prc_Pgt+0x3d4>
#endif
    
    Pgt_Old=Prc_Op->Pgt;
80167410:	e51b3008 	ldr	r3, [fp, #-8]
80167414:	e5933018 	ldr	r3, [r3, #24]
80167418:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    
#if(RME_PGT_RAW_ENABLE==0U)
    /* Convert to root */
    Pgt_New=RME_CAP_CONV_ROOT(Pgt_New,struct RME_Cap_Pgt*);
8016741c:	e51b300c 	ldr	r3, [fp, #-12]
80167420:	e5933000 	ldr	r3, [r3]
80167424:	e6ff3073 	uxth	r3, r3
80167428:	e3530000 	cmp	r3, #0
8016742c:	0a000002 	beq	8016743c <_RME_Prc_Pgt+0x374>
80167430:	e51b300c 	ldr	r3, [fp, #-12]
80167434:	e5933004 	ldr	r3, [r3, #4]
80167438:	ea000000 	b	80167440 <_RME_Prc_Pgt+0x378>
8016743c:	e51b300c 	ldr	r3, [fp, #-12]
80167440:	e50b300c 	str	r3, [fp, #-12]
    /* Actually commit the change */
    if(RME_COMP_SWAP((rme_ptr_t*)(&(Prc_Op->Pgt)),
80167444:	e51b3008 	ldr	r3, [fp, #-8]
80167448:	e2833018 	add	r3, r3, #24
8016744c:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
80167450:	e51b200c 	ldr	r2, [fp, #-12]
80167454:	e1a00003 	mov	r0, r3
80167458:	ebffe5d7 	bl	80160bbc <_RME_Comp_Swap_Single>
8016745c:	e1a03000 	mov	r3, r0
80167460:	e3530000 	cmp	r3, #0
80167464:	1a000001 	bne	80167470 <_RME_Prc_Pgt+0x3a8>
                     Raw_Pgt)==RME_CASFAIL)
#endif
    {
        RME_COV_MARKER();
        
        return RME_ERR_PTH_CONFLICT;
80167468:	e3e030c9 	mvn	r3, #201	@ 0xc9
8016746c:	ea00000a 	b	8016749c <_RME_Prc_Pgt+0x3d4>
        /* No action required */
    }
    
    /* Reference new table and dereference the old table */
#if(RME_PGT_RAW_ENABLE==0U)
    RME_FETCH_ADD(&(Pgt_New->Head.Root_Ref),1);
80167470:	e51b300c 	ldr	r3, [fp, #-12]
80167474:	e2833004 	add	r3, r3, #4
80167478:	e3a01001 	mov	r1, #1
8016747c:	e1a00003 	mov	r0, r3
80167480:	ebffe5e2 	bl	80160c10 <_RME_Fetch_Add_Single>
    RME_FETCH_ADD(&(Pgt_Old->Head.Root_Ref),-1);
80167484:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167488:	e2833004 	add	r3, r3, #4
8016748c:	e3e01000 	mvn	r1, #0
80167490:	e1a00003 	mov	r0, r3
80167494:	ebffe5dd 	bl	80160c10 <_RME_Fetch_Add_Single>
#endif
    
    return 0;
80167498:	e3a03000 	mov	r3, #0
}
8016749c:	e1a00003 	mov	r0, r3
801674a0:	e24bd004 	sub	sp, fp, #4
801674a4:	e8bd8800 	pop	{fp, pc}

801674a8 <_RME_Thd_Boot_Crt>:
                            rme_cid_t Cap_Thd,
                            rme_cid_t Cap_Prc,
                            rme_ptr_t Vaddr,
                            rme_ptr_t Prio,
                            struct RME_CPU_Local* Local)
{
801674a8:	e92d4800 	push	{fp, lr}
801674ac:	e28db004 	add	fp, sp, #4
801674b0:	e24dd028 	sub	sp, sp, #40	@ 0x28
801674b4:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
801674b8:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
801674bc:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
801674c0:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
    struct RME_Cap_Prc* Prc_Root;
    struct RME_Thd_Struct* Thread;
    rme_ptr_t Type_Stat;
    
    /* Check whether the priority level is allowed */
    if(Prio>=RME_PREEMPT_PRIO_NUM)
801674c4:	e59b3008 	ldr	r3, [fp, #8]
801674c8:	e353001f 	cmp	r3, #31
801674cc:	9a000001 	bls	801674d8 <_RME_Thd_Boot_Crt+0x30>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_PRIO;
801674d0:	e3e030cc 	mvn	r3, #204	@ 0xcc
801674d4:	ea00014c 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
801674d8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801674dc:	e2033080 	and	r3, r3, #128	@ 0x80
801674e0:	e3530000 	cmp	r3, #0
801674e4:	1a00001c 	bne	8016755c <_RME_Thd_Boot_Crt+0xb4>
801674e8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801674ec:	e5932014 	ldr	r2, [r3, #20]
801674f0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801674f4:	e1520003 	cmp	r2, r3
801674f8:	8a000001 	bhi	80167504 <_RME_Thd_Boot_Crt+0x5c>
801674fc:	e3e03002 	mvn	r3, #2
80167500:	ea000141 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
80167504:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80167508:	e1a02283 	lsl	r2, r3, #5
8016750c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167510:	e593300c 	ldr	r3, [r3, #12]
80167514:	e0823003 	add	r3, r2, r3
80167518:	e50b3008 	str	r3, [fp, #-8]
8016751c:	e51b3008 	ldr	r3, [fp, #-8]
80167520:	e1a00003 	mov	r0, r3
80167524:	ebffe475 	bl	80160700 <__RME_A7A_Read_Acquire>
80167528:	e50b0010 	str	r0, [fp, #-16]
8016752c:	e51b3010 	ldr	r3, [fp, #-16]
80167530:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80167534:	e3530802 	cmp	r3, #131072	@ 0x20000
80167538:	1a000001 	bne	80167544 <_RME_Thd_Boot_Crt+0x9c>
8016753c:	e3e03008 	mvn	r3, #8
80167540:	ea000131 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
80167544:	e51b3010 	ldr	r3, [fp, #-16]
80167548:	e1a03c23 	lsr	r3, r3, #24
8016754c:	e3530003 	cmp	r3, #3
80167550:	0a00003f 	beq	80167654 <_RME_Thd_Boot_Crt+0x1ac>
80167554:	e3e03001 	mvn	r3, #1
80167558:	ea00012b 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
8016755c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80167560:	e1a02423 	lsr	r2, r3, #8
80167564:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167568:	e5933014 	ldr	r3, [r3, #20]
8016756c:	e1520003 	cmp	r2, r3
80167570:	3a000001 	bcc	8016757c <_RME_Thd_Boot_Crt+0xd4>
80167574:	e3e03002 	mvn	r3, #2
80167578:	ea000123 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
8016757c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80167580:	e1a03423 	lsr	r3, r3, #8
80167584:	e1a02283 	lsl	r2, r3, #5
80167588:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016758c:	e593300c 	ldr	r3, [r3, #12]
80167590:	e0823003 	add	r3, r2, r3
80167594:	e50b3008 	str	r3, [fp, #-8]
80167598:	e51b3008 	ldr	r3, [fp, #-8]
8016759c:	e1a00003 	mov	r0, r3
801675a0:	ebffe456 	bl	80160700 <__RME_A7A_Read_Acquire>
801675a4:	e50b0010 	str	r0, [fp, #-16]
801675a8:	e51b3010 	ldr	r3, [fp, #-16]
801675ac:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801675b0:	e3530802 	cmp	r3, #131072	@ 0x20000
801675b4:	1a000001 	bne	801675c0 <_RME_Thd_Boot_Crt+0x118>
801675b8:	e3e03008 	mvn	r3, #8
801675bc:	ea000112 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
801675c0:	e51b3010 	ldr	r3, [fp, #-16]
801675c4:	e1a03c23 	lsr	r3, r3, #24
801675c8:	e3530003 	cmp	r3, #3
801675cc:	0a000001 	beq	801675d8 <_RME_Thd_Boot_Crt+0x130>
801675d0:	e3e03001 	mvn	r3, #1
801675d4:	ea00010c 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
801675d8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801675dc:	e203207f 	and	r2, r3, #127	@ 0x7f
801675e0:	e51b3008 	ldr	r3, [fp, #-8]
801675e4:	e5933014 	ldr	r3, [r3, #20]
801675e8:	e1520003 	cmp	r2, r3
801675ec:	3a000001 	bcc	801675f8 <_RME_Thd_Boot_Crt+0x150>
801675f0:	e3e03002 	mvn	r3, #2
801675f4:	ea000104 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
801675f8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801675fc:	e203307f 	and	r3, r3, #127	@ 0x7f
80167600:	e1a02283 	lsl	r2, r3, #5
80167604:	e51b3008 	ldr	r3, [fp, #-8]
80167608:	e593300c 	ldr	r3, [r3, #12]
8016760c:	e0823003 	add	r3, r2, r3
80167610:	e50b3008 	str	r3, [fp, #-8]
80167614:	e51b3008 	ldr	r3, [fp, #-8]
80167618:	e1a00003 	mov	r0, r3
8016761c:	ebffe437 	bl	80160700 <__RME_A7A_Read_Acquire>
80167620:	e50b0010 	str	r0, [fp, #-16]
80167624:	e51b3010 	ldr	r3, [fp, #-16]
80167628:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016762c:	e3530802 	cmp	r3, #131072	@ 0x20000
80167630:	1a000001 	bne	8016763c <_RME_Thd_Boot_Crt+0x194>
80167634:	e3e03008 	mvn	r3, #8
80167638:	ea0000f3 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
8016763c:	e51b3010 	ldr	r3, [fp, #-16]
80167640:	e1a03c23 	lsr	r3, r3, #24
80167644:	e3530003 	cmp	r3, #3
80167648:	0a000001 	beq	80167654 <_RME_Thd_Boot_Crt+0x1ac>
8016764c:	e3e03001 	mvn	r3, #1
80167650:	ea0000ed 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat); 
    RME_CPT_GETCAP(Cpt,Cap_Prc,RME_CAP_TYPE_PRC,
80167654:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80167658:	e2033080 	and	r3, r3, #128	@ 0x80
8016765c:	e3530000 	cmp	r3, #0
80167660:	1a00001c 	bne	801676d8 <_RME_Thd_Boot_Crt+0x230>
80167664:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167668:	e5932014 	ldr	r2, [r3, #20]
8016766c:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80167670:	e1520003 	cmp	r2, r3
80167674:	8a000001 	bhi	80167680 <_RME_Thd_Boot_Crt+0x1d8>
80167678:	e3e03002 	mvn	r3, #2
8016767c:	ea0000e2 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
80167680:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80167684:	e1a02283 	lsl	r2, r3, #5
80167688:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016768c:	e593300c 	ldr	r3, [r3, #12]
80167690:	e0823003 	add	r3, r2, r3
80167694:	e50b300c 	str	r3, [fp, #-12]
80167698:	e51b300c 	ldr	r3, [fp, #-12]
8016769c:	e1a00003 	mov	r0, r3
801676a0:	ebffe416 	bl	80160700 <__RME_A7A_Read_Acquire>
801676a4:	e50b0010 	str	r0, [fp, #-16]
801676a8:	e51b3010 	ldr	r3, [fp, #-16]
801676ac:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801676b0:	e3530802 	cmp	r3, #131072	@ 0x20000
801676b4:	1a000001 	bne	801676c0 <_RME_Thd_Boot_Crt+0x218>
801676b8:	e3e03008 	mvn	r3, #8
801676bc:	ea0000d2 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
801676c0:	e51b3010 	ldr	r3, [fp, #-16]
801676c4:	e1a03c23 	lsr	r3, r3, #24
801676c8:	e3530005 	cmp	r3, #5
801676cc:	0a00003f 	beq	801677d0 <_RME_Thd_Boot_Crt+0x328>
801676d0:	e3e03001 	mvn	r3, #1
801676d4:	ea0000cc 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
801676d8:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801676dc:	e1a02423 	lsr	r2, r3, #8
801676e0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801676e4:	e5933014 	ldr	r3, [r3, #20]
801676e8:	e1520003 	cmp	r2, r3
801676ec:	3a000001 	bcc	801676f8 <_RME_Thd_Boot_Crt+0x250>
801676f0:	e3e03002 	mvn	r3, #2
801676f4:	ea0000c4 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
801676f8:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
801676fc:	e1a03423 	lsr	r3, r3, #8
80167700:	e1a02283 	lsl	r2, r3, #5
80167704:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80167708:	e593300c 	ldr	r3, [r3, #12]
8016770c:	e0823003 	add	r3, r2, r3
80167710:	e50b300c 	str	r3, [fp, #-12]
80167714:	e51b300c 	ldr	r3, [fp, #-12]
80167718:	e1a00003 	mov	r0, r3
8016771c:	ebffe3f7 	bl	80160700 <__RME_A7A_Read_Acquire>
80167720:	e50b0010 	str	r0, [fp, #-16]
80167724:	e51b3010 	ldr	r3, [fp, #-16]
80167728:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016772c:	e3530802 	cmp	r3, #131072	@ 0x20000
80167730:	1a000001 	bne	8016773c <_RME_Thd_Boot_Crt+0x294>
80167734:	e3e03008 	mvn	r3, #8
80167738:	ea0000b3 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
8016773c:	e51b3010 	ldr	r3, [fp, #-16]
80167740:	e1a03c23 	lsr	r3, r3, #24
80167744:	e3530003 	cmp	r3, #3
80167748:	0a000001 	beq	80167754 <_RME_Thd_Boot_Crt+0x2ac>
8016774c:	e3e03001 	mvn	r3, #1
80167750:	ea0000ad 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
80167754:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80167758:	e203207f 	and	r2, r3, #127	@ 0x7f
8016775c:	e51b300c 	ldr	r3, [fp, #-12]
80167760:	e5933014 	ldr	r3, [r3, #20]
80167764:	e1520003 	cmp	r2, r3
80167768:	3a000001 	bcc	80167774 <_RME_Thd_Boot_Crt+0x2cc>
8016776c:	e3e03002 	mvn	r3, #2
80167770:	ea0000a5 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
80167774:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
80167778:	e203307f 	and	r3, r3, #127	@ 0x7f
8016777c:	e1a02283 	lsl	r2, r3, #5
80167780:	e51b300c 	ldr	r3, [fp, #-12]
80167784:	e593300c 	ldr	r3, [r3, #12]
80167788:	e0823003 	add	r3, r2, r3
8016778c:	e50b300c 	str	r3, [fp, #-12]
80167790:	e51b300c 	ldr	r3, [fp, #-12]
80167794:	e1a00003 	mov	r0, r3
80167798:	ebffe3d8 	bl	80160700 <__RME_A7A_Read_Acquire>
8016779c:	e50b0010 	str	r0, [fp, #-16]
801677a0:	e51b3010 	ldr	r3, [fp, #-16]
801677a4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801677a8:	e3530802 	cmp	r3, #131072	@ 0x20000
801677ac:	1a000001 	bne	801677b8 <_RME_Thd_Boot_Crt+0x310>
801677b0:	e3e03008 	mvn	r3, #8
801677b4:	ea000094 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
801677b8:	e51b3010 	ldr	r3, [fp, #-16]
801677bc:	e1a03c23 	lsr	r3, r3, #24
801677c0:	e3530005 	cmp	r3, #5
801677c4:	0a000001 	beq	801677d0 <_RME_Thd_Boot_Crt+0x328>
801677c8:	e3e03001 	mvn	r3, #1
801677cc:	ea00008e 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
                   struct RME_Cap_Prc*,Prc_Op,Type_Stat);   
    /* Check if the target caps is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_CRT);
801677d0:	e51b3008 	ldr	r3, [fp, #-8]
801677d4:	e5933008 	ldr	r3, [r3, #8]
801677d8:	e2033001 	and	r3, r3, #1
801677dc:	e3530000 	cmp	r3, #0
801677e0:	1a000001 	bne	801677ec <_RME_Thd_Boot_Crt+0x344>
801677e4:	e3e03006 	mvn	r3, #6
801677e8:	ea000087 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
    RME_CAP_CHECK(Prc_Op,RME_PRC_FLAG_THD);
801677ec:	e51b300c 	ldr	r3, [fp, #-12]
801677f0:	e5933008 	ldr	r3, [r3, #8]
801677f4:	e2033002 	and	r3, r3, #2
801677f8:	e3530000 	cmp	r3, #0
801677fc:	1a000001 	bne	80167808 <_RME_Thd_Boot_Crt+0x360>
80167800:	e3e03006 	mvn	r3, #6
80167804:	ea000080 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Thd,struct RME_Cap_Thd*,Thd_Crt);
80167808:	e51b3008 	ldr	r3, [fp, #-8]
8016780c:	e5932014 	ldr	r2, [r3, #20]
80167810:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80167814:	e1520003 	cmp	r2, r3
80167818:	8a000001 	bhi	80167824 <_RME_Thd_Boot_Crt+0x37c>
8016781c:	e3e03002 	mvn	r3, #2
80167820:	ea000079 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
80167824:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80167828:	e1a02283 	lsl	r2, r3, #5
8016782c:	e51b3008 	ldr	r3, [fp, #-8]
80167830:	e593300c 	ldr	r3, [r3, #12]
80167834:	e0823003 	add	r3, r2, r3
80167838:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Thd_Crt);
8016783c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167840:	e3a02801 	mov	r2, #65536	@ 0x10000
80167844:	e3a01000 	mov	r1, #0
80167848:	e1a00003 	mov	r0, r3
8016784c:	ebffe4da 	bl	80160bbc <_RME_Comp_Swap_Single>
80167850:	e1a03000 	mov	r3, r0
80167854:	e3530000 	cmp	r3, #0
80167858:	1a000001 	bne	80167864 <_RME_Thd_Boot_Crt+0x3bc>
8016785c:	e3e03004 	mvn	r3, #4
80167860:	ea000069 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
80167864:	e3003000 	movw	r3, #0
80167868:	e3483017 	movt	r3, #32791	@ 0x8017
8016786c:	e5932000 	ldr	r2, [r3]
80167870:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167874:	e5832010 	str	r2, [r3, #16]
     
    /* Try to populate the area */
    if(_RME_Kot_Mark(Vaddr,RME_THD_SIZE(0U))!=0)
80167878:	e3a0109c 	mov	r1, #156	@ 0x9c
8016787c:	e59b0004 	ldr	r0, [fp, #4]
80167880:	ebfff5bd 	bl	80164f7c <_RME_Kot_Mark>
80167884:	e1a03000 	mov	r3, r0
80167888:	e3530000 	cmp	r3, #0
8016788c:	0a000005 	beq	801678a8 <_RME_Thd_Boot_Crt+0x400>
    {
        RME_COV_MARKER();

        RME_WRITE_RELEASE(&(Thd_Crt->Head.Type_Stat),0U);
80167890:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167894:	e3a01000 	mov	r1, #0
80167898:	e1a00003 	mov	r0, r3
8016789c:	ebffe39a 	bl	8016070c <__RME_A7A_Write_Release>
        return RME_ERR_CPT_KOT;
801678a0:	e3e03003 	mvn	r3, #3
801678a4:	ea000058 	b	80167a0c <_RME_Thd_Boot_Crt+0x564>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Object init */
    Thread=(struct RME_Thd_Struct*)Vaddr;
801678a8:	e59b3004 	ldr	r3, [fp, #4]
801678ac:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    /* The TID of these threads are by default taken care of by the kernel */
    Thread->Sched.TID=0U;
801678b0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801678b4:	e3a02000 	mov	r2, #0
801678b8:	e5832010 	str	r2, [r3, #16]
    Thread->Sched.Slice=RME_THD_INIT_TIME;
801678bc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801678c0:	e3e02102 	mvn	r2, #-2147483648	@ 0x80000000
801678c4:	e5832018 	str	r2, [r3, #24]
    Thread->Sched.State=RME_THD_READY;
801678c8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801678cc:	e3a02000 	mov	r2, #0
801678d0:	e583201c 	str	r2, [r3, #28]
    Prc_Root=RME_CAP_CONV_ROOT(Prc_Op,struct RME_Cap_Prc*);
801678d4:	e51b300c 	ldr	r3, [fp, #-12]
801678d8:	e5933000 	ldr	r3, [r3]
801678dc:	e6ff3073 	uxth	r3, r3
801678e0:	e3530000 	cmp	r3, #0
801678e4:	0a000002 	beq	801678f4 <_RME_Thd_Boot_Crt+0x44c>
801678e8:	e51b300c 	ldr	r3, [fp, #-12]
801678ec:	e5933004 	ldr	r3, [r3, #4]
801678f0:	ea000000 	b	801678f8 <_RME_Thd_Boot_Crt+0x450>
801678f4:	e51b300c 	ldr	r3, [fp, #-12]
801678f8:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    Thread->Sched.Prc=Prc_Root;
801678fc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167900:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
80167904:	e583202c 	str	r2, [r3, #44]	@ 0x2c
    Thread->Sched.Signal=0U;
80167908:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016790c:	e3a02000 	mov	r2, #0
80167910:	e5832028 	str	r2, [r3, #40]	@ 0x28
    Thread->Sched.Prio=Prio;
80167914:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167918:	e59b2008 	ldr	r2, [fp, #8]
8016791c:	e5832020 	str	r2, [r3, #32]
    Thread->Sched.Prio_Max=RME_PREEMPT_PRIO_NUM-1U;
80167920:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167924:	e3a0201f 	mov	r2, #31
80167928:	e5832024 	str	r2, [r3, #36]	@ 0x24
    /* Set scheduler reference to 1 so cannot be free */
    Thread->Sched.Sched_Ref=1U;
8016792c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167930:	e3a02001 	mov	r2, #1
80167934:	e5832030 	str	r2, [r3, #48]	@ 0x30
    Thread->Sched.Sched_Sig=0U;
80167938:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016793c:	e3a02000 	mov	r2, #0
80167940:	e5832038 	str	r2, [r3, #56]	@ 0x38
    /* Bind the thread to the current CPU */
    Thread->Sched.Local=Local;
80167944:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167948:	e59b200c 	ldr	r2, [fp, #12]
8016794c:	e5832014 	str	r2, [r3, #20]
    /* This is a marking that this thread haven't sent any notifications */
    _RME_List_Crt(&(Thread->Sched.Notif));
80167950:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167954:	e2833008 	add	r3, r3, #8
80167958:	e1a00003 	mov	r0, r3
8016795c:	ebffe4d0 	bl	80160ca4 <_RME_List_Crt>
    _RME_List_Crt(&(Thread->Sched.Event));
80167960:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167964:	e283303c 	add	r3, r3, #60	@ 0x3c
80167968:	e1a00003 	mov	r0, r3
8016796c:	ebffe4cc 	bl	80160ca4 <_RME_List_Crt>
    /* Point its pointer to itself - this will never be a hypervisor thread */
    Thread->Ctx.Hyp_Attr=0U;
80167970:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167974:	e3a02000 	mov	r2, #0
80167978:	e5832044 	str	r2, [r3, #68]	@ 0x44
    Thread->Ctx.Reg=(struct RME_Thd_Reg*)(Vaddr+RME_HYP_SIZE);
8016797c:	e59b3004 	ldr	r3, [fp, #4]
80167980:	e2833058 	add	r3, r3, #88	@ 0x58
80167984:	e1a02003 	mov	r2, r3
80167988:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016798c:	e5832048 	str	r2, [r3, #72]	@ 0x48
    /* Initialize the invocation stack */
    _RME_List_Crt(&(Thread->Ctx.Invstk));
80167990:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167994:	e283304c 	add	r3, r3, #76	@ 0x4c
80167998:	e1a00003 	mov	r0, r3
8016799c:	ebffe4c0 	bl	80160ca4 <_RME_List_Crt>
    Thread->Ctx.Invstk_Depth=0U;
801679a0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801679a4:	e3a02000 	mov	r2, #0
801679a8:	e5832054 	str	r2, [r3, #84]	@ 0x54
    
    /* Info init */
    Thd_Crt->Head.Root_Ref=1U;
801679ac:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801679b0:	e3a02001 	mov	r2, #1
801679b4:	e5832004 	str	r2, [r3, #4]
    Thd_Crt->Head.Object=Vaddr;
801679b8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801679bc:	e59b2004 	ldr	r2, [fp, #4]
801679c0:	e583200c 	str	r2, [r3, #12]
    /* This can only be a parent, and not a child, and cannot be freed. Additionally,
     * this should not be blocked on any endpoint. Any attempt to block this thread will fail.
     * Setting execution information for this is also prohibited. */
    Thd_Crt->Head.Flag=RME_THD_FLAG_SCHED_PRIO|RME_THD_FLAG_SCHED_PARENT|
801679c4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801679c8:	e3a02f7b 	mov	r2, #492	@ 0x1ec
801679cc:	e5832008 	str	r2, [r3, #8]
                       RME_THD_FLAG_XFER_DST|RME_THD_FLAG_XFER_SRC|
                       RME_THD_FLAG_SCHED_RCV|RME_THD_FLAG_SWT;

    /* Referece process */
    RME_FETCH_ADD(&(Prc_Root->Head.Root_Ref), 1U);
801679d0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801679d4:	e2833004 	add	r3, r3, #4
801679d8:	e3a01001 	mov	r1, #1
801679dc:	e1a00003 	mov	r0, r3
801679e0:	ebffe48a 	bl	80160c10 <_RME_Fetch_Add_Single>
    
    /* Insert this into the runqueue, and set current thread to it */
    _RME_Run_Ins(Thread);
801679e4:	e51b0018 	ldr	r0, [fp, #-24]	@ 0xffffffe8
801679e8:	ebfff7b1 	bl	801658b4 <_RME_Run_Ins>
    Local->Thd_Cur=Thread;
801679ec:	e59b300c 	ldr	r3, [fp, #12]
801679f0:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
801679f4:	e5832004 	str	r2, [r3, #4]

    /* Establish cap */
    RME_WRITE_RELEASE(&(Thd_Crt->Head.Type_Stat),
801679f8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801679fc:	e3a01406 	mov	r1, #100663296	@ 0x6000000
80167a00:	e1a00003 	mov	r0, r3
80167a04:	ebffe340 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_THD,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
80167a08:	e3a03000 	mov	r3, #0
}
80167a0c:	e1a00003 	mov	r0, r3
80167a10:	e24bd004 	sub	sp, fp, #4
80167a14:	e8bd8800 	pop	{fp, pc}

80167a18 <_RME_Thd_Crt>:
                              rme_cid_t Cap_Prc,
                              rme_ptr_t Prio_Max,
                              rme_ptr_t Raddr,
                              rme_ptr_t Attr,
                              rme_ptr_t Is_Hyp)
{
80167a18:	e92d4800 	push	{fp, lr}
80167a1c:	e28db004 	add	fp, sp, #4
80167a20:	e24dd038 	sub	sp, sp, #56	@ 0x38
80167a24:	e50b0030 	str	r0, [fp, #-48]	@ 0xffffffd0
80167a28:	e50b1034 	str	r1, [fp, #-52]	@ 0xffffffcc
80167a2c:	e50b2038 	str	r2, [fp, #-56]	@ 0xffffffc8
80167a30:	e50b303c 	str	r3, [fp, #-60]	@ 0xffffffc4
    RME_DBG_H(Is_Hyp);*/
     
    
    /* See if the maximum priority relationship is correct - a thread
     * can never create a thread with higher maximum priority */
    if((RME_CPU_LOCAL()->Thd_Cur)->Sched.Prio_Max<Prio_Max)
80167a34:	e3003004 	movw	r3, #4
80167a38:	e3483017 	movt	r3, #32791	@ 0x8017
80167a3c:	e5933004 	ldr	r3, [r3, #4]
80167a40:	e5933024 	ldr	r3, [r3, #36]	@ 0x24
80167a44:	e59b2008 	ldr	r2, [fp, #8]
80167a48:	e1520003 	cmp	r2, r3
80167a4c:	9a000004 	bls	80167a64 <_RME_Thd_Crt+0x4c>
    {
        RME_COV_MARKER();
        RME_DBG_S("\r\nmaximum priority relationship is not correct");
80167a50:	e30e094c 	movw	r0, #59724	@ 0xe94c
80167a54:	e3480016 	movt	r0, #32790	@ 0x8016
80167a58:	ebffe42d 	bl	80160b14 <RME_Str_Print>
        return RME_ERR_PTH_PRIO;
80167a5c:	e3e030cc 	mvn	r3, #204	@ 0xcc
80167a60:	ea0001ea 	b	80168210 <_RME_Thd_Crt+0x7f8>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
80167a64:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80167a68:	e2033080 	and	r3, r3, #128	@ 0x80
80167a6c:	e3530000 	cmp	r3, #0
80167a70:	1a00001c 	bne	80167ae8 <_RME_Thd_Crt+0xd0>
80167a74:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167a78:	e5932014 	ldr	r2, [r3, #20]
80167a7c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80167a80:	e1520003 	cmp	r2, r3
80167a84:	8a000001 	bhi	80167a90 <_RME_Thd_Crt+0x78>
80167a88:	e3e03002 	mvn	r3, #2
80167a8c:	ea0001df 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167a90:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80167a94:	e1a02283 	lsl	r2, r3, #5
80167a98:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167a9c:	e593300c 	ldr	r3, [r3, #12]
80167aa0:	e0823003 	add	r3, r2, r3
80167aa4:	e50b3008 	str	r3, [fp, #-8]
80167aa8:	e51b3008 	ldr	r3, [fp, #-8]
80167aac:	e1a00003 	mov	r0, r3
80167ab0:	ebffe312 	bl	80160700 <__RME_A7A_Read_Acquire>
80167ab4:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80167ab8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167abc:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80167ac0:	e3530802 	cmp	r3, #131072	@ 0x20000
80167ac4:	1a000001 	bne	80167ad0 <_RME_Thd_Crt+0xb8>
80167ac8:	e3e03008 	mvn	r3, #8
80167acc:	ea0001cf 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167ad0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167ad4:	e1a03c23 	lsr	r3, r3, #24
80167ad8:	e3530003 	cmp	r3, #3
80167adc:	0a00003f 	beq	80167be0 <_RME_Thd_Crt+0x1c8>
80167ae0:	e3e03001 	mvn	r3, #1
80167ae4:	ea0001c9 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167ae8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80167aec:	e1a02423 	lsr	r2, r3, #8
80167af0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167af4:	e5933014 	ldr	r3, [r3, #20]
80167af8:	e1520003 	cmp	r2, r3
80167afc:	3a000001 	bcc	80167b08 <_RME_Thd_Crt+0xf0>
80167b00:	e3e03002 	mvn	r3, #2
80167b04:	ea0001c1 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167b08:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80167b0c:	e1a03423 	lsr	r3, r3, #8
80167b10:	e1a02283 	lsl	r2, r3, #5
80167b14:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167b18:	e593300c 	ldr	r3, [r3, #12]
80167b1c:	e0823003 	add	r3, r2, r3
80167b20:	e50b3008 	str	r3, [fp, #-8]
80167b24:	e51b3008 	ldr	r3, [fp, #-8]
80167b28:	e1a00003 	mov	r0, r3
80167b2c:	ebffe2f3 	bl	80160700 <__RME_A7A_Read_Acquire>
80167b30:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80167b34:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167b38:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80167b3c:	e3530802 	cmp	r3, #131072	@ 0x20000
80167b40:	1a000001 	bne	80167b4c <_RME_Thd_Crt+0x134>
80167b44:	e3e03008 	mvn	r3, #8
80167b48:	ea0001b0 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167b4c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167b50:	e1a03c23 	lsr	r3, r3, #24
80167b54:	e3530003 	cmp	r3, #3
80167b58:	0a000001 	beq	80167b64 <_RME_Thd_Crt+0x14c>
80167b5c:	e3e03001 	mvn	r3, #1
80167b60:	ea0001aa 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167b64:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80167b68:	e203207f 	and	r2, r3, #127	@ 0x7f
80167b6c:	e51b3008 	ldr	r3, [fp, #-8]
80167b70:	e5933014 	ldr	r3, [r3, #20]
80167b74:	e1520003 	cmp	r2, r3
80167b78:	3a000001 	bcc	80167b84 <_RME_Thd_Crt+0x16c>
80167b7c:	e3e03002 	mvn	r3, #2
80167b80:	ea0001a2 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167b84:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80167b88:	e203307f 	and	r3, r3, #127	@ 0x7f
80167b8c:	e1a02283 	lsl	r2, r3, #5
80167b90:	e51b3008 	ldr	r3, [fp, #-8]
80167b94:	e593300c 	ldr	r3, [r3, #12]
80167b98:	e0823003 	add	r3, r2, r3
80167b9c:	e50b3008 	str	r3, [fp, #-8]
80167ba0:	e51b3008 	ldr	r3, [fp, #-8]
80167ba4:	e1a00003 	mov	r0, r3
80167ba8:	ebffe2d4 	bl	80160700 <__RME_A7A_Read_Acquire>
80167bac:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80167bb0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167bb4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80167bb8:	e3530802 	cmp	r3, #131072	@ 0x20000
80167bbc:	1a000001 	bne	80167bc8 <_RME_Thd_Crt+0x1b0>
80167bc0:	e3e03008 	mvn	r3, #8
80167bc4:	ea000191 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167bc8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167bcc:	e1a03c23 	lsr	r3, r3, #24
80167bd0:	e3530003 	cmp	r3, #3
80167bd4:	0a000001 	beq	80167be0 <_RME_Thd_Crt+0x1c8>
80167bd8:	e3e03001 	mvn	r3, #1
80167bdc:	ea00018b 	b	80168210 <_RME_Thd_Crt+0x7f8>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat); 
                   //RME_DBG_S("\r\nreach 1");
    RME_CPT_GETCAP(Cpt,Cap_Kom,RME_CAP_TYPE_KOM,
80167be0:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80167be4:	e2033080 	and	r3, r3, #128	@ 0x80
80167be8:	e3530000 	cmp	r3, #0
80167bec:	1a00001c 	bne	80167c64 <_RME_Thd_Crt+0x24c>
80167bf0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167bf4:	e5932014 	ldr	r2, [r3, #20]
80167bf8:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80167bfc:	e1520003 	cmp	r2, r3
80167c00:	8a000001 	bhi	80167c0c <_RME_Thd_Crt+0x1f4>
80167c04:	e3e03002 	mvn	r3, #2
80167c08:	ea000180 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167c0c:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80167c10:	e1a02283 	lsl	r2, r3, #5
80167c14:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167c18:	e593300c 	ldr	r3, [r3, #12]
80167c1c:	e0823003 	add	r3, r2, r3
80167c20:	e50b3010 	str	r3, [fp, #-16]
80167c24:	e51b3010 	ldr	r3, [fp, #-16]
80167c28:	e1a00003 	mov	r0, r3
80167c2c:	ebffe2b3 	bl	80160700 <__RME_A7A_Read_Acquire>
80167c30:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80167c34:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167c38:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80167c3c:	e3530802 	cmp	r3, #131072	@ 0x20000
80167c40:	1a000001 	bne	80167c4c <_RME_Thd_Crt+0x234>
80167c44:	e3e03008 	mvn	r3, #8
80167c48:	ea000170 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167c4c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167c50:	e1a03c23 	lsr	r3, r3, #24
80167c54:	e3530002 	cmp	r3, #2
80167c58:	0a00003f 	beq	80167d5c <_RME_Thd_Crt+0x344>
80167c5c:	e3e03001 	mvn	r3, #1
80167c60:	ea00016a 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167c64:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80167c68:	e1a02423 	lsr	r2, r3, #8
80167c6c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167c70:	e5933014 	ldr	r3, [r3, #20]
80167c74:	e1520003 	cmp	r2, r3
80167c78:	3a000001 	bcc	80167c84 <_RME_Thd_Crt+0x26c>
80167c7c:	e3e03002 	mvn	r3, #2
80167c80:	ea000162 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167c84:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80167c88:	e1a03423 	lsr	r3, r3, #8
80167c8c:	e1a02283 	lsl	r2, r3, #5
80167c90:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167c94:	e593300c 	ldr	r3, [r3, #12]
80167c98:	e0823003 	add	r3, r2, r3
80167c9c:	e50b3010 	str	r3, [fp, #-16]
80167ca0:	e51b3010 	ldr	r3, [fp, #-16]
80167ca4:	e1a00003 	mov	r0, r3
80167ca8:	ebffe294 	bl	80160700 <__RME_A7A_Read_Acquire>
80167cac:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80167cb0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167cb4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80167cb8:	e3530802 	cmp	r3, #131072	@ 0x20000
80167cbc:	1a000001 	bne	80167cc8 <_RME_Thd_Crt+0x2b0>
80167cc0:	e3e03008 	mvn	r3, #8
80167cc4:	ea000151 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167cc8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167ccc:	e1a03c23 	lsr	r3, r3, #24
80167cd0:	e3530003 	cmp	r3, #3
80167cd4:	0a000001 	beq	80167ce0 <_RME_Thd_Crt+0x2c8>
80167cd8:	e3e03001 	mvn	r3, #1
80167cdc:	ea00014b 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167ce0:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80167ce4:	e203207f 	and	r2, r3, #127	@ 0x7f
80167ce8:	e51b3010 	ldr	r3, [fp, #-16]
80167cec:	e5933014 	ldr	r3, [r3, #20]
80167cf0:	e1520003 	cmp	r2, r3
80167cf4:	3a000001 	bcc	80167d00 <_RME_Thd_Crt+0x2e8>
80167cf8:	e3e03002 	mvn	r3, #2
80167cfc:	ea000143 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167d00:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80167d04:	e203307f 	and	r3, r3, #127	@ 0x7f
80167d08:	e1a02283 	lsl	r2, r3, #5
80167d0c:	e51b3010 	ldr	r3, [fp, #-16]
80167d10:	e593300c 	ldr	r3, [r3, #12]
80167d14:	e0823003 	add	r3, r2, r3
80167d18:	e50b3010 	str	r3, [fp, #-16]
80167d1c:	e51b3010 	ldr	r3, [fp, #-16]
80167d20:	e1a00003 	mov	r0, r3
80167d24:	ebffe275 	bl	80160700 <__RME_A7A_Read_Acquire>
80167d28:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80167d2c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167d30:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80167d34:	e3530802 	cmp	r3, #131072	@ 0x20000
80167d38:	1a000001 	bne	80167d44 <_RME_Thd_Crt+0x32c>
80167d3c:	e3e03008 	mvn	r3, #8
80167d40:	ea000132 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167d44:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167d48:	e1a03c23 	lsr	r3, r3, #24
80167d4c:	e3530002 	cmp	r3, #2
80167d50:	0a000001 	beq	80167d5c <_RME_Thd_Crt+0x344>
80167d54:	e3e03001 	mvn	r3, #1
80167d58:	ea00012c 	b	80168210 <_RME_Thd_Crt+0x7f8>
                   struct RME_Cap_Kom*,Kom_Op,Type_Stat);
                   //RME_DBG_S("\r\nreach 2");
    RME_CPT_GETCAP(Cpt,Cap_Prc,RME_CAP_TYPE_PRC,
80167d5c:	e59b3004 	ldr	r3, [fp, #4]
80167d60:	e2033080 	and	r3, r3, #128	@ 0x80
80167d64:	e3530000 	cmp	r3, #0
80167d68:	1a00001c 	bne	80167de0 <_RME_Thd_Crt+0x3c8>
80167d6c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167d70:	e5932014 	ldr	r2, [r3, #20]
80167d74:	e59b3004 	ldr	r3, [fp, #4]
80167d78:	e1520003 	cmp	r2, r3
80167d7c:	8a000001 	bhi	80167d88 <_RME_Thd_Crt+0x370>
80167d80:	e3e03002 	mvn	r3, #2
80167d84:	ea000121 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167d88:	e59b3004 	ldr	r3, [fp, #4]
80167d8c:	e1a02283 	lsl	r2, r3, #5
80167d90:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167d94:	e593300c 	ldr	r3, [r3, #12]
80167d98:	e0823003 	add	r3, r2, r3
80167d9c:	e50b300c 	str	r3, [fp, #-12]
80167da0:	e51b300c 	ldr	r3, [fp, #-12]
80167da4:	e1a00003 	mov	r0, r3
80167da8:	ebffe254 	bl	80160700 <__RME_A7A_Read_Acquire>
80167dac:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80167db0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167db4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80167db8:	e3530802 	cmp	r3, #131072	@ 0x20000
80167dbc:	1a000001 	bne	80167dc8 <_RME_Thd_Crt+0x3b0>
80167dc0:	e3e03008 	mvn	r3, #8
80167dc4:	ea000111 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167dc8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167dcc:	e1a03c23 	lsr	r3, r3, #24
80167dd0:	e3530005 	cmp	r3, #5
80167dd4:	0a00003f 	beq	80167ed8 <_RME_Thd_Crt+0x4c0>
80167dd8:	e3e03001 	mvn	r3, #1
80167ddc:	ea00010b 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167de0:	e59b3004 	ldr	r3, [fp, #4]
80167de4:	e1a02423 	lsr	r2, r3, #8
80167de8:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167dec:	e5933014 	ldr	r3, [r3, #20]
80167df0:	e1520003 	cmp	r2, r3
80167df4:	3a000001 	bcc	80167e00 <_RME_Thd_Crt+0x3e8>
80167df8:	e3e03002 	mvn	r3, #2
80167dfc:	ea000103 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167e00:	e59b3004 	ldr	r3, [fp, #4]
80167e04:	e1a03423 	lsr	r3, r3, #8
80167e08:	e1a02283 	lsl	r2, r3, #5
80167e0c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80167e10:	e593300c 	ldr	r3, [r3, #12]
80167e14:	e0823003 	add	r3, r2, r3
80167e18:	e50b300c 	str	r3, [fp, #-12]
80167e1c:	e51b300c 	ldr	r3, [fp, #-12]
80167e20:	e1a00003 	mov	r0, r3
80167e24:	ebffe235 	bl	80160700 <__RME_A7A_Read_Acquire>
80167e28:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80167e2c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167e30:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80167e34:	e3530802 	cmp	r3, #131072	@ 0x20000
80167e38:	1a000001 	bne	80167e44 <_RME_Thd_Crt+0x42c>
80167e3c:	e3e03008 	mvn	r3, #8
80167e40:	ea0000f2 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167e44:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167e48:	e1a03c23 	lsr	r3, r3, #24
80167e4c:	e3530003 	cmp	r3, #3
80167e50:	0a000001 	beq	80167e5c <_RME_Thd_Crt+0x444>
80167e54:	e3e03001 	mvn	r3, #1
80167e58:	ea0000ec 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167e5c:	e59b3004 	ldr	r3, [fp, #4]
80167e60:	e203207f 	and	r2, r3, #127	@ 0x7f
80167e64:	e51b300c 	ldr	r3, [fp, #-12]
80167e68:	e5933014 	ldr	r3, [r3, #20]
80167e6c:	e1520003 	cmp	r2, r3
80167e70:	3a000001 	bcc	80167e7c <_RME_Thd_Crt+0x464>
80167e74:	e3e03002 	mvn	r3, #2
80167e78:	ea0000e4 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167e7c:	e59b3004 	ldr	r3, [fp, #4]
80167e80:	e203307f 	and	r3, r3, #127	@ 0x7f
80167e84:	e1a02283 	lsl	r2, r3, #5
80167e88:	e51b300c 	ldr	r3, [fp, #-12]
80167e8c:	e593300c 	ldr	r3, [r3, #12]
80167e90:	e0823003 	add	r3, r2, r3
80167e94:	e50b300c 	str	r3, [fp, #-12]
80167e98:	e51b300c 	ldr	r3, [fp, #-12]
80167e9c:	e1a00003 	mov	r0, r3
80167ea0:	ebffe216 	bl	80160700 <__RME_A7A_Read_Acquire>
80167ea4:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80167ea8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167eac:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80167eb0:	e3530802 	cmp	r3, #131072	@ 0x20000
80167eb4:	1a000001 	bne	80167ec0 <_RME_Thd_Crt+0x4a8>
80167eb8:	e3e03008 	mvn	r3, #8
80167ebc:	ea0000d3 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167ec0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80167ec4:	e1a03c23 	lsr	r3, r3, #24
80167ec8:	e3530005 	cmp	r3, #5
80167ecc:	0a000001 	beq	80167ed8 <_RME_Thd_Crt+0x4c0>
80167ed0:	e3e03001 	mvn	r3, #1
80167ed4:	ea0000cd 	b	80168210 <_RME_Thd_Crt+0x7f8>
                   struct RME_Cap_Prc*,Prc_Op,Type_Stat);
                   //RME_DBG_S("\r\nreach 3");
    /* Check if the target caps is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_CRT);
80167ed8:	e51b3008 	ldr	r3, [fp, #-8]
80167edc:	e5933008 	ldr	r3, [r3, #8]
80167ee0:	e2033001 	and	r3, r3, #1
80167ee4:	e3530000 	cmp	r3, #0
80167ee8:	1a000001 	bne	80167ef4 <_RME_Thd_Crt+0x4dc>
80167eec:	e3e03006 	mvn	r3, #6
80167ef0:	ea0000c6 	b	80168210 <_RME_Thd_Crt+0x7f8>
    //RME_DBG_S("\r\nreach 4");
    RME_CAP_CHECK(Prc_Op,RME_PRC_FLAG_THD);
80167ef4:	e51b300c 	ldr	r3, [fp, #-12]
80167ef8:	e5933008 	ldr	r3, [r3, #8]
80167efc:	e2033002 	and	r3, r3, #2
80167f00:	e3530000 	cmp	r3, #0
80167f04:	1a000001 	bne	80167f10 <_RME_Thd_Crt+0x4f8>
80167f08:	e3e03006 	mvn	r3, #6
80167f0c:	ea0000bf 	b	80168210 <_RME_Thd_Crt+0x7f8>
    //RME_DBG_S("\r\nreach 5");
    /* See if the creation is valid for this kmem range */
    if(Is_Hyp==0U)
80167f10:	e59b3014 	ldr	r3, [fp, #20]
80167f14:	e3530000 	cmp	r3, #0
80167f18:	1a000002 	bne	80167f28 <_RME_Thd_Crt+0x510>
    {
        RME_COV_MARKER();
        
        Size=RME_THD_SIZE(Attr);
80167f1c:	e3a0309c 	mov	r3, #156	@ 0x9c
80167f20:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
80167f24:	ea000001 	b	80167f30 <_RME_Thd_Crt+0x518>
        RME_COV_MARKER();
        
#if(RME_HYP_VA_SIZE==0U)
        return RME_ERR_PTH_HADDR;
#else
        Size=RME_HYP_SIZE;
80167f28:	e3a03058 	mov	r3, #88	@ 0x58
80167f2c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
#endif
    }
    
    RME_KOM_CHECK(Kom_Op,RME_KOM_FLAG_THD,Raddr,Vaddr,Size);
80167f30:	e51b3010 	ldr	r3, [fp, #-16]
80167f34:	e5933008 	ldr	r3, [r3, #8]
80167f38:	e2033004 	and	r3, r3, #4
80167f3c:	e3530000 	cmp	r3, #0
80167f40:	1a000001 	bne	80167f4c <_RME_Thd_Crt+0x534>
80167f44:	e3e03006 	mvn	r3, #6
80167f48:	ea0000b0 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167f4c:	e51b3010 	ldr	r3, [fp, #-16]
80167f50:	e5933014 	ldr	r3, [r3, #20]
80167f54:	e59b200c 	ldr	r2, [fp, #12]
80167f58:	e0823003 	add	r3, r2, r3
80167f5c:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
80167f60:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
80167f64:	e59b300c 	ldr	r3, [fp, #12]
80167f68:	e1520003 	cmp	r2, r3
80167f6c:	2a000001 	bcs	80167f78 <_RME_Thd_Crt+0x560>
80167f70:	e3e03006 	mvn	r3, #6
80167f74:	ea0000a5 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167f78:	e51b3010 	ldr	r3, [fp, #-16]
80167f7c:	e5933014 	ldr	r3, [r3, #20]
80167f80:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
80167f84:	e1520003 	cmp	r2, r3
80167f88:	2a000001 	bcs	80167f94 <_RME_Thd_Crt+0x57c>
80167f8c:	e3e03006 	mvn	r3, #6
80167f90:	ea00009e 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167f94:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
80167f98:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167f9c:	e0823003 	add	r3, r2, r3
80167fa0:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
80167fa4:	e1520003 	cmp	r2, r3
80167fa8:	9a000001 	bls	80167fb4 <_RME_Thd_Crt+0x59c>
80167fac:	e3e03006 	mvn	r3, #6
80167fb0:	ea000096 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167fb4:	e51b3010 	ldr	r3, [fp, #-16]
80167fb8:	e5932018 	ldr	r2, [r3, #24]
80167fbc:	e51b101c 	ldr	r1, [fp, #-28]	@ 0xffffffe4
80167fc0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80167fc4:	e0813003 	add	r3, r1, r3
80167fc8:	e2433001 	sub	r3, r3, #1
80167fcc:	e1520003 	cmp	r2, r3
80167fd0:	2a000001 	bcs	80167fdc <_RME_Thd_Crt+0x5c4>
80167fd4:	e3e03006 	mvn	r3, #6
80167fd8:	ea00008c 	b	80168210 <_RME_Thd_Crt+0x7f8>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Thd,struct RME_Cap_Thd*,Thd_Crt);
80167fdc:	e51b3008 	ldr	r3, [fp, #-8]
80167fe0:	e5932014 	ldr	r2, [r3, #20]
80167fe4:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80167fe8:	e1520003 	cmp	r2, r3
80167fec:	8a000001 	bhi	80167ff8 <_RME_Thd_Crt+0x5e0>
80167ff0:	e3e03002 	mvn	r3, #2
80167ff4:	ea000085 	b	80168210 <_RME_Thd_Crt+0x7f8>
80167ff8:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80167ffc:	e1a02283 	lsl	r2, r3, #5
80168000:	e51b3008 	ldr	r3, [fp, #-8]
80168004:	e593300c 	ldr	r3, [r3, #12]
80168008:	e0823003 	add	r3, r2, r3
8016800c:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0

    /* Take the slot if possible */
    RME_CPT_OCCUPY(Thd_Crt);
80168010:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168014:	e3a02801 	mov	r2, #65536	@ 0x10000
80168018:	e3a01000 	mov	r1, #0
8016801c:	e1a00003 	mov	r0, r3
80168020:	ebffe2e5 	bl	80160bbc <_RME_Comp_Swap_Single>
80168024:	e1a03000 	mov	r3, r0
80168028:	e3530000 	cmp	r3, #0
8016802c:	1a000001 	bne	80168038 <_RME_Thd_Crt+0x620>
80168030:	e3e03004 	mvn	r3, #4
80168034:	ea000075 	b	80168210 <_RME_Thd_Crt+0x7f8>
80168038:	e3003000 	movw	r3, #0
8016803c:	e3483017 	movt	r3, #32791	@ 0x8017
80168040:	e5932000 	ldr	r2, [r3]
80168044:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168048:	e5832010 	str	r2, [r3, #16]
     
    /* Try to populate the area */
    if(_RME_Kot_Mark(Vaddr,Size)<0)
8016804c:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
80168050:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80168054:	ebfff3c8 	bl	80164f7c <_RME_Kot_Mark>
80168058:	e1a03000 	mov	r3, r0
8016805c:	e3530000 	cmp	r3, #0
80168060:	aa00000e 	bge	801680a0 <_RME_Thd_Crt+0x688>
    {
        RME_COV_MARKER();
        RME_DBG_S("\r\n_RME_Kot_Mark(Vaddr,Size)");
80168064:	e30e097c 	movw	r0, #59772	@ 0xe97c
80168068:	e3480016 	movt	r0, #32790	@ 0x8016
8016806c:	ebffe2a8 	bl	80160b14 <RME_Str_Print>
        RME_DBG_I(_RME_Kot_Mark(Vaddr,Size));
80168070:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
80168074:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80168078:	ebfff3bf 	bl	80164f7c <_RME_Kot_Mark>
8016807c:	e1a03000 	mov	r3, r0
80168080:	e1a00003 	mov	r0, r3
80168084:	ebffe201 	bl	80160890 <RME_Int_Print>
        RME_WRITE_RELEASE(&(Thd_Crt->Head.Type_Stat),0U);
80168088:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016808c:	e3a01000 	mov	r1, #0
80168090:	e1a00003 	mov	r0, r3
80168094:	ebffe19c 	bl	8016070c <__RME_A7A_Write_Release>
        return RME_ERR_CPT_KOT;
80168098:	e3e03003 	mvn	r3, #3
8016809c:	ea00005b 	b	80168210 <_RME_Thd_Crt+0x7f8>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Object init */
    Thread=(struct RME_Thd_Struct*)Vaddr;
801680a0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
801680a4:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    /* These thread's TID default to 0, and have no timeslices assigned */
    Thread->Sched.TID=0U;
801680a8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801680ac:	e3a02000 	mov	r2, #0
801680b0:	e5832010 	str	r2, [r3, #16]
    Thread->Sched.Slice=0U;
801680b4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801680b8:	e3a02000 	mov	r2, #0
801680bc:	e5832018 	str	r2, [r3, #24]
    Thread->Sched.State=RME_THD_TIMEOUT;
801680c0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801680c4:	e3a02002 	mov	r2, #2
801680c8:	e583201c 	str	r2, [r3, #28]
    Prc_Root=RME_CAP_CONV_ROOT(Prc_Op,struct RME_Cap_Prc*);
801680cc:	e51b300c 	ldr	r3, [fp, #-12]
801680d0:	e5933000 	ldr	r3, [r3]
801680d4:	e6ff3073 	uxth	r3, r3
801680d8:	e3530000 	cmp	r3, #0
801680dc:	0a000002 	beq	801680ec <_RME_Thd_Crt+0x6d4>
801680e0:	e51b300c 	ldr	r3, [fp, #-12]
801680e4:	e5933004 	ldr	r3, [r3, #4]
801680e8:	ea000000 	b	801680f0 <_RME_Thd_Crt+0x6d8>
801680ec:	e51b300c 	ldr	r3, [fp, #-12]
801680f0:	e50b3028 	str	r3, [fp, #-40]	@ 0xffffffd8
    Thread->Sched.Prc=Prc_Root;
801680f4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801680f8:	e51b2028 	ldr	r2, [fp, #-40]	@ 0xffffffd8
801680fc:	e583202c 	str	r2, [r3, #44]	@ 0x2c
    Thread->Sched.Signal=0U;
80168100:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168104:	e3a02000 	mov	r2, #0
80168108:	e5832028 	str	r2, [r3, #40]	@ 0x28
    Thread->Sched.Prio_Max=Prio_Max;
8016810c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168110:	e59b2008 	ldr	r2, [fp, #8]
80168114:	e5832024 	str	r2, [r3, #36]	@ 0x24
    Thread->Sched.Sched_Ref=0U;
80168118:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016811c:	e3a02000 	mov	r2, #0
80168120:	e5832030 	str	r2, [r3, #48]	@ 0x30
    Thread->Sched.Sched_Sig=0U;
80168124:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168128:	e3a02000 	mov	r2, #0
8016812c:	e5832038 	str	r2, [r3, #56]	@ 0x38
    /* Currently the thread is not bound to any particular CPU */
    Thread->Sched.Local=RME_THD_FREE;
80168130:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168134:	e3e02000 	mvn	r2, #0
80168138:	e5832014 	str	r2, [r3, #20]
    /* This is a marking that this thread haven't sent any notifications */
    _RME_List_Crt(&(Thread->Sched.Notif));
8016813c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168140:	e2833008 	add	r3, r3, #8
80168144:	e1a00003 	mov	r0, r3
80168148:	ebffe2d5 	bl	80160ca4 <_RME_List_Crt>
    _RME_List_Crt(&(Thread->Sched.Event));
8016814c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168150:	e283303c 	add	r3, r3, #60	@ 0x3c
80168154:	e1a00003 	mov	r0, r3
80168158:	ebffe2d1 	bl	80160ca4 <_RME_List_Crt>
    /* Point its pointer to itself - this is not a hypervisor thread yet */
    if(Is_Hyp==0U)
8016815c:	e59b3014 	ldr	r3, [fp, #20]
80168160:	e3530000 	cmp	r3, #0
80168164:	1a000008 	bne	8016818c <_RME_Thd_Crt+0x774>
    {
        RME_COV_MARKER();
        
        Thread->Ctx.Hyp_Attr=Attr;
80168168:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016816c:	e59b2010 	ldr	r2, [fp, #16]
80168170:	e5832044 	str	r2, [r3, #68]	@ 0x44
        Thread->Ctx.Reg=(struct RME_Thd_Reg*)(Vaddr+RME_HYP_SIZE);
80168174:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168178:	e2833058 	add	r3, r3, #88	@ 0x58
8016817c:	e1a02003 	mov	r2, r3
80168180:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168184:	e5832048 	str	r2, [r3, #72]	@ 0x48
80168188:	ea000006 	b	801681a8 <_RME_Thd_Crt+0x790>
    /* Default to HYP_VA_BASE for all created hypervisor threads */
    else
    {
        RME_COV_MARKER();
        
        Thread->Ctx.Hyp_Attr=Attr|RME_THD_HYP_FLAG;
8016818c:	e59b3010 	ldr	r3, [fp, #16]
80168190:	e3832102 	orr	r2, r3, #-2147483648	@ 0x80000000
80168194:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168198:	e5832044 	str	r2, [r3, #68]	@ 0x44
        Thread->Ctx.Reg=(struct RME_Thd_Reg *)RME_HYP_VA_BASE;
8016819c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801681a0:	e3a02202 	mov	r2, #536870912	@ 0x20000000
801681a4:	e5832048 	str	r2, [r3, #72]	@ 0x48
    }
    /* Initialize the invocation stack */
    _RME_List_Crt(&(Thread->Ctx.Invstk));
801681a8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801681ac:	e283304c 	add	r3, r3, #76	@ 0x4c
801681b0:	e1a00003 	mov	r0, r3
801681b4:	ebffe2ba 	bl	80160ca4 <_RME_List_Crt>
    Thread->Ctx.Invstk_Depth=0U;
801681b8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801681bc:	e3a02000 	mov	r2, #0
801681c0:	e5832054 	str	r2, [r3, #84]	@ 0x54

    /* Header init */
    Thd_Crt->Head.Root_Ref=0U;
801681c4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801681c8:	e3a02000 	mov	r2, #0
801681cc:	e5832004 	str	r2, [r3, #4]
    Thd_Crt->Head.Object=Vaddr;
801681d0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801681d4:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
801681d8:	e583200c 	str	r2, [r3, #12]
    Thd_Crt->Head.Flag=RME_THD_FLAG_ALL;
801681dc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801681e0:	e30021ff 	movw	r2, #511	@ 0x1ff
801681e4:	e5832008 	str	r2, [r3, #8]

    /* Reference process */
    RME_FETCH_ADD(&(Prc_Root->Head.Root_Ref), 1U);
801681e8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801681ec:	e2833004 	add	r3, r3, #4
801681f0:	e3a01001 	mov	r1, #1
801681f4:	e1a00003 	mov	r0, r3
801681f8:	ebffe284 	bl	80160c10 <_RME_Fetch_Add_Single>
    
    /* Establish cap */
    RME_WRITE_RELEASE(&(Thd_Crt->Head.Type_Stat),
801681fc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168200:	e3a01406 	mov	r1, #100663296	@ 0x6000000
80168204:	e1a00003 	mov	r0, r3
80168208:	ebffe13f 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_THD,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
8016820c:	e3a03000 	mov	r3, #0
}
80168210:	e1a00003 	mov	r0, r3
80168214:	e24bd004 	sub	sp, fp, #4
80168218:	e8bd8800 	pop	{fp, pc}

8016821c <_RME_Thd_Del>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Thd_Del(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt,
                              rme_cid_t Cap_Thd)
{
8016821c:	e92d4800 	push	{fp, lr}
80168220:	e28db004 	add	fp, sp, #4
80168224:	e24dd028 	sub	sp, sp, #40	@ 0x28
80168228:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
8016822c:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
80168230:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
    /* These are for deletion */
    struct RME_Thd_Struct* Thread;
    struct RME_Inv_Struct* Invocation;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
80168234:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168238:	e2033080 	and	r3, r3, #128	@ 0x80
8016823c:	e3530000 	cmp	r3, #0
80168240:	1a00001c 	bne	801682b8 <_RME_Thd_Del+0x9c>
80168244:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168248:	e5932014 	ldr	r2, [r3, #20]
8016824c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168250:	e1520003 	cmp	r2, r3
80168254:	8a000001 	bhi	80168260 <_RME_Thd_Del+0x44>
80168258:	e3e03002 	mvn	r3, #2
8016825c:	ea00010a 	b	8016868c <_RME_Thd_Del+0x470>
80168260:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168264:	e1a02283 	lsl	r2, r3, #5
80168268:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016826c:	e593300c 	ldr	r3, [r3, #12]
80168270:	e0823003 	add	r3, r2, r3
80168274:	e50b3008 	str	r3, [fp, #-8]
80168278:	e51b3008 	ldr	r3, [fp, #-8]
8016827c:	e1a00003 	mov	r0, r3
80168280:	ebffe11e 	bl	80160700 <__RME_A7A_Read_Acquire>
80168284:	e50b000c 	str	r0, [fp, #-12]
80168288:	e51b300c 	ldr	r3, [fp, #-12]
8016828c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80168290:	e3530802 	cmp	r3, #131072	@ 0x20000
80168294:	1a000001 	bne	801682a0 <_RME_Thd_Del+0x84>
80168298:	e3e03008 	mvn	r3, #8
8016829c:	ea0000fa 	b	8016868c <_RME_Thd_Del+0x470>
801682a0:	e51b300c 	ldr	r3, [fp, #-12]
801682a4:	e1a03c23 	lsr	r3, r3, #24
801682a8:	e3530003 	cmp	r3, #3
801682ac:	0a00003f 	beq	801683b0 <_RME_Thd_Del+0x194>
801682b0:	e3e03001 	mvn	r3, #1
801682b4:	ea0000f4 	b	8016868c <_RME_Thd_Del+0x470>
801682b8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801682bc:	e1a02423 	lsr	r2, r3, #8
801682c0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801682c4:	e5933014 	ldr	r3, [r3, #20]
801682c8:	e1520003 	cmp	r2, r3
801682cc:	3a000001 	bcc	801682d8 <_RME_Thd_Del+0xbc>
801682d0:	e3e03002 	mvn	r3, #2
801682d4:	ea0000ec 	b	8016868c <_RME_Thd_Del+0x470>
801682d8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801682dc:	e1a03423 	lsr	r3, r3, #8
801682e0:	e1a02283 	lsl	r2, r3, #5
801682e4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801682e8:	e593300c 	ldr	r3, [r3, #12]
801682ec:	e0823003 	add	r3, r2, r3
801682f0:	e50b3008 	str	r3, [fp, #-8]
801682f4:	e51b3008 	ldr	r3, [fp, #-8]
801682f8:	e1a00003 	mov	r0, r3
801682fc:	ebffe0ff 	bl	80160700 <__RME_A7A_Read_Acquire>
80168300:	e50b000c 	str	r0, [fp, #-12]
80168304:	e51b300c 	ldr	r3, [fp, #-12]
80168308:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016830c:	e3530802 	cmp	r3, #131072	@ 0x20000
80168310:	1a000001 	bne	8016831c <_RME_Thd_Del+0x100>
80168314:	e3e03008 	mvn	r3, #8
80168318:	ea0000db 	b	8016868c <_RME_Thd_Del+0x470>
8016831c:	e51b300c 	ldr	r3, [fp, #-12]
80168320:	e1a03c23 	lsr	r3, r3, #24
80168324:	e3530003 	cmp	r3, #3
80168328:	0a000001 	beq	80168334 <_RME_Thd_Del+0x118>
8016832c:	e3e03001 	mvn	r3, #1
80168330:	ea0000d5 	b	8016868c <_RME_Thd_Del+0x470>
80168334:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168338:	e203207f 	and	r2, r3, #127	@ 0x7f
8016833c:	e51b3008 	ldr	r3, [fp, #-8]
80168340:	e5933014 	ldr	r3, [r3, #20]
80168344:	e1520003 	cmp	r2, r3
80168348:	3a000001 	bcc	80168354 <_RME_Thd_Del+0x138>
8016834c:	e3e03002 	mvn	r3, #2
80168350:	ea0000cd 	b	8016868c <_RME_Thd_Del+0x470>
80168354:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168358:	e203307f 	and	r3, r3, #127	@ 0x7f
8016835c:	e1a02283 	lsl	r2, r3, #5
80168360:	e51b3008 	ldr	r3, [fp, #-8]
80168364:	e593300c 	ldr	r3, [r3, #12]
80168368:	e0823003 	add	r3, r2, r3
8016836c:	e50b3008 	str	r3, [fp, #-8]
80168370:	e51b3008 	ldr	r3, [fp, #-8]
80168374:	e1a00003 	mov	r0, r3
80168378:	ebffe0e0 	bl	80160700 <__RME_A7A_Read_Acquire>
8016837c:	e50b000c 	str	r0, [fp, #-12]
80168380:	e51b300c 	ldr	r3, [fp, #-12]
80168384:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80168388:	e3530802 	cmp	r3, #131072	@ 0x20000
8016838c:	1a000001 	bne	80168398 <_RME_Thd_Del+0x17c>
80168390:	e3e03008 	mvn	r3, #8
80168394:	ea0000bc 	b	8016868c <_RME_Thd_Del+0x470>
80168398:	e51b300c 	ldr	r3, [fp, #-12]
8016839c:	e1a03c23 	lsr	r3, r3, #24
801683a0:	e3530003 	cmp	r3, #3
801683a4:	0a000001 	beq	801683b0 <_RME_Thd_Del+0x194>
801683a8:	e3e03001 	mvn	r3, #1
801683ac:	ea0000b6 	b	8016868c <_RME_Thd_Del+0x470>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_DEL);
801683b0:	e51b3008 	ldr	r3, [fp, #-8]
801683b4:	e5933008 	ldr	r3, [r3, #8]
801683b8:	e2033002 	and	r3, r3, #2
801683bc:	e3530000 	cmp	r3, #0
801683c0:	1a000001 	bne	801683cc <_RME_Thd_Del+0x1b0>
801683c4:	e3e03006 	mvn	r3, #6
801683c8:	ea0000af 	b	8016868c <_RME_Thd_Del+0x470>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Thd,struct RME_Cap_Thd*,Thd_Del);
801683cc:	e51b3008 	ldr	r3, [fp, #-8]
801683d0:	e5932014 	ldr	r2, [r3, #20]
801683d4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801683d8:	e1520003 	cmp	r2, r3
801683dc:	8a000001 	bhi	801683e8 <_RME_Thd_Del+0x1cc>
801683e0:	e3e03002 	mvn	r3, #2
801683e4:	ea0000a8 	b	8016868c <_RME_Thd_Del+0x470>
801683e8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
801683ec:	e1a02283 	lsl	r2, r3, #5
801683f0:	e51b3008 	ldr	r3, [fp, #-8]
801683f4:	e593300c 	ldr	r3, [r3, #12]
801683f8:	e0823003 	add	r3, r2, r3
801683fc:	e50b3010 	str	r3, [fp, #-16]
    /* Delete check */
    RME_CAP_DEL_CHECK(Thd_Del,Type_Stat,RME_CAP_TYPE_THD);
80168400:	e51b3010 	ldr	r3, [fp, #-16]
80168404:	e1a00003 	mov	r0, r3
80168408:	ebffe0bc 	bl	80160700 <__RME_A7A_Read_Acquire>
8016840c:	e50b000c 	str	r0, [fp, #-12]
80168410:	e51b300c 	ldr	r3, [fp, #-12]
80168414:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80168418:	e3530802 	cmp	r3, #131072	@ 0x20000
8016841c:	0a000001 	beq	80168428 <_RME_Thd_Del+0x20c>
80168420:	e3e03008 	mvn	r3, #8
80168424:	ea000098 	b	8016868c <_RME_Thd_Del+0x470>
80168428:	e51b300c 	ldr	r3, [fp, #-12]
8016842c:	e1a03c23 	lsr	r3, r3, #24
80168430:	e3530006 	cmp	r3, #6
80168434:	0a000001 	beq	80168440 <_RME_Thd_Del+0x224>
80168438:	e3e03001 	mvn	r3, #1
8016843c:	ea000092 	b	8016868c <_RME_Thd_Del+0x470>
80168440:	e3003000 	movw	r3, #0
80168444:	e3483017 	movt	r3, #32791	@ 0x8017
80168448:	e5932000 	ldr	r2, [r3]
8016844c:	e51b3010 	ldr	r3, [fp, #-16]
80168450:	e5933010 	ldr	r3, [r3, #16]
80168454:	e1a01003 	mov	r1, r3
80168458:	e1a00002 	mov	r0, r2
8016845c:	ebffe243 	bl	80160d70 <_RME_Diff>
80168460:	e1a03000 	mov	r3, r0
80168464:	e353000a 	cmp	r3, #10
80168468:	8a000001 	bhi	80168474 <_RME_Thd_Del+0x258>
8016846c:	e3e03007 	mvn	r3, #7
80168470:	ea000085 	b	8016868c <_RME_Thd_Del+0x470>
80168474:	e51b3010 	ldr	r3, [fp, #-16]
80168478:	e5933004 	ldr	r3, [r3, #4]
8016847c:	e3530000 	cmp	r3, #0
80168480:	0a00000b 	beq	801684b4 <_RME_Thd_Del+0x298>
80168484:	e51b300c 	ldr	r3, [fp, #-12]
80168488:	e6ff3073 	uxth	r3, r3
8016848c:	e3530000 	cmp	r3, #0
80168490:	1a000005 	bne	801684ac <_RME_Thd_Del+0x290>
80168494:	e51b0010 	ldr	r0, [fp, #-16]
80168498:	e51b300c 	ldr	r3, [fp, #-12]
8016849c:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
801684a0:	e1a02003 	mov	r2, r3
801684a4:	e51b100c 	ldr	r1, [fp, #-12]
801684a8:	ebffe1c3 	bl	80160bbc <_RME_Comp_Swap_Single>
801684ac:	e3e03005 	mvn	r3, #5
801684b0:	ea000075 	b	8016868c <_RME_Thd_Del+0x470>
801684b4:	e51b300c 	ldr	r3, [fp, #-12]
801684b8:	e6ff3073 	uxth	r3, r3
801684bc:	e3530000 	cmp	r3, #0
801684c0:	0a000008 	beq	801684e8 <_RME_Thd_Del+0x2cc>
801684c4:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
801684c8:	e3483016 	movt	r3, #32790	@ 0x8016
801684cc:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
801684d0:	e3482016 	movt	r2, #32790	@ 0x8016
801684d4:	e3011538 	movw	r1, #5432	@ 0x1538
801684d8:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
801684dc:	e3480016 	movt	r0, #32790	@ 0x8016
801684e0:	ebffe1aa 	bl	80160b90 <RME_Log>
801684e4:	eafffffe 	b	801684e4 <_RME_Thd_Del+0x2c8>
    
    /* Get the thread */
    Thread=RME_CAP_GETOBJ(Thd_Del,struct RME_Thd_Struct*);
801684e8:	e51b3010 	ldr	r3, [fp, #-16]
801684ec:	e593300c 	ldr	r3, [r3, #12]
801684f0:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    
    /* See if the thread is free. If still bound, we cannot proceed to deletion */
    if(Thread->Sched.Local!=RME_THD_FREE)
801684f4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801684f8:	e5933014 	ldr	r3, [r3, #20]
801684fc:	e3730001 	cmn	r3, #1
80168500:	0a000007 	beq	80168524 <_RME_Thd_Del+0x308>
    {
        RME_COV_MARKER();

        RME_CAP_DEFROST(Thd_Del,Type_Stat);
80168504:	e51b0010 	ldr	r0, [fp, #-16]
80168508:	e51b300c 	ldr	r3, [fp, #-12]
8016850c:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
80168510:	e1a02003 	mov	r2, r3
80168514:	e51b100c 	ldr	r1, [fp, #-12]
80168518:	ebffe1a7 	bl	80160bbc <_RME_Comp_Swap_Single>
        return RME_ERR_PTH_INVSTATE;
8016851c:	e3e030cb 	mvn	r3, #203	@ 0xcb
80168520:	ea000059 	b	8016868c <_RME_Thd_Del+0x470>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Now we can safely delete the cap */
    RME_CAP_DELETE(Thd_Del,Type_Stat);
80168524:	e51b3010 	ldr	r3, [fp, #-16]
80168528:	e3a02000 	mov	r2, #0
8016852c:	e51b100c 	ldr	r1, [fp, #-12]
80168530:	e1a00003 	mov	r0, r3
80168534:	ebffe1a0 	bl	80160bbc <_RME_Comp_Swap_Single>
80168538:	e1a03000 	mov	r3, r0
8016853c:	e3530000 	cmp	r3, #0
80168540:	1a000013 	bne	80168594 <_RME_Thd_Del+0x378>
80168544:	e3e03000 	mvn	r3, #0
80168548:	ea00004f 	b	8016868c <_RME_Thd_Del+0x470>
     * stack to empty, and free all the invocation stubs. This can be virtually
     * unbounded if the invocation stack is just too deep. This is left to the
     * user; if this is what he or she wants, be our guest. */
    while(Thread->Ctx.Invstk.Next!=&(Thread->Ctx.Invstk))
    {
        Invocation=(struct RME_Inv_Struct*)(Thread->Ctx.Invstk.Next);
8016854c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168550:	e593304c 	ldr	r3, [r3, #76]	@ 0x4c
80168554:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
        _RME_List_Del(Invocation->Head.Prev,Invocation->Head.Next);
80168558:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016855c:	e5932004 	ldr	r2, [r3, #4]
80168560:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168564:	e5933000 	ldr	r3, [r3]
80168568:	e1a01003 	mov	r1, r3
8016856c:	e1a00002 	mov	r0, r2
80168570:	ebffe1d9 	bl	80160cdc <_RME_List_Del>
        Invocation->Thd_Act=0U;
80168574:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168578:	e3a02000 	mov	r2, #0
8016857c:	e583200c 	str	r2, [r3, #12]
        Thread->Ctx.Invstk_Depth--;
80168580:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168584:	e5933054 	ldr	r3, [r3, #84]	@ 0x54
80168588:	e2432001 	sub	r2, r3, #1
8016858c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168590:	e5832054 	str	r2, [r3, #84]	@ 0x54
    while(Thread->Ctx.Invstk.Next!=&(Thread->Ctx.Invstk))
80168594:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168598:	e593204c 	ldr	r2, [r3, #76]	@ 0x4c
8016859c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801685a0:	e283304c 	add	r3, r3, #76	@ 0x4c
801685a4:	e1520003 	cmp	r2, r3
801685a8:	1affffe7 	bne	8016854c <_RME_Thd_Del+0x330>
    }
    RME_ASSERT(Thread->Ctx.Invstk_Depth==0U);
801685ac:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801685b0:	e5933054 	ldr	r3, [r3, #84]	@ 0x54
801685b4:	e3530000 	cmp	r3, #0
801685b8:	0a000008 	beq	801685e0 <_RME_Thd_Del+0x3c4>
801685bc:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
801685c0:	e3483016 	movt	r3, #32790	@ 0x8016
801685c4:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
801685c8:	e3482016 	movt	r2, #32790	@ 0x8016
801685cc:	e3011559 	movw	r1, #5465	@ 0x1559
801685d0:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
801685d4:	e3480016 	movt	r0, #32790	@ 0x8016
801685d8:	ebffe16c 	bl	80160b90 <RME_Log>
801685dc:	eafffffe 	b	801685dc <_RME_Thd_Del+0x3c0>
    
    /* Dereference the process */
    RME_FETCH_ADD(&(Thread->Sched.Prc->Head.Root_Ref), -1);
801685e0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801685e4:	e593302c 	ldr	r3, [r3, #44]	@ 0x2c
801685e8:	e2833004 	add	r3, r3, #4
801685ec:	e3e01000 	mvn	r1, #0
801685f0:	e1a00003 	mov	r0, r3
801685f4:	ebffe185 	bl	80160c10 <_RME_Fetch_Add_Single>
    
    /* Try to depopulate the area - this must be successful */
    if((Thread->Ctx.Hyp_Attr&RME_THD_HYP_FLAG)==0U)
801685f8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801685fc:	e5933044 	ldr	r3, [r3, #68]	@ 0x44
80168600:	e3530000 	cmp	r3, #0
80168604:	ba00000f 	blt	80168648 <_RME_Thd_Del+0x42c>
    {
        RME_COV_MARKER();

        RME_ASSERT(_RME_Kot_Erase((rme_ptr_t)Thread,
80168608:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016860c:	e3a0109c 	mov	r1, #156	@ 0x9c
80168610:	e1a00003 	mov	r0, r3
80168614:	ebfff32c 	bl	801652cc <_RME_Kot_Erase>
80168618:	e1a03000 	mov	r3, r0
8016861c:	e3530000 	cmp	r3, #0
80168620:	0a000018 	beq	80168688 <_RME_Thd_Del+0x46c>
80168624:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
80168628:	e3483016 	movt	r3, #32790	@ 0x8016
8016862c:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
80168630:	e3482016 	movt	r2, #32790	@ 0x8016
80168634:	e3011563 	movw	r1, #5475	@ 0x1563
80168638:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
8016863c:	e3480016 	movt	r0, #32790	@ 0x8016
80168640:	ebffe152 	bl	80160b90 <RME_Log>
80168644:	eafffffe 	b	80168644 <_RME_Thd_Del+0x428>
    }
    else
    {
        RME_COV_MARKER();

        RME_ASSERT(_RME_Kot_Erase((rme_ptr_t)Thread,
80168648:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016864c:	e3a01058 	mov	r1, #88	@ 0x58
80168650:	e1a00003 	mov	r0, r3
80168654:	ebfff31c 	bl	801652cc <_RME_Kot_Erase>
80168658:	e1a03000 	mov	r3, r0
8016865c:	e3530000 	cmp	r3, #0
80168660:	0a000008 	beq	80168688 <_RME_Thd_Del+0x46c>
80168664:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
80168668:	e3483016 	movt	r3, #32790	@ 0x8016
8016866c:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
80168670:	e3482016 	movt	r2, #32790	@ 0x8016
80168674:	e301156a 	movw	r1, #5482	@ 0x156a
80168678:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
8016867c:	e3480016 	movt	r0, #32790	@ 0x8016
80168680:	ebffe142 	bl	80160b90 <RME_Log>
80168684:	eafffffe 	b	80168684 <_RME_Thd_Del+0x468>
                   RME_HYP_SIZE)==0);
    }
    
    return 0;
80168688:	e3a03000 	mov	r3, #0
}
8016868c:	e1a00003 	mov	r0, r3
80168690:	e24bd004 	sub	sp, fp, #4
80168694:	e8bd8800 	pop	{fp, pc}

80168698 <_RME_Thd_Sched_Bind>:
                                     rme_cid_t Cap_Thd_Sched,
                                     rme_cid_t Cap_Sig,
                                     rme_tid_t TID,
                                     rme_ptr_t Prio,
                                     rme_ptr_t Haddr)
{
80168698:	e92d4800 	push	{fp, lr}
8016869c:	e28db004 	add	fp, sp, #4
801686a0:	e24dd038 	sub	sp, sp, #56	@ 0x38
801686a4:	e50b0030 	str	r0, [fp, #-48]	@ 0xffffffd0
801686a8:	e50b1034 	str	r1, [fp, #-52]	@ 0xffffffcc
801686ac:	e50b2038 	str	r2, [fp, #-56]	@ 0xffffffc8
801686b0:	e50b303c 	str	r3, [fp, #-60]	@ 0xffffffc4
    RME_DBG_H(Haddr);
    //RME_DBG_S("\r\nRME_CID_NULL ");
    //RME_DBG_I(RME_CID_NULL);*/

    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Thd,RME_CAP_TYPE_THD,
801686b4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801686b8:	e2033080 	and	r3, r3, #128	@ 0x80
801686bc:	e3530000 	cmp	r3, #0
801686c0:	1a00001c 	bne	80168738 <_RME_Thd_Sched_Bind+0xa0>
801686c4:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801686c8:	e5932014 	ldr	r2, [r3, #20]
801686cc:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801686d0:	e1520003 	cmp	r2, r3
801686d4:	8a000001 	bhi	801686e0 <_RME_Thd_Sched_Bind+0x48>
801686d8:	e3e03002 	mvn	r3, #2
801686dc:	ea0001d6 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
801686e0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801686e4:	e1a02283 	lsl	r2, r3, #5
801686e8:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801686ec:	e593300c 	ldr	r3, [r3, #12]
801686f0:	e0823003 	add	r3, r2, r3
801686f4:	e50b3008 	str	r3, [fp, #-8]
801686f8:	e51b3008 	ldr	r3, [fp, #-8]
801686fc:	e1a00003 	mov	r0, r3
80168700:	ebffdffe 	bl	80160700 <__RME_A7A_Read_Acquire>
80168704:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80168708:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016870c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80168710:	e3530802 	cmp	r3, #131072	@ 0x20000
80168714:	1a000001 	bne	80168720 <_RME_Thd_Sched_Bind+0x88>
80168718:	e3e03008 	mvn	r3, #8
8016871c:	ea0001c6 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168720:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168724:	e1a03c23 	lsr	r3, r3, #24
80168728:	e3530006 	cmp	r3, #6
8016872c:	0a00003f 	beq	80168830 <_RME_Thd_Sched_Bind+0x198>
80168730:	e3e03001 	mvn	r3, #1
80168734:	ea0001c0 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168738:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
8016873c:	e1a02423 	lsr	r2, r3, #8
80168740:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80168744:	e5933014 	ldr	r3, [r3, #20]
80168748:	e1520003 	cmp	r2, r3
8016874c:	3a000001 	bcc	80168758 <_RME_Thd_Sched_Bind+0xc0>
80168750:	e3e03002 	mvn	r3, #2
80168754:	ea0001b8 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168758:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
8016875c:	e1a03423 	lsr	r3, r3, #8
80168760:	e1a02283 	lsl	r2, r3, #5
80168764:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80168768:	e593300c 	ldr	r3, [r3, #12]
8016876c:	e0823003 	add	r3, r2, r3
80168770:	e50b3008 	str	r3, [fp, #-8]
80168774:	e51b3008 	ldr	r3, [fp, #-8]
80168778:	e1a00003 	mov	r0, r3
8016877c:	ebffdfdf 	bl	80160700 <__RME_A7A_Read_Acquire>
80168780:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80168784:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168788:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016878c:	e3530802 	cmp	r3, #131072	@ 0x20000
80168790:	1a000001 	bne	8016879c <_RME_Thd_Sched_Bind+0x104>
80168794:	e3e03008 	mvn	r3, #8
80168798:	ea0001a7 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
8016879c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801687a0:	e1a03c23 	lsr	r3, r3, #24
801687a4:	e3530003 	cmp	r3, #3
801687a8:	0a000001 	beq	801687b4 <_RME_Thd_Sched_Bind+0x11c>
801687ac:	e3e03001 	mvn	r3, #1
801687b0:	ea0001a1 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
801687b4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801687b8:	e203207f 	and	r2, r3, #127	@ 0x7f
801687bc:	e51b3008 	ldr	r3, [fp, #-8]
801687c0:	e5933014 	ldr	r3, [r3, #20]
801687c4:	e1520003 	cmp	r2, r3
801687c8:	3a000001 	bcc	801687d4 <_RME_Thd_Sched_Bind+0x13c>
801687cc:	e3e03002 	mvn	r3, #2
801687d0:	ea000199 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
801687d4:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
801687d8:	e203307f 	and	r3, r3, #127	@ 0x7f
801687dc:	e1a02283 	lsl	r2, r3, #5
801687e0:	e51b3008 	ldr	r3, [fp, #-8]
801687e4:	e593300c 	ldr	r3, [r3, #12]
801687e8:	e0823003 	add	r3, r2, r3
801687ec:	e50b3008 	str	r3, [fp, #-8]
801687f0:	e51b3008 	ldr	r3, [fp, #-8]
801687f4:	e1a00003 	mov	r0, r3
801687f8:	ebffdfc0 	bl	80160700 <__RME_A7A_Read_Acquire>
801687fc:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80168800:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168804:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80168808:	e3530802 	cmp	r3, #131072	@ 0x20000
8016880c:	1a000001 	bne	80168818 <_RME_Thd_Sched_Bind+0x180>
80168810:	e3e03008 	mvn	r3, #8
80168814:	ea000188 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168818:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016881c:	e1a03c23 	lsr	r3, r3, #24
80168820:	e3530006 	cmp	r3, #6
80168824:	0a000001 	beq	80168830 <_RME_Thd_Sched_Bind+0x198>
80168828:	e3e03001 	mvn	r3, #1
8016882c:	ea000182 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
                   struct RME_Cap_Thd*,Thd_Op,Type_Stat);
                   //RME_DBG_S("\r\nreach 1");
    RME_CPT_GETCAP(Cpt,Cap_Thd_Sched,RME_CAP_TYPE_THD,
80168830:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80168834:	e2033080 	and	r3, r3, #128	@ 0x80
80168838:	e3530000 	cmp	r3, #0
8016883c:	1a00001c 	bne	801688b4 <_RME_Thd_Sched_Bind+0x21c>
80168840:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80168844:	e5932014 	ldr	r2, [r3, #20]
80168848:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
8016884c:	e1520003 	cmp	r2, r3
80168850:	8a000001 	bhi	8016885c <_RME_Thd_Sched_Bind+0x1c4>
80168854:	e3e03002 	mvn	r3, #2
80168858:	ea000177 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
8016885c:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80168860:	e1a02283 	lsl	r2, r3, #5
80168864:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80168868:	e593300c 	ldr	r3, [r3, #12]
8016886c:	e0823003 	add	r3, r2, r3
80168870:	e50b300c 	str	r3, [fp, #-12]
80168874:	e51b300c 	ldr	r3, [fp, #-12]
80168878:	e1a00003 	mov	r0, r3
8016887c:	ebffdf9f 	bl	80160700 <__RME_A7A_Read_Acquire>
80168880:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80168884:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168888:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016888c:	e3530802 	cmp	r3, #131072	@ 0x20000
80168890:	1a000001 	bne	8016889c <_RME_Thd_Sched_Bind+0x204>
80168894:	e3e03008 	mvn	r3, #8
80168898:	ea000167 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
8016889c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801688a0:	e1a03c23 	lsr	r3, r3, #24
801688a4:	e3530006 	cmp	r3, #6
801688a8:	0a00003f 	beq	801689ac <_RME_Thd_Sched_Bind+0x314>
801688ac:	e3e03001 	mvn	r3, #1
801688b0:	ea000161 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
801688b4:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
801688b8:	e1a02423 	lsr	r2, r3, #8
801688bc:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801688c0:	e5933014 	ldr	r3, [r3, #20]
801688c4:	e1520003 	cmp	r2, r3
801688c8:	3a000001 	bcc	801688d4 <_RME_Thd_Sched_Bind+0x23c>
801688cc:	e3e03002 	mvn	r3, #2
801688d0:	ea000159 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
801688d4:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
801688d8:	e1a03423 	lsr	r3, r3, #8
801688dc:	e1a02283 	lsl	r2, r3, #5
801688e0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
801688e4:	e593300c 	ldr	r3, [r3, #12]
801688e8:	e0823003 	add	r3, r2, r3
801688ec:	e50b300c 	str	r3, [fp, #-12]
801688f0:	e51b300c 	ldr	r3, [fp, #-12]
801688f4:	e1a00003 	mov	r0, r3
801688f8:	ebffdf80 	bl	80160700 <__RME_A7A_Read_Acquire>
801688fc:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80168900:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168904:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80168908:	e3530802 	cmp	r3, #131072	@ 0x20000
8016890c:	1a000001 	bne	80168918 <_RME_Thd_Sched_Bind+0x280>
80168910:	e3e03008 	mvn	r3, #8
80168914:	ea000148 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168918:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016891c:	e1a03c23 	lsr	r3, r3, #24
80168920:	e3530003 	cmp	r3, #3
80168924:	0a000001 	beq	80168930 <_RME_Thd_Sched_Bind+0x298>
80168928:	e3e03001 	mvn	r3, #1
8016892c:	ea000142 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168930:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80168934:	e203207f 	and	r2, r3, #127	@ 0x7f
80168938:	e51b300c 	ldr	r3, [fp, #-12]
8016893c:	e5933014 	ldr	r3, [r3, #20]
80168940:	e1520003 	cmp	r2, r3
80168944:	3a000001 	bcc	80168950 <_RME_Thd_Sched_Bind+0x2b8>
80168948:	e3e03002 	mvn	r3, #2
8016894c:	ea00013a 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168950:	e51b3038 	ldr	r3, [fp, #-56]	@ 0xffffffc8
80168954:	e203307f 	and	r3, r3, #127	@ 0x7f
80168958:	e1a02283 	lsl	r2, r3, #5
8016895c:	e51b300c 	ldr	r3, [fp, #-12]
80168960:	e593300c 	ldr	r3, [r3, #12]
80168964:	e0823003 	add	r3, r2, r3
80168968:	e50b300c 	str	r3, [fp, #-12]
8016896c:	e51b300c 	ldr	r3, [fp, #-12]
80168970:	e1a00003 	mov	r0, r3
80168974:	ebffdf61 	bl	80160700 <__RME_A7A_Read_Acquire>
80168978:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016897c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168980:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80168984:	e3530802 	cmp	r3, #131072	@ 0x20000
80168988:	1a000001 	bne	80168994 <_RME_Thd_Sched_Bind+0x2fc>
8016898c:	e3e03008 	mvn	r3, #8
80168990:	ea000129 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168994:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168998:	e1a03c23 	lsr	r3, r3, #24
8016899c:	e3530006 	cmp	r3, #6
801689a0:	0a000001 	beq	801689ac <_RME_Thd_Sched_Bind+0x314>
801689a4:	e3e03001 	mvn	r3, #1
801689a8:	ea000123 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
                   struct RME_Cap_Thd*,Thd_Sched,Type_Stat);
                   //RME_DBG_S("\r\nreach 2");
    /* Check if the target cap is not frozen and allows such operations */
    RME_CAP_CHECK(Thd_Op,RME_THD_FLAG_SCHED_CHILD);
801689ac:	e51b3008 	ldr	r3, [fp, #-8]
801689b0:	e5933008 	ldr	r3, [r3, #8]
801689b4:	e2033002 	and	r3, r3, #2
801689b8:	e3530000 	cmp	r3, #0
801689bc:	1a000001 	bne	801689c8 <_RME_Thd_Sched_Bind+0x330>
801689c0:	e3e03006 	mvn	r3, #6
801689c4:	ea00011c 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
    //RME_DBG_S("\r\nreach 3");
    RME_CAP_CHECK(Thd_Sched,RME_THD_FLAG_SCHED_PARENT);
801689c8:	e51b300c 	ldr	r3, [fp, #-12]
801689cc:	e5933008 	ldr	r3, [r3, #8]
801689d0:	e2033004 	and	r3, r3, #4
801689d4:	e3530000 	cmp	r3, #0
801689d8:	1a000001 	bne	801689e4 <_RME_Thd_Sched_Bind+0x34c>
801689dc:	e3e03006 	mvn	r3, #6
801689e0:	ea000115 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
    //RME_DBG_S("\r\nreach 4");
    
    /* Check if we need the signal endpoint for this operation */
    if(Cap_Sig!=RME_CID_NULL)
801689e4:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
801689e8:	e3530902 	cmp	r3, #32768	@ 0x8000
801689ec:	0a000065 	beq	80168b88 <_RME_Thd_Sched_Bind+0x4f0>
    {
        RME_COV_MARKER();

        RME_CPT_GETCAP(Cpt,Cap_Sig,RME_CAP_TYPE_SIG,
801689f0:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
801689f4:	e2033080 	and	r3, r3, #128	@ 0x80
801689f8:	e3530000 	cmp	r3, #0
801689fc:	1a00001c 	bne	80168a74 <_RME_Thd_Sched_Bind+0x3dc>
80168a00:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80168a04:	e5932014 	ldr	r2, [r3, #20]
80168a08:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80168a0c:	e1520003 	cmp	r2, r3
80168a10:	8a000001 	bhi	80168a1c <_RME_Thd_Sched_Bind+0x384>
80168a14:	e3e03002 	mvn	r3, #2
80168a18:	ea000107 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168a1c:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80168a20:	e1a02283 	lsl	r2, r3, #5
80168a24:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80168a28:	e593300c 	ldr	r3, [r3, #12]
80168a2c:	e0823003 	add	r3, r2, r3
80168a30:	e50b3010 	str	r3, [fp, #-16]
80168a34:	e51b3010 	ldr	r3, [fp, #-16]
80168a38:	e1a00003 	mov	r0, r3
80168a3c:	ebffdf2f 	bl	80160700 <__RME_A7A_Read_Acquire>
80168a40:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80168a44:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168a48:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80168a4c:	e3530802 	cmp	r3, #131072	@ 0x20000
80168a50:	1a000001 	bne	80168a5c <_RME_Thd_Sched_Bind+0x3c4>
80168a54:	e3e03008 	mvn	r3, #8
80168a58:	ea0000f7 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168a5c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168a60:	e1a03c23 	lsr	r3, r3, #24
80168a64:	e3530008 	cmp	r3, #8
80168a68:	0a00003f 	beq	80168b6c <_RME_Thd_Sched_Bind+0x4d4>
80168a6c:	e3e03001 	mvn	r3, #1
80168a70:	ea0000f1 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168a74:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80168a78:	e1a02423 	lsr	r2, r3, #8
80168a7c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80168a80:	e5933014 	ldr	r3, [r3, #20]
80168a84:	e1520003 	cmp	r2, r3
80168a88:	3a000001 	bcc	80168a94 <_RME_Thd_Sched_Bind+0x3fc>
80168a8c:	e3e03002 	mvn	r3, #2
80168a90:	ea0000e9 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168a94:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80168a98:	e1a03423 	lsr	r3, r3, #8
80168a9c:	e1a02283 	lsl	r2, r3, #5
80168aa0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80168aa4:	e593300c 	ldr	r3, [r3, #12]
80168aa8:	e0823003 	add	r3, r2, r3
80168aac:	e50b3010 	str	r3, [fp, #-16]
80168ab0:	e51b3010 	ldr	r3, [fp, #-16]
80168ab4:	e1a00003 	mov	r0, r3
80168ab8:	ebffdf10 	bl	80160700 <__RME_A7A_Read_Acquire>
80168abc:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80168ac0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168ac4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80168ac8:	e3530802 	cmp	r3, #131072	@ 0x20000
80168acc:	1a000001 	bne	80168ad8 <_RME_Thd_Sched_Bind+0x440>
80168ad0:	e3e03008 	mvn	r3, #8
80168ad4:	ea0000d8 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168ad8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168adc:	e1a03c23 	lsr	r3, r3, #24
80168ae0:	e3530003 	cmp	r3, #3
80168ae4:	0a000001 	beq	80168af0 <_RME_Thd_Sched_Bind+0x458>
80168ae8:	e3e03001 	mvn	r3, #1
80168aec:	ea0000d2 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168af0:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80168af4:	e203207f 	and	r2, r3, #127	@ 0x7f
80168af8:	e51b3010 	ldr	r3, [fp, #-16]
80168afc:	e5933014 	ldr	r3, [r3, #20]
80168b00:	e1520003 	cmp	r2, r3
80168b04:	3a000001 	bcc	80168b10 <_RME_Thd_Sched_Bind+0x478>
80168b08:	e3e03002 	mvn	r3, #2
80168b0c:	ea0000ca 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168b10:	e51b303c 	ldr	r3, [fp, #-60]	@ 0xffffffc4
80168b14:	e203307f 	and	r3, r3, #127	@ 0x7f
80168b18:	e1a02283 	lsl	r2, r3, #5
80168b1c:	e51b3010 	ldr	r3, [fp, #-16]
80168b20:	e593300c 	ldr	r3, [r3, #12]
80168b24:	e0823003 	add	r3, r2, r3
80168b28:	e50b3010 	str	r3, [fp, #-16]
80168b2c:	e51b3010 	ldr	r3, [fp, #-16]
80168b30:	e1a00003 	mov	r0, r3
80168b34:	ebffdef1 	bl	80160700 <__RME_A7A_Read_Acquire>
80168b38:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80168b3c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168b40:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80168b44:	e3530802 	cmp	r3, #131072	@ 0x20000
80168b48:	1a000001 	bne	80168b54 <_RME_Thd_Sched_Bind+0x4bc>
80168b4c:	e3e03008 	mvn	r3, #8
80168b50:	ea0000b9 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
80168b54:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80168b58:	e1a03c23 	lsr	r3, r3, #24
80168b5c:	e3530008 	cmp	r3, #8
80168b60:	0a000001 	beq	80168b6c <_RME_Thd_Sched_Bind+0x4d4>
80168b64:	e3e03001 	mvn	r3, #1
80168b68:	ea0000b3 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
                       struct RME_Cap_Sig*,Sig_Op,Type_Stat);
        RME_CAP_CHECK(Sig_Op,RME_SIG_FLAG_SCHED);
80168b6c:	e51b3010 	ldr	r3, [fp, #-16]
80168b70:	e5933008 	ldr	r3, [r3, #8]
80168b74:	e2033020 	and	r3, r3, #32
80168b78:	e3530000 	cmp	r3, #0
80168b7c:	1a000003 	bne	80168b90 <_RME_Thd_Sched_Bind+0x4f8>
80168b80:	e3e03006 	mvn	r3, #6
80168b84:	ea0000ac 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
    }
    else
    {
        RME_COV_MARKER();

        Sig_Op=RME_NULL;
80168b88:	e3a03000 	mov	r3, #0
80168b8c:	e50b3010 	str	r3, [fp, #-16]
    }

    /* Check if the target thread is already bound. If yes, we just quit */
    Thread=RME_CAP_GETOBJ(Thd_Op,struct RME_Thd_Struct*);
80168b90:	e51b3008 	ldr	r3, [fp, #-8]
80168b94:	e593300c 	ldr	r3, [r3, #12]
80168b98:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    //RME_DBG_S("\r\nreach 5");
    Local_Old=Thread->Sched.Local;
80168b9c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168ba0:	e5933014 	ldr	r3, [r3, #20]
80168ba4:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    if(Local_Old!=RME_THD_FREE)
80168ba8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80168bac:	e3730001 	cmn	r3, #1
80168bb0:	0a000001 	beq	80168bbc <_RME_Thd_Sched_Bind+0x524>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
80168bb4:	e3e030cb 	mvn	r3, #203	@ 0xcb
80168bb8:	ea00009f 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* See if the parent thread is on the same core with the current processor */
    Local_New=RME_CPU_LOCAL();
80168bbc:	e3003004 	movw	r3, #4
80168bc0:	e3483017 	movt	r3, #32791	@ 0x8017
80168bc4:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
    Scheduler=RME_CAP_GETOBJ(Thd_Sched,struct RME_Thd_Struct*);
80168bc8:	e51b300c 	ldr	r3, [fp, #-12]
80168bcc:	e593300c 	ldr	r3, [r3, #12]
80168bd0:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    if(Scheduler->Sched.Local!=Local_New)
80168bd4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168bd8:	e5933014 	ldr	r3, [r3, #20]
80168bdc:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80168be0:	e1520003 	cmp	r2, r3
80168be4:	0a000001 	beq	80168bf0 <_RME_Thd_Sched_Bind+0x558>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
80168be8:	e3e030cb 	mvn	r3, #203	@ 0xcb
80168bec:	ea000092 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
        RME_COV_MARKER();
        /* No action required */
    }

    /* See if we are trying to bind to ourself - prohibited */
    if(Thread==Scheduler)
80168bf0:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80168bf4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168bf8:	e1520003 	cmp	r2, r3
80168bfc:	1a000001 	bne	80168c08 <_RME_Thd_Sched_Bind+0x570>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_NOTIF;
80168c00:	e3e030ce 	mvn	r3, #206	@ 0xce
80168c04:	ea00008c 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* See if the priority relationship is correct */
    if(Scheduler->Sched.Prio_Max<Prio)
80168c08:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168c0c:	e5933024 	ldr	r3, [r3, #36]	@ 0x24
80168c10:	e59b2008 	ldr	r2, [fp, #8]
80168c14:	e1520003 	cmp	r2, r3
80168c18:	9a000001 	bls	80168c24 <_RME_Thd_Sched_Bind+0x58c>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_PRIO;
80168c1c:	e3e030cc 	mvn	r3, #204	@ 0xcc
80168c20:	ea000085 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Check whether the coprocessor context attribute is compatible with this core */
    Hyp_Attr=Thread->Ctx.Hyp_Attr;
80168c24:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168c28:	e5933044 	ldr	r3, [r3, #68]	@ 0x44
80168c2c:	e50b3028 	str	r3, [fp, #-40]	@ 0xffffffd8
        RME_COV_MARKER();

        return RME_ERR_CPT_FLAG;
    }
#else
    if(RME_THD_ATTR(Hyp_Attr)!=0U)
80168c30:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168c34:	e3c33102 	bic	r3, r3, #-2147483648	@ 0x80000000
80168c38:	e3530000 	cmp	r3, #0
80168c3c:	0a000001 	beq	80168c48 <_RME_Thd_Sched_Bind+0x5b0>
    {
        RME_COV_MARKER();

        return RME_ERR_CPT_FLAG;
80168c40:	e3e03006 	mvn	r3, #6
80168c44:	ea00007c 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Check the hypervisor context buffer passed in to see whether it is good */
    if((Haddr!=RME_NULL)&&((Hyp_Attr&RME_THD_HYP_FLAG)!=0U))
80168c48:	e59b300c 	ldr	r3, [fp, #12]
80168c4c:	e3530000 	cmp	r3, #0
80168c50:	0a000020 	beq	80168cd8 <_RME_Thd_Sched_Bind+0x640>
80168c54:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168c58:	e3530000 	cmp	r3, #0
80168c5c:	aa00001d 	bge	80168cd8 <_RME_Thd_Sched_Bind+0x640>
    {
        RME_COV_MARKER();
        
        /* Register save area must be aligned to word boundary */
        if(RME_IS_ALIGNED(Haddr)!=0U)
80168c60:	e59b300c 	ldr	r3, [fp, #12]
80168c64:	e2033003 	and	r3, r3, #3
80168c68:	e3530000 	cmp	r3, #0
80168c6c:	1a000001 	bne	80168c78 <_RME_Thd_Sched_Bind+0x5e0>
80168c70:	e3a03001 	mov	r3, #1
80168c74:	ea000000 	b	80168c7c <_RME_Thd_Sched_Bind+0x5e4>
80168c78:	e3a03000 	mov	r3, #0
80168c7c:	e3530000 	cmp	r3, #0
80168c80:	0a000012 	beq	80168cd0 <_RME_Thd_Sched_Bind+0x638>
        {
            RME_COV_MARKER();
            
            /* It needs to be safely accessible to the kernel as well */
#if(RME_HYP_VA_BASE!=0U)
            if(Haddr<RME_HYP_VA_BASE)
80168c84:	e59b300c 	ldr	r3, [fp, #12]
80168c88:	e373021e 	cmn	r3, #-536870911	@ 0xe0000001
80168c8c:	8a000001 	bhi	80168c98 <_RME_Thd_Sched_Bind+0x600>
            {
                RME_COV_MARKER();

                return RME_ERR_PTH_HADDR;
80168c90:	e3e030ca 	mvn	r3, #202	@ 0xca
80168c94:	ea000068 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
            }
            else
            {
#endif
                End=Haddr+RME_REG_SIZE(RME_THD_ATTR(Thread->Ctx.Hyp_Attr));
80168c98:	e59b300c 	ldr	r3, [fp, #12]
80168c9c:	e2833044 	add	r3, r3, #68	@ 0x44
80168ca0:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
                if((End<=Haddr)||(End>(RME_HYP_VA_BASE+RME_HYP_VA_SIZE)))
80168ca4:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
80168ca8:	e59b300c 	ldr	r3, [fp, #12]
80168cac:	e1520003 	cmp	r2, r3
80168cb0:	9a000004 	bls	80168cc8 <_RME_Thd_Sched_Bind+0x630>
80168cb4:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
80168cb8:	e3a03000 	mov	r3, #0
80168cbc:	e3423002 	movt	r3, #8194	@ 0x2002
80168cc0:	e1520003 	cmp	r2, r3
80168cc4:	9a000011 	bls	80168d10 <_RME_Thd_Sched_Bind+0x678>
                {
                    RME_COV_MARKER();

                    return RME_ERR_PTH_HADDR;
80168cc8:	e3e030ca 	mvn	r3, #202	@ 0xca
80168ccc:	ea00005a 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
        /* Not aligned, exiting */
        else
        {
            RME_COV_MARKER();

            return RME_ERR_PTH_HADDR;
80168cd0:	e3e030ca 	mvn	r3, #202	@ 0xca
80168cd4:	ea000058 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
        }
    }
    /* We don't allow setting HYP addr for normal threads, nor do we allow
     * setting HYP addr to NULL for hypervisor-managed threads. */
    else if(((Haddr!=RME_NULL)&&((Hyp_Attr&RME_THD_HYP_FLAG)==0U))||
80168cd8:	e59b300c 	ldr	r3, [fp, #12]
80168cdc:	e3530000 	cmp	r3, #0
80168ce0:	0a000002 	beq	80168cf0 <_RME_Thd_Sched_Bind+0x658>
80168ce4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168ce8:	e3530000 	cmp	r3, #0
80168cec:	aa000005 	bge	80168d08 <_RME_Thd_Sched_Bind+0x670>
80168cf0:	e59b300c 	ldr	r3, [fp, #12]
80168cf4:	e3530000 	cmp	r3, #0
80168cf8:	1a000005 	bne	80168d14 <_RME_Thd_Sched_Bind+0x67c>
            ((Haddr==RME_NULL)&&((Hyp_Attr&RME_THD_HYP_FLAG)!=0U)))
80168cfc:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80168d00:	e3530000 	cmp	r3, #0
80168d04:	aa000002 	bge	80168d14 <_RME_Thd_Sched_Bind+0x67c>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_HADDR;
80168d08:	e3e030ca 	mvn	r3, #202	@ 0xca
80168d0c:	ea00004a 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
        if(RME_IS_ALIGNED(Haddr)!=0U)
80168d10:	e320f000 	nop	{0}
        RME_COV_MARKER();
        /* No action required */
    }

    /* Try to bind the thread */
    if(RME_COMP_SWAP((rme_ptr_t*)&(Thread->Sched.Local),
80168d14:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168d18:	e2833014 	add	r3, r3, #20
80168d1c:	e51b101c 	ldr	r1, [fp, #-28]	@ 0xffffffe4
80168d20:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
80168d24:	e1a00003 	mov	r0, r3
80168d28:	ebffdfa3 	bl	80160bbc <_RME_Comp_Swap_Single>
80168d2c:	e1a03000 	mov	r3, r0
80168d30:	e3530000 	cmp	r3, #0
80168d34:	1a000001 	bne	80168d40 <_RME_Thd_Sched_Bind+0x6a8>
                     (rme_ptr_t)Local_Old,
                     (rme_ptr_t)Local_New)==RME_CASFAIL)
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_CONFLICT;
80168d38:	e3e030c9 	mvn	r3, #201	@ 0xc9
80168d3c:	ea00003e 	b	80168e3c <_RME_Thd_Sched_Bind+0x7a4>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Increase the reference count of the scheduler thread struct - same core */
    Scheduler->Sched.Sched_Ref++;
80168d40:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168d44:	e5933030 	ldr	r3, [r3, #48]	@ 0x30
80168d48:	e2832001 	add	r2, r3, #1
80168d4c:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80168d50:	e5832030 	str	r2, [r3, #48]	@ 0x30
    
    /* Bind successful and finish the work off. No need to worry about other cores'
     * operations on this thread because this thread is already bound to this core.
     * TID is half-word parameter-wise, but is stored and returned as a full word. */
    Thread->Sched.Sched_Thd=Scheduler;
80168d54:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168d58:	e51b2024 	ldr	r2, [fp, #-36]	@ 0xffffffdc
80168d5c:	e5832034 	str	r2, [r3, #52]	@ 0x34
    Thread->Sched.Prio=Prio;
80168d60:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168d64:	e59b2008 	ldr	r2, [fp, #8]
80168d68:	e5832020 	str	r2, [r3, #32]
    Thread->Sched.TID=(rme_ptr_t)TID;
80168d6c:	e59b2004 	ldr	r2, [fp, #4]
80168d70:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168d74:	e5832010 	str	r2, [r3, #16]
    
    /* The state must be TIMEOUT or EXCPEND at this point */
    RME_ASSERT((Thread->Sched.State==RME_THD_TIMEOUT)||
80168d78:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168d7c:	e593301c 	ldr	r3, [r3, #28]
80168d80:	e3530002 	cmp	r3, #2
80168d84:	0a00000c 	beq	80168dbc <_RME_Thd_Sched_Bind+0x724>
80168d88:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168d8c:	e593301c 	ldr	r3, [r3, #28]
80168d90:	e3530003 	cmp	r3, #3
80168d94:	0a000008 	beq	80168dbc <_RME_Thd_Sched_Bind+0x724>
80168d98:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
80168d9c:	e3483016 	movt	r3, #32790	@ 0x8016
80168da0:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
80168da4:	e3482016 	movt	r2, #32790	@ 0x8016
80168da8:	e301167b 	movw	r1, #5755	@ 0x167b
80168dac:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
80168db0:	e3480016 	movt	r0, #32790	@ 0x8016
80168db4:	ebffdf75 	bl	80160b90 <RME_Log>
80168db8:	eafffffe 	b	80168db8 <_RME_Thd_Sched_Bind+0x720>
               (Thread->Sched.State==RME_THD_EXCPEND));

    /* Tie the signal endpoint to it if not zero */
    if(Sig_Op==0U)
80168dbc:	e51b3010 	ldr	r3, [fp, #-16]
80168dc0:	e3530000 	cmp	r3, #0
80168dc4:	1a000003 	bne	80168dd8 <_RME_Thd_Sched_Bind+0x740>
    {
        RME_COV_MARKER();

        Thread->Sched.Sched_Sig=0U;
80168dc8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168dcc:	e3a02000 	mov	r2, #0
80168dd0:	e5832038 	str	r2, [r3, #56]	@ 0x38
80168dd4:	ea000010 	b	80168e1c <_RME_Thd_Sched_Bind+0x784>
    else
    {
        RME_COV_MARKER();

        /* Convert to root cap */
        Thread->Sched.Sched_Sig=RME_CAP_CONV_ROOT(Sig_Op,struct RME_Cap_Sig*);
80168dd8:	e51b3010 	ldr	r3, [fp, #-16]
80168ddc:	e5933000 	ldr	r3, [r3]
80168de0:	e6ff3073 	uxth	r3, r3
80168de4:	e3530000 	cmp	r3, #0
80168de8:	0a000002 	beq	80168df8 <_RME_Thd_Sched_Bind+0x760>
80168dec:	e51b3010 	ldr	r3, [fp, #-16]
80168df0:	e5933004 	ldr	r3, [r3, #4]
80168df4:	ea000000 	b	80168dfc <_RME_Thd_Sched_Bind+0x764>
80168df8:	e51b3010 	ldr	r3, [fp, #-16]
80168dfc:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80168e00:	e5823038 	str	r3, [r2, #56]	@ 0x38
        
        /* Increase refcnt */
        RME_FETCH_ADD(&(Thread->Sched.Sched_Sig->Head.Root_Ref),1U);
80168e04:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168e08:	e5933038 	ldr	r3, [r3, #56]	@ 0x38
80168e0c:	e2833004 	add	r3, r3, #4
80168e10:	e3a01001 	mov	r1, #1
80168e14:	e1a00003 	mov	r0, r3
80168e18:	ebffdf7c 	bl	80160c10 <_RME_Fetch_Add_Single>
    }
    
    /* Set hypervisor context address if we're hypervisor-managed */
    if((Thread->Ctx.Hyp_Attr&RME_THD_HYP_FLAG)!=0U)
80168e1c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168e20:	e5933044 	ldr	r3, [r3, #68]	@ 0x44
80168e24:	e3530000 	cmp	r3, #0
80168e28:	aa000002 	bge	80168e38 <_RME_Thd_Sched_Bind+0x7a0>
    {
        RME_COV_MARKER();
        Thread->Ctx.Reg=(struct RME_Thd_Reg*)Haddr;
80168e2c:	e59b200c 	ldr	r2, [fp, #12]
80168e30:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168e34:	e5832048 	str	r2, [r3, #72]	@ 0x48
    {
        RME_COV_MARKER();
        /* No action required */
    }
    
    return 0;
80168e38:	e3a03000 	mov	r3, #0
}
80168e3c:	e1a00003 	mov	r0, r3
80168e40:	e24bd004 	sub	sp, fp, #4
80168e44:	e8bd8800 	pop	{fp, pc}

80168e48 <_RME_Thd_Sched_Free>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Thd_Sched_Free(struct RME_Cap_Cpt* Cpt, 
                                     struct RME_Reg_Struct* Reg,
                                     rme_cid_t Cap_Thd)
{
80168e48:	e92d4800 	push	{fp, lr}
80168e4c:	e28db004 	add	fp, sp, #4
80168e50:	e24dd020 	sub	sp, sp, #32
80168e54:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80168e58:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
80168e5c:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    /* These are used to free the thread */
    struct RME_CPU_Local* Local;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Thd,RME_CAP_TYPE_THD,
80168e60:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168e64:	e2033080 	and	r3, r3, #128	@ 0x80
80168e68:	e3530000 	cmp	r3, #0
80168e6c:	1a00001c 	bne	80168ee4 <_RME_Thd_Sched_Free+0x9c>
80168e70:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168e74:	e5932014 	ldr	r2, [r3, #20]
80168e78:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168e7c:	e1520003 	cmp	r2, r3
80168e80:	8a000001 	bhi	80168e8c <_RME_Thd_Sched_Free+0x44>
80168e84:	e3e03002 	mvn	r3, #2
80168e88:	ea0000d9 	b	801691f4 <_RME_Thd_Sched_Free+0x3ac>
80168e8c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168e90:	e1a02283 	lsl	r2, r3, #5
80168e94:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168e98:	e593300c 	ldr	r3, [r3, #12]
80168e9c:	e0823003 	add	r3, r2, r3
80168ea0:	e50b3008 	str	r3, [fp, #-8]
80168ea4:	e51b3008 	ldr	r3, [fp, #-8]
80168ea8:	e1a00003 	mov	r0, r3
80168eac:	ebffde13 	bl	80160700 <__RME_A7A_Read_Acquire>
80168eb0:	e50b000c 	str	r0, [fp, #-12]
80168eb4:	e51b300c 	ldr	r3, [fp, #-12]
80168eb8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80168ebc:	e3530802 	cmp	r3, #131072	@ 0x20000
80168ec0:	1a000001 	bne	80168ecc <_RME_Thd_Sched_Free+0x84>
80168ec4:	e3e03008 	mvn	r3, #8
80168ec8:	ea0000c9 	b	801691f4 <_RME_Thd_Sched_Free+0x3ac>
80168ecc:	e51b300c 	ldr	r3, [fp, #-12]
80168ed0:	e1a03c23 	lsr	r3, r3, #24
80168ed4:	e3530006 	cmp	r3, #6
80168ed8:	0a00003f 	beq	80168fdc <_RME_Thd_Sched_Free+0x194>
80168edc:	e3e03001 	mvn	r3, #1
80168ee0:	ea0000c3 	b	801691f4 <_RME_Thd_Sched_Free+0x3ac>
80168ee4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168ee8:	e1a02423 	lsr	r2, r3, #8
80168eec:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168ef0:	e5933014 	ldr	r3, [r3, #20]
80168ef4:	e1520003 	cmp	r2, r3
80168ef8:	3a000001 	bcc	80168f04 <_RME_Thd_Sched_Free+0xbc>
80168efc:	e3e03002 	mvn	r3, #2
80168f00:	ea0000bb 	b	801691f4 <_RME_Thd_Sched_Free+0x3ac>
80168f04:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168f08:	e1a03423 	lsr	r3, r3, #8
80168f0c:	e1a02283 	lsl	r2, r3, #5
80168f10:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80168f14:	e593300c 	ldr	r3, [r3, #12]
80168f18:	e0823003 	add	r3, r2, r3
80168f1c:	e50b3008 	str	r3, [fp, #-8]
80168f20:	e51b3008 	ldr	r3, [fp, #-8]
80168f24:	e1a00003 	mov	r0, r3
80168f28:	ebffddf4 	bl	80160700 <__RME_A7A_Read_Acquire>
80168f2c:	e50b000c 	str	r0, [fp, #-12]
80168f30:	e51b300c 	ldr	r3, [fp, #-12]
80168f34:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80168f38:	e3530802 	cmp	r3, #131072	@ 0x20000
80168f3c:	1a000001 	bne	80168f48 <_RME_Thd_Sched_Free+0x100>
80168f40:	e3e03008 	mvn	r3, #8
80168f44:	ea0000aa 	b	801691f4 <_RME_Thd_Sched_Free+0x3ac>
80168f48:	e51b300c 	ldr	r3, [fp, #-12]
80168f4c:	e1a03c23 	lsr	r3, r3, #24
80168f50:	e3530003 	cmp	r3, #3
80168f54:	0a000001 	beq	80168f60 <_RME_Thd_Sched_Free+0x118>
80168f58:	e3e03001 	mvn	r3, #1
80168f5c:	ea0000a4 	b	801691f4 <_RME_Thd_Sched_Free+0x3ac>
80168f60:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168f64:	e203207f 	and	r2, r3, #127	@ 0x7f
80168f68:	e51b3008 	ldr	r3, [fp, #-8]
80168f6c:	e5933014 	ldr	r3, [r3, #20]
80168f70:	e1520003 	cmp	r2, r3
80168f74:	3a000001 	bcc	80168f80 <_RME_Thd_Sched_Free+0x138>
80168f78:	e3e03002 	mvn	r3, #2
80168f7c:	ea00009c 	b	801691f4 <_RME_Thd_Sched_Free+0x3ac>
80168f80:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80168f84:	e203307f 	and	r3, r3, #127	@ 0x7f
80168f88:	e1a02283 	lsl	r2, r3, #5
80168f8c:	e51b3008 	ldr	r3, [fp, #-8]
80168f90:	e593300c 	ldr	r3, [r3, #12]
80168f94:	e0823003 	add	r3, r2, r3
80168f98:	e50b3008 	str	r3, [fp, #-8]
80168f9c:	e51b3008 	ldr	r3, [fp, #-8]
80168fa0:	e1a00003 	mov	r0, r3
80168fa4:	ebffddd5 	bl	80160700 <__RME_A7A_Read_Acquire>
80168fa8:	e50b000c 	str	r0, [fp, #-12]
80168fac:	e51b300c 	ldr	r3, [fp, #-12]
80168fb0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80168fb4:	e3530802 	cmp	r3, #131072	@ 0x20000
80168fb8:	1a000001 	bne	80168fc4 <_RME_Thd_Sched_Free+0x17c>
80168fbc:	e3e03008 	mvn	r3, #8
80168fc0:	ea00008b 	b	801691f4 <_RME_Thd_Sched_Free+0x3ac>
80168fc4:	e51b300c 	ldr	r3, [fp, #-12]
80168fc8:	e1a03c23 	lsr	r3, r3, #24
80168fcc:	e3530006 	cmp	r3, #6
80168fd0:	0a000001 	beq	80168fdc <_RME_Thd_Sched_Free+0x194>
80168fd4:	e3e03001 	mvn	r3, #1
80168fd8:	ea000085 	b	801691f4 <_RME_Thd_Sched_Free+0x3ac>
                   struct RME_Cap_Thd*,Thd_Op,Type_Stat);
    /* Check if the target cap is not frozen and allows such operations */
    RME_CAP_CHECK(Thd_Op,RME_THD_FLAG_SCHED_FREE);
80168fdc:	e51b3008 	ldr	r3, [fp, #-8]
80168fe0:	e5933008 	ldr	r3, [r3, #8]
80168fe4:	e2033010 	and	r3, r3, #16
80168fe8:	e3530000 	cmp	r3, #0
80168fec:	1a000001 	bne	80168ff8 <_RME_Thd_Sched_Free+0x1b0>
80168ff0:	e3e03006 	mvn	r3, #6
80168ff4:	ea00007e 	b	801691f4 <_RME_Thd_Sched_Free+0x3ac>
    
    /* Check if the target thread is already bound to this core */
    Local=RME_CPU_LOCAL();
80168ff8:	e3003004 	movw	r3, #4
80168ffc:	e3483017 	movt	r3, #32791	@ 0x8017
80169000:	e50b3010 	str	r3, [fp, #-16]
    Thread=(struct RME_Thd_Struct*)Thd_Op->Head.Object;
80169004:	e51b3008 	ldr	r3, [fp, #-8]
80169008:	e593300c 	ldr	r3, [r3, #12]
8016900c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    if(Thread->Sched.Local!=Local)
80169010:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169014:	e5933014 	ldr	r3, [r3, #20]
80169018:	e51b2010 	ldr	r2, [fp, #-16]
8016901c:	e1520003 	cmp	r2, r3
80169020:	0a000001 	beq	8016902c <_RME_Thd_Sched_Free+0x1e4>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
80169024:	e3e030cb 	mvn	r3, #203	@ 0xcb
80169028:	ea000071 	b	801691f4 <_RME_Thd_Sched_Free+0x3ac>
        /* No action required */
    }
    
    /* Am I referenced by someone as a scheduler? If yes, we cannot unbind. Because
     * boot-time thread's refcnt will never be 0, thus they will never pass this checking */
    if(Thread->Sched.Sched_Ref!=0U)
8016902c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169030:	e5933030 	ldr	r3, [r3, #48]	@ 0x30
80169034:	e3530000 	cmp	r3, #0
80169038:	0a000001 	beq	80169044 <_RME_Thd_Sched_Free+0x1fc>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_REFCNT;
8016903c:	e3e030cd 	mvn	r3, #205	@ 0xcd
80169040:	ea00006b 	b	801691f4 <_RME_Thd_Sched_Free+0x3ac>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Decrease the parent's reference count - on the same core */
    Thread->Sched.Sched_Thd->Sched.Sched_Ref--;
80169044:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169048:	e5933034 	ldr	r3, [r3, #52]	@ 0x34
8016904c:	e5932030 	ldr	r2, [r3, #48]	@ 0x30
80169050:	e2422001 	sub	r2, r2, #1
80169054:	e5832030 	str	r2, [r3, #48]	@ 0x30

    /* See if we have any events sent to the parent. If yes, remove that event */
    if(Thread->Sched.Notif.Next!=&(Thread->Sched.Notif))
80169058:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016905c:	e5932008 	ldr	r2, [r3, #8]
80169060:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169064:	e2833008 	add	r3, r3, #8
80169068:	e1520003 	cmp	r2, r3
8016906c:	0a00000a 	beq	8016909c <_RME_Thd_Sched_Free+0x254>
    {
        RME_COV_MARKER();

        _RME_List_Del(Thread->Sched.Notif.Prev,Thread->Sched.Notif.Next);
80169070:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169074:	e593200c 	ldr	r2, [r3, #12]
80169078:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016907c:	e5933008 	ldr	r3, [r3, #8]
80169080:	e1a01003 	mov	r1, r3
80169084:	e1a00002 	mov	r0, r2
80169088:	ebffdf13 	bl	80160cdc <_RME_List_Del>
        _RME_List_Crt(&(Thread->Sched.Notif));
8016908c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169090:	e2833008 	add	r3, r3, #8
80169094:	e1a00003 	mov	r0, r3
80169098:	ebffdf01 	bl	80160ca4 <_RME_List_Crt>
        RME_COV_MARKER();
        /* No action required */
    }

    /* If we have an scheduler event endpoint, release it */
    if(Thread->Sched.Sched_Sig!=RME_NULL)
8016909c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801690a0:	e5933038 	ldr	r3, [r3, #56]	@ 0x38
801690a4:	e3530000 	cmp	r3, #0
801690a8:	0a000005 	beq	801690c4 <_RME_Thd_Sched_Free+0x27c>
    {
        RME_COV_MARKER();

        RME_FETCH_ADD(&(Thread->Sched.Sched_Sig->Head.Root_Ref),-1);
801690ac:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801690b0:	e5933038 	ldr	r3, [r3, #56]	@ 0x38
801690b4:	e2833004 	add	r3, r3, #4
801690b8:	e3e01000 	mvn	r1, #0
801690bc:	e1a00003 	mov	r0, r3
801690c0:	ebffded2 	bl	80160c10 <_RME_Fetch_Add_Single>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Now save the system call return value to the caller stack */
    __RME_Svc_Retval_Set(Reg,0);  
801690c4:	e3a01000 	mov	r1, #0
801690c8:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
801690cc:	eb001203 	bl	8016d8e0 <__RME_Svc_Retval_Set>
    /* If the thread is ready, kick it out of the run queue. If it is blocked on
     * some endpoint, end the blocking and set the return value to RME_ERR_SIV_FREE.
     * If the thread is killed due to a fault, we will not clear the fault here, and
     * we will wait for the Exec_Set to clear it. No scheduler notifications are sent
     * because the thread is being freed and notifications at this point are useless. */
    if(Thread->Sched.State==RME_THD_READY)
801690d0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801690d4:	e593301c 	ldr	r3, [r3, #28]
801690d8:	e3530000 	cmp	r3, #0
801690dc:	1a000005 	bne	801690f8 <_RME_Thd_Sched_Free+0x2b0>
    {
        RME_COV_MARKER();

        /* Remove from runqueue and timeout but don't notify parent */
        _RME_Run_Del(Thread);
801690e0:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
801690e4:	ebfff229 	bl	80165990 <_RME_Run_Del>
        Thread->Sched.State=RME_THD_TIMEOUT;
801690e8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801690ec:	e3a02002 	mov	r2, #2
801690f0:	e583201c 	str	r2, [r3, #28]
801690f4:	ea000013 	b	80169148 <_RME_Thd_Sched_Free+0x300>
    }
    /* BLOCKED */
    else if(Thread->Sched.State==RME_THD_BLOCKED)
801690f8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801690fc:	e593301c 	ldr	r3, [r3, #28]
80169100:	e3530001 	cmp	r3, #1
80169104:	1a00000f 	bne	80169148 <_RME_Thd_Sched_Free+0x300>
    {
        RME_COV_MARKER();
        
        /* If it got here, the thread that is operated on cannot be the current 
         * thread, so we are not overwriting the return value of the caller. */
        __RME_Svc_Retval_Set(&(Thread->Ctx.Reg->Reg),RME_ERR_SIV_FREE);
80169108:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016910c:	e5933048 	ldr	r3, [r3, #72]	@ 0x48
80169110:	e30f1ece 	movw	r1, #65230	@ 0xfece
80169114:	e34f1fff 	movt	r1, #65535	@ 0xffff
80169118:	e1a00003 	mov	r0, r3
8016911c:	eb0011ef 	bl	8016d8e0 <__RME_Svc_Retval_Set>
        /* Release signal and thread from each other */
        Thread->Sched.Signal->Thd=RME_NULL;
80169120:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169124:	e5933028 	ldr	r3, [r3, #40]	@ 0x28
80169128:	e3a02000 	mov	r2, #0
8016912c:	e5832018 	str	r2, [r3, #24]
        Thread->Sched.Signal=RME_NULL;
80169130:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169134:	e3a02000 	mov	r2, #0
80169138:	e5832028 	str	r2, [r3, #40]	@ 0x28
        /* Timeout but don't notify parent */
        Thread->Sched.State=RME_THD_TIMEOUT;
8016913c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169140:	e3a02002 	mov	r2, #2
80169144:	e583201c 	str	r2, [r3, #28]
        RME_COV_MARKER();
        /* No action required */
    }

    /* Cleanup all remaining timeslices on it */
    Thread->Sched.Slice=0U;
80169148:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016914c:	e3a02000 	mov	r2, #0
80169150:	e5832018 	str	r2, [r3, #24]
    
    /* Check if this thread is the current one and we may need to switch away */
    if(Local->Thd_Cur==Thread)
80169154:	e51b3010 	ldr	r3, [fp, #-16]
80169158:	e5933004 	ldr	r3, [r3, #4]
8016915c:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
80169160:	e1520003 	cmp	r2, r3
80169164:	1a00001c 	bne	801691dc <_RME_Thd_Sched_Free+0x394>
    {
        RME_COV_MARKER();

        Local->Thd_Cur=_RME_Run_High(Local);
80169168:	e51b0010 	ldr	r0, [fp, #-16]
8016916c:	ebfff245 	bl	80165a88 <_RME_Run_High>
80169170:	e1a02000 	mov	r2, r0
80169174:	e51b3010 	ldr	r3, [fp, #-16]
80169178:	e5832004 	str	r2, [r3, #4]
        _RME_Run_Ins(Local->Thd_Cur);
8016917c:	e51b3010 	ldr	r3, [fp, #-16]
80169180:	e5933004 	ldr	r3, [r3, #4]
80169184:	e1a00003 	mov	r0, r3
80169188:	ebfff1c9 	bl	801658b4 <_RME_Run_Ins>
        RME_ASSERT(Local->Thd_Cur->Sched.State==RME_THD_READY);
8016918c:	e51b3010 	ldr	r3, [fp, #-16]
80169190:	e5933004 	ldr	r3, [r3, #4]
80169194:	e593301c 	ldr	r3, [r3, #28]
80169198:	e3530000 	cmp	r3, #0
8016919c:	0a000008 	beq	801691c4 <_RME_Thd_Sched_Free+0x37c>
801691a0:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
801691a4:	e3483016 	movt	r3, #32790	@ 0x8016
801691a8:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
801691ac:	e3482016 	movt	r2, #32790	@ 0x8016
801691b0:	e3011728 	movw	r1, #5928	@ 0x1728
801691b4:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
801691b8:	e3480016 	movt	r0, #32790	@ 0x8016
801691bc:	ebffde73 	bl	80160b90 <RME_Log>
801691c0:	eafffffe 	b	801691c0 <_RME_Thd_Sched_Free+0x378>
        _RME_Run_Swt(Reg,Thread,Local->Thd_Cur);
801691c4:	e51b3010 	ldr	r3, [fp, #-16]
801691c8:	e5933004 	ldr	r3, [r3, #4]
801691cc:	e1a02003 	mov	r2, r3
801691d0:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
801691d4:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
801691d8:	ebfff29d 	bl	80165c54 <_RME_Run_Swt>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Set the state to free so other cores can bind */
    RME_WRITE_RELEASE((rme_ptr_t*)&(Thread->Sched.Local),
801691dc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
801691e0:	e2833014 	add	r3, r3, #20
801691e4:	e3e01000 	mvn	r1, #0
801691e8:	e1a00003 	mov	r0, r3
801691ec:	ebffdd46 	bl	8016070c <__RME_A7A_Write_Release>
                      (rme_ptr_t)RME_THD_FREE);

    return 0;
801691f0:	e3a03000 	mov	r3, #0
}
801691f4:	e1a00003 	mov	r0, r3
801691f8:	e24bd004 	sub	sp, fp, #4
801691fc:	e8bd8800 	pop	{fp, pc}

80169200 <_RME_Thd_Exec_Set>:
                                   struct RME_Reg_Struct* Reg,
                                   rme_cid_t Cap_Thd,
                                   rme_ptr_t Entry,
                                   rme_ptr_t Stack,
                                   rme_ptr_t Param)
{
80169200:	e92d4800 	push	{fp, lr}
80169204:	e28db004 	add	fp, sp, #4
80169208:	e24dd028 	sub	sp, sp, #40	@ 0x28
8016920c:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
80169210:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
80169214:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
80169218:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    RME_DBG_S("\r\nParam ");
    RME_DBG_H(Param);*/


    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Thd,RME_CAP_TYPE_THD,
8016921c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169220:	e2033080 	and	r3, r3, #128	@ 0x80
80169224:	e3530000 	cmp	r3, #0
80169228:	1a00001c 	bne	801692a0 <_RME_Thd_Exec_Set+0xa0>
8016922c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169230:	e5932014 	ldr	r2, [r3, #20]
80169234:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169238:	e1520003 	cmp	r2, r3
8016923c:	8a000001 	bhi	80169248 <_RME_Thd_Exec_Set+0x48>
80169240:	e3e03002 	mvn	r3, #2
80169244:	ea000091 	b	80169490 <_RME_Thd_Exec_Set+0x290>
80169248:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016924c:	e1a02283 	lsl	r2, r3, #5
80169250:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169254:	e593300c 	ldr	r3, [r3, #12]
80169258:	e0823003 	add	r3, r2, r3
8016925c:	e50b3008 	str	r3, [fp, #-8]
80169260:	e51b3008 	ldr	r3, [fp, #-8]
80169264:	e1a00003 	mov	r0, r3
80169268:	ebffdd24 	bl	80160700 <__RME_A7A_Read_Acquire>
8016926c:	e50b000c 	str	r0, [fp, #-12]
80169270:	e51b300c 	ldr	r3, [fp, #-12]
80169274:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80169278:	e3530802 	cmp	r3, #131072	@ 0x20000
8016927c:	1a000001 	bne	80169288 <_RME_Thd_Exec_Set+0x88>
80169280:	e3e03008 	mvn	r3, #8
80169284:	ea000081 	b	80169490 <_RME_Thd_Exec_Set+0x290>
80169288:	e51b300c 	ldr	r3, [fp, #-12]
8016928c:	e1a03c23 	lsr	r3, r3, #24
80169290:	e3530006 	cmp	r3, #6
80169294:	0a00003f 	beq	80169398 <_RME_Thd_Exec_Set+0x198>
80169298:	e3e03001 	mvn	r3, #1
8016929c:	ea00007b 	b	80169490 <_RME_Thd_Exec_Set+0x290>
801692a0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801692a4:	e1a02423 	lsr	r2, r3, #8
801692a8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801692ac:	e5933014 	ldr	r3, [r3, #20]
801692b0:	e1520003 	cmp	r2, r3
801692b4:	3a000001 	bcc	801692c0 <_RME_Thd_Exec_Set+0xc0>
801692b8:	e3e03002 	mvn	r3, #2
801692bc:	ea000073 	b	80169490 <_RME_Thd_Exec_Set+0x290>
801692c0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801692c4:	e1a03423 	lsr	r3, r3, #8
801692c8:	e1a02283 	lsl	r2, r3, #5
801692cc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
801692d0:	e593300c 	ldr	r3, [r3, #12]
801692d4:	e0823003 	add	r3, r2, r3
801692d8:	e50b3008 	str	r3, [fp, #-8]
801692dc:	e51b3008 	ldr	r3, [fp, #-8]
801692e0:	e1a00003 	mov	r0, r3
801692e4:	ebffdd05 	bl	80160700 <__RME_A7A_Read_Acquire>
801692e8:	e50b000c 	str	r0, [fp, #-12]
801692ec:	e51b300c 	ldr	r3, [fp, #-12]
801692f0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801692f4:	e3530802 	cmp	r3, #131072	@ 0x20000
801692f8:	1a000001 	bne	80169304 <_RME_Thd_Exec_Set+0x104>
801692fc:	e3e03008 	mvn	r3, #8
80169300:	ea000062 	b	80169490 <_RME_Thd_Exec_Set+0x290>
80169304:	e51b300c 	ldr	r3, [fp, #-12]
80169308:	e1a03c23 	lsr	r3, r3, #24
8016930c:	e3530003 	cmp	r3, #3
80169310:	0a000001 	beq	8016931c <_RME_Thd_Exec_Set+0x11c>
80169314:	e3e03001 	mvn	r3, #1
80169318:	ea00005c 	b	80169490 <_RME_Thd_Exec_Set+0x290>
8016931c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169320:	e203207f 	and	r2, r3, #127	@ 0x7f
80169324:	e51b3008 	ldr	r3, [fp, #-8]
80169328:	e5933014 	ldr	r3, [r3, #20]
8016932c:	e1520003 	cmp	r2, r3
80169330:	3a000001 	bcc	8016933c <_RME_Thd_Exec_Set+0x13c>
80169334:	e3e03002 	mvn	r3, #2
80169338:	ea000054 	b	80169490 <_RME_Thd_Exec_Set+0x290>
8016933c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169340:	e203307f 	and	r3, r3, #127	@ 0x7f
80169344:	e1a02283 	lsl	r2, r3, #5
80169348:	e51b3008 	ldr	r3, [fp, #-8]
8016934c:	e593300c 	ldr	r3, [r3, #12]
80169350:	e0823003 	add	r3, r2, r3
80169354:	e50b3008 	str	r3, [fp, #-8]
80169358:	e51b3008 	ldr	r3, [fp, #-8]
8016935c:	e1a00003 	mov	r0, r3
80169360:	ebffdce6 	bl	80160700 <__RME_A7A_Read_Acquire>
80169364:	e50b000c 	str	r0, [fp, #-12]
80169368:	e51b300c 	ldr	r3, [fp, #-12]
8016936c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80169370:	e3530802 	cmp	r3, #131072	@ 0x20000
80169374:	1a000001 	bne	80169380 <_RME_Thd_Exec_Set+0x180>
80169378:	e3e03008 	mvn	r3, #8
8016937c:	ea000043 	b	80169490 <_RME_Thd_Exec_Set+0x290>
80169380:	e51b300c 	ldr	r3, [fp, #-12]
80169384:	e1a03c23 	lsr	r3, r3, #24
80169388:	e3530006 	cmp	r3, #6
8016938c:	0a000001 	beq	80169398 <_RME_Thd_Exec_Set+0x198>
80169390:	e3e03001 	mvn	r3, #1
80169394:	ea00003d 	b	80169490 <_RME_Thd_Exec_Set+0x290>
                   struct RME_Cap_Thd*,Thd_Op,Type_Stat);
    /* Check if the target cap is not frozen and allows such operations */
    RME_CAP_CHECK(Thd_Op,RME_THD_FLAG_EXEC_SET);
80169398:	e51b3008 	ldr	r3, [fp, #-8]
8016939c:	e5933008 	ldr	r3, [r3, #8]
801693a0:	e2033001 	and	r3, r3, #1
801693a4:	e3530000 	cmp	r3, #0
801693a8:	1a000001 	bne	801693b4 <_RME_Thd_Exec_Set+0x1b4>
801693ac:	e3e03006 	mvn	r3, #6
801693b0:	ea000036 	b	80169490 <_RME_Thd_Exec_Set+0x290>
    
    /* Check if the target thread is already bound, and quit if it is not on our core */
    Thread=RME_CAP_GETOBJ(Thd_Op,struct RME_Thd_Struct*);
801693b4:	e51b3008 	ldr	r3, [fp, #-8]
801693b8:	e593300c 	ldr	r3, [r3, #12]
801693bc:	e50b3010 	str	r3, [fp, #-16]
    Local=RME_CPU_LOCAL();
801693c0:	e3003004 	movw	r3, #4
801693c4:	e3483017 	movt	r3, #32791	@ 0x8017
801693c8:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    if(Thread->Sched.Local!=Local)
801693cc:	e51b3010 	ldr	r3, [fp, #-16]
801693d0:	e5933014 	ldr	r3, [r3, #20]
801693d4:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
801693d8:	e1520003 	cmp	r2, r3
801693dc:	0a000001 	beq	801693e8 <_RME_Thd_Exec_Set+0x1e8>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
801693e0:	e3e030cb 	mvn	r3, #203	@ 0xcb
801693e4:	ea000029 	b	80169490 <_RME_Thd_Exec_Set+0x290>
        /* No action required */
    }
    
    /* Commit the change if both values are non-zero. If both are zero we are just
     * clearing the error flag and continue from where the exception happened. */
    if((Entry!=RME_NULL)&&(Stack!=RME_NULL))
801693e8:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801693ec:	e3530000 	cmp	r3, #0
801693f0:	0a00000c 	beq	80169428 <_RME_Thd_Exec_Set+0x228>
801693f4:	e59b3004 	ldr	r3, [fp, #4]
801693f8:	e3530000 	cmp	r3, #0
801693fc:	0a000009 	beq	80169428 <_RME_Thd_Exec_Set+0x228>
    {
        RME_COV_MARKER();

        __RME_Thd_Reg_Init(RME_THD_ATTR(Thread->Ctx.Hyp_Attr),
80169400:	e51b3010 	ldr	r3, [fp, #-16]
80169404:	e5933044 	ldr	r3, [r3, #68]	@ 0x44
80169408:	e3c30102 	bic	r0, r3, #-2147483648	@ 0x80000000
                           Entry,Stack,Param,&(Thread->Ctx.Reg->Reg));
8016940c:	e51b3010 	ldr	r3, [fp, #-16]
80169410:	e5933048 	ldr	r3, [r3, #72]	@ 0x48
        __RME_Thd_Reg_Init(RME_THD_ATTR(Thread->Ctx.Hyp_Attr),
80169414:	e58d3000 	str	r3, [sp]
80169418:	e59b3008 	ldr	r3, [fp, #8]
8016941c:	e59b2004 	ldr	r2, [fp, #4]
80169420:	e51b1024 	ldr	r1, [fp, #-36]	@ 0xffffffdc
80169424:	eb001139 	bl	8016d910 <__RME_Thd_Reg_Init>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Now save the system call return value to the caller stack */
    __RME_Svc_Retval_Set(Reg,0);  
80169428:	e3a01000 	mov	r1, #0
8016942c:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80169430:	eb00112a 	bl	8016d8e0 <__RME_Svc_Retval_Set>
    
    /* Check if there is a exception pending and clear it if there is */
    if(Thread->Sched.State==RME_THD_EXCPEND)
80169434:	e51b3010 	ldr	r3, [fp, #-16]
80169438:	e593301c 	ldr	r3, [r3, #28]
8016943c:	e3530003 	cmp	r3, #3
80169440:	1a000011 	bne	8016948c <_RME_Thd_Exec_Set+0x28c>
    {
        RME_COV_MARKER();
        
        /* Check if the thread still have timeslices. If yes, put it into the runqueue;
         * if no, mark it as TIMEOUT and send scheduler notification to its parent. */
        if(Thread->Sched.Slice!=0U)
80169444:	e51b3010 	ldr	r3, [fp, #-16]
80169448:	e5933018 	ldr	r3, [r3, #24]
8016944c:	e3530000 	cmp	r3, #0
80169450:	0a000005 	beq	8016946c <_RME_Thd_Exec_Set+0x26c>
        {
            RME_COV_MARKER();
            
            /* Ready and add to runqueue */
            Thread->Sched.State=RME_THD_READY;
80169454:	e51b3010 	ldr	r3, [fp, #-16]
80169458:	e3a02000 	mov	r2, #0
8016945c:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Ins(Thread);
80169460:	e51b0010 	ldr	r0, [fp, #-16]
80169464:	ebfff112 	bl	801658b4 <_RME_Run_Ins>
80169468:	ea000004 	b	80169480 <_RME_Thd_Exec_Set+0x280>
        else
        {
            RME_COV_MARKER();
            
            /* Timeout and notify parent */
            Thread->Sched.State=RME_THD_TIMEOUT;
8016946c:	e51b3010 	ldr	r3, [fp, #-16]
80169470:	e3a02002 	mov	r2, #2
80169474:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Notif(Thread);
80169478:	e51b0010 	ldr	r0, [fp, #-16]
8016947c:	ebfff1b7 	bl	80165b60 <_RME_Run_Notif>
        }
        
        /* Pick the highest priority thread because something unblocked */
        _RME_Kern_High(Reg,Local);
80169480:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
80169484:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
80169488:	eb000688 	bl	8016aeb0 <_RME_Kern_High>
    {
        RME_COV_MARKER();
        /* No action required */
    }
    
    return 0;
8016948c:	e3a03000 	mov	r3, #0
}
80169490:	e1a00003 	mov	r0, r3
80169494:	e24bd004 	sub	sp, fp, #4
80169498:	e8bd8800 	pop	{fp, pc}

8016949c <_RME_Thd_Sched_Prio>:
                                     rme_ptr_t Prio0,
                                     rme_cid_t Cap_Thd1,
                                     rme_ptr_t Prio1,
                                     rme_cid_t Cap_Thd2,
                                     rme_ptr_t Prio2)
{
8016949c:	e92d4800 	push	{fp, lr}
801694a0:	e28db004 	add	fp, sp, #4
801694a4:	e24dd050 	sub	sp, sp, #80	@ 0x50
801694a8:	e50b0048 	str	r0, [fp, #-72]	@ 0xffffffb8
801694ac:	e50b104c 	str	r1, [fp, #-76]	@ 0xffffffb4
801694b0:	e50b2050 	str	r2, [fp, #-80]	@ 0xffffffb0
801694b4:	e50b3054 	str	r3, [fp, #-84]	@ 0xffffffac
    struct RME_Thd_Struct* Thread[3];
    struct RME_CPU_Local* Local;
    rme_ptr_t Type_Stat;
    
    /* Check parameter validity */
    if((Number==0U)||(Number>3U))
801694b8:	e51b3050 	ldr	r3, [fp, #-80]	@ 0xffffffb0
801694bc:	e3530000 	cmp	r3, #0
801694c0:	0a000002 	beq	801694d0 <_RME_Thd_Sched_Prio+0x34>
801694c4:	e51b3050 	ldr	r3, [fp, #-80]	@ 0xffffffb0
801694c8:	e3530003 	cmp	r3, #3
801694cc:	9a000001 	bls	801694d8 <_RME_Thd_Sched_Prio+0x3c>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
801694d0:	e3e030cb 	mvn	r3, #203	@ 0xcb
801694d4:	ea000126 	b	80169974 <_RME_Thd_Sched_Prio+0x4d8>
    }
    
    /* We'll use arrays in the next */
    Cap_Thd[0]=Cap_Thd0;
801694d8:	e51b3054 	ldr	r3, [fp, #-84]	@ 0xffffffac
801694dc:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    Cap_Thd[1]=Cap_Thd1;
801694e0:	e59b3008 	ldr	r3, [fp, #8]
801694e4:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Cap_Thd[2]=Cap_Thd2;
801694e8:	e59b3010 	ldr	r3, [fp, #16]
801694ec:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Prio[0]=Prio0;
801694f0:	e59b3004 	ldr	r3, [fp, #4]
801694f4:	e50b3028 	str	r3, [fp, #-40]	@ 0xffffffd8
    Prio[1]=Prio1;
801694f8:	e59b300c 	ldr	r3, [fp, #12]
801694fc:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    Prio[2]=Prio2;
80169500:	e59b3014 	ldr	r3, [fp, #20]
80169504:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0

    Local=RME_CPU_LOCAL();
80169508:	e3003004 	movw	r3, #4
8016950c:	e3483017 	movt	r3, #32791	@ 0x8017
80169510:	e50b300c 	str	r3, [fp, #-12]
    for(Count=0U;Count<Number;Count++)
80169514:	e3a03000 	mov	r3, #0
80169518:	e50b3008 	str	r3, [fp, #-8]
8016951c:	ea0000d2 	b	8016986c <_RME_Thd_Sched_Prio+0x3d0>
    {
        /* Get the capability slot */
        RME_CPT_GETCAP(Cpt,Cap_Thd[Count],RME_CAP_TYPE_THD,
80169520:	e51b3008 	ldr	r3, [fp, #-8]
80169524:	e1a03103 	lsl	r3, r3, #2
80169528:	e2433004 	sub	r3, r3, #4
8016952c:	e083300b 	add	r3, r3, fp
80169530:	e5133018 	ldr	r3, [r3, #-24]	@ 0xffffffe8
80169534:	e2033080 	and	r3, r3, #128	@ 0x80
80169538:	e3530000 	cmp	r3, #0
8016953c:	1a00002e 	bne	801695fc <_RME_Thd_Sched_Prio+0x160>
80169540:	e51b3008 	ldr	r3, [fp, #-8]
80169544:	e1a03103 	lsl	r3, r3, #2
80169548:	e2433004 	sub	r3, r3, #4
8016954c:	e083300b 	add	r3, r3, fp
80169550:	e5133018 	ldr	r3, [r3, #-24]	@ 0xffffffe8
80169554:	e1a02003 	mov	r2, r3
80169558:	e51b3048 	ldr	r3, [fp, #-72]	@ 0xffffffb8
8016955c:	e5933014 	ldr	r3, [r3, #20]
80169560:	e1520003 	cmp	r2, r3
80169564:	3a000001 	bcc	80169570 <_RME_Thd_Sched_Prio+0xd4>
80169568:	e3e03002 	mvn	r3, #2
8016956c:	ea000100 	b	80169974 <_RME_Thd_Sched_Prio+0x4d8>
80169570:	e51b3008 	ldr	r3, [fp, #-8]
80169574:	e1a03103 	lsl	r3, r3, #2
80169578:	e2433004 	sub	r3, r3, #4
8016957c:	e083300b 	add	r3, r3, fp
80169580:	e5133018 	ldr	r3, [r3, #-24]	@ 0xffffffe8
80169584:	e1a02283 	lsl	r2, r3, #5
80169588:	e51b3048 	ldr	r3, [fp, #-72]	@ 0xffffffb8
8016958c:	e593300c 	ldr	r3, [r3, #12]
80169590:	e0823003 	add	r3, r2, r3
80169594:	e1a02003 	mov	r2, r3
80169598:	e51b3008 	ldr	r3, [fp, #-8]
8016959c:	e1a03103 	lsl	r3, r3, #2
801695a0:	e2433004 	sub	r3, r3, #4
801695a4:	e083300b 	add	r3, r3, fp
801695a8:	e5032030 	str	r2, [r3, #-48]	@ 0xffffffd0
801695ac:	e51b3008 	ldr	r3, [fp, #-8]
801695b0:	e1a03103 	lsl	r3, r3, #2
801695b4:	e2433004 	sub	r3, r3, #4
801695b8:	e083300b 	add	r3, r3, fp
801695bc:	e5133030 	ldr	r3, [r3, #-48]	@ 0xffffffd0
801695c0:	e1a00003 	mov	r0, r3
801695c4:	ebffdc4d 	bl	80160700 <__RME_A7A_Read_Acquire>
801695c8:	e50b0010 	str	r0, [fp, #-16]
801695cc:	e51b3010 	ldr	r3, [fp, #-16]
801695d0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801695d4:	e3530802 	cmp	r3, #131072	@ 0x20000
801695d8:	1a000001 	bne	801695e4 <_RME_Thd_Sched_Prio+0x148>
801695dc:	e3e03008 	mvn	r3, #8
801695e0:	ea0000e3 	b	80169974 <_RME_Thd_Sched_Prio+0x4d8>
801695e4:	e51b3010 	ldr	r3, [fp, #-16]
801695e8:	e1a03c23 	lsr	r3, r3, #24
801695ec:	e3530006 	cmp	r3, #6
801695f0:	0a000069 	beq	8016979c <_RME_Thd_Sched_Prio+0x300>
801695f4:	e3e03001 	mvn	r3, #1
801695f8:	ea0000dd 	b	80169974 <_RME_Thd_Sched_Prio+0x4d8>
801695fc:	e51b3008 	ldr	r3, [fp, #-8]
80169600:	e1a03103 	lsl	r3, r3, #2
80169604:	e2433004 	sub	r3, r3, #4
80169608:	e083300b 	add	r3, r3, fp
8016960c:	e5133018 	ldr	r3, [r3, #-24]	@ 0xffffffe8
80169610:	e1a02423 	lsr	r2, r3, #8
80169614:	e51b3048 	ldr	r3, [fp, #-72]	@ 0xffffffb8
80169618:	e5933014 	ldr	r3, [r3, #20]
8016961c:	e1520003 	cmp	r2, r3
80169620:	3a000001 	bcc	8016962c <_RME_Thd_Sched_Prio+0x190>
80169624:	e3e03002 	mvn	r3, #2
80169628:	ea0000d1 	b	80169974 <_RME_Thd_Sched_Prio+0x4d8>
8016962c:	e51b3008 	ldr	r3, [fp, #-8]
80169630:	e1a03103 	lsl	r3, r3, #2
80169634:	e2433004 	sub	r3, r3, #4
80169638:	e083300b 	add	r3, r3, fp
8016963c:	e5133018 	ldr	r3, [r3, #-24]	@ 0xffffffe8
80169640:	e1a03423 	lsr	r3, r3, #8
80169644:	e1a02283 	lsl	r2, r3, #5
80169648:	e51b3048 	ldr	r3, [fp, #-72]	@ 0xffffffb8
8016964c:	e593300c 	ldr	r3, [r3, #12]
80169650:	e0823003 	add	r3, r2, r3
80169654:	e1a02003 	mov	r2, r3
80169658:	e51b3008 	ldr	r3, [fp, #-8]
8016965c:	e1a03103 	lsl	r3, r3, #2
80169660:	e2433004 	sub	r3, r3, #4
80169664:	e083300b 	add	r3, r3, fp
80169668:	e5032030 	str	r2, [r3, #-48]	@ 0xffffffd0
8016966c:	e51b3008 	ldr	r3, [fp, #-8]
80169670:	e1a03103 	lsl	r3, r3, #2
80169674:	e2433004 	sub	r3, r3, #4
80169678:	e083300b 	add	r3, r3, fp
8016967c:	e5133030 	ldr	r3, [r3, #-48]	@ 0xffffffd0
80169680:	e1a00003 	mov	r0, r3
80169684:	ebffdc1d 	bl	80160700 <__RME_A7A_Read_Acquire>
80169688:	e50b0010 	str	r0, [fp, #-16]
8016968c:	e51b3010 	ldr	r3, [fp, #-16]
80169690:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80169694:	e3530802 	cmp	r3, #131072	@ 0x20000
80169698:	1a000001 	bne	801696a4 <_RME_Thd_Sched_Prio+0x208>
8016969c:	e3e03008 	mvn	r3, #8
801696a0:	ea0000b3 	b	80169974 <_RME_Thd_Sched_Prio+0x4d8>
801696a4:	e51b3010 	ldr	r3, [fp, #-16]
801696a8:	e1a03c23 	lsr	r3, r3, #24
801696ac:	e3530003 	cmp	r3, #3
801696b0:	0a000001 	beq	801696bc <_RME_Thd_Sched_Prio+0x220>
801696b4:	e3e03001 	mvn	r3, #1
801696b8:	ea0000ad 	b	80169974 <_RME_Thd_Sched_Prio+0x4d8>
801696bc:	e51b3008 	ldr	r3, [fp, #-8]
801696c0:	e1a03103 	lsl	r3, r3, #2
801696c4:	e2433004 	sub	r3, r3, #4
801696c8:	e083300b 	add	r3, r3, fp
801696cc:	e5133018 	ldr	r3, [r3, #-24]	@ 0xffffffe8
801696d0:	e203207f 	and	r2, r3, #127	@ 0x7f
801696d4:	e51b3008 	ldr	r3, [fp, #-8]
801696d8:	e1a03103 	lsl	r3, r3, #2
801696dc:	e2433004 	sub	r3, r3, #4
801696e0:	e083300b 	add	r3, r3, fp
801696e4:	e5133030 	ldr	r3, [r3, #-48]	@ 0xffffffd0
801696e8:	e5933014 	ldr	r3, [r3, #20]
801696ec:	e1520003 	cmp	r2, r3
801696f0:	3a000001 	bcc	801696fc <_RME_Thd_Sched_Prio+0x260>
801696f4:	e3e03002 	mvn	r3, #2
801696f8:	ea00009d 	b	80169974 <_RME_Thd_Sched_Prio+0x4d8>
801696fc:	e51b3008 	ldr	r3, [fp, #-8]
80169700:	e1a03103 	lsl	r3, r3, #2
80169704:	e2433004 	sub	r3, r3, #4
80169708:	e083300b 	add	r3, r3, fp
8016970c:	e5133018 	ldr	r3, [r3, #-24]	@ 0xffffffe8
80169710:	e203307f 	and	r3, r3, #127	@ 0x7f
80169714:	e1a02283 	lsl	r2, r3, #5
80169718:	e51b3008 	ldr	r3, [fp, #-8]
8016971c:	e1a03103 	lsl	r3, r3, #2
80169720:	e2433004 	sub	r3, r3, #4
80169724:	e083300b 	add	r3, r3, fp
80169728:	e5133030 	ldr	r3, [r3, #-48]	@ 0xffffffd0
8016972c:	e593300c 	ldr	r3, [r3, #12]
80169730:	e0823003 	add	r3, r2, r3
80169734:	e1a02003 	mov	r2, r3
80169738:	e51b3008 	ldr	r3, [fp, #-8]
8016973c:	e1a03103 	lsl	r3, r3, #2
80169740:	e2433004 	sub	r3, r3, #4
80169744:	e083300b 	add	r3, r3, fp
80169748:	e5032030 	str	r2, [r3, #-48]	@ 0xffffffd0
8016974c:	e51b3008 	ldr	r3, [fp, #-8]
80169750:	e1a03103 	lsl	r3, r3, #2
80169754:	e2433004 	sub	r3, r3, #4
80169758:	e083300b 	add	r3, r3, fp
8016975c:	e5133030 	ldr	r3, [r3, #-48]	@ 0xffffffd0
80169760:	e1a00003 	mov	r0, r3
80169764:	ebffdbe5 	bl	80160700 <__RME_A7A_Read_Acquire>
80169768:	e50b0010 	str	r0, [fp, #-16]
8016976c:	e51b3010 	ldr	r3, [fp, #-16]
80169770:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80169774:	e3530802 	cmp	r3, #131072	@ 0x20000
80169778:	1a000001 	bne	80169784 <_RME_Thd_Sched_Prio+0x2e8>
8016977c:	e3e03008 	mvn	r3, #8
80169780:	ea00007b 	b	80169974 <_RME_Thd_Sched_Prio+0x4d8>
80169784:	e51b3010 	ldr	r3, [fp, #-16]
80169788:	e1a03c23 	lsr	r3, r3, #24
8016978c:	e3530006 	cmp	r3, #6
80169790:	0a000001 	beq	8016979c <_RME_Thd_Sched_Prio+0x300>
80169794:	e3e03001 	mvn	r3, #1
80169798:	ea000075 	b	80169974 <_RME_Thd_Sched_Prio+0x4d8>
                       struct RME_Cap_Thd*,Thd_Op[Count],Type_Stat);
        /* Check if the target cap is not frozen and allows such operations */
        RME_CAP_CHECK(Thd_Op[Count],RME_THD_FLAG_SCHED_PRIO);
8016979c:	e51b3008 	ldr	r3, [fp, #-8]
801697a0:	e1a03103 	lsl	r3, r3, #2
801697a4:	e2433004 	sub	r3, r3, #4
801697a8:	e083300b 	add	r3, r3, fp
801697ac:	e5133030 	ldr	r3, [r3, #-48]	@ 0xffffffd0
801697b0:	e5933008 	ldr	r3, [r3, #8]
801697b4:	e2033008 	and	r3, r3, #8
801697b8:	e3530000 	cmp	r3, #0
801697bc:	1a000001 	bne	801697c8 <_RME_Thd_Sched_Prio+0x32c>
801697c0:	e3e03006 	mvn	r3, #6
801697c4:	ea00006a 	b	80169974 <_RME_Thd_Sched_Prio+0x4d8>
        
        /* See if the target thread is already bound to this core. If no, we just quit */
        Thread[Count]=(struct RME_Thd_Struct*)(Thd_Op[Count]->Head.Object);
801697c8:	e51b3008 	ldr	r3, [fp, #-8]
801697cc:	e1a03103 	lsl	r3, r3, #2
801697d0:	e2433004 	sub	r3, r3, #4
801697d4:	e083300b 	add	r3, r3, fp
801697d8:	e5133030 	ldr	r3, [r3, #-48]	@ 0xffffffd0
801697dc:	e593300c 	ldr	r3, [r3, #12]
801697e0:	e1a02003 	mov	r2, r3
801697e4:	e51b3008 	ldr	r3, [fp, #-8]
801697e8:	e1a03103 	lsl	r3, r3, #2
801697ec:	e2433004 	sub	r3, r3, #4
801697f0:	e083300b 	add	r3, r3, fp
801697f4:	e503203c 	str	r2, [r3, #-60]	@ 0xffffffc4
        if(Thread[Count]->Sched.Local!=Local)
801697f8:	e51b3008 	ldr	r3, [fp, #-8]
801697fc:	e1a03103 	lsl	r3, r3, #2
80169800:	e2433004 	sub	r3, r3, #4
80169804:	e083300b 	add	r3, r3, fp
80169808:	e513303c 	ldr	r3, [r3, #-60]	@ 0xffffffc4
8016980c:	e5933014 	ldr	r3, [r3, #20]
80169810:	e51b200c 	ldr	r2, [fp, #-12]
80169814:	e1520003 	cmp	r2, r3
80169818:	0a000001 	beq	80169824 <_RME_Thd_Sched_Prio+0x388>
        {
            RME_COV_MARKER();

            return RME_ERR_PTH_INVSTATE;
8016981c:	e3e030cb 	mvn	r3, #203	@ 0xcb
80169820:	ea000053 	b	80169974 <_RME_Thd_Sched_Prio+0x4d8>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* See if the priority relationship is correct */
        if(Thread[Count]->Sched.Prio_Max<Prio[Count])
80169824:	e51b3008 	ldr	r3, [fp, #-8]
80169828:	e1a03103 	lsl	r3, r3, #2
8016982c:	e2433004 	sub	r3, r3, #4
80169830:	e083300b 	add	r3, r3, fp
80169834:	e513303c 	ldr	r3, [r3, #-60]	@ 0xffffffc4
80169838:	e5932024 	ldr	r2, [r3, #36]	@ 0x24
8016983c:	e51b3008 	ldr	r3, [fp, #-8]
80169840:	e1a03103 	lsl	r3, r3, #2
80169844:	e2433004 	sub	r3, r3, #4
80169848:	e083300b 	add	r3, r3, fp
8016984c:	e5133024 	ldr	r3, [r3, #-36]	@ 0xffffffdc
80169850:	e1520003 	cmp	r2, r3
80169854:	2a000001 	bcs	80169860 <_RME_Thd_Sched_Prio+0x3c4>
        {
            RME_COV_MARKER();

            return RME_ERR_PTH_PRIO;
80169858:	e3e030cc 	mvn	r3, #204	@ 0xcc
8016985c:	ea000044 	b	80169974 <_RME_Thd_Sched_Prio+0x4d8>
    for(Count=0U;Count<Number;Count++)
80169860:	e51b3008 	ldr	r3, [fp, #-8]
80169864:	e2833001 	add	r3, r3, #1
80169868:	e50b3008 	str	r3, [fp, #-8]
8016986c:	e51b2008 	ldr	r2, [fp, #-8]
80169870:	e51b3050 	ldr	r3, [fp, #-80]	@ 0xffffffb0
80169874:	e1520003 	cmp	r2, r3
80169878:	3affff28 	bcc	80169520 <_RME_Thd_Sched_Prio+0x84>
            /* No action required */
        }
    }
    
    /* Now save the system call return value to the caller stack */
    __RME_Svc_Retval_Set(Reg,0);
8016987c:	e3a01000 	mov	r1, #0
80169880:	e51b004c 	ldr	r0, [fp, #-76]	@ 0xffffffb4
80169884:	eb001015 	bl	8016d8e0 <__RME_Svc_Retval_Set>
    
    /* Change priority for each thread, and we'll switch to the real highest priority
     * thread after all these changes. This can help remove the excessive overhead. */
    for(Count=0U;Count<Number;Count++)
80169888:	e3a03000 	mov	r3, #0
8016988c:	e50b3008 	str	r3, [fp, #-8]
80169890:	ea00002f 	b	80169954 <_RME_Thd_Sched_Prio+0x4b8>
    {
        /* See if this thread is currently in the runqueue */
        if(Thread[Count]->Sched.State==RME_THD_READY)
80169894:	e51b3008 	ldr	r3, [fp, #-8]
80169898:	e1a03103 	lsl	r3, r3, #2
8016989c:	e2433004 	sub	r3, r3, #4
801698a0:	e083300b 	add	r3, r3, fp
801698a4:	e513303c 	ldr	r3, [r3, #-60]	@ 0xffffffc4
801698a8:	e593301c 	ldr	r3, [r3, #28]
801698ac:	e3530000 	cmp	r3, #0
801698b0:	1a000019 	bne	8016991c <_RME_Thd_Sched_Prio+0x480>
        {
            RME_COV_MARKER();

            /* Remove from runqueue, change priority, and add it back */
            _RME_Run_Del(Thread[Count]);
801698b4:	e51b3008 	ldr	r3, [fp, #-8]
801698b8:	e1a03103 	lsl	r3, r3, #2
801698bc:	e2433004 	sub	r3, r3, #4
801698c0:	e083300b 	add	r3, r3, fp
801698c4:	e513303c 	ldr	r3, [r3, #-60]	@ 0xffffffc4
801698c8:	e1a00003 	mov	r0, r3
801698cc:	ebfff02f 	bl	80165990 <_RME_Run_Del>
            Thread[Count]->Sched.Prio=Prio[Count];
801698d0:	e51b3008 	ldr	r3, [fp, #-8]
801698d4:	e1a03103 	lsl	r3, r3, #2
801698d8:	e2433004 	sub	r3, r3, #4
801698dc:	e083300b 	add	r3, r3, fp
801698e0:	e513203c 	ldr	r2, [r3, #-60]	@ 0xffffffc4
801698e4:	e51b3008 	ldr	r3, [fp, #-8]
801698e8:	e1a03103 	lsl	r3, r3, #2
801698ec:	e2433004 	sub	r3, r3, #4
801698f0:	e083300b 	add	r3, r3, fp
801698f4:	e5133024 	ldr	r3, [r3, #-36]	@ 0xffffffdc
801698f8:	e5823020 	str	r3, [r2, #32]
            _RME_Run_Ins(Thread[Count]);
801698fc:	e51b3008 	ldr	r3, [fp, #-8]
80169900:	e1a03103 	lsl	r3, r3, #2
80169904:	e2433004 	sub	r3, r3, #4
80169908:	e083300b 	add	r3, r3, fp
8016990c:	e513303c 	ldr	r3, [r3, #-60]	@ 0xffffffc4
80169910:	e1a00003 	mov	r0, r3
80169914:	ebffefe6 	bl	801658b4 <_RME_Run_Ins>
80169918:	ea00000a 	b	80169948 <_RME_Thd_Sched_Prio+0x4ac>
        /* If it is BLOCKED, TIMEOUT or EXCPEND, changing the number will suffice */
        else
        {
            RME_COV_MARKER();

            Thread[Count]->Sched.Prio=Prio[Count];
8016991c:	e51b3008 	ldr	r3, [fp, #-8]
80169920:	e1a03103 	lsl	r3, r3, #2
80169924:	e2433004 	sub	r3, r3, #4
80169928:	e083300b 	add	r3, r3, fp
8016992c:	e513203c 	ldr	r2, [r3, #-60]	@ 0xffffffc4
80169930:	e51b3008 	ldr	r3, [fp, #-8]
80169934:	e1a03103 	lsl	r3, r3, #2
80169938:	e2433004 	sub	r3, r3, #4
8016993c:	e083300b 	add	r3, r3, fp
80169940:	e5133024 	ldr	r3, [r3, #-36]	@ 0xffffffdc
80169944:	e5823020 	str	r3, [r2, #32]
    for(Count=0U;Count<Number;Count++)
80169948:	e51b3008 	ldr	r3, [fp, #-8]
8016994c:	e2833001 	add	r3, r3, #1
80169950:	e50b3008 	str	r3, [fp, #-8]
80169954:	e51b2008 	ldr	r2, [fp, #-8]
80169958:	e51b3050 	ldr	r3, [fp, #-80]	@ 0xffffffb0
8016995c:	e1520003 	cmp	r2, r3
80169960:	3affffcb 	bcc	80169894 <_RME_Thd_Sched_Prio+0x3f8>
        }
    }
    
    /* Pick the current highest priority thread to run */
    _RME_Kern_High(Reg,Local);
80169964:	e51b100c 	ldr	r1, [fp, #-12]
80169968:	e51b004c 	ldr	r0, [fp, #-76]	@ 0xffffffb4
8016996c:	eb00054f 	bl	8016aeb0 <_RME_Kern_High>

    return 0;
80169970:	e3a03000 	mov	r3, #0
}
80169974:	e1a00003 	mov	r0, r3
80169978:	e24bd004 	sub	sp, fp, #4
8016997c:	e8bd8800 	pop	{fp, pc}

80169980 <_RME_Thd_Sched_Rcv>:
Output      : None.
Return      : rme_ret_t - If successful, the thread ID; or an error code.
******************************************************************************/
static rme_ret_t _RME_Thd_Sched_Rcv(struct RME_Cap_Cpt* Cpt,
                                    rme_cid_t Cap_Thd)
{
80169980:	e92d4800 	push	{fp, lr}
80169984:	e28db004 	add	fp, sp, #4
80169988:	e24dd020 	sub	sp, sp, #32
8016998c:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
80169990:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
    struct RME_Thd_Struct* Thread;
    rme_ptr_t Type_Stat;
    rme_ptr_t Flag;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Thd,RME_CAP_TYPE_THD,
80169994:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80169998:	e2033080 	and	r3, r3, #128	@ 0x80
8016999c:	e3530000 	cmp	r3, #0
801699a0:	1a00001c 	bne	80169a18 <_RME_Thd_Sched_Rcv+0x98>
801699a4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801699a8:	e5932014 	ldr	r2, [r3, #20]
801699ac:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801699b0:	e1520003 	cmp	r2, r3
801699b4:	8a000001 	bhi	801699c0 <_RME_Thd_Sched_Rcv+0x40>
801699b8:	e3e03002 	mvn	r3, #2
801699bc:	ea000097 	b	80169c20 <_RME_Thd_Sched_Rcv+0x2a0>
801699c0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
801699c4:	e1a02283 	lsl	r2, r3, #5
801699c8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
801699cc:	e593300c 	ldr	r3, [r3, #12]
801699d0:	e0823003 	add	r3, r2, r3
801699d4:	e50b3008 	str	r3, [fp, #-8]
801699d8:	e51b3008 	ldr	r3, [fp, #-8]
801699dc:	e1a00003 	mov	r0, r3
801699e0:	ebffdb46 	bl	80160700 <__RME_A7A_Read_Acquire>
801699e4:	e50b0010 	str	r0, [fp, #-16]
801699e8:	e51b3010 	ldr	r3, [fp, #-16]
801699ec:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
801699f0:	e3530802 	cmp	r3, #131072	@ 0x20000
801699f4:	1a000001 	bne	80169a00 <_RME_Thd_Sched_Rcv+0x80>
801699f8:	e3e03008 	mvn	r3, #8
801699fc:	ea000087 	b	80169c20 <_RME_Thd_Sched_Rcv+0x2a0>
80169a00:	e51b3010 	ldr	r3, [fp, #-16]
80169a04:	e1a03c23 	lsr	r3, r3, #24
80169a08:	e3530006 	cmp	r3, #6
80169a0c:	0a00003f 	beq	80169b10 <_RME_Thd_Sched_Rcv+0x190>
80169a10:	e3e03001 	mvn	r3, #1
80169a14:	ea000081 	b	80169c20 <_RME_Thd_Sched_Rcv+0x2a0>
80169a18:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80169a1c:	e1a02423 	lsr	r2, r3, #8
80169a20:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169a24:	e5933014 	ldr	r3, [r3, #20]
80169a28:	e1520003 	cmp	r2, r3
80169a2c:	3a000001 	bcc	80169a38 <_RME_Thd_Sched_Rcv+0xb8>
80169a30:	e3e03002 	mvn	r3, #2
80169a34:	ea000079 	b	80169c20 <_RME_Thd_Sched_Rcv+0x2a0>
80169a38:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80169a3c:	e1a03423 	lsr	r3, r3, #8
80169a40:	e1a02283 	lsl	r2, r3, #5
80169a44:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169a48:	e593300c 	ldr	r3, [r3, #12]
80169a4c:	e0823003 	add	r3, r2, r3
80169a50:	e50b3008 	str	r3, [fp, #-8]
80169a54:	e51b3008 	ldr	r3, [fp, #-8]
80169a58:	e1a00003 	mov	r0, r3
80169a5c:	ebffdb27 	bl	80160700 <__RME_A7A_Read_Acquire>
80169a60:	e50b0010 	str	r0, [fp, #-16]
80169a64:	e51b3010 	ldr	r3, [fp, #-16]
80169a68:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80169a6c:	e3530802 	cmp	r3, #131072	@ 0x20000
80169a70:	1a000001 	bne	80169a7c <_RME_Thd_Sched_Rcv+0xfc>
80169a74:	e3e03008 	mvn	r3, #8
80169a78:	ea000068 	b	80169c20 <_RME_Thd_Sched_Rcv+0x2a0>
80169a7c:	e51b3010 	ldr	r3, [fp, #-16]
80169a80:	e1a03c23 	lsr	r3, r3, #24
80169a84:	e3530003 	cmp	r3, #3
80169a88:	0a000001 	beq	80169a94 <_RME_Thd_Sched_Rcv+0x114>
80169a8c:	e3e03001 	mvn	r3, #1
80169a90:	ea000062 	b	80169c20 <_RME_Thd_Sched_Rcv+0x2a0>
80169a94:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80169a98:	e203207f 	and	r2, r3, #127	@ 0x7f
80169a9c:	e51b3008 	ldr	r3, [fp, #-8]
80169aa0:	e5933014 	ldr	r3, [r3, #20]
80169aa4:	e1520003 	cmp	r2, r3
80169aa8:	3a000001 	bcc	80169ab4 <_RME_Thd_Sched_Rcv+0x134>
80169aac:	e3e03002 	mvn	r3, #2
80169ab0:	ea00005a 	b	80169c20 <_RME_Thd_Sched_Rcv+0x2a0>
80169ab4:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
80169ab8:	e203307f 	and	r3, r3, #127	@ 0x7f
80169abc:	e1a02283 	lsl	r2, r3, #5
80169ac0:	e51b3008 	ldr	r3, [fp, #-8]
80169ac4:	e593300c 	ldr	r3, [r3, #12]
80169ac8:	e0823003 	add	r3, r2, r3
80169acc:	e50b3008 	str	r3, [fp, #-8]
80169ad0:	e51b3008 	ldr	r3, [fp, #-8]
80169ad4:	e1a00003 	mov	r0, r3
80169ad8:	ebffdb08 	bl	80160700 <__RME_A7A_Read_Acquire>
80169adc:	e50b0010 	str	r0, [fp, #-16]
80169ae0:	e51b3010 	ldr	r3, [fp, #-16]
80169ae4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80169ae8:	e3530802 	cmp	r3, #131072	@ 0x20000
80169aec:	1a000001 	bne	80169af8 <_RME_Thd_Sched_Rcv+0x178>
80169af0:	e3e03008 	mvn	r3, #8
80169af4:	ea000049 	b	80169c20 <_RME_Thd_Sched_Rcv+0x2a0>
80169af8:	e51b3010 	ldr	r3, [fp, #-16]
80169afc:	e1a03c23 	lsr	r3, r3, #24
80169b00:	e3530006 	cmp	r3, #6
80169b04:	0a000001 	beq	80169b10 <_RME_Thd_Sched_Rcv+0x190>
80169b08:	e3e03001 	mvn	r3, #1
80169b0c:	ea000043 	b	80169c20 <_RME_Thd_Sched_Rcv+0x2a0>
                   struct RME_Cap_Thd*,Thd_Op,Type_Stat);
    /* Check if the target cap is not frozen and allows such operations */
    RME_CAP_CHECK(Thd_Op,RME_THD_FLAG_SCHED_RCV);
80169b10:	e51b3008 	ldr	r3, [fp, #-8]
80169b14:	e5933008 	ldr	r3, [r3, #8]
80169b18:	e2033020 	and	r3, r3, #32
80169b1c:	e3530000 	cmp	r3, #0
80169b20:	1a000001 	bne	80169b2c <_RME_Thd_Sched_Rcv+0x1ac>
80169b24:	e3e03006 	mvn	r3, #6
80169b28:	ea00003c 	b	80169c20 <_RME_Thd_Sched_Rcv+0x2a0>
    
    /* Check if we are on the same core with the target thread */
    Scheduler=(struct RME_Thd_Struct*)Thd_Op->Head.Object;
80169b2c:	e51b3008 	ldr	r3, [fp, #-8]
80169b30:	e593300c 	ldr	r3, [r3, #12]
80169b34:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    if(Scheduler->Sched.Local!=RME_CPU_LOCAL())
80169b38:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169b3c:	e5932014 	ldr	r2, [r3, #20]
80169b40:	e3003004 	movw	r3, #4
80169b44:	e3483017 	movt	r3, #32791	@ 0x8017
80169b48:	e1520003 	cmp	r2, r3
80169b4c:	0a000001 	beq	80169b58 <_RME_Thd_Sched_Rcv+0x1d8>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
80169b50:	e3e030cb 	mvn	r3, #203	@ 0xcb
80169b54:	ea000031 	b	80169c20 <_RME_Thd_Sched_Rcv+0x2a0>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Check if there are any notifications */
    if(Scheduler->Sched.Event.Next==&(Scheduler->Sched.Event))
80169b58:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169b5c:	e593203c 	ldr	r2, [r3, #60]	@ 0x3c
80169b60:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169b64:	e283303c 	add	r3, r3, #60	@ 0x3c
80169b68:	e1520003 	cmp	r2, r3
80169b6c:	1a000001 	bne	80169b78 <_RME_Thd_Sched_Rcv+0x1f8>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_NOTIF;
80169b70:	e3e030ce 	mvn	r3, #206	@ 0xce
80169b74:	ea000029 	b	80169c20 <_RME_Thd_Sched_Rcv+0x2a0>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Return one notification and delete it from the notification list */
    Thread=(struct RME_Thd_Struct*)(Scheduler->Sched.Event.Next-1U);
80169b78:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169b7c:	e593303c 	ldr	r3, [r3, #60]	@ 0x3c
80169b80:	e2433008 	sub	r3, r3, #8
80169b84:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    _RME_List_Del(Thread->Sched.Notif.Prev,Thread->Sched.Notif.Next);
80169b88:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169b8c:	e593200c 	ldr	r2, [r3, #12]
80169b90:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169b94:	e5933008 	ldr	r3, [r3, #8]
80169b98:	e1a01003 	mov	r1, r3
80169b9c:	e1a00002 	mov	r0, r2
80169ba0:	ebffdc4d 	bl	80160cdc <_RME_List_Del>
    /* We need to do this because we are using this to detect whether the notification is sent */
    _RME_List_Crt(&(Thread->Sched.Notif));
80169ba4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169ba8:	e2833008 	add	r3, r3, #8
80169bac:	e1a00003 	mov	r0, r3
80169bb0:	ebffdc3b 	bl	80160ca4 <_RME_List_Crt>
    
    /* Exception pending */
    if(Thread->Sched.State==RME_THD_EXCPEND)
80169bb4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169bb8:	e593301c 	ldr	r3, [r3, #28]
80169bbc:	e3530003 	cmp	r3, #3
80169bc0:	1a000009 	bne	80169bec <_RME_Thd_Sched_Rcv+0x26c>
    {
        RME_COV_MARKER();
        
        Flag=RME_THD_EXCPEND_FLAG;
80169bc4:	e3a03101 	mov	r3, #1073741824	@ 0x40000000
80169bc8:	e50b300c 	str	r3, [fp, #-12]
        
        /* Is it also out of timeslice? */
        if(Thread->Sched.Slice==0U)
80169bcc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169bd0:	e5933018 	ldr	r3, [r3, #24]
80169bd4:	e3530000 	cmp	r3, #0
80169bd8:	1a00000c 	bne	80169c10 <_RME_Thd_Sched_Rcv+0x290>
        {
            RME_COV_MARKER();
            
            Flag|=RME_THD_TIMEOUT_FLAG;
80169bdc:	e51b300c 	ldr	r3, [fp, #-12]
80169be0:	e3833202 	orr	r3, r3, #536870912	@ 0x20000000
80169be4:	e50b300c 	str	r3, [fp, #-12]
80169be8:	ea000008 	b	80169c10 <_RME_Thd_Sched_Rcv+0x290>
            RME_COV_MARKER();
            /* No action required */
        }
    }
    /* Timeout */
    else if(Thread->Sched.State==RME_THD_TIMEOUT)
80169bec:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169bf0:	e593301c 	ldr	r3, [r3, #28]
80169bf4:	e3530002 	cmp	r3, #2
80169bf8:	1a000002 	bne	80169c08 <_RME_Thd_Sched_Rcv+0x288>
    {
        RME_COV_MARKER();
        
        Flag=RME_THD_TIMEOUT_FLAG;
80169bfc:	e3a03202 	mov	r3, #536870912	@ 0x20000000
80169c00:	e50b300c 	str	r3, [fp, #-12]
80169c04:	ea000001 	b	80169c10 <_RME_Thd_Sched_Rcv+0x290>
    /* Spurious notification, cause eliminated before this sched rcv */
    else
    {
        RME_COV_MARKER();
        
        Flag=0U;
80169c08:	e3a03000 	mov	r3, #0
80169c0c:	e50b300c 	str	r3, [fp, #-12]
    }
    
    /* Return the notification TID with the flags */
    return (rme_ret_t)(Thread->Sched.TID|Flag);
80169c10:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
80169c14:	e5932010 	ldr	r2, [r3, #16]
80169c18:	e51b300c 	ldr	r3, [fp, #-12]
80169c1c:	e1823003 	orr	r3, r2, r3
}
80169c20:	e1a00003 	mov	r0, r3
80169c24:	e24bd004 	sub	sp, fp, #4
80169c28:	e8bd8800 	pop	{fp, pc}

80169c2c <_RME_Thd_Time_Xfer>:
static rme_ret_t _RME_Thd_Time_Xfer(struct RME_Cap_Cpt* Cpt,
                                    struct RME_Reg_Struct* Reg,
                                    rme_cid_t Cap_Thd_Dst,
                                    rme_cid_t Cap_Thd_Src,
                                    rme_ptr_t Time)
{
80169c2c:	e92d4800 	push	{fp, lr}
80169c30:	e28db004 	add	fp, sp, #4
80169c34:	e24dd030 	sub	sp, sp, #48	@ 0x30
80169c38:	e50b0028 	str	r0, [fp, #-40]	@ 0xffffffd8
80169c3c:	e50b102c 	str	r1, [fp, #-44]	@ 0xffffffd4
80169c40:	e50b2030 	str	r2, [fp, #-48]	@ 0xffffffd0
80169c44:	e50b3034 	str	r3, [fp, #-52]	@ 0xffffffcc
    RME_DBG_S("\r\nCap_Thd_Src ");
    RME_DBG_I(Cap_Thd_Src);
    RME_DBG_S("\r\nTime ");
    RME_DBG_H(Time);*/
    /* We may allow transferring infinite time here */
    if(Time==0U)
80169c48:	e59b3004 	ldr	r3, [fp, #4]
80169c4c:	e3530000 	cmp	r3, #0
80169c50:	1a000001 	bne	80169c5c <_RME_Thd_Time_Xfer+0x30>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
80169c54:	e3e030cb 	mvn	r3, #203	@ 0xcb
80169c58:	ea00017a 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Thd_Dst,RME_CAP_TYPE_THD,
80169c5c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80169c60:	e2033080 	and	r3, r3, #128	@ 0x80
80169c64:	e3530000 	cmp	r3, #0
80169c68:	1a00001c 	bne	80169ce0 <_RME_Thd_Time_Xfer+0xb4>
80169c6c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169c70:	e5932014 	ldr	r2, [r3, #20]
80169c74:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80169c78:	e1520003 	cmp	r2, r3
80169c7c:	8a000001 	bhi	80169c88 <_RME_Thd_Time_Xfer+0x5c>
80169c80:	e3e03002 	mvn	r3, #2
80169c84:	ea00016f 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169c88:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80169c8c:	e1a02283 	lsl	r2, r3, #5
80169c90:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169c94:	e593300c 	ldr	r3, [r3, #12]
80169c98:	e0823003 	add	r3, r2, r3
80169c9c:	e50b3008 	str	r3, [fp, #-8]
80169ca0:	e51b3008 	ldr	r3, [fp, #-8]
80169ca4:	e1a00003 	mov	r0, r3
80169ca8:	ebffda94 	bl	80160700 <__RME_A7A_Read_Acquire>
80169cac:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80169cb0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169cb4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80169cb8:	e3530802 	cmp	r3, #131072	@ 0x20000
80169cbc:	1a000001 	bne	80169cc8 <_RME_Thd_Time_Xfer+0x9c>
80169cc0:	e3e03008 	mvn	r3, #8
80169cc4:	ea00015f 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169cc8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169ccc:	e1a03c23 	lsr	r3, r3, #24
80169cd0:	e3530006 	cmp	r3, #6
80169cd4:	0a00003f 	beq	80169dd8 <_RME_Thd_Time_Xfer+0x1ac>
80169cd8:	e3e03001 	mvn	r3, #1
80169cdc:	ea000159 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169ce0:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80169ce4:	e1a02423 	lsr	r2, r3, #8
80169ce8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169cec:	e5933014 	ldr	r3, [r3, #20]
80169cf0:	e1520003 	cmp	r2, r3
80169cf4:	3a000001 	bcc	80169d00 <_RME_Thd_Time_Xfer+0xd4>
80169cf8:	e3e03002 	mvn	r3, #2
80169cfc:	ea000151 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169d00:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80169d04:	e1a03423 	lsr	r3, r3, #8
80169d08:	e1a02283 	lsl	r2, r3, #5
80169d0c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169d10:	e593300c 	ldr	r3, [r3, #12]
80169d14:	e0823003 	add	r3, r2, r3
80169d18:	e50b3008 	str	r3, [fp, #-8]
80169d1c:	e51b3008 	ldr	r3, [fp, #-8]
80169d20:	e1a00003 	mov	r0, r3
80169d24:	ebffda75 	bl	80160700 <__RME_A7A_Read_Acquire>
80169d28:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80169d2c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169d30:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80169d34:	e3530802 	cmp	r3, #131072	@ 0x20000
80169d38:	1a000001 	bne	80169d44 <_RME_Thd_Time_Xfer+0x118>
80169d3c:	e3e03008 	mvn	r3, #8
80169d40:	ea000140 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169d44:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169d48:	e1a03c23 	lsr	r3, r3, #24
80169d4c:	e3530003 	cmp	r3, #3
80169d50:	0a000001 	beq	80169d5c <_RME_Thd_Time_Xfer+0x130>
80169d54:	e3e03001 	mvn	r3, #1
80169d58:	ea00013a 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169d5c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80169d60:	e203207f 	and	r2, r3, #127	@ 0x7f
80169d64:	e51b3008 	ldr	r3, [fp, #-8]
80169d68:	e5933014 	ldr	r3, [r3, #20]
80169d6c:	e1520003 	cmp	r2, r3
80169d70:	3a000001 	bcc	80169d7c <_RME_Thd_Time_Xfer+0x150>
80169d74:	e3e03002 	mvn	r3, #2
80169d78:	ea000132 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169d7c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
80169d80:	e203307f 	and	r3, r3, #127	@ 0x7f
80169d84:	e1a02283 	lsl	r2, r3, #5
80169d88:	e51b3008 	ldr	r3, [fp, #-8]
80169d8c:	e593300c 	ldr	r3, [r3, #12]
80169d90:	e0823003 	add	r3, r2, r3
80169d94:	e50b3008 	str	r3, [fp, #-8]
80169d98:	e51b3008 	ldr	r3, [fp, #-8]
80169d9c:	e1a00003 	mov	r0, r3
80169da0:	ebffda56 	bl	80160700 <__RME_A7A_Read_Acquire>
80169da4:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80169da8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169dac:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80169db0:	e3530802 	cmp	r3, #131072	@ 0x20000
80169db4:	1a000001 	bne	80169dc0 <_RME_Thd_Time_Xfer+0x194>
80169db8:	e3e03008 	mvn	r3, #8
80169dbc:	ea000121 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169dc0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169dc4:	e1a03c23 	lsr	r3, r3, #24
80169dc8:	e3530006 	cmp	r3, #6
80169dcc:	0a000001 	beq	80169dd8 <_RME_Thd_Time_Xfer+0x1ac>
80169dd0:	e3e03001 	mvn	r3, #1
80169dd4:	ea00011b 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
                   struct RME_Cap_Thd*,Thd_Dst_Op,Type_Stat);

    RME_CPT_GETCAP(Cpt,Cap_Thd_Src,RME_CAP_TYPE_THD,
80169dd8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80169ddc:	e2033080 	and	r3, r3, #128	@ 0x80
80169de0:	e3530000 	cmp	r3, #0
80169de4:	1a00001c 	bne	80169e5c <_RME_Thd_Time_Xfer+0x230>
80169de8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169dec:	e5932014 	ldr	r2, [r3, #20]
80169df0:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80169df4:	e1520003 	cmp	r2, r3
80169df8:	8a000001 	bhi	80169e04 <_RME_Thd_Time_Xfer+0x1d8>
80169dfc:	e3e03002 	mvn	r3, #2
80169e00:	ea000110 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169e04:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80169e08:	e1a02283 	lsl	r2, r3, #5
80169e0c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169e10:	e593300c 	ldr	r3, [r3, #12]
80169e14:	e0823003 	add	r3, r2, r3
80169e18:	e50b300c 	str	r3, [fp, #-12]
80169e1c:	e51b300c 	ldr	r3, [fp, #-12]
80169e20:	e1a00003 	mov	r0, r3
80169e24:	ebffda35 	bl	80160700 <__RME_A7A_Read_Acquire>
80169e28:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80169e2c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169e30:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80169e34:	e3530802 	cmp	r3, #131072	@ 0x20000
80169e38:	1a000001 	bne	80169e44 <_RME_Thd_Time_Xfer+0x218>
80169e3c:	e3e03008 	mvn	r3, #8
80169e40:	ea000100 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169e44:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169e48:	e1a03c23 	lsr	r3, r3, #24
80169e4c:	e3530006 	cmp	r3, #6
80169e50:	0a00003f 	beq	80169f54 <_RME_Thd_Time_Xfer+0x328>
80169e54:	e3e03001 	mvn	r3, #1
80169e58:	ea0000fa 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169e5c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80169e60:	e1a02423 	lsr	r2, r3, #8
80169e64:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169e68:	e5933014 	ldr	r3, [r3, #20]
80169e6c:	e1520003 	cmp	r2, r3
80169e70:	3a000001 	bcc	80169e7c <_RME_Thd_Time_Xfer+0x250>
80169e74:	e3e03002 	mvn	r3, #2
80169e78:	ea0000f2 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169e7c:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80169e80:	e1a03423 	lsr	r3, r3, #8
80169e84:	e1a02283 	lsl	r2, r3, #5
80169e88:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
80169e8c:	e593300c 	ldr	r3, [r3, #12]
80169e90:	e0823003 	add	r3, r2, r3
80169e94:	e50b300c 	str	r3, [fp, #-12]
80169e98:	e51b300c 	ldr	r3, [fp, #-12]
80169e9c:	e1a00003 	mov	r0, r3
80169ea0:	ebffda16 	bl	80160700 <__RME_A7A_Read_Acquire>
80169ea4:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80169ea8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169eac:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80169eb0:	e3530802 	cmp	r3, #131072	@ 0x20000
80169eb4:	1a000001 	bne	80169ec0 <_RME_Thd_Time_Xfer+0x294>
80169eb8:	e3e03008 	mvn	r3, #8
80169ebc:	ea0000e1 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169ec0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169ec4:	e1a03c23 	lsr	r3, r3, #24
80169ec8:	e3530003 	cmp	r3, #3
80169ecc:	0a000001 	beq	80169ed8 <_RME_Thd_Time_Xfer+0x2ac>
80169ed0:	e3e03001 	mvn	r3, #1
80169ed4:	ea0000db 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169ed8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80169edc:	e203207f 	and	r2, r3, #127	@ 0x7f
80169ee0:	e51b300c 	ldr	r3, [fp, #-12]
80169ee4:	e5933014 	ldr	r3, [r3, #20]
80169ee8:	e1520003 	cmp	r2, r3
80169eec:	3a000001 	bcc	80169ef8 <_RME_Thd_Time_Xfer+0x2cc>
80169ef0:	e3e03002 	mvn	r3, #2
80169ef4:	ea0000d3 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169ef8:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
80169efc:	e203307f 	and	r3, r3, #127	@ 0x7f
80169f00:	e1a02283 	lsl	r2, r3, #5
80169f04:	e51b300c 	ldr	r3, [fp, #-12]
80169f08:	e593300c 	ldr	r3, [r3, #12]
80169f0c:	e0823003 	add	r3, r2, r3
80169f10:	e50b300c 	str	r3, [fp, #-12]
80169f14:	e51b300c 	ldr	r3, [fp, #-12]
80169f18:	e1a00003 	mov	r0, r3
80169f1c:	ebffd9f7 	bl	80160700 <__RME_A7A_Read_Acquire>
80169f20:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
80169f24:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169f28:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
80169f2c:	e3530802 	cmp	r3, #131072	@ 0x20000
80169f30:	1a000001 	bne	80169f3c <_RME_Thd_Time_Xfer+0x310>
80169f34:	e3e03008 	mvn	r3, #8
80169f38:	ea0000c2 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
80169f3c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
80169f40:	e1a03c23 	lsr	r3, r3, #24
80169f44:	e3530006 	cmp	r3, #6
80169f48:	0a000001 	beq	80169f54 <_RME_Thd_Time_Xfer+0x328>
80169f4c:	e3e03001 	mvn	r3, #1
80169f50:	ea0000bc 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
                   struct RME_Cap_Thd*,Thd_Src_Op,Type_Stat);

    /* Check if the target cap is not frozen and allows such operations */
    RME_CAP_CHECK(Thd_Dst_Op,RME_THD_FLAG_XFER_DST);
80169f54:	e51b3008 	ldr	r3, [fp, #-8]
80169f58:	e5933008 	ldr	r3, [r3, #8]
80169f5c:	e2033080 	and	r3, r3, #128	@ 0x80
80169f60:	e3530000 	cmp	r3, #0
80169f64:	1a000001 	bne	80169f70 <_RME_Thd_Time_Xfer+0x344>
80169f68:	e3e03006 	mvn	r3, #6
80169f6c:	ea0000b5 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>

    RME_CAP_CHECK(Thd_Src_Op,RME_THD_FLAG_XFER_SRC);
80169f70:	e51b300c 	ldr	r3, [fp, #-12]
80169f74:	e5933008 	ldr	r3, [r3, #8]
80169f78:	e2033040 	and	r3, r3, #64	@ 0x40
80169f7c:	e3530000 	cmp	r3, #0
80169f80:	1a000001 	bne	80169f8c <_RME_Thd_Time_Xfer+0x360>
80169f84:	e3e03006 	mvn	r3, #6
80169f88:	ea0000ae 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>


    /* Check if the two threads are on the core that is accordance with what we are on */
    Local=RME_CPU_LOCAL();
80169f8c:	e3003004 	movw	r3, #4
80169f90:	e3483017 	movt	r3, #32791	@ 0x8017
80169f94:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Thd_Src=RME_CAP_GETOBJ(Thd_Src_Op,struct RME_Thd_Struct*);
80169f98:	e51b300c 	ldr	r3, [fp, #-12]
80169f9c:	e593300c 	ldr	r3, [r3, #12]
80169fa0:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4


    if(Thd_Src->Sched.Local!=Local)
80169fa4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169fa8:	e5933014 	ldr	r3, [r3, #20]
80169fac:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80169fb0:	e1520003 	cmp	r2, r3
80169fb4:	0a000004 	beq	80169fcc <_RME_Thd_Time_Xfer+0x3a0>
    {
        RME_COV_MARKER();
        RME_DBG_S("\r\nRME_ERR_PTH_INVSTATE");
80169fb8:	e30e0998 	movw	r0, #59800	@ 0xe998
80169fbc:	e3480016 	movt	r0, #32790	@ 0x8016
80169fc0:	ebffdad3 	bl	80160b14 <RME_Str_Print>
        return RME_ERR_PTH_INVSTATE;
80169fc4:	e3e030cb 	mvn	r3, #203	@ 0xcb
80169fc8:	ea00009e 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Check if we have slices to transfer; 0 implies TIMEOUT, BLOCKED, or EXCPEND */
    if(Thd_Src->Sched.Slice==0U)
80169fcc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
80169fd0:	e5933018 	ldr	r3, [r3, #24]
80169fd4:	e3530000 	cmp	r3, #0
80169fd8:	1a000001 	bne	80169fe4 <_RME_Thd_Time_Xfer+0x3b8>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
80169fdc:	e3e030cb 	mvn	r3, #203	@ 0xcb
80169fe0:	ea000098 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
    {
        RME_COV_MARKER();
        /* No action required */
    }

    Thd_Dst=RME_CAP_GETOBJ(Thd_Dst_Op,struct RME_Thd_Struct*);
80169fe4:	e51b3008 	ldr	r3, [fp, #-8]
80169fe8:	e593300c 	ldr	r3, [r3, #12]
80169fec:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
    
    if(Thd_Dst->Sched.Local!=Local)
80169ff0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
80169ff4:	e5933014 	ldr	r3, [r3, #20]
80169ff8:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
80169ffc:	e1520003 	cmp	r2, r3
8016a000:	0a000001 	beq	8016a00c <_RME_Thd_Time_Xfer+0x3e0>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_INVSTATE;
8016a004:	e3e030cb 	mvn	r3, #203	@ 0xcb
8016a008:	ea00008e 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
        /* No action required */
    }

    /* The destination must never have higher maximum priority than the source,
     * unless it is a init thread which could be used as a black hole */
    if((Thd_Src->Sched.Prio_Max<Thd_Dst->Sched.Prio_Max)&&
8016a00c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a010:	e5932024 	ldr	r2, [r3, #36]	@ 0x24
8016a014:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a018:	e5933024 	ldr	r3, [r3, #36]	@ 0x24
8016a01c:	e1520003 	cmp	r2, r3
8016a020:	2a000005 	bcs	8016a03c <_RME_Thd_Time_Xfer+0x410>
       (Thd_Dst->Sched.Slice!=RME_THD_INIT_TIME))
8016a024:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a028:	e5933018 	ldr	r3, [r3, #24]
    if((Thd_Src->Sched.Prio_Max<Thd_Dst->Sched.Prio_Max)&&
8016a02c:	e3730106 	cmn	r3, #-2147483647	@ 0x80000001
8016a030:	0a000001 	beq	8016a03c <_RME_Thd_Time_Xfer+0x410>
    {
        RME_COV_MARKER();

        return RME_ERR_PTH_PRIO;
8016a034:	e3e030cc 	mvn	r3, #204	@ 0xcc
8016a038:	ea000082 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Delegating from a normal thread */
    if(Thd_Src->Sched.Slice<RME_THD_INF_TIME)
8016a03c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a040:	e5933018 	ldr	r3, [r3, #24]
8016a044:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
8016a048:	8a000032 	bhi	8016a118 <_RME_Thd_Time_Xfer+0x4ec>
    {
        RME_COV_MARKER();

        /* Delegate all our time */
        if(Time>=RME_THD_INF_TIME)
8016a04c:	e59b3004 	ldr	r3, [fp, #4]
8016a050:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
8016a054:	9a000003 	bls	8016a068 <_RME_Thd_Time_Xfer+0x43c>
        {
            RME_COV_MARKER();

            Time_Xfer=Thd_Src->Sched.Slice;
8016a058:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a05c:	e5933018 	ldr	r3, [r3, #24]
8016a060:	e50b3010 	str	r3, [fp, #-16]
8016a064:	ea00000a 	b	8016a094 <_RME_Thd_Time_Xfer+0x468>
        /* Delegate some time, if not sufficient, clean up the source time */
        else
        {
            RME_COV_MARKER();
            
            if(Thd_Src->Sched.Slice>Time)
8016a068:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a06c:	e5933018 	ldr	r3, [r3, #24]
8016a070:	e59b2004 	ldr	r2, [fp, #4]
8016a074:	e1520003 	cmp	r2, r3
8016a078:	2a000002 	bcs	8016a088 <_RME_Thd_Time_Xfer+0x45c>
            {
                RME_COV_MARKER();

                Time_Xfer=Time;
8016a07c:	e59b3004 	ldr	r3, [fp, #4]
8016a080:	e50b3010 	str	r3, [fp, #-16]
8016a084:	ea000002 	b	8016a094 <_RME_Thd_Time_Xfer+0x468>
            }
            else
            {
                RME_COV_MARKER();

                Time_Xfer=Thd_Src->Sched.Slice;
8016a088:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a08c:	e5933018 	ldr	r3, [r3, #24]
8016a090:	e50b3010 	str	r3, [fp, #-16]
            }
        }
        
        /* See if we are transferring to an infinite budget thread. If yes, we
         * are revoking timeslices; If not, this is a finite transfer */
        if(Thd_Dst->Sched.Slice<RME_THD_INF_TIME)
8016a094:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a098:	e5933018 	ldr	r3, [r3, #24]
8016a09c:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
8016a0a0:	8a000015 	bhi	8016a0fc <_RME_Thd_Time_Xfer+0x4d0>
        {
            RME_COV_MARKER();
            
            RME_TIME_CHECK(Thd_Dst->Sched.Slice,Time_Xfer);
8016a0a4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a0a8:	e5932018 	ldr	r2, [r3, #24]
8016a0ac:	e51b3010 	ldr	r3, [fp, #-16]
8016a0b0:	e0823003 	add	r3, r2, r3
8016a0b4:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
8016a0b8:	8a000007 	bhi	8016a0dc <_RME_Thd_Time_Xfer+0x4b0>
8016a0bc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a0c0:	e5932018 	ldr	r2, [r3, #24]
8016a0c4:	e51b3010 	ldr	r3, [fp, #-16]
8016a0c8:	e0822003 	add	r2, r2, r3
8016a0cc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a0d0:	e5933018 	ldr	r3, [r3, #24]
8016a0d4:	e1520003 	cmp	r2, r3
8016a0d8:	2a000001 	bcs	8016a0e4 <_RME_Thd_Time_Xfer+0x4b8>
8016a0dc:	e3e030cf 	mvn	r3, #207	@ 0xcf
8016a0e0:	ea000058 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
            Thd_Dst->Sched.Slice+=Time_Xfer;
8016a0e4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a0e8:	e5932018 	ldr	r2, [r3, #24]
8016a0ec:	e51b3010 	ldr	r3, [fp, #-16]
8016a0f0:	e0822003 	add	r2, r2, r3
8016a0f4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a0f8:	e5832018 	str	r2, [r3, #24]
        {
            RME_COV_MARKER();
            /* No action required */
        }
        
        Thd_Src->Sched.Slice-=Time_Xfer;
8016a0fc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a100:	e5932018 	ldr	r2, [r3, #24]
8016a104:	e51b3010 	ldr	r3, [fp, #-16]
8016a108:	e0422003 	sub	r2, r2, r3
8016a10c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a110:	e5832018 	str	r2, [r3, #24]
8016a114:	ea00002a 	b	8016a1c4 <_RME_Thd_Time_Xfer+0x598>
    else
    {
        RME_COV_MARKER();

        /* Infinite transfer to the destination */
        if(Time>=RME_THD_INF_TIME)
8016a118:	e59b3004 	ldr	r3, [fp, #4]
8016a11c:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
8016a120:	9a000011 	bls	8016a16c <_RME_Thd_Time_Xfer+0x540>
        {
            RME_COV_MARKER();

            /* This transfer will revoke the infinite budget */
            if(Time==RME_THD_INIT_TIME)
8016a124:	e59b3004 	ldr	r3, [fp, #4]
8016a128:	e3730106 	cmn	r3, #-2147483647	@ 0x80000001
8016a12c:	1a000006 	bne	8016a14c <_RME_Thd_Time_Xfer+0x520>
            {
                RME_COV_MARKER();
                
                /* Will not revoke, source is an init thread */
                if(Thd_Src->Sched.Slice!=RME_THD_INIT_TIME)
8016a130:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a134:	e5933018 	ldr	r3, [r3, #24]
8016a138:	e3730106 	cmn	r3, #-2147483647	@ 0x80000001
8016a13c:	0a000002 	beq	8016a14c <_RME_Thd_Time_Xfer+0x520>
                {
                    RME_COV_MARKER();
                    
                    Thd_Src->Sched.Slice=0U;
8016a140:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a144:	e3a02000 	mov	r2, #0
8016a148:	e5832018 	str	r2, [r3, #24]
                RME_COV_MARKER();
                /* No action required */
            }
            
            /* Set destination to infinite if it is not an init thread */
            if(Thd_Dst->Sched.Slice<RME_THD_INF_TIME)
8016a14c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a150:	e5933018 	ldr	r3, [r3, #24]
8016a154:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
8016a158:	8a000019 	bhi	8016a1c4 <_RME_Thd_Time_Xfer+0x598>
            {
                RME_COV_MARKER();
                
                Thd_Dst->Sched.Slice=RME_THD_INF_TIME;
8016a15c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a160:	e3e02106 	mvn	r2, #-2147483647	@ 0x80000001
8016a164:	e5832018 	str	r2, [r3, #24]
8016a168:	ea000015 	b	8016a1c4 <_RME_Thd_Time_Xfer+0x598>
        else
        {
            RME_COV_MARKER();

            /* Just increase the budget of the other thread - check first */
            RME_TIME_CHECK(Thd_Dst->Sched.Slice,Time);
8016a16c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a170:	e5932018 	ldr	r2, [r3, #24]
8016a174:	e59b3004 	ldr	r3, [fp, #4]
8016a178:	e0823003 	add	r3, r2, r3
8016a17c:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
8016a180:	8a000007 	bhi	8016a1a4 <_RME_Thd_Time_Xfer+0x578>
8016a184:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a188:	e5932018 	ldr	r2, [r3, #24]
8016a18c:	e59b3004 	ldr	r3, [fp, #4]
8016a190:	e0822003 	add	r2, r2, r3
8016a194:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a198:	e5933018 	ldr	r3, [r3, #24]
8016a19c:	e1520003 	cmp	r2, r3
8016a1a0:	2a000001 	bcs	8016a1ac <_RME_Thd_Time_Xfer+0x580>
8016a1a4:	e3e030cf 	mvn	r3, #207	@ 0xcf
8016a1a8:	ea000026 	b	8016a248 <_RME_Thd_Time_Xfer+0x61c>
            Thd_Dst->Sched.Slice+=Time;
8016a1ac:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a1b0:	e5932018 	ldr	r2, [r3, #24]
8016a1b4:	e59b3004 	ldr	r3, [fp, #4]
8016a1b8:	e0822003 	add	r2, r2, r3
8016a1bc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a1c0:	e5832018 	str	r2, [r3, #24]
        }
    }

    /* Is the source time used up? If yes, delete it from the run queue, and notify its 
     * parent. If it is not in the run queue, The state of the source must be BLOCKED. */
    if(Thd_Src->Sched.Slice==0U)
8016a1c4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a1c8:	e5933018 	ldr	r3, [r3, #24]
8016a1cc:	e3530000 	cmp	r3, #0
8016a1d0:	1a00000a 	bne	8016a200 <_RME_Thd_Time_Xfer+0x5d4>
        
        /* If it is blocked or have an exception, we neither change its state nor send
         * the scheduler notification. It will be sent when the thread unblocks, or gets
         * its exception handled. The rule of the thumb is, we only send scheduler 
         * notifications when the thread really enter TIMEOUT or EXCPEND state. */
        if(Thd_Src->Sched.State==RME_THD_READY)
8016a1d4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a1d8:	e593301c 	ldr	r3, [r3, #28]
8016a1dc:	e3530000 	cmp	r3, #0
8016a1e0:	1a000006 	bne	8016a200 <_RME_Thd_Time_Xfer+0x5d4>
        {
            RME_COV_MARKER();
            
            /* Remove from runqueue */
            _RME_Run_Del(Thd_Src);
8016a1e4:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
8016a1e8:	ebffede8 	bl	80165990 <_RME_Run_Del>
            
            /* Timeout and notify parent */
            Thd_Src->Sched.State=RME_THD_TIMEOUT;
8016a1ec:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a1f0:	e3a02002 	mov	r2, #2
8016a1f4:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Notif(Thd_Src);
8016a1f8:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
8016a1fc:	ebffee57 	bl	80165b60 <_RME_Run_Notif>
        /* No action required */
    }

    /* Now save the system call return value to the caller 
     * stack - how much time the destination have now */
    __RME_Svc_Retval_Set(Reg,(rme_ret_t)(Thd_Dst->Sched.Slice));
8016a200:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a204:	e5933018 	ldr	r3, [r3, #24]
8016a208:	e1a01003 	mov	r1, r3
8016a20c:	e51b002c 	ldr	r0, [fp, #-44]	@ 0xffffffd4
8016a210:	eb000db2 	bl	8016d8e0 <__RME_Svc_Retval_Set>

    /* See what was the state of the destination thread. If it is timeout, then activate
     * it. If it is BLOCKED or EXCPEND, then leave it alone, and it will be activated
     * when it unblocks or when the exception is handled. */
    if(Thd_Dst->Sched.State==RME_THD_TIMEOUT)
8016a214:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a218:	e593301c 	ldr	r3, [r3, #28]
8016a21c:	e3530002 	cmp	r3, #2
8016a220:	1a000004 	bne	8016a238 <_RME_Thd_Time_Xfer+0x60c>
    {
        RME_COV_MARKER();

        /* Ready and add to runqueue */
        Thd_Dst->Sched.State=RME_THD_READY;
8016a224:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a228:	e3a02000 	mov	r2, #0
8016a22c:	e583201c 	str	r2, [r3, #28]
        _RME_Run_Ins(Thd_Dst);
8016a230:	e51b0020 	ldr	r0, [fp, #-32]	@ 0xffffffe0
8016a234:	ebffed9e 	bl	801658b4 <_RME_Run_Ins>
        RME_COV_MARKER();
    }
    
    /* All possible kernel send (scheduler notifications) done,
     * now pick the highest priority thread to run */
    _RME_Kern_High(Reg,Local);
8016a238:	e51b1018 	ldr	r1, [fp, #-24]	@ 0xffffffe8
8016a23c:	e51b002c 	ldr	r0, [fp, #-44]	@ 0xffffffd4
8016a240:	eb00031a 	bl	8016aeb0 <_RME_Kern_High>

    return 0;
8016a244:	e3a03000 	mov	r3, #0
}
8016a248:	e1a00003 	mov	r0, r3
8016a24c:	e24bd004 	sub	sp, fp, #4
8016a250:	e8bd8800 	pop	{fp, pc}

8016a254 <_RME_Thd_Swt>:
******************************************************************************/
static rme_ret_t _RME_Thd_Swt(struct RME_Cap_Cpt* Cpt,
                              struct RME_Reg_Struct* Reg,
                              rme_cid_t Cap_Thd,
                              rme_ptr_t Is_Yield)
{
8016a254:	e92d4800 	push	{fp, lr}
8016a258:	e28db004 	add	fp, sp, #4
8016a25c:	e24dd028 	sub	sp, sp, #40	@ 0x28
8016a260:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
8016a264:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
8016a268:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
8016a26c:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
    RME_DBG_H(Cap_Thd);
    RME_DBG_S("\r\nIs_Yield ");
    RME_DBG_H(Is_Yield);*/
    

    Local=RME_CPU_LOCAL();
8016a270:	e3003004 	movw	r3, #4
8016a274:	e3483017 	movt	r3, #32791	@ 0x8017
8016a278:	e50b3010 	str	r3, [fp, #-16]
    Thd_Cur=Local->Thd_Cur;
8016a27c:	e51b3010 	ldr	r3, [fp, #-16]
8016a280:	e5933004 	ldr	r3, [r3, #4]
8016a284:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    
    /* The caller have picked a thread to switch to */
    if(Cap_Thd<RME_CID_NULL)
8016a288:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a28c:	e3530902 	cmp	r3, #32768	@ 0x8000
8016a290:	aa0000b4 	bge	8016a568 <_RME_Thd_Swt+0x314>
    {
        RME_COV_MARKER();
        
        RME_CPT_GETCAP(Cpt,Cap_Thd,RME_CAP_TYPE_THD,
8016a294:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a298:	e2033080 	and	r3, r3, #128	@ 0x80
8016a29c:	e3530000 	cmp	r3, #0
8016a2a0:	1a00001c 	bne	8016a318 <_RME_Thd_Swt+0xc4>
8016a2a4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a2a8:	e5932014 	ldr	r2, [r3, #20]
8016a2ac:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a2b0:	e1520003 	cmp	r2, r3
8016a2b4:	8a000001 	bhi	8016a2c0 <_RME_Thd_Swt+0x6c>
8016a2b8:	e3e03002 	mvn	r3, #2
8016a2bc:	ea0000ed 	b	8016a678 <_RME_Thd_Swt+0x424>
8016a2c0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a2c4:	e1a02283 	lsl	r2, r3, #5
8016a2c8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a2cc:	e593300c 	ldr	r3, [r3, #12]
8016a2d0:	e0823003 	add	r3, r2, r3
8016a2d4:	e50b3008 	str	r3, [fp, #-8]
8016a2d8:	e51b3008 	ldr	r3, [fp, #-8]
8016a2dc:	e1a00003 	mov	r0, r3
8016a2e0:	ebffd906 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a2e4:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
8016a2e8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a2ec:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016a2f0:	e3530802 	cmp	r3, #131072	@ 0x20000
8016a2f4:	1a000001 	bne	8016a300 <_RME_Thd_Swt+0xac>
8016a2f8:	e3e03008 	mvn	r3, #8
8016a2fc:	ea0000dd 	b	8016a678 <_RME_Thd_Swt+0x424>
8016a300:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a304:	e1a03c23 	lsr	r3, r3, #24
8016a308:	e3530006 	cmp	r3, #6
8016a30c:	0a00003f 	beq	8016a410 <_RME_Thd_Swt+0x1bc>
8016a310:	e3e03001 	mvn	r3, #1
8016a314:	ea0000d7 	b	8016a678 <_RME_Thd_Swt+0x424>
8016a318:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a31c:	e1a02423 	lsr	r2, r3, #8
8016a320:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a324:	e5933014 	ldr	r3, [r3, #20]
8016a328:	e1520003 	cmp	r2, r3
8016a32c:	3a000001 	bcc	8016a338 <_RME_Thd_Swt+0xe4>
8016a330:	e3e03002 	mvn	r3, #2
8016a334:	ea0000cf 	b	8016a678 <_RME_Thd_Swt+0x424>
8016a338:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a33c:	e1a03423 	lsr	r3, r3, #8
8016a340:	e1a02283 	lsl	r2, r3, #5
8016a344:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a348:	e593300c 	ldr	r3, [r3, #12]
8016a34c:	e0823003 	add	r3, r2, r3
8016a350:	e50b3008 	str	r3, [fp, #-8]
8016a354:	e51b3008 	ldr	r3, [fp, #-8]
8016a358:	e1a00003 	mov	r0, r3
8016a35c:	ebffd8e7 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a360:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
8016a364:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a368:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016a36c:	e3530802 	cmp	r3, #131072	@ 0x20000
8016a370:	1a000001 	bne	8016a37c <_RME_Thd_Swt+0x128>
8016a374:	e3e03008 	mvn	r3, #8
8016a378:	ea0000be 	b	8016a678 <_RME_Thd_Swt+0x424>
8016a37c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a380:	e1a03c23 	lsr	r3, r3, #24
8016a384:	e3530003 	cmp	r3, #3
8016a388:	0a000001 	beq	8016a394 <_RME_Thd_Swt+0x140>
8016a38c:	e3e03001 	mvn	r3, #1
8016a390:	ea0000b8 	b	8016a678 <_RME_Thd_Swt+0x424>
8016a394:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a398:	e203207f 	and	r2, r3, #127	@ 0x7f
8016a39c:	e51b3008 	ldr	r3, [fp, #-8]
8016a3a0:	e5933014 	ldr	r3, [r3, #20]
8016a3a4:	e1520003 	cmp	r2, r3
8016a3a8:	3a000001 	bcc	8016a3b4 <_RME_Thd_Swt+0x160>
8016a3ac:	e3e03002 	mvn	r3, #2
8016a3b0:	ea0000b0 	b	8016a678 <_RME_Thd_Swt+0x424>
8016a3b4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016a3b8:	e203307f 	and	r3, r3, #127	@ 0x7f
8016a3bc:	e1a02283 	lsl	r2, r3, #5
8016a3c0:	e51b3008 	ldr	r3, [fp, #-8]
8016a3c4:	e593300c 	ldr	r3, [r3, #12]
8016a3c8:	e0823003 	add	r3, r2, r3
8016a3cc:	e50b3008 	str	r3, [fp, #-8]
8016a3d0:	e51b3008 	ldr	r3, [fp, #-8]
8016a3d4:	e1a00003 	mov	r0, r3
8016a3d8:	ebffd8c8 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a3dc:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
8016a3e0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a3e4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016a3e8:	e3530802 	cmp	r3, #131072	@ 0x20000
8016a3ec:	1a000001 	bne	8016a3f8 <_RME_Thd_Swt+0x1a4>
8016a3f0:	e3e03008 	mvn	r3, #8
8016a3f4:	ea00009f 	b	8016a678 <_RME_Thd_Swt+0x424>
8016a3f8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a3fc:	e1a03c23 	lsr	r3, r3, #24
8016a400:	e3530006 	cmp	r3, #6
8016a404:	0a000001 	beq	8016a410 <_RME_Thd_Swt+0x1bc>
8016a408:	e3e03001 	mvn	r3, #1
8016a40c:	ea000099 	b	8016a678 <_RME_Thd_Swt+0x424>
                       struct RME_Cap_Thd*,Thd_Cap_New,Type_Stat);

        /* Check if the target cap is not frozen and allows such operations */
        RME_CAP_CHECK(Thd_Cap_New,RME_THD_FLAG_SWT);
8016a410:	e51b3008 	ldr	r3, [fp, #-8]
8016a414:	e5933008 	ldr	r3, [r3, #8]
8016a418:	e2033c01 	and	r3, r3, #256	@ 0x100
8016a41c:	e3530000 	cmp	r3, #0
8016a420:	1a000001 	bne	8016a42c <_RME_Thd_Swt+0x1d8>
8016a424:	e3e03006 	mvn	r3, #6
8016a428:	ea000092 	b	8016a678 <_RME_Thd_Swt+0x424>

        /* See if we can do operation on this core */
        Thd_New=RME_CAP_GETOBJ(Thd_Cap_New,struct RME_Thd_Struct*);
8016a42c:	e51b3008 	ldr	r3, [fp, #-8]
8016a430:	e593300c 	ldr	r3, [r3, #12]
8016a434:	e50b300c 	str	r3, [fp, #-12]

        if(Thd_New->Sched.Local!=Local)
8016a438:	e51b300c 	ldr	r3, [fp, #-12]
8016a43c:	e5933014 	ldr	r3, [r3, #20]
8016a440:	e51b2010 	ldr	r2, [fp, #-16]
8016a444:	e1520003 	cmp	r2, r3
8016a448:	0a000001 	beq	8016a454 <_RME_Thd_Swt+0x200>
        {
            RME_COV_MARKER();
            
            return RME_ERR_PTH_INVSTATE;
8016a44c:	e3e030cb 	mvn	r3, #203	@ 0xcb
8016a450:	ea000088 	b	8016a678 <_RME_Thd_Swt+0x424>
            RME_COV_MARKER();
            /* No action required */
        }

        /* See if we can yield to the thread */
        if(Thd_Cur->Sched.Prio!=Thd_New->Sched.Prio)
8016a454:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a458:	e5932020 	ldr	r2, [r3, #32]
8016a45c:	e51b300c 	ldr	r3, [fp, #-12]
8016a460:	e5933020 	ldr	r3, [r3, #32]
8016a464:	e1520003 	cmp	r2, r3
8016a468:	0a00000f 	beq	8016a4ac <_RME_Thd_Swt+0x258>
        {
            RME_COV_MARKER();
            RME_DBG_S("\r\nThd_Cur->Sched.Prio = "); 
8016a46c:	e30e09b0 	movw	r0, #59824	@ 0xe9b0
8016a470:	e3480016 	movt	r0, #32790	@ 0x8016
8016a474:	ebffd9a6 	bl	80160b14 <RME_Str_Print>
            RME_DBG_H(Thd_Cur->Sched.Prio);
8016a478:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a47c:	e5933020 	ldr	r3, [r3, #32]
8016a480:	e1a00003 	mov	r0, r3
8016a484:	ebffd960 	bl	80160a0c <RME_Hex_Print>
            RME_DBG_S("\r\nThd_New->Sched.Prio = "); 
8016a488:	e30e09cc 	movw	r0, #59852	@ 0xe9cc
8016a48c:	e3480016 	movt	r0, #32790	@ 0x8016
8016a490:	ebffd99f 	bl	80160b14 <RME_Str_Print>
            RME_DBG_H(Thd_New->Sched.Prio);
8016a494:	e51b300c 	ldr	r3, [fp, #-12]
8016a498:	e5933020 	ldr	r3, [r3, #32]
8016a49c:	e1a00003 	mov	r0, r3
8016a4a0:	ebffd959 	bl	80160a0c <RME_Hex_Print>
            return RME_ERR_PTH_PRIO;
8016a4a4:	e3e030cc 	mvn	r3, #204	@ 0xcc
8016a4a8:	ea000072 	b	8016a678 <_RME_Thd_Swt+0x424>
            RME_COV_MARKER();
            /* No action required */
        }

        /* Check if the target thread state is valid */
        if((Thd_New->Sched.State==RME_THD_BLOCKED)||
8016a4ac:	e51b300c 	ldr	r3, [fp, #-12]
8016a4b0:	e593301c 	ldr	r3, [r3, #28]
8016a4b4:	e3530001 	cmp	r3, #1
8016a4b8:	0a000007 	beq	8016a4dc <_RME_Thd_Swt+0x288>
           (Thd_New->Sched.State==RME_THD_TIMEOUT)||
8016a4bc:	e51b300c 	ldr	r3, [fp, #-12]
8016a4c0:	e593301c 	ldr	r3, [r3, #28]
        if((Thd_New->Sched.State==RME_THD_BLOCKED)||
8016a4c4:	e3530002 	cmp	r3, #2
8016a4c8:	0a000003 	beq	8016a4dc <_RME_Thd_Swt+0x288>
           (Thd_New->Sched.State==RME_THD_EXCPEND))
8016a4cc:	e51b300c 	ldr	r3, [fp, #-12]
8016a4d0:	e593301c 	ldr	r3, [r3, #28]
           (Thd_New->Sched.State==RME_THD_TIMEOUT)||
8016a4d4:	e3530003 	cmp	r3, #3
8016a4d8:	1a000001 	bne	8016a4e4 <_RME_Thd_Swt+0x290>
        {
            RME_COV_MARKER();

            return RME_ERR_PTH_INVSTATE;
8016a4dc:	e3e030cb 	mvn	r3, #203	@ 0xcb
8016a4e0:	ea000064 	b	8016a678 <_RME_Thd_Swt+0x424>
            RME_COV_MARKER();
            /* No action required */
        }

        /* See if we need to give up all our timeslices in this yield */
        if((Is_Yield!=0U)&&(Thd_Cur->Sched.Slice<RME_THD_INF_TIME))
8016a4e4:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016a4e8:	e3530000 	cmp	r3, #0
8016a4ec:	0a000043 	beq	8016a600 <_RME_Thd_Swt+0x3ac>
8016a4f0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a4f4:	e5933018 	ldr	r3, [r3, #24]
8016a4f8:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
8016a4fc:	8a00003f 	bhi	8016a600 <_RME_Thd_Swt+0x3ac>
        {
            RME_COV_MARKER();
            
            /* Deprive all timeslices and remove from runqueue */
            Thd_Cur->Sched.Slice=0U;
8016a500:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a504:	e3a02000 	mov	r2, #0
8016a508:	e5832018 	str	r2, [r3, #24]
            _RME_Run_Del(Thd_Cur);
8016a50c:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016a510:	ebffed1e 	bl	80165990 <_RME_Run_Del>
            
            /* Timeout and notify parent */
            Thd_Cur->Sched.State=RME_THD_TIMEOUT;
8016a514:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a518:	e3a02002 	mov	r2, #2
8016a51c:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Notif(Thd_Cur);
8016a520:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016a524:	ebffed8d 	bl	80165b60 <_RME_Run_Notif>
            
            /* Because we have sent a notification, we could have unblocked a
             * thread at higher priority. Additionally, if the new thread is
             * the current thread, we are forced to switch to someone else,
             * because the current thread's timeslice must be exhausted. */
            Thd_High=_RME_Run_High(Local);
8016a528:	e51b0010 	ldr	r0, [fp, #-16]
8016a52c:	ebffed55 	bl	80165a88 <_RME_Run_High>
8016a530:	e50b001c 	str	r0, [fp, #-28]	@ 0xffffffe4
            if((Thd_High->Sched.Prio>Thd_New->Sched.Prio)||(Thd_Cur==Thd_New))
8016a534:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a538:	e5932020 	ldr	r2, [r3, #32]
8016a53c:	e51b300c 	ldr	r3, [fp, #-12]
8016a540:	e5933020 	ldr	r3, [r3, #32]
8016a544:	e1520003 	cmp	r2, r3
8016a548:	8a000003 	bhi	8016a55c <_RME_Thd_Swt+0x308>
8016a54c:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
8016a550:	e51b300c 	ldr	r3, [fp, #-12]
8016a554:	e1520003 	cmp	r2, r3
8016a558:	1a000028 	bne	8016a600 <_RME_Thd_Swt+0x3ac>
            {
                RME_COV_MARKER();

                Thd_New=Thd_High;
8016a55c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a560:	e50b300c 	str	r3, [fp, #-12]
8016a564:	ea000025 	b	8016a600 <_RME_Thd_Swt+0x3ac>
    else
    {
        RME_COV_MARKER();
        
        /* See if we need to give up all our timeslices in this yield */
        if((Is_Yield!=0U)&&(Thd_Cur->Sched.Slice<RME_THD_INF_TIME))
8016a568:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016a56c:	e3530000 	cmp	r3, #0
8016a570:	0a00000e 	beq	8016a5b0 <_RME_Thd_Swt+0x35c>
8016a574:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a578:	e5933018 	ldr	r3, [r3, #24]
8016a57c:	e373010e 	cmn	r3, #-2147483645	@ 0x80000003
8016a580:	8a00000a 	bhi	8016a5b0 <_RME_Thd_Swt+0x35c>
        {
            RME_COV_MARKER();
            
            /* Deprive all timeslices and remove from runqueue */
            Thd_Cur->Sched.Slice=0U;
8016a584:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a588:	e3a02000 	mov	r2, #0
8016a58c:	e5832018 	str	r2, [r3, #24]
            _RME_Run_Del(Thd_Cur);
8016a590:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016a594:	ebffecfd 	bl	80165990 <_RME_Run_Del>
            
            /* Timeout and notify parent */
            Thd_Cur->Sched.State=RME_THD_TIMEOUT;
8016a598:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a59c:	e3a02002 	mov	r2, #2
8016a5a0:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Notif(Thd_Cur);
8016a5a4:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016a5a8:	ebffed6c 	bl	80165b60 <_RME_Run_Notif>
8016a5ac:	ea000010 	b	8016a5f4 <_RME_Thd_Swt+0x3a0>
        {
            RME_COV_MARKER();
            
            /* This operation is just to make sure that if there are any other
             * thread at the same priority level, we're not switching to ourself */
            RME_ASSERT(Thd_Cur->Sched.State==RME_THD_READY);
8016a5b0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016a5b4:	e593301c 	ldr	r3, [r3, #28]
8016a5b8:	e3530000 	cmp	r3, #0
8016a5bc:	0a000008 	beq	8016a5e4 <_RME_Thd_Swt+0x390>
8016a5c0:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
8016a5c4:	e3483016 	movt	r3, #32790	@ 0x8016
8016a5c8:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
8016a5cc:	e3482016 	movt	r2, #32790	@ 0x8016
8016a5d0:	e3011a91 	movw	r1, #6801	@ 0x1a91
8016a5d4:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
8016a5d8:	e3480016 	movt	r0, #32790	@ 0x8016
8016a5dc:	ebffd96b 	bl	80160b90 <RME_Log>
8016a5e0:	eafffffe 	b	8016a5e0 <_RME_Thd_Swt+0x38c>
            _RME_Run_Del(Thd_Cur);
8016a5e4:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016a5e8:	ebffece8 	bl	80165990 <_RME_Run_Del>
            _RME_Run_Ins(Thd_Cur);
8016a5ec:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016a5f0:	ebffecaf 	bl	801658b4 <_RME_Run_Ins>
        }

        Thd_New=_RME_Run_High(Local);
8016a5f4:	e51b0010 	ldr	r0, [fp, #-16]
8016a5f8:	ebffed22 	bl	80165a88 <_RME_Run_High>
8016a5fc:	e50b000c 	str	r0, [fp, #-12]
    }
    
    /* Now that we are successful, save the return value to the caller stack */
    __RME_Svc_Retval_Set(Reg,0);
8016a600:	e3a01000 	mov	r1, #0
8016a604:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
8016a608:	eb000cb4 	bl	8016d8e0 <__RME_Svc_Retval_Set>

    RME_ASSERT(Thd_New->Sched.State==RME_THD_READY);
8016a60c:	e51b300c 	ldr	r3, [fp, #-12]
8016a610:	e593301c 	ldr	r3, [r3, #28]
8016a614:	e3530000 	cmp	r3, #0
8016a618:	0a000008 	beq	8016a640 <_RME_Thd_Swt+0x3ec>
8016a61c:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
8016a620:	e3483016 	movt	r3, #32790	@ 0x8016
8016a624:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
8016a628:	e3482016 	movt	r2, #32790	@ 0x8016
8016a62c:	e3011a9c 	movw	r1, #6812	@ 0x1a9c
8016a630:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
8016a634:	e3480016 	movt	r0, #32790	@ 0x8016
8016a638:	ebffd954 	bl	80160b90 <RME_Log>
8016a63c:	eafffffe 	b	8016a63c <_RME_Thd_Swt+0x3e8>
    /* We cannot call _RME_Kern_High because it picks some random thread. Instead,
     * we use a manual implementation that is faster than the _RME_Kern_High. */
    if(Thd_Cur==Thd_New)
8016a640:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
8016a644:	e51b300c 	ldr	r3, [fp, #-12]
8016a648:	e1520003 	cmp	r2, r3
8016a64c:	1a000001 	bne	8016a658 <_RME_Thd_Swt+0x404>
    {
        RME_COV_MARKER();
        
        return 0;
8016a650:	e3a03000 	mov	r3, #0
8016a654:	ea000007 	b	8016a678 <_RME_Thd_Swt+0x424>
        RME_COV_MARKER();
        /* No action required */
    }
            
    /* We have a solid context switch at this point */
    _RME_Run_Swt(Reg,Thd_Cur,Thd_New);
8016a658:	e51b200c 	ldr	r2, [fp, #-12]
8016a65c:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
8016a660:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
8016a664:	ebffed7a 	bl	80165c54 <_RME_Run_Swt>
    Local->Thd_Cur=Thd_New;
8016a668:	e51b3010 	ldr	r3, [fp, #-16]
8016a66c:	e51b200c 	ldr	r2, [fp, #-12]
8016a670:	e5832004 	str	r2, [r3, #4]

    return 0;
8016a674:	e3a03000 	mov	r3, #0
}
8016a678:	e1a00003 	mov	r0, r3
8016a67c:	e24bd004 	sub	sp, fp, #4
8016a680:	e8bd8800 	pop	{fp, pc}

8016a684 <_RME_Sig_Boot_Crt>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
rme_ret_t _RME_Sig_Boot_Crt(struct RME_Cap_Cpt* Cpt,
                            rme_cid_t Cap_Cpt,
                            rme_cid_t Cap_Sig)
{
8016a684:	e92d4800 	push	{fp, lr}
8016a688:	e28db004 	add	fp, sp, #4
8016a68c:	e24dd020 	sub	sp, sp, #32
8016a690:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
8016a694:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
8016a698:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    struct RME_Cap_Cpt* Cpt_Crt;
    struct RME_Cap_Sig* Sig_Crt;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
8016a69c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a6a0:	e2033080 	and	r3, r3, #128	@ 0x80
8016a6a4:	e3530000 	cmp	r3, #0
8016a6a8:	1a00001c 	bne	8016a720 <_RME_Sig_Boot_Crt+0x9c>
8016a6ac:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a6b0:	e5932014 	ldr	r2, [r3, #20]
8016a6b4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a6b8:	e1520003 	cmp	r2, r3
8016a6bc:	8a000001 	bhi	8016a6c8 <_RME_Sig_Boot_Crt+0x44>
8016a6c0:	e3e03002 	mvn	r3, #2
8016a6c4:	ea00008a 	b	8016a8f4 <_RME_Sig_Boot_Crt+0x270>
8016a6c8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a6cc:	e1a02283 	lsl	r2, r3, #5
8016a6d0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a6d4:	e593300c 	ldr	r3, [r3, #12]
8016a6d8:	e0823003 	add	r3, r2, r3
8016a6dc:	e50b3008 	str	r3, [fp, #-8]
8016a6e0:	e51b3008 	ldr	r3, [fp, #-8]
8016a6e4:	e1a00003 	mov	r0, r3
8016a6e8:	ebffd804 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a6ec:	e50b000c 	str	r0, [fp, #-12]
8016a6f0:	e51b300c 	ldr	r3, [fp, #-12]
8016a6f4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016a6f8:	e3530802 	cmp	r3, #131072	@ 0x20000
8016a6fc:	1a000001 	bne	8016a708 <_RME_Sig_Boot_Crt+0x84>
8016a700:	e3e03008 	mvn	r3, #8
8016a704:	ea00007a 	b	8016a8f4 <_RME_Sig_Boot_Crt+0x270>
8016a708:	e51b300c 	ldr	r3, [fp, #-12]
8016a70c:	e1a03c23 	lsr	r3, r3, #24
8016a710:	e3530003 	cmp	r3, #3
8016a714:	0a00003f 	beq	8016a818 <_RME_Sig_Boot_Crt+0x194>
8016a718:	e3e03001 	mvn	r3, #1
8016a71c:	ea000074 	b	8016a8f4 <_RME_Sig_Boot_Crt+0x270>
8016a720:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a724:	e1a02423 	lsr	r2, r3, #8
8016a728:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a72c:	e5933014 	ldr	r3, [r3, #20]
8016a730:	e1520003 	cmp	r2, r3
8016a734:	3a000001 	bcc	8016a740 <_RME_Sig_Boot_Crt+0xbc>
8016a738:	e3e03002 	mvn	r3, #2
8016a73c:	ea00006c 	b	8016a8f4 <_RME_Sig_Boot_Crt+0x270>
8016a740:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a744:	e1a03423 	lsr	r3, r3, #8
8016a748:	e1a02283 	lsl	r2, r3, #5
8016a74c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a750:	e593300c 	ldr	r3, [r3, #12]
8016a754:	e0823003 	add	r3, r2, r3
8016a758:	e50b3008 	str	r3, [fp, #-8]
8016a75c:	e51b3008 	ldr	r3, [fp, #-8]
8016a760:	e1a00003 	mov	r0, r3
8016a764:	ebffd7e5 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a768:	e50b000c 	str	r0, [fp, #-12]
8016a76c:	e51b300c 	ldr	r3, [fp, #-12]
8016a770:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016a774:	e3530802 	cmp	r3, #131072	@ 0x20000
8016a778:	1a000001 	bne	8016a784 <_RME_Sig_Boot_Crt+0x100>
8016a77c:	e3e03008 	mvn	r3, #8
8016a780:	ea00005b 	b	8016a8f4 <_RME_Sig_Boot_Crt+0x270>
8016a784:	e51b300c 	ldr	r3, [fp, #-12]
8016a788:	e1a03c23 	lsr	r3, r3, #24
8016a78c:	e3530003 	cmp	r3, #3
8016a790:	0a000001 	beq	8016a79c <_RME_Sig_Boot_Crt+0x118>
8016a794:	e3e03001 	mvn	r3, #1
8016a798:	ea000055 	b	8016a8f4 <_RME_Sig_Boot_Crt+0x270>
8016a79c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a7a0:	e203207f 	and	r2, r3, #127	@ 0x7f
8016a7a4:	e51b3008 	ldr	r3, [fp, #-8]
8016a7a8:	e5933014 	ldr	r3, [r3, #20]
8016a7ac:	e1520003 	cmp	r2, r3
8016a7b0:	3a000001 	bcc	8016a7bc <_RME_Sig_Boot_Crt+0x138>
8016a7b4:	e3e03002 	mvn	r3, #2
8016a7b8:	ea00004d 	b	8016a8f4 <_RME_Sig_Boot_Crt+0x270>
8016a7bc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a7c0:	e203307f 	and	r3, r3, #127	@ 0x7f
8016a7c4:	e1a02283 	lsl	r2, r3, #5
8016a7c8:	e51b3008 	ldr	r3, [fp, #-8]
8016a7cc:	e593300c 	ldr	r3, [r3, #12]
8016a7d0:	e0823003 	add	r3, r2, r3
8016a7d4:	e50b3008 	str	r3, [fp, #-8]
8016a7d8:	e51b3008 	ldr	r3, [fp, #-8]
8016a7dc:	e1a00003 	mov	r0, r3
8016a7e0:	ebffd7c6 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a7e4:	e50b000c 	str	r0, [fp, #-12]
8016a7e8:	e51b300c 	ldr	r3, [fp, #-12]
8016a7ec:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016a7f0:	e3530802 	cmp	r3, #131072	@ 0x20000
8016a7f4:	1a000001 	bne	8016a800 <_RME_Sig_Boot_Crt+0x17c>
8016a7f8:	e3e03008 	mvn	r3, #8
8016a7fc:	ea00003c 	b	8016a8f4 <_RME_Sig_Boot_Crt+0x270>
8016a800:	e51b300c 	ldr	r3, [fp, #-12]
8016a804:	e1a03c23 	lsr	r3, r3, #24
8016a808:	e3530003 	cmp	r3, #3
8016a80c:	0a000001 	beq	8016a818 <_RME_Sig_Boot_Crt+0x194>
8016a810:	e3e03001 	mvn	r3, #1
8016a814:	ea000036 	b	8016a8f4 <_RME_Sig_Boot_Crt+0x270>
                   struct RME_Cap_Cpt*,Cpt_Crt,Type_Stat);
    /* Check if the captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Crt,RME_CPT_FLAG_CRT);
8016a818:	e51b3008 	ldr	r3, [fp, #-8]
8016a81c:	e5933008 	ldr	r3, [r3, #8]
8016a820:	e2033001 	and	r3, r3, #1
8016a824:	e3530000 	cmp	r3, #0
8016a828:	1a000001 	bne	8016a834 <_RME_Sig_Boot_Crt+0x1b0>
8016a82c:	e3e03006 	mvn	r3, #6
8016a830:	ea00002f 	b	8016a8f4 <_RME_Sig_Boot_Crt+0x270>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Crt,Cap_Sig,struct RME_Cap_Sig*,Sig_Crt);
8016a834:	e51b3008 	ldr	r3, [fp, #-8]
8016a838:	e5932014 	ldr	r2, [r3, #20]
8016a83c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a840:	e1520003 	cmp	r2, r3
8016a844:	8a000001 	bhi	8016a850 <_RME_Sig_Boot_Crt+0x1cc>
8016a848:	e3e03002 	mvn	r3, #2
8016a84c:	ea000028 	b	8016a8f4 <_RME_Sig_Boot_Crt+0x270>
8016a850:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016a854:	e1a02283 	lsl	r2, r3, #5
8016a858:	e51b3008 	ldr	r3, [fp, #-8]
8016a85c:	e593300c 	ldr	r3, [r3, #12]
8016a860:	e0823003 	add	r3, r2, r3
8016a864:	e50b3010 	str	r3, [fp, #-16]
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Sig_Crt);
8016a868:	e51b3010 	ldr	r3, [fp, #-16]
8016a86c:	e3a02801 	mov	r2, #65536	@ 0x10000
8016a870:	e3a01000 	mov	r1, #0
8016a874:	e1a00003 	mov	r0, r3
8016a878:	ebffd8cf 	bl	80160bbc <_RME_Comp_Swap_Single>
8016a87c:	e1a03000 	mov	r3, r0
8016a880:	e3530000 	cmp	r3, #0
8016a884:	1a000001 	bne	8016a890 <_RME_Sig_Boot_Crt+0x20c>
8016a888:	e3e03004 	mvn	r3, #4
8016a88c:	ea000018 	b	8016a8f4 <_RME_Sig_Boot_Crt+0x270>
8016a890:	e3003000 	movw	r3, #0
8016a894:	e3483017 	movt	r3, #32791	@ 0x8017
8016a898:	e5932000 	ldr	r2, [r3]
8016a89c:	e51b3010 	ldr	r3, [fp, #-16]
8016a8a0:	e5832010 	str	r2, [r3, #16]
    
    /* Header init */
    Sig_Crt->Head.Root_Ref=1U;
8016a8a4:	e51b3010 	ldr	r3, [fp, #-16]
8016a8a8:	e3a02001 	mov	r2, #1
8016a8ac:	e5832004 	str	r2, [r3, #4]
    Sig_Crt->Head.Object=0U;
8016a8b0:	e51b3010 	ldr	r3, [fp, #-16]
8016a8b4:	e3a02000 	mov	r2, #0
8016a8b8:	e583200c 	str	r2, [r3, #12]
    Sig_Crt->Head.Flag=RME_SIG_FLAG_ALL;
8016a8bc:	e51b3010 	ldr	r3, [fp, #-16]
8016a8c0:	e3a0203f 	mov	r2, #63	@ 0x3f
8016a8c4:	e5832008 	str	r2, [r3, #8]
    
    /* Info init */
    Sig_Crt->Sig_Num=0U;
8016a8c8:	e51b3010 	ldr	r3, [fp, #-16]
8016a8cc:	e3a02000 	mov	r2, #0
8016a8d0:	e5832014 	str	r2, [r3, #20]
    Sig_Crt->Thd=RME_NULL;
8016a8d4:	e51b3010 	ldr	r3, [fp, #-16]
8016a8d8:	e3a02000 	mov	r2, #0
8016a8dc:	e5832018 	str	r2, [r3, #24]

    /* Establish cap */
    RME_WRITE_RELEASE(&(Sig_Crt->Head.Type_Stat),
8016a8e0:	e51b3010 	ldr	r3, [fp, #-16]
8016a8e4:	e3a01302 	mov	r1, #134217728	@ 0x8000000
8016a8e8:	e1a00003 	mov	r0, r3
8016a8ec:	ebffd786 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_SIG,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
8016a8f0:	e3a03000 	mov	r3, #0
}
8016a8f4:	e1a00003 	mov	r0, r3
8016a8f8:	e24bd004 	sub	sp, fp, #4
8016a8fc:	e8bd8800 	pop	{fp, pc}

8016a900 <_RME_Sig_Crt>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Sig_Crt(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt,
                              rme_cid_t Cap_Sig)
{
8016a900:	e92d4800 	push	{fp, lr}
8016a904:	e28db004 	add	fp, sp, #4
8016a908:	e24dd020 	sub	sp, sp, #32
8016a90c:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
8016a910:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
8016a914:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    /*RME_DBG_S("\r\n Cap_Cpt ");
    RME_DBG_H(Cap_Cpt);
    RME_DBG_S("\r\n Cap_Sig ");
    RME_DBG_H(Cap_Sig);*/
    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
8016a918:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a91c:	e2033080 	and	r3, r3, #128	@ 0x80
8016a920:	e3530000 	cmp	r3, #0
8016a924:	1a00001c 	bne	8016a99c <_RME_Sig_Crt+0x9c>
8016a928:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a92c:	e5932014 	ldr	r2, [r3, #20]
8016a930:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a934:	e1520003 	cmp	r2, r3
8016a938:	8a000001 	bhi	8016a944 <_RME_Sig_Crt+0x44>
8016a93c:	e3e03002 	mvn	r3, #2
8016a940:	ea00008a 	b	8016ab70 <_RME_Sig_Crt+0x270>
8016a944:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a948:	e1a02283 	lsl	r2, r3, #5
8016a94c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a950:	e593300c 	ldr	r3, [r3, #12]
8016a954:	e0823003 	add	r3, r2, r3
8016a958:	e50b3008 	str	r3, [fp, #-8]
8016a95c:	e51b3008 	ldr	r3, [fp, #-8]
8016a960:	e1a00003 	mov	r0, r3
8016a964:	ebffd765 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a968:	e50b000c 	str	r0, [fp, #-12]
8016a96c:	e51b300c 	ldr	r3, [fp, #-12]
8016a970:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016a974:	e3530802 	cmp	r3, #131072	@ 0x20000
8016a978:	1a000001 	bne	8016a984 <_RME_Sig_Crt+0x84>
8016a97c:	e3e03008 	mvn	r3, #8
8016a980:	ea00007a 	b	8016ab70 <_RME_Sig_Crt+0x270>
8016a984:	e51b300c 	ldr	r3, [fp, #-12]
8016a988:	e1a03c23 	lsr	r3, r3, #24
8016a98c:	e3530003 	cmp	r3, #3
8016a990:	0a00003f 	beq	8016aa94 <_RME_Sig_Crt+0x194>
8016a994:	e3e03001 	mvn	r3, #1
8016a998:	ea000074 	b	8016ab70 <_RME_Sig_Crt+0x270>
8016a99c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a9a0:	e1a02423 	lsr	r2, r3, #8
8016a9a4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a9a8:	e5933014 	ldr	r3, [r3, #20]
8016a9ac:	e1520003 	cmp	r2, r3
8016a9b0:	3a000001 	bcc	8016a9bc <_RME_Sig_Crt+0xbc>
8016a9b4:	e3e03002 	mvn	r3, #2
8016a9b8:	ea00006c 	b	8016ab70 <_RME_Sig_Crt+0x270>
8016a9bc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016a9c0:	e1a03423 	lsr	r3, r3, #8
8016a9c4:	e1a02283 	lsl	r2, r3, #5
8016a9c8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016a9cc:	e593300c 	ldr	r3, [r3, #12]
8016a9d0:	e0823003 	add	r3, r2, r3
8016a9d4:	e50b3008 	str	r3, [fp, #-8]
8016a9d8:	e51b3008 	ldr	r3, [fp, #-8]
8016a9dc:	e1a00003 	mov	r0, r3
8016a9e0:	ebffd746 	bl	80160700 <__RME_A7A_Read_Acquire>
8016a9e4:	e50b000c 	str	r0, [fp, #-12]
8016a9e8:	e51b300c 	ldr	r3, [fp, #-12]
8016a9ec:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016a9f0:	e3530802 	cmp	r3, #131072	@ 0x20000
8016a9f4:	1a000001 	bne	8016aa00 <_RME_Sig_Crt+0x100>
8016a9f8:	e3e03008 	mvn	r3, #8
8016a9fc:	ea00005b 	b	8016ab70 <_RME_Sig_Crt+0x270>
8016aa00:	e51b300c 	ldr	r3, [fp, #-12]
8016aa04:	e1a03c23 	lsr	r3, r3, #24
8016aa08:	e3530003 	cmp	r3, #3
8016aa0c:	0a000001 	beq	8016aa18 <_RME_Sig_Crt+0x118>
8016aa10:	e3e03001 	mvn	r3, #1
8016aa14:	ea000055 	b	8016ab70 <_RME_Sig_Crt+0x270>
8016aa18:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016aa1c:	e203207f 	and	r2, r3, #127	@ 0x7f
8016aa20:	e51b3008 	ldr	r3, [fp, #-8]
8016aa24:	e5933014 	ldr	r3, [r3, #20]
8016aa28:	e1520003 	cmp	r2, r3
8016aa2c:	3a000001 	bcc	8016aa38 <_RME_Sig_Crt+0x138>
8016aa30:	e3e03002 	mvn	r3, #2
8016aa34:	ea00004d 	b	8016ab70 <_RME_Sig_Crt+0x270>
8016aa38:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016aa3c:	e203307f 	and	r3, r3, #127	@ 0x7f
8016aa40:	e1a02283 	lsl	r2, r3, #5
8016aa44:	e51b3008 	ldr	r3, [fp, #-8]
8016aa48:	e593300c 	ldr	r3, [r3, #12]
8016aa4c:	e0823003 	add	r3, r2, r3
8016aa50:	e50b3008 	str	r3, [fp, #-8]
8016aa54:	e51b3008 	ldr	r3, [fp, #-8]
8016aa58:	e1a00003 	mov	r0, r3
8016aa5c:	ebffd727 	bl	80160700 <__RME_A7A_Read_Acquire>
8016aa60:	e50b000c 	str	r0, [fp, #-12]
8016aa64:	e51b300c 	ldr	r3, [fp, #-12]
8016aa68:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016aa6c:	e3530802 	cmp	r3, #131072	@ 0x20000
8016aa70:	1a000001 	bne	8016aa7c <_RME_Sig_Crt+0x17c>
8016aa74:	e3e03008 	mvn	r3, #8
8016aa78:	ea00003c 	b	8016ab70 <_RME_Sig_Crt+0x270>
8016aa7c:	e51b300c 	ldr	r3, [fp, #-12]
8016aa80:	e1a03c23 	lsr	r3, r3, #24
8016aa84:	e3530003 	cmp	r3, #3
8016aa88:	0a000001 	beq	8016aa94 <_RME_Sig_Crt+0x194>
8016aa8c:	e3e03001 	mvn	r3, #1
8016aa90:	ea000036 	b	8016ab70 <_RME_Sig_Crt+0x270>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
    //RME_DBG_S("reach 1 ");
    /* Check if the captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_CRT);
8016aa94:	e51b3008 	ldr	r3, [fp, #-8]
8016aa98:	e5933008 	ldr	r3, [r3, #8]
8016aa9c:	e2033001 	and	r3, r3, #1
8016aaa0:	e3530000 	cmp	r3, #0
8016aaa4:	1a000001 	bne	8016aab0 <_RME_Sig_Crt+0x1b0>
8016aaa8:	e3e03006 	mvn	r3, #6
8016aaac:	ea00002f 	b	8016ab70 <_RME_Sig_Crt+0x270>
    //RME_DBG_S("reach 2 ");
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Sig,struct RME_Cap_Sig*,Sig_Crt);
8016aab0:	e51b3008 	ldr	r3, [fp, #-8]
8016aab4:	e5932014 	ldr	r2, [r3, #20]
8016aab8:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016aabc:	e1520003 	cmp	r2, r3
8016aac0:	8a000001 	bhi	8016aacc <_RME_Sig_Crt+0x1cc>
8016aac4:	e3e03002 	mvn	r3, #2
8016aac8:	ea000028 	b	8016ab70 <_RME_Sig_Crt+0x270>
8016aacc:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016aad0:	e1a02283 	lsl	r2, r3, #5
8016aad4:	e51b3008 	ldr	r3, [fp, #-8]
8016aad8:	e593300c 	ldr	r3, [r3, #12]
8016aadc:	e0823003 	add	r3, r2, r3
8016aae0:	e50b3010 	str	r3, [fp, #-16]
    //RME_DBG_S("reach 3 ");
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Sig_Crt);
8016aae4:	e51b3010 	ldr	r3, [fp, #-16]
8016aae8:	e3a02801 	mov	r2, #65536	@ 0x10000
8016aaec:	e3a01000 	mov	r1, #0
8016aaf0:	e1a00003 	mov	r0, r3
8016aaf4:	ebffd830 	bl	80160bbc <_RME_Comp_Swap_Single>
8016aaf8:	e1a03000 	mov	r3, r0
8016aafc:	e3530000 	cmp	r3, #0
8016ab00:	1a000001 	bne	8016ab0c <_RME_Sig_Crt+0x20c>
8016ab04:	e3e03004 	mvn	r3, #4
8016ab08:	ea000018 	b	8016ab70 <_RME_Sig_Crt+0x270>
8016ab0c:	e3003000 	movw	r3, #0
8016ab10:	e3483017 	movt	r3, #32791	@ 0x8017
8016ab14:	e5932000 	ldr	r2, [r3]
8016ab18:	e51b3010 	ldr	r3, [fp, #-16]
8016ab1c:	e5832010 	str	r2, [r3, #16]

    /* Header init */
    Sig_Crt->Head.Root_Ref=0U;
8016ab20:	e51b3010 	ldr	r3, [fp, #-16]
8016ab24:	e3a02000 	mov	r2, #0
8016ab28:	e5832004 	str	r2, [r3, #4]
    Sig_Crt->Head.Object=0U;
8016ab2c:	e51b3010 	ldr	r3, [fp, #-16]
8016ab30:	e3a02000 	mov	r2, #0
8016ab34:	e583200c 	str	r2, [r3, #12]
    Sig_Crt->Head.Flag=RME_SIG_FLAG_ALL;
8016ab38:	e51b3010 	ldr	r3, [fp, #-16]
8016ab3c:	e3a0203f 	mov	r2, #63	@ 0x3f
8016ab40:	e5832008 	str	r2, [r3, #8]
    
    /* Info init */
    Sig_Crt->Sig_Num=0U;
8016ab44:	e51b3010 	ldr	r3, [fp, #-16]
8016ab48:	e3a02000 	mov	r2, #0
8016ab4c:	e5832014 	str	r2, [r3, #20]
    Sig_Crt->Thd=0U;
8016ab50:	e51b3010 	ldr	r3, [fp, #-16]
8016ab54:	e3a02000 	mov	r2, #0
8016ab58:	e5832018 	str	r2, [r3, #24]
    
    /* Establish cap */
    RME_WRITE_RELEASE(&(Sig_Crt->Head.Type_Stat),
8016ab5c:	e51b3010 	ldr	r3, [fp, #-16]
8016ab60:	e3a01302 	mov	r1, #134217728	@ 0x8000000
8016ab64:	e1a00003 	mov	r0, r3
8016ab68:	ebffd6e7 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_SIG,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
8016ab6c:	e3a03000 	mov	r3, #0
}
8016ab70:	e1a00003 	mov	r0, r3
8016ab74:	e24bd004 	sub	sp, fp, #4
8016ab78:	e8bd8800 	pop	{fp, pc}

8016ab7c <_RME_Sig_Del>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Sig_Del(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt,
                              rme_cid_t Cap_Sig)
{
8016ab7c:	e92d4800 	push	{fp, lr}
8016ab80:	e28db004 	add	fp, sp, #4
8016ab84:	e24dd020 	sub	sp, sp, #32
8016ab88:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
8016ab8c:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
8016ab90:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    struct RME_Cap_Cpt* Cpt_Op;
    volatile struct RME_Cap_Sig* Sig_Del;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
8016ab94:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016ab98:	e2033080 	and	r3, r3, #128	@ 0x80
8016ab9c:	e3530000 	cmp	r3, #0
8016aba0:	1a00001c 	bne	8016ac18 <_RME_Sig_Del+0x9c>
8016aba4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016aba8:	e5932014 	ldr	r2, [r3, #20]
8016abac:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016abb0:	e1520003 	cmp	r2, r3
8016abb4:	8a000001 	bhi	8016abc0 <_RME_Sig_Del+0x44>
8016abb8:	e3e03002 	mvn	r3, #2
8016abbc:	ea0000b8 	b	8016aea4 <_RME_Sig_Del+0x328>
8016abc0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016abc4:	e1a02283 	lsl	r2, r3, #5
8016abc8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016abcc:	e593300c 	ldr	r3, [r3, #12]
8016abd0:	e0823003 	add	r3, r2, r3
8016abd4:	e50b3008 	str	r3, [fp, #-8]
8016abd8:	e51b3008 	ldr	r3, [fp, #-8]
8016abdc:	e1a00003 	mov	r0, r3
8016abe0:	ebffd6c6 	bl	80160700 <__RME_A7A_Read_Acquire>
8016abe4:	e50b000c 	str	r0, [fp, #-12]
8016abe8:	e51b300c 	ldr	r3, [fp, #-12]
8016abec:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016abf0:	e3530802 	cmp	r3, #131072	@ 0x20000
8016abf4:	1a000001 	bne	8016ac00 <_RME_Sig_Del+0x84>
8016abf8:	e3e03008 	mvn	r3, #8
8016abfc:	ea0000a8 	b	8016aea4 <_RME_Sig_Del+0x328>
8016ac00:	e51b300c 	ldr	r3, [fp, #-12]
8016ac04:	e1a03c23 	lsr	r3, r3, #24
8016ac08:	e3530003 	cmp	r3, #3
8016ac0c:	0a00003f 	beq	8016ad10 <_RME_Sig_Del+0x194>
8016ac10:	e3e03001 	mvn	r3, #1
8016ac14:	ea0000a2 	b	8016aea4 <_RME_Sig_Del+0x328>
8016ac18:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016ac1c:	e1a02423 	lsr	r2, r3, #8
8016ac20:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016ac24:	e5933014 	ldr	r3, [r3, #20]
8016ac28:	e1520003 	cmp	r2, r3
8016ac2c:	3a000001 	bcc	8016ac38 <_RME_Sig_Del+0xbc>
8016ac30:	e3e03002 	mvn	r3, #2
8016ac34:	ea00009a 	b	8016aea4 <_RME_Sig_Del+0x328>
8016ac38:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016ac3c:	e1a03423 	lsr	r3, r3, #8
8016ac40:	e1a02283 	lsl	r2, r3, #5
8016ac44:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016ac48:	e593300c 	ldr	r3, [r3, #12]
8016ac4c:	e0823003 	add	r3, r2, r3
8016ac50:	e50b3008 	str	r3, [fp, #-8]
8016ac54:	e51b3008 	ldr	r3, [fp, #-8]
8016ac58:	e1a00003 	mov	r0, r3
8016ac5c:	ebffd6a7 	bl	80160700 <__RME_A7A_Read_Acquire>
8016ac60:	e50b000c 	str	r0, [fp, #-12]
8016ac64:	e51b300c 	ldr	r3, [fp, #-12]
8016ac68:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016ac6c:	e3530802 	cmp	r3, #131072	@ 0x20000
8016ac70:	1a000001 	bne	8016ac7c <_RME_Sig_Del+0x100>
8016ac74:	e3e03008 	mvn	r3, #8
8016ac78:	ea000089 	b	8016aea4 <_RME_Sig_Del+0x328>
8016ac7c:	e51b300c 	ldr	r3, [fp, #-12]
8016ac80:	e1a03c23 	lsr	r3, r3, #24
8016ac84:	e3530003 	cmp	r3, #3
8016ac88:	0a000001 	beq	8016ac94 <_RME_Sig_Del+0x118>
8016ac8c:	e3e03001 	mvn	r3, #1
8016ac90:	ea000083 	b	8016aea4 <_RME_Sig_Del+0x328>
8016ac94:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016ac98:	e203207f 	and	r2, r3, #127	@ 0x7f
8016ac9c:	e51b3008 	ldr	r3, [fp, #-8]
8016aca0:	e5933014 	ldr	r3, [r3, #20]
8016aca4:	e1520003 	cmp	r2, r3
8016aca8:	3a000001 	bcc	8016acb4 <_RME_Sig_Del+0x138>
8016acac:	e3e03002 	mvn	r3, #2
8016acb0:	ea00007b 	b	8016aea4 <_RME_Sig_Del+0x328>
8016acb4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016acb8:	e203307f 	and	r3, r3, #127	@ 0x7f
8016acbc:	e1a02283 	lsl	r2, r3, #5
8016acc0:	e51b3008 	ldr	r3, [fp, #-8]
8016acc4:	e593300c 	ldr	r3, [r3, #12]
8016acc8:	e0823003 	add	r3, r2, r3
8016accc:	e50b3008 	str	r3, [fp, #-8]
8016acd0:	e51b3008 	ldr	r3, [fp, #-8]
8016acd4:	e1a00003 	mov	r0, r3
8016acd8:	ebffd688 	bl	80160700 <__RME_A7A_Read_Acquire>
8016acdc:	e50b000c 	str	r0, [fp, #-12]
8016ace0:	e51b300c 	ldr	r3, [fp, #-12]
8016ace4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016ace8:	e3530802 	cmp	r3, #131072	@ 0x20000
8016acec:	1a000001 	bne	8016acf8 <_RME_Sig_Del+0x17c>
8016acf0:	e3e03008 	mvn	r3, #8
8016acf4:	ea00006a 	b	8016aea4 <_RME_Sig_Del+0x328>
8016acf8:	e51b300c 	ldr	r3, [fp, #-12]
8016acfc:	e1a03c23 	lsr	r3, r3, #24
8016ad00:	e3530003 	cmp	r3, #3
8016ad04:	0a000001 	beq	8016ad10 <_RME_Sig_Del+0x194>
8016ad08:	e3e03001 	mvn	r3, #1
8016ad0c:	ea000064 	b	8016aea4 <_RME_Sig_Del+0x328>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_DEL);
8016ad10:	e51b3008 	ldr	r3, [fp, #-8]
8016ad14:	e5933008 	ldr	r3, [r3, #8]
8016ad18:	e2033002 	and	r3, r3, #2
8016ad1c:	e3530000 	cmp	r3, #0
8016ad20:	1a000001 	bne	8016ad2c <_RME_Sig_Del+0x1b0>
8016ad24:	e3e03006 	mvn	r3, #6
8016ad28:	ea00005d 	b	8016aea4 <_RME_Sig_Del+0x328>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Sig,struct RME_Cap_Sig*,Sig_Del);
8016ad2c:	e51b3008 	ldr	r3, [fp, #-8]
8016ad30:	e5932014 	ldr	r2, [r3, #20]
8016ad34:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016ad38:	e1520003 	cmp	r2, r3
8016ad3c:	8a000001 	bhi	8016ad48 <_RME_Sig_Del+0x1cc>
8016ad40:	e3e03002 	mvn	r3, #2
8016ad44:	ea000056 	b	8016aea4 <_RME_Sig_Del+0x328>
8016ad48:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016ad4c:	e1a02283 	lsl	r2, r3, #5
8016ad50:	e51b3008 	ldr	r3, [fp, #-8]
8016ad54:	e593300c 	ldr	r3, [r3, #12]
8016ad58:	e0823003 	add	r3, r2, r3
8016ad5c:	e50b3010 	str	r3, [fp, #-16]
    /* Delete check */
    RME_CAP_DEL_CHECK(Sig_Del,Type_Stat,RME_CAP_TYPE_SIG);
8016ad60:	e51b3010 	ldr	r3, [fp, #-16]
8016ad64:	e1a00003 	mov	r0, r3
8016ad68:	ebffd664 	bl	80160700 <__RME_A7A_Read_Acquire>
8016ad6c:	e50b000c 	str	r0, [fp, #-12]
8016ad70:	e51b300c 	ldr	r3, [fp, #-12]
8016ad74:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016ad78:	e3530802 	cmp	r3, #131072	@ 0x20000
8016ad7c:	0a000001 	beq	8016ad88 <_RME_Sig_Del+0x20c>
8016ad80:	e3e03008 	mvn	r3, #8
8016ad84:	ea000046 	b	8016aea4 <_RME_Sig_Del+0x328>
8016ad88:	e51b300c 	ldr	r3, [fp, #-12]
8016ad8c:	e1a03c23 	lsr	r3, r3, #24
8016ad90:	e3530008 	cmp	r3, #8
8016ad94:	0a000001 	beq	8016ada0 <_RME_Sig_Del+0x224>
8016ad98:	e3e03001 	mvn	r3, #1
8016ad9c:	ea000040 	b	8016aea4 <_RME_Sig_Del+0x328>
8016ada0:	e3003000 	movw	r3, #0
8016ada4:	e3483017 	movt	r3, #32791	@ 0x8017
8016ada8:	e5932000 	ldr	r2, [r3]
8016adac:	e51b3010 	ldr	r3, [fp, #-16]
8016adb0:	e5933010 	ldr	r3, [r3, #16]
8016adb4:	e1a01003 	mov	r1, r3
8016adb8:	e1a00002 	mov	r0, r2
8016adbc:	ebffd7eb 	bl	80160d70 <_RME_Diff>
8016adc0:	e1a03000 	mov	r3, r0
8016adc4:	e353000a 	cmp	r3, #10
8016adc8:	8a000001 	bhi	8016add4 <_RME_Sig_Del+0x258>
8016adcc:	e3e03007 	mvn	r3, #7
8016add0:	ea000033 	b	8016aea4 <_RME_Sig_Del+0x328>
8016add4:	e51b3010 	ldr	r3, [fp, #-16]
8016add8:	e5933004 	ldr	r3, [r3, #4]
8016addc:	e3530000 	cmp	r3, #0
8016ade0:	0a00000b 	beq	8016ae14 <_RME_Sig_Del+0x298>
8016ade4:	e51b300c 	ldr	r3, [fp, #-12]
8016ade8:	e6ff3073 	uxth	r3, r3
8016adec:	e3530000 	cmp	r3, #0
8016adf0:	1a000005 	bne	8016ae0c <_RME_Sig_Del+0x290>
8016adf4:	e51b0010 	ldr	r0, [fp, #-16]
8016adf8:	e51b300c 	ldr	r3, [fp, #-12]
8016adfc:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
8016ae00:	e1a02003 	mov	r2, r3
8016ae04:	e51b100c 	ldr	r1, [fp, #-12]
8016ae08:	ebffd76b 	bl	80160bbc <_RME_Comp_Swap_Single>
8016ae0c:	e3e03005 	mvn	r3, #5
8016ae10:	ea000023 	b	8016aea4 <_RME_Sig_Del+0x328>
8016ae14:	e51b300c 	ldr	r3, [fp, #-12]
8016ae18:	e6ff3073 	uxth	r3, r3
8016ae1c:	e3530000 	cmp	r3, #0
8016ae20:	0a000008 	beq	8016ae48 <_RME_Sig_Del+0x2cc>
8016ae24:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
8016ae28:	e3483016 	movt	r3, #32790	@ 0x8016
8016ae2c:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
8016ae30:	e3482016 	movt	r2, #32790	@ 0x8016
8016ae34:	e3011b3c 	movw	r1, #6972	@ 0x1b3c
8016ae38:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
8016ae3c:	e3480016 	movt	r0, #32790	@ 0x8016
8016ae40:	ebffd752 	bl	80160b90 <RME_Log>
8016ae44:	eafffffe 	b	8016ae44 <_RME_Sig_Del+0x2c8>

    /* Check if the signal endpoint is currently used and cannot be deleted */
    if(Sig_Del->Thd!=0U)
8016ae48:	e51b3010 	ldr	r3, [fp, #-16]
8016ae4c:	e5933018 	ldr	r3, [r3, #24]
8016ae50:	e3530000 	cmp	r3, #0
8016ae54:	0a000007 	beq	8016ae78 <_RME_Sig_Del+0x2fc>
    {
        RME_COV_MARKER();

        RME_CAP_DEFROST(Sig_Del,Type_Stat);
8016ae58:	e51b0010 	ldr	r0, [fp, #-16]
8016ae5c:	e51b300c 	ldr	r3, [fp, #-12]
8016ae60:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
8016ae64:	e1a02003 	mov	r2, r3
8016ae68:	e51b100c 	ldr	r1, [fp, #-12]
8016ae6c:	ebffd752 	bl	80160bbc <_RME_Comp_Swap_Single>
        return RME_ERR_SIV_ACT;
8016ae70:	e3e03f4b 	mvn	r3, #300	@ 0x12c
8016ae74:	ea00000a 	b	8016aea4 <_RME_Sig_Del+0x328>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Now we can safely delete the cap */
    RME_CAP_DELETE(Sig_Del,Type_Stat);
8016ae78:	e51b3010 	ldr	r3, [fp, #-16]
8016ae7c:	e3a02000 	mov	r2, #0
8016ae80:	e51b100c 	ldr	r1, [fp, #-12]
8016ae84:	e1a00003 	mov	r0, r3
8016ae88:	ebffd74b 	bl	80160bbc <_RME_Comp_Swap_Single>
8016ae8c:	e1a03000 	mov	r3, r0
8016ae90:	e3530000 	cmp	r3, #0
8016ae94:	1a000001 	bne	8016aea0 <_RME_Sig_Del+0x324>
8016ae98:	e3e03000 	mvn	r3, #0
8016ae9c:	ea000000 	b	8016aea4 <_RME_Sig_Del+0x328>
    
    return 0;
8016aea0:	e3a03000 	mov	r3, #0
}
8016aea4:	e1a00003 	mov	r0, r3
8016aea8:	e24bd004 	sub	sp, fp, #4
8016aeac:	e8bd8800 	pop	{fp, pc}

8016aeb0 <_RME_Kern_High>:
Output      : volatile struct RME_Reg_Struct* Reg - The updated register set.
Return      : None.
******************************************************************************/
void _RME_Kern_High(struct RME_Reg_Struct* Reg,
                    struct RME_CPU_Local* Local)
{
8016aeb0:	e92d4800 	push	{fp, lr}
8016aeb4:	e28db004 	add	fp, sp, #4
8016aeb8:	e24dd010 	sub	sp, sp, #16
8016aebc:	e50b0010 	str	r0, [fp, #-16]
8016aec0:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
    struct RME_Thd_Struct* Thd_New;
    struct RME_Thd_Struct* Thd_Cur;

    Thd_New=_RME_Run_High(Local);
8016aec4:	e51b0014 	ldr	r0, [fp, #-20]	@ 0xffffffec
8016aec8:	ebffeaee 	bl	80165a88 <_RME_Run_High>
8016aecc:	e50b0008 	str	r0, [fp, #-8]
    RME_ASSERT(Thd_New!=RME_NULL);
8016aed0:	e51b3008 	ldr	r3, [fp, #-8]
8016aed4:	e3530000 	cmp	r3, #0
8016aed8:	1a000008 	bne	8016af00 <_RME_Kern_High+0x50>
8016aedc:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
8016aee0:	e3483016 	movt	r3, #32790	@ 0x8016
8016aee4:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
8016aee8:	e3482016 	movt	r2, #32790	@ 0x8016
8016aeec:	e3011b65 	movw	r1, #7013	@ 0x1b65
8016aef0:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
8016aef4:	e3480016 	movt	r0, #32790	@ 0x8016
8016aef8:	ebffd724 	bl	80160b90 <RME_Log>
8016aefc:	eafffffe 	b	8016aefc <_RME_Kern_High+0x4c>
    Thd_Cur=Local->Thd_Cur;
8016af00:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016af04:	e5933004 	ldr	r3, [r3, #4]
8016af08:	e50b300c 	str	r3, [fp, #-12]

    /* Are these two threads the same? */
    if(Thd_New==Thd_Cur)
8016af0c:	e51b2008 	ldr	r2, [fp, #-8]
8016af10:	e51b300c 	ldr	r3, [fp, #-12]
8016af14:	e1520003 	cmp	r2, r3
8016af18:	0a00001e 	beq	8016af98 <_RME_Kern_High+0xe8>
        /* No action required */
    }

    /* Check if we need to do the context switch regardless of priority
     * because the current thread is not ready yet. */
    if(Thd_Cur->Sched.State==RME_THD_READY)
8016af1c:	e51b300c 	ldr	r3, [fp, #-12]
8016af20:	e593301c 	ldr	r3, [r3, #28]
8016af24:	e3530000 	cmp	r3, #0
8016af28:	1a000005 	bne	8016af44 <_RME_Kern_High+0x94>
    {
        RME_COV_MARKER();

        /* Check priority to see if the switch is necessary */
        if(Thd_New->Sched.Prio<=Thd_Cur->Sched.Prio)
8016af2c:	e51b3008 	ldr	r3, [fp, #-8]
8016af30:	e5932020 	ldr	r2, [r3, #32]
8016af34:	e51b300c 	ldr	r3, [fp, #-12]
8016af38:	e5933020 	ldr	r3, [r3, #32]
8016af3c:	e1520003 	cmp	r2, r3
8016af40:	9a000016 	bls	8016afa0 <_RME_Kern_High+0xf0>
        /* No action required */
    }

    /* We will have a solid context switch on this point. The current 
     * thread is not necessarily READY, it could be EXCPEND as well. */
    RME_ASSERT(Thd_New->Sched.State==RME_THD_READY);
8016af44:	e51b3008 	ldr	r3, [fp, #-8]
8016af48:	e593301c 	ldr	r3, [r3, #28]
8016af4c:	e3530000 	cmp	r3, #0
8016af50:	0a000008 	beq	8016af78 <_RME_Kern_High+0xc8>
8016af54:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
8016af58:	e3483016 	movt	r3, #32790	@ 0x8016
8016af5c:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
8016af60:	e3482016 	movt	r2, #32790	@ 0x8016
8016af64:	e3011b90 	movw	r1, #7056	@ 0x1b90
8016af68:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
8016af6c:	e3480016 	movt	r0, #32790	@ 0x8016
8016af70:	ebffd706 	bl	80160b90 <RME_Log>
8016af74:	eafffffe 	b	8016af74 <_RME_Kern_High+0xc4>
    _RME_Run_Swt(Reg,Thd_Cur,Thd_New);
8016af78:	e51b2008 	ldr	r2, [fp, #-8]
8016af7c:	e51b100c 	ldr	r1, [fp, #-12]
8016af80:	e51b0010 	ldr	r0, [fp, #-16]
8016af84:	ebffeb32 	bl	80165c54 <_RME_Run_Swt>
    Local->Thd_Cur=Thd_New;
8016af88:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016af8c:	e51b2008 	ldr	r2, [fp, #-8]
8016af90:	e5832004 	str	r2, [r3, #4]
8016af94:	ea000002 	b	8016afa4 <_RME_Kern_High+0xf4>
        return;
8016af98:	e320f000 	nop	{0}
8016af9c:	ea000000 	b	8016afa4 <_RME_Kern_High+0xf4>
            return;
8016afa0:	e320f000 	nop	{0}
}
8016afa4:	e24bd004 	sub	sp, fp, #4
8016afa8:	e8bd8800 	pop	{fp, pc}

8016afac <_RME_Kern_Snd>:
Input       : struct RME_Cap_Sig* Cap_Sig - The signal root capability.
Output      : None.
Return      : rme_ret_t - If successful, 0, or an error code.
******************************************************************************/
rme_ret_t _RME_Kern_Snd(struct RME_Cap_Sig* Cap_Sig)
{
8016afac:	e92d4800 	push	{fp, lr}
8016afb0:	e28db004 	add	fp, sp, #4
8016afb4:	e24dd010 	sub	sp, sp, #16
8016afb8:	e50b0010 	str	r0, [fp, #-16]
    rme_ptr_t Unblock;
    struct RME_Thd_Struct* Thd_Sig;
    
    Thd_Sig=Cap_Sig->Thd;
8016afbc:	e51b3010 	ldr	r3, [fp, #-16]
8016afc0:	e5933018 	ldr	r3, [r3, #24]
8016afc4:	e50b300c 	str	r3, [fp, #-12]
    
    /* If and only if we are calling from the same core do we unblock */
    if(Thd_Sig!=RME_NULL)
8016afc8:	e51b300c 	ldr	r3, [fp, #-12]
8016afcc:	e3530000 	cmp	r3, #0
8016afd0:	0a00000b 	beq	8016b004 <_RME_Kern_Snd+0x58>
    {
        RME_COV_MARKER();

        if(Thd_Sig->Sched.Local==RME_CPU_LOCAL())
8016afd4:	e51b300c 	ldr	r3, [fp, #-12]
8016afd8:	e5932014 	ldr	r2, [r3, #20]
8016afdc:	e3003004 	movw	r3, #4
8016afe0:	e3483017 	movt	r3, #32791	@ 0x8017
8016afe4:	e1520003 	cmp	r2, r3
8016afe8:	1a000002 	bne	8016aff8 <_RME_Kern_Snd+0x4c>
        {
            RME_COV_MARKER();

            Unblock=1U;
8016afec:	e3a03001 	mov	r3, #1
8016aff0:	e50b3008 	str	r3, [fp, #-8]
8016aff4:	ea000004 	b	8016b00c <_RME_Kern_Snd+0x60>
        }
        else
        {
            RME_COV_MARKER();

            Unblock=0U;
8016aff8:	e3a03000 	mov	r3, #0
8016affc:	e50b3008 	str	r3, [fp, #-8]
8016b000:	ea000001 	b	8016b00c <_RME_Kern_Snd+0x60>
    }
    else
    {
        RME_COV_MARKER();

        Unblock=0U;
8016b004:	e3a03000 	mov	r3, #0
8016b008:	e50b3008 	str	r3, [fp, #-8]
    }

    if(Unblock!=0U)
8016b00c:	e51b3008 	ldr	r3, [fp, #-8]
8016b010:	e3530000 	cmp	r3, #0
8016b014:	0a000017 	beq	8016b078 <_RME_Kern_Snd+0xcc>

        /* The thread is blocked, and it is on our core. Unblock it, and
         * set the return value to one as always, Even if we were specifying
         * multi-receive. This is because other cores may reduce the count
         * to zero while we are doing this. */
        __RME_Svc_Retval_Set(&(Thd_Sig->Ctx.Reg->Reg),1);
8016b018:	e51b300c 	ldr	r3, [fp, #-12]
8016b01c:	e5933048 	ldr	r3, [r3, #72]	@ 0x48
8016b020:	e3a01001 	mov	r1, #1
8016b024:	e1a00003 	mov	r0, r3
8016b028:	eb000a2c 	bl	8016d8e0 <__RME_Svc_Retval_Set>
        
        /* See if the thread still have time left */
        if(Thd_Sig->Sched.Slice!=0U)
8016b02c:	e51b300c 	ldr	r3, [fp, #-12]
8016b030:	e5933018 	ldr	r3, [r3, #24]
8016b034:	e3530000 	cmp	r3, #0
8016b038:	0a000005 	beq	8016b054 <_RME_Kern_Snd+0xa8>
        {
            RME_COV_MARKER();

            /* Ready and add to runqueue */
            Thd_Sig->Sched.State=RME_THD_READY;
8016b03c:	e51b300c 	ldr	r3, [fp, #-12]
8016b040:	e3a02000 	mov	r2, #0
8016b044:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Ins(Thd_Sig);
8016b048:	e51b000c 	ldr	r0, [fp, #-12]
8016b04c:	ebffea18 	bl	801658b4 <_RME_Run_Ins>
8016b050:	ea000004 	b	8016b068 <_RME_Kern_Snd+0xbc>
        else
        {
            RME_COV_MARKER();

            /* Timeout and notify parent */
            Thd_Sig->Sched.State=RME_THD_TIMEOUT;
8016b054:	e51b300c 	ldr	r3, [fp, #-12]
8016b058:	e3a02002 	mov	r2, #2
8016b05c:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Notif(Thd_Sig);
8016b060:	e51b000c 	ldr	r0, [fp, #-12]
8016b064:	ebffeabd 	bl	80165b60 <_RME_Run_Notif>
         * we hope to perform the context switch only once when exiting that
         * handler. Also note that the current thread could be EXCPEND as well;
         * this is different from the normal signal sending system call. */
        
        /* Clear endpoint blocking status - no write release required */
        Cap_Sig->Thd=RME_NULL;
8016b068:	e51b3010 	ldr	r3, [fp, #-16]
8016b06c:	e3a02000 	mov	r2, #0
8016b070:	e5832018 	str	r2, [r3, #24]
8016b074:	ea00000f 	b	8016b0b8 <_RME_Kern_Snd+0x10c>
    {
        RME_COV_MARKER();

        /* The guy who blocked on it is not on our core, or nobody blocked.
         * We just faa the counter value and return. */
        if(RME_FETCH_ADD(&(Cap_Sig->Sig_Num),1U)>=RME_MAX_SIG_NUM)
8016b078:	e51b3010 	ldr	r3, [fp, #-16]
8016b07c:	e2833014 	add	r3, r3, #20
8016b080:	e3a01001 	mov	r1, #1
8016b084:	e1a00003 	mov	r0, r3
8016b088:	ebffd6e0 	bl	80160c10 <_RME_Fetch_Add_Single>
8016b08c:	e1a03000 	mov	r3, r0
8016b090:	e373010a 	cmn	r3, #-2147483646	@ 0x80000002
8016b094:	9a000007 	bls	8016b0b8 <_RME_Kern_Snd+0x10c>
        {
            RME_COV_MARKER();

            RME_FETCH_ADD(&(Cap_Sig->Sig_Num),-1);
8016b098:	e51b3010 	ldr	r3, [fp, #-16]
8016b09c:	e2833014 	add	r3, r3, #20
8016b0a0:	e3e01000 	mvn	r1, #0
8016b0a4:	e1a00003 	mov	r0, r3
8016b0a8:	ebffd6d8 	bl	80160c10 <_RME_Fetch_Add_Single>
            return RME_ERR_SIV_FULL;
8016b0ac:	e30f3ed1 	movw	r3, #65233	@ 0xfed1
8016b0b0:	e34f3fff 	movt	r3, #65535	@ 0xffff
8016b0b4:	ea000000 	b	8016b0bc <_RME_Kern_Snd+0x110>
            RME_COV_MARKER();
            /* No action required */
        }
    }

    return 0;
8016b0b8:	e3a03000 	mov	r3, #0
}
8016b0bc:	e1a00003 	mov	r0, r3
8016b0c0:	e24bd004 	sub	sp, fp, #4
8016b0c4:	e8bd8800 	pop	{fp, pc}

8016b0c8 <_RME_Sig_Snd>:
Return      : rme_ret_t - If successful, 0, or an error code.
******************************************************************************/
static rme_ret_t _RME_Sig_Snd(struct RME_Cap_Cpt* Cpt, 
                              struct RME_Reg_Struct* Reg,
                              rme_cid_t Cap_Sig)
{
8016b0c8:	e92d4800 	push	{fp, lr}
8016b0cc:	e28db004 	add	fp, sp, #4
8016b0d0:	e24dd028 	sub	sp, sp, #40	@ 0x28
8016b0d4:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
8016b0d8:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
8016b0dc:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
    struct RME_CPU_Local* Local;
    rme_ptr_t Unblock;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Sig,RME_CAP_TYPE_SIG,
8016b0e0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b0e4:	e2033080 	and	r3, r3, #128	@ 0x80
8016b0e8:	e3530000 	cmp	r3, #0
8016b0ec:	1a00001c 	bne	8016b164 <_RME_Sig_Snd+0x9c>
8016b0f0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016b0f4:	e5932014 	ldr	r2, [r3, #20]
8016b0f8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b0fc:	e1520003 	cmp	r2, r3
8016b100:	8a000001 	bhi	8016b10c <_RME_Sig_Snd+0x44>
8016b104:	e3e03002 	mvn	r3, #2
8016b108:	ea0000af 	b	8016b3cc <_RME_Sig_Snd+0x304>
8016b10c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b110:	e1a02283 	lsl	r2, r3, #5
8016b114:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016b118:	e593300c 	ldr	r3, [r3, #12]
8016b11c:	e0823003 	add	r3, r2, r3
8016b120:	e50b3008 	str	r3, [fp, #-8]
8016b124:	e51b3008 	ldr	r3, [fp, #-8]
8016b128:	e1a00003 	mov	r0, r3
8016b12c:	ebffd573 	bl	80160700 <__RME_A7A_Read_Acquire>
8016b130:	e50b0010 	str	r0, [fp, #-16]
8016b134:	e51b3010 	ldr	r3, [fp, #-16]
8016b138:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016b13c:	e3530802 	cmp	r3, #131072	@ 0x20000
8016b140:	1a000001 	bne	8016b14c <_RME_Sig_Snd+0x84>
8016b144:	e3e03008 	mvn	r3, #8
8016b148:	ea00009f 	b	8016b3cc <_RME_Sig_Snd+0x304>
8016b14c:	e51b3010 	ldr	r3, [fp, #-16]
8016b150:	e1a03c23 	lsr	r3, r3, #24
8016b154:	e3530008 	cmp	r3, #8
8016b158:	0a00003f 	beq	8016b25c <_RME_Sig_Snd+0x194>
8016b15c:	e3e03001 	mvn	r3, #1
8016b160:	ea000099 	b	8016b3cc <_RME_Sig_Snd+0x304>
8016b164:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b168:	e1a02423 	lsr	r2, r3, #8
8016b16c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016b170:	e5933014 	ldr	r3, [r3, #20]
8016b174:	e1520003 	cmp	r2, r3
8016b178:	3a000001 	bcc	8016b184 <_RME_Sig_Snd+0xbc>
8016b17c:	e3e03002 	mvn	r3, #2
8016b180:	ea000091 	b	8016b3cc <_RME_Sig_Snd+0x304>
8016b184:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b188:	e1a03423 	lsr	r3, r3, #8
8016b18c:	e1a02283 	lsl	r2, r3, #5
8016b190:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016b194:	e593300c 	ldr	r3, [r3, #12]
8016b198:	e0823003 	add	r3, r2, r3
8016b19c:	e50b3008 	str	r3, [fp, #-8]
8016b1a0:	e51b3008 	ldr	r3, [fp, #-8]
8016b1a4:	e1a00003 	mov	r0, r3
8016b1a8:	ebffd554 	bl	80160700 <__RME_A7A_Read_Acquire>
8016b1ac:	e50b0010 	str	r0, [fp, #-16]
8016b1b0:	e51b3010 	ldr	r3, [fp, #-16]
8016b1b4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016b1b8:	e3530802 	cmp	r3, #131072	@ 0x20000
8016b1bc:	1a000001 	bne	8016b1c8 <_RME_Sig_Snd+0x100>
8016b1c0:	e3e03008 	mvn	r3, #8
8016b1c4:	ea000080 	b	8016b3cc <_RME_Sig_Snd+0x304>
8016b1c8:	e51b3010 	ldr	r3, [fp, #-16]
8016b1cc:	e1a03c23 	lsr	r3, r3, #24
8016b1d0:	e3530003 	cmp	r3, #3
8016b1d4:	0a000001 	beq	8016b1e0 <_RME_Sig_Snd+0x118>
8016b1d8:	e3e03001 	mvn	r3, #1
8016b1dc:	ea00007a 	b	8016b3cc <_RME_Sig_Snd+0x304>
8016b1e0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b1e4:	e203207f 	and	r2, r3, #127	@ 0x7f
8016b1e8:	e51b3008 	ldr	r3, [fp, #-8]
8016b1ec:	e5933014 	ldr	r3, [r3, #20]
8016b1f0:	e1520003 	cmp	r2, r3
8016b1f4:	3a000001 	bcc	8016b200 <_RME_Sig_Snd+0x138>
8016b1f8:	e3e03002 	mvn	r3, #2
8016b1fc:	ea000072 	b	8016b3cc <_RME_Sig_Snd+0x304>
8016b200:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b204:	e203307f 	and	r3, r3, #127	@ 0x7f
8016b208:	e1a02283 	lsl	r2, r3, #5
8016b20c:	e51b3008 	ldr	r3, [fp, #-8]
8016b210:	e593300c 	ldr	r3, [r3, #12]
8016b214:	e0823003 	add	r3, r2, r3
8016b218:	e50b3008 	str	r3, [fp, #-8]
8016b21c:	e51b3008 	ldr	r3, [fp, #-8]
8016b220:	e1a00003 	mov	r0, r3
8016b224:	ebffd535 	bl	80160700 <__RME_A7A_Read_Acquire>
8016b228:	e50b0010 	str	r0, [fp, #-16]
8016b22c:	e51b3010 	ldr	r3, [fp, #-16]
8016b230:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016b234:	e3530802 	cmp	r3, #131072	@ 0x20000
8016b238:	1a000001 	bne	8016b244 <_RME_Sig_Snd+0x17c>
8016b23c:	e3e03008 	mvn	r3, #8
8016b240:	ea000061 	b	8016b3cc <_RME_Sig_Snd+0x304>
8016b244:	e51b3010 	ldr	r3, [fp, #-16]
8016b248:	e1a03c23 	lsr	r3, r3, #24
8016b24c:	e3530008 	cmp	r3, #8
8016b250:	0a000001 	beq	8016b25c <_RME_Sig_Snd+0x194>
8016b254:	e3e03001 	mvn	r3, #1
8016b258:	ea00005b 	b	8016b3cc <_RME_Sig_Snd+0x304>
                   struct RME_Cap_Sig*,Sig_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Sig_Op,RME_SIG_FLAG_SND);
8016b25c:	e51b3008 	ldr	r3, [fp, #-8]
8016b260:	e5933008 	ldr	r3, [r3, #8]
8016b264:	e2033001 	and	r3, r3, #1
8016b268:	e3530000 	cmp	r3, #0
8016b26c:	1a000001 	bne	8016b278 <_RME_Sig_Snd+0x1b0>
8016b270:	e3e03006 	mvn	r3, #6
8016b274:	ea000054 	b	8016b3cc <_RME_Sig_Snd+0x304>
    
    Local=RME_CPU_LOCAL();
8016b278:	e3003004 	movw	r3, #4
8016b27c:	e3483017 	movt	r3, #32791	@ 0x8017
8016b280:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Sig_Root=RME_CAP_CONV_ROOT(Sig_Op,struct RME_Cap_Sig*);
8016b284:	e51b3008 	ldr	r3, [fp, #-8]
8016b288:	e5933000 	ldr	r3, [r3]
8016b28c:	e6ff3073 	uxth	r3, r3
8016b290:	e3530000 	cmp	r3, #0
8016b294:	0a000002 	beq	8016b2a4 <_RME_Sig_Snd+0x1dc>
8016b298:	e51b3008 	ldr	r3, [fp, #-8]
8016b29c:	e5933004 	ldr	r3, [r3, #4]
8016b2a0:	ea000000 	b	8016b2a8 <_RME_Sig_Snd+0x1e0>
8016b2a4:	e51b3008 	ldr	r3, [fp, #-8]
8016b2a8:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    Thd_Rcv=Sig_Root->Thd;
8016b2ac:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b2b0:	e5933018 	ldr	r3, [r3, #24]
8016b2b4:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4

    /* If and only if we are calling from the same core do we unblock */
    if(Thd_Rcv!=RME_NULL)
8016b2b8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016b2bc:	e3530000 	cmp	r3, #0
8016b2c0:	0a00000a 	beq	8016b2f0 <_RME_Sig_Snd+0x228>
    {
        RME_COV_MARKER();

        if(Thd_Rcv->Sched.Local==Local)
8016b2c4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016b2c8:	e5933014 	ldr	r3, [r3, #20]
8016b2cc:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
8016b2d0:	e1520003 	cmp	r2, r3
8016b2d4:	1a000002 	bne	8016b2e4 <_RME_Sig_Snd+0x21c>
        {
            RME_COV_MARKER();

            Unblock=1U;
8016b2d8:	e3a03001 	mov	r3, #1
8016b2dc:	e50b300c 	str	r3, [fp, #-12]
8016b2e0:	ea000004 	b	8016b2f8 <_RME_Sig_Snd+0x230>
        }
        else
        {
            RME_COV_MARKER();

            Unblock=0U;
8016b2e4:	e3a03000 	mov	r3, #0
8016b2e8:	e50b300c 	str	r3, [fp, #-12]
8016b2ec:	ea000001 	b	8016b2f8 <_RME_Sig_Snd+0x230>
    }
    else
    {
        RME_COV_MARKER();

        Unblock=0U;
8016b2f0:	e3a03000 	mov	r3, #0
8016b2f4:	e50b300c 	str	r3, [fp, #-12]
    }
    
    if(Unblock!=0U)
8016b2f8:	e51b300c 	ldr	r3, [fp, #-12]
8016b2fc:	e3530000 	cmp	r3, #0
8016b300:	0a00001d 	beq	8016b37c <_RME_Sig_Snd+0x2b4>
    {
        RME_COV_MARKER();

        /* Now save the system call return value to the caller stack */
        __RME_Svc_Retval_Set(Reg,0);
8016b304:	e3a01000 	mov	r1, #0
8016b308:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
8016b30c:	eb000973 	bl	8016d8e0 <__RME_Svc_Retval_Set>
        
        /* The thread is blocked, and it is on our core. Unblock it, and
         * set the return value to one as always, Even if we were specifying
         * multi-receive. This is because other cores may reduce the count
         * to zero while we are doing this. */
        __RME_Svc_Retval_Set(&(Thd_Rcv->Ctx.Reg->Reg),1);
8016b310:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016b314:	e5933048 	ldr	r3, [r3, #72]	@ 0x48
8016b318:	e3a01001 	mov	r1, #1
8016b31c:	e1a00003 	mov	r0, r3
8016b320:	eb00096e 	bl	8016d8e0 <__RME_Svc_Retval_Set>
        
        /* See if the thread still have time left */
        if(Thd_Rcv->Sched.Slice!=0U)
8016b324:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016b328:	e5933018 	ldr	r3, [r3, #24]
8016b32c:	e3530000 	cmp	r3, #0
8016b330:	0a000005 	beq	8016b34c <_RME_Sig_Snd+0x284>
        {
            RME_COV_MARKER();

            /* Ready and add to runqueue */
            Thd_Rcv->Sched.State=RME_THD_READY;
8016b334:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016b338:	e3a02000 	mov	r2, #0
8016b33c:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Ins(Thd_Rcv);
8016b340:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
8016b344:	ebffe95a 	bl	801658b4 <_RME_Run_Ins>
8016b348:	ea000004 	b	8016b360 <_RME_Sig_Snd+0x298>
        else
        {
            RME_COV_MARKER();

            /* Timeout and notify parent */
            Thd_Rcv->Sched.State=RME_THD_TIMEOUT;
8016b34c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016b350:	e3a02002 	mov	r2, #2
8016b354:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Notif(Thd_Rcv);
8016b358:	e51b001c 	ldr	r0, [fp, #-28]	@ 0xffffffe4
8016b35c:	ebffe9ff 	bl	80165b60 <_RME_Run_Notif>
        }
        
        /* Pick the highest priority thread to run */
        _RME_Kern_High(Reg,Local);
8016b360:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
8016b364:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
8016b368:	ebfffed0 	bl	8016aeb0 <_RME_Kern_High>
        
        /* Clear endpoint blocking status - no write release required */
        Sig_Root->Thd=RME_NULL;
8016b36c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b370:	e3a02000 	mov	r2, #0
8016b374:	e5832018 	str	r2, [r3, #24]
8016b378:	ea000012 	b	8016b3c8 <_RME_Sig_Snd+0x300>
    else
    {
        RME_COV_MARKER();

        /* The guy who blocked on it is not on our core, we just faa and return */
        if(RME_FETCH_ADD(&(Sig_Root->Sig_Num),1U)>=RME_MAX_SIG_NUM)
8016b37c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b380:	e2833014 	add	r3, r3, #20
8016b384:	e3a01001 	mov	r1, #1
8016b388:	e1a00003 	mov	r0, r3
8016b38c:	ebffd61f 	bl	80160c10 <_RME_Fetch_Add_Single>
8016b390:	e1a03000 	mov	r3, r0
8016b394:	e373010a 	cmn	r3, #-2147483646	@ 0x80000002
8016b398:	9a000007 	bls	8016b3bc <_RME_Sig_Snd+0x2f4>
        {
            RME_COV_MARKER();

            RME_FETCH_ADD(&(Sig_Root->Sig_Num),-1);
8016b39c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b3a0:	e2833014 	add	r3, r3, #20
8016b3a4:	e3e01000 	mvn	r1, #0
8016b3a8:	e1a00003 	mov	r0, r3
8016b3ac:	ebffd617 	bl	80160c10 <_RME_Fetch_Add_Single>
            return RME_ERR_SIV_FULL;
8016b3b0:	e30f3ed1 	movw	r3, #65233	@ 0xfed1
8016b3b4:	e34f3fff 	movt	r3, #65535	@ 0xffff
8016b3b8:	ea000003 	b	8016b3cc <_RME_Sig_Snd+0x304>
            RME_COV_MARKER();
            /* No action required */
        }
        
        /* Now save the system call return value to the caller stack */
        __RME_Svc_Retval_Set(Reg,0);
8016b3bc:	e3a01000 	mov	r1, #0
8016b3c0:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
8016b3c4:	eb000945 	bl	8016d8e0 <__RME_Svc_Retval_Set>
    }

    return 0;
8016b3c8:	e3a03000 	mov	r3, #0
}
8016b3cc:	e1a00003 	mov	r0, r3
8016b3d0:	e24bd004 	sub	sp, fp, #4
8016b3d4:	e8bd8800 	pop	{fp, pc}

8016b3d8 <_RME_Sig_Rcv>:
******************************************************************************/
static rme_ret_t _RME_Sig_Rcv(struct RME_Cap_Cpt* Cpt,
                              struct RME_Reg_Struct* Reg,
                              rme_cid_t Cap_Sig,
                              rme_ptr_t Option)
{
8016b3d8:	e92d4800 	push	{fp, lr}
8016b3dc:	e28db004 	add	fp, sp, #4
8016b3e0:	e24dd028 	sub	sp, sp, #40	@ 0x28
8016b3e4:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
8016b3e8:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
8016b3ec:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
8016b3f0:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
    struct RME_Thd_Struct* Thd_Cur;
    rme_ptr_t Old_Value;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Sig,RME_CAP_TYPE_SIG,
8016b3f4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b3f8:	e2033080 	and	r3, r3, #128	@ 0x80
8016b3fc:	e3530000 	cmp	r3, #0
8016b400:	1a00001c 	bne	8016b478 <_RME_Sig_Rcv+0xa0>
8016b404:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016b408:	e5932014 	ldr	r2, [r3, #20]
8016b40c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b410:	e1520003 	cmp	r2, r3
8016b414:	8a000001 	bhi	8016b420 <_RME_Sig_Rcv+0x48>
8016b418:	e3e03002 	mvn	r3, #2
8016b41c:	ea0000f6 	b	8016b7fc <_RME_Sig_Rcv+0x424>
8016b420:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b424:	e1a02283 	lsl	r2, r3, #5
8016b428:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016b42c:	e593300c 	ldr	r3, [r3, #12]
8016b430:	e0823003 	add	r3, r2, r3
8016b434:	e50b3008 	str	r3, [fp, #-8]
8016b438:	e51b3008 	ldr	r3, [fp, #-8]
8016b43c:	e1a00003 	mov	r0, r3
8016b440:	ebffd4ae 	bl	80160700 <__RME_A7A_Read_Acquire>
8016b444:	e50b000c 	str	r0, [fp, #-12]
8016b448:	e51b300c 	ldr	r3, [fp, #-12]
8016b44c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016b450:	e3530802 	cmp	r3, #131072	@ 0x20000
8016b454:	1a000001 	bne	8016b460 <_RME_Sig_Rcv+0x88>
8016b458:	e3e03008 	mvn	r3, #8
8016b45c:	ea0000e6 	b	8016b7fc <_RME_Sig_Rcv+0x424>
8016b460:	e51b300c 	ldr	r3, [fp, #-12]
8016b464:	e1a03c23 	lsr	r3, r3, #24
8016b468:	e3530008 	cmp	r3, #8
8016b46c:	0a00003f 	beq	8016b570 <_RME_Sig_Rcv+0x198>
8016b470:	e3e03001 	mvn	r3, #1
8016b474:	ea0000e0 	b	8016b7fc <_RME_Sig_Rcv+0x424>
8016b478:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b47c:	e1a02423 	lsr	r2, r3, #8
8016b480:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016b484:	e5933014 	ldr	r3, [r3, #20]
8016b488:	e1520003 	cmp	r2, r3
8016b48c:	3a000001 	bcc	8016b498 <_RME_Sig_Rcv+0xc0>
8016b490:	e3e03002 	mvn	r3, #2
8016b494:	ea0000d8 	b	8016b7fc <_RME_Sig_Rcv+0x424>
8016b498:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b49c:	e1a03423 	lsr	r3, r3, #8
8016b4a0:	e1a02283 	lsl	r2, r3, #5
8016b4a4:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016b4a8:	e593300c 	ldr	r3, [r3, #12]
8016b4ac:	e0823003 	add	r3, r2, r3
8016b4b0:	e50b3008 	str	r3, [fp, #-8]
8016b4b4:	e51b3008 	ldr	r3, [fp, #-8]
8016b4b8:	e1a00003 	mov	r0, r3
8016b4bc:	ebffd48f 	bl	80160700 <__RME_A7A_Read_Acquire>
8016b4c0:	e50b000c 	str	r0, [fp, #-12]
8016b4c4:	e51b300c 	ldr	r3, [fp, #-12]
8016b4c8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016b4cc:	e3530802 	cmp	r3, #131072	@ 0x20000
8016b4d0:	1a000001 	bne	8016b4dc <_RME_Sig_Rcv+0x104>
8016b4d4:	e3e03008 	mvn	r3, #8
8016b4d8:	ea0000c7 	b	8016b7fc <_RME_Sig_Rcv+0x424>
8016b4dc:	e51b300c 	ldr	r3, [fp, #-12]
8016b4e0:	e1a03c23 	lsr	r3, r3, #24
8016b4e4:	e3530003 	cmp	r3, #3
8016b4e8:	0a000001 	beq	8016b4f4 <_RME_Sig_Rcv+0x11c>
8016b4ec:	e3e03001 	mvn	r3, #1
8016b4f0:	ea0000c1 	b	8016b7fc <_RME_Sig_Rcv+0x424>
8016b4f4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b4f8:	e203207f 	and	r2, r3, #127	@ 0x7f
8016b4fc:	e51b3008 	ldr	r3, [fp, #-8]
8016b500:	e5933014 	ldr	r3, [r3, #20]
8016b504:	e1520003 	cmp	r2, r3
8016b508:	3a000001 	bcc	8016b514 <_RME_Sig_Rcv+0x13c>
8016b50c:	e3e03002 	mvn	r3, #2
8016b510:	ea0000b9 	b	8016b7fc <_RME_Sig_Rcv+0x424>
8016b514:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b518:	e203307f 	and	r3, r3, #127	@ 0x7f
8016b51c:	e1a02283 	lsl	r2, r3, #5
8016b520:	e51b3008 	ldr	r3, [fp, #-8]
8016b524:	e593300c 	ldr	r3, [r3, #12]
8016b528:	e0823003 	add	r3, r2, r3
8016b52c:	e50b3008 	str	r3, [fp, #-8]
8016b530:	e51b3008 	ldr	r3, [fp, #-8]
8016b534:	e1a00003 	mov	r0, r3
8016b538:	ebffd470 	bl	80160700 <__RME_A7A_Read_Acquire>
8016b53c:	e50b000c 	str	r0, [fp, #-12]
8016b540:	e51b300c 	ldr	r3, [fp, #-12]
8016b544:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016b548:	e3530802 	cmp	r3, #131072	@ 0x20000
8016b54c:	1a000001 	bne	8016b558 <_RME_Sig_Rcv+0x180>
8016b550:	e3e03008 	mvn	r3, #8
8016b554:	ea0000a8 	b	8016b7fc <_RME_Sig_Rcv+0x424>
8016b558:	e51b300c 	ldr	r3, [fp, #-12]
8016b55c:	e1a03c23 	lsr	r3, r3, #24
8016b560:	e3530008 	cmp	r3, #8
8016b564:	0a000001 	beq	8016b570 <_RME_Sig_Rcv+0x198>
8016b568:	e3e03001 	mvn	r3, #1
8016b56c:	ea0000a2 	b	8016b7fc <_RME_Sig_Rcv+0x424>
                   struct RME_Cap_Sig*,Sig_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    switch(Option)
8016b570:	e51b202c 	ldr	r2, [fp, #-44]	@ 0xffffffd4
8016b574:	e59f328c 	ldr	r3, [pc, #652]	@ 8016b808 <_RME_Sig_Rcv+0x430>
8016b578:	e3520003 	cmp	r2, #3
8016b57c:	8a00001d 	bhi	8016b5f8 <_RME_Sig_Rcv+0x220>
8016b580:	e793f102 	ldr	pc, [r3, r2, lsl #2]
8016b584:	e320f000 	nop	{0}
    {
        case RME_RCV_BS:
        {
            RME_COV_MARKER();

            RME_CAP_CHECK(Sig_Op,RME_SIG_FLAG_RCV_BS);
8016b588:	e51b3008 	ldr	r3, [fp, #-8]
8016b58c:	e5933008 	ldr	r3, [r3, #8]
8016b590:	e2033002 	and	r3, r3, #2
8016b594:	e3530000 	cmp	r3, #0
8016b598:	1a000018 	bne	8016b600 <_RME_Sig_Rcv+0x228>
8016b59c:	e3e03006 	mvn	r3, #6
8016b5a0:	ea000095 	b	8016b7fc <_RME_Sig_Rcv+0x424>
        }
        case RME_RCV_BM:
        {
            RME_COV_MARKER();
            
            RME_CAP_CHECK(Sig_Op,RME_SIG_FLAG_RCV_BM);
8016b5a4:	e51b3008 	ldr	r3, [fp, #-8]
8016b5a8:	e5933008 	ldr	r3, [r3, #8]
8016b5ac:	e2033004 	and	r3, r3, #4
8016b5b0:	e3530000 	cmp	r3, #0
8016b5b4:	1a000013 	bne	8016b608 <_RME_Sig_Rcv+0x230>
8016b5b8:	e3e03006 	mvn	r3, #6
8016b5bc:	ea00008e 	b	8016b7fc <_RME_Sig_Rcv+0x424>
        }
        case RME_RCV_NS:
        {
            RME_COV_MARKER();
            
            RME_CAP_CHECK(Sig_Op,RME_SIG_FLAG_RCV_NS);
8016b5c0:	e51b3008 	ldr	r3, [fp, #-8]
8016b5c4:	e5933008 	ldr	r3, [r3, #8]
8016b5c8:	e2033008 	and	r3, r3, #8
8016b5cc:	e3530000 	cmp	r3, #0
8016b5d0:	1a00000e 	bne	8016b610 <_RME_Sig_Rcv+0x238>
8016b5d4:	e3e03006 	mvn	r3, #6
8016b5d8:	ea000087 	b	8016b7fc <_RME_Sig_Rcv+0x424>
        }
        case RME_RCV_NM:
        {
            RME_COV_MARKER();
            
            RME_CAP_CHECK(Sig_Op,RME_SIG_FLAG_RCV_NM);
8016b5dc:	e51b3008 	ldr	r3, [fp, #-8]
8016b5e0:	e5933008 	ldr	r3, [r3, #8]
8016b5e4:	e2033010 	and	r3, r3, #16
8016b5e8:	e3530000 	cmp	r3, #0
8016b5ec:	1a000009 	bne	8016b618 <_RME_Sig_Rcv+0x240>
8016b5f0:	e3e03006 	mvn	r3, #6
8016b5f4:	ea000080 	b	8016b7fc <_RME_Sig_Rcv+0x424>
        }
        default:
        {
            RME_COV_MARKER();
            
            return RME_ERR_SIV_ACT;
8016b5f8:	e3e03f4b 	mvn	r3, #300	@ 0x12c
8016b5fc:	ea00007e 	b	8016b7fc <_RME_Sig_Rcv+0x424>
            break;
8016b600:	e320f000 	nop	{0}
8016b604:	ea000004 	b	8016b61c <_RME_Sig_Rcv+0x244>
            break;
8016b608:	e320f000 	nop	{0}
8016b60c:	ea000002 	b	8016b61c <_RME_Sig_Rcv+0x244>
            break;
8016b610:	e320f000 	nop	{0}
8016b614:	ea000000 	b	8016b61c <_RME_Sig_Rcv+0x244>
            break;
8016b618:	e320f000 	nop	{0}
        }
    }
    
    /* Convert to root cap */
    Sig_Root=RME_CAP_CONV_ROOT(Sig_Op,struct RME_Cap_Sig*);
8016b61c:	e51b3008 	ldr	r3, [fp, #-8]
8016b620:	e5933000 	ldr	r3, [r3]
8016b624:	e6ff3073 	uxth	r3, r3
8016b628:	e3530000 	cmp	r3, #0
8016b62c:	0a000002 	beq	8016b63c <_RME_Sig_Rcv+0x264>
8016b630:	e51b3008 	ldr	r3, [fp, #-8]
8016b634:	e5933004 	ldr	r3, [r3, #4]
8016b638:	ea000000 	b	8016b640 <_RME_Sig_Rcv+0x268>
8016b63c:	e51b3008 	ldr	r3, [fp, #-8]
8016b640:	e50b3010 	str	r3, [fp, #-16]
    
    /* See if we can receive on that endpoint - if someone blocks on it, we 
     * must wait for it to unblock before we can proceed. */
    if(Sig_Root->Thd!=RME_NULL)
8016b644:	e51b3010 	ldr	r3, [fp, #-16]
8016b648:	e5933018 	ldr	r3, [r3, #24]
8016b64c:	e3530000 	cmp	r3, #0
8016b650:	0a000001 	beq	8016b65c <_RME_Sig_Rcv+0x284>
    {
        RME_COV_MARKER();

        return RME_ERR_SIV_ACT;
8016b654:	e3e03f4b 	mvn	r3, #300	@ 0x12c
8016b658:	ea000067 	b	8016b7fc <_RME_Sig_Rcv+0x424>
    {
        RME_COV_MARKER();
        /* No action required */
    }
    
    Local=RME_CPU_LOCAL();
8016b65c:	e3003004 	movw	r3, #4
8016b660:	e3483017 	movt	r3, #32791	@ 0x8017
8016b664:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    Thd_Cur=Local->Thd_Cur;
8016b668:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016b66c:	e5933004 	ldr	r3, [r3, #4]
8016b670:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
    
    /* Check if we trying to let a boot-time thread block on a signal, which is
     * disallowed. Additionally, if the current thread have no timeslice left
     * (which shouldn't happen under any circumstances), we assert and die. */
    RME_ASSERT(Thd_Cur->Sched.Slice!=0U);
8016b674:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b678:	e5933018 	ldr	r3, [r3, #24]
8016b67c:	e3530000 	cmp	r3, #0
8016b680:	1a000008 	bne	8016b6a8 <_RME_Sig_Rcv+0x2d0>
8016b684:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
8016b688:	e3483016 	movt	r3, #32790	@ 0x8016
8016b68c:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
8016b690:	e3482016 	movt	r2, #32790	@ 0x8016
8016b694:	e3011cd3 	movw	r1, #7379	@ 0x1cd3
8016b698:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
8016b69c:	e3480016 	movt	r0, #32790	@ 0x8016
8016b6a0:	ebffd53a 	bl	80160b90 <RME_Log>
8016b6a4:	eafffffe 	b	8016b6a4 <_RME_Sig_Rcv+0x2cc>
    if(Thd_Cur->Sched.Slice==RME_THD_INIT_TIME)
8016b6a8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b6ac:	e5933018 	ldr	r3, [r3, #24]
8016b6b0:	e3730106 	cmn	r3, #-2147483647	@ 0x80000001
8016b6b4:	1a000002 	bne	8016b6c4 <_RME_Sig_Rcv+0x2ec>
    {
        RME_COV_MARKER();

        return RME_ERR_SIV_BOOT;
8016b6b8:	e30f3ecd 	movw	r3, #65229	@ 0xfecd
8016b6bc:	e34f3fff 	movt	r3, #65535	@ 0xffff
8016b6c0:	ea00004d 	b	8016b7fc <_RME_Sig_Rcv+0x424>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Check if there are signals available */
    Old_Value=Sig_Root->Sig_Num;
8016b6c4:	e51b3010 	ldr	r3, [fp, #-16]
8016b6c8:	e5933014 	ldr	r3, [r3, #20]
8016b6cc:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    if(Old_Value>0U)
8016b6d0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016b6d4:	e3530000 	cmp	r3, #0
8016b6d8:	0a000026 	beq	8016b778 <_RME_Sig_Rcv+0x3a0>
    {
        RME_COV_MARKER();

        /* Can't use faa, other cores may reduce count to zero in the meantime */
        if((Option==RME_RCV_BS)||(Option==RME_RCV_NS))
8016b6dc:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016b6e0:	e3530000 	cmp	r3, #0
8016b6e4:	0a000002 	beq	8016b6f4 <_RME_Sig_Rcv+0x31c>
8016b6e8:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016b6ec:	e3530002 	cmp	r3, #2
8016b6f0:	1a00000f 	bne	8016b734 <_RME_Sig_Rcv+0x35c>
        {
            RME_COV_MARKER();

            /* Try to take one */
            if(RME_COMP_SWAP(&(Sig_Root->Sig_Num),
8016b6f4:	e51b3010 	ldr	r3, [fp, #-16]
8016b6f8:	e2830014 	add	r0, r3, #20
8016b6fc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016b700:	e2433001 	sub	r3, r3, #1
8016b704:	e1a02003 	mov	r2, r3
8016b708:	e51b101c 	ldr	r1, [fp, #-28]	@ 0xffffffe4
8016b70c:	ebffd52a 	bl	80160bbc <_RME_Comp_Swap_Single>
8016b710:	e1a03000 	mov	r3, r0
8016b714:	e3530000 	cmp	r3, #0
8016b718:	1a000001 	bne	8016b724 <_RME_Sig_Rcv+0x34c>
                             Old_Value,
                             Old_Value-1U)==RME_CASFAIL)
            {
                RME_COV_MARKER();

                return RME_ERR_SIV_CONFLICT;
8016b71c:	e3e03e13 	mvn	r3, #304	@ 0x130
8016b720:	ea000035 	b	8016b7fc <_RME_Sig_Rcv+0x424>
                RME_COV_MARKER();
                /* No action required */
            }
            
            /* We have taken it, now return what we have taken */
            __RME_Svc_Retval_Set(Reg,1);
8016b724:	e3a01001 	mov	r1, #1
8016b728:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
8016b72c:	eb00086b 	bl	8016d8e0 <__RME_Svc_Retval_Set>
8016b730:	ea00000e 	b	8016b770 <_RME_Sig_Rcv+0x398>
        else
        {
            RME_COV_MARKER();

            /* Try to take all */
            if(RME_COMP_SWAP(&(Sig_Root->Sig_Num),
8016b734:	e51b3010 	ldr	r3, [fp, #-16]
8016b738:	e2833014 	add	r3, r3, #20
8016b73c:	e3a02000 	mov	r2, #0
8016b740:	e51b101c 	ldr	r1, [fp, #-28]	@ 0xffffffe4
8016b744:	e1a00003 	mov	r0, r3
8016b748:	ebffd51b 	bl	80160bbc <_RME_Comp_Swap_Single>
8016b74c:	e1a03000 	mov	r3, r0
8016b750:	e3530000 	cmp	r3, #0
8016b754:	1a000001 	bne	8016b760 <_RME_Sig_Rcv+0x388>
                             Old_Value,
                             0U)==RME_CASFAIL)
            {
                RME_COV_MARKER();

                return RME_ERR_SIV_CONFLICT;
8016b758:	e3e03e13 	mvn	r3, #304	@ 0x130
8016b75c:	ea000026 	b	8016b7fc <_RME_Sig_Rcv+0x424>
                RME_COV_MARKER();
                /* No action required */
            }
            
            /* We have taken all, now return what we have taken */
            __RME_Svc_Retval_Set(Reg,(rme_ret_t)Old_Value);
8016b760:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016b764:	e1a01003 	mov	r1, r3
8016b768:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
8016b76c:	eb00085b 	bl	8016d8e0 <__RME_Svc_Retval_Set>
        }
        
        return 0;
8016b770:	e3a03000 	mov	r3, #0
8016b774:	ea000020 	b	8016b7fc <_RME_Sig_Rcv+0x424>
    else
    {
        RME_COV_MARKER();

        /* There's no value, try to block */
        if((Option==RME_RCV_BS)||(Option==RME_RCV_BM))
8016b778:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016b77c:	e3530000 	cmp	r3, #0
8016b780:	0a000002 	beq	8016b790 <_RME_Sig_Rcv+0x3b8>
8016b784:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016b788:	e3530001 	cmp	r3, #1
8016b78c:	1a000016 	bne	8016b7ec <_RME_Sig_Rcv+0x414>
        {
            RME_COV_MARKER();

            if(RME_COMP_SWAP((rme_ptr_t*)&(Sig_Root->Thd),
8016b790:	e51b3010 	ldr	r3, [fp, #-16]
8016b794:	e2833018 	add	r3, r3, #24
8016b798:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016b79c:	e3a01000 	mov	r1, #0
8016b7a0:	e1a00003 	mov	r0, r3
8016b7a4:	ebffd504 	bl	80160bbc <_RME_Comp_Swap_Single>
8016b7a8:	e1a03000 	mov	r3, r0
8016b7ac:	e3530000 	cmp	r3, #0
8016b7b0:	1a000001 	bne	8016b7bc <_RME_Sig_Rcv+0x3e4>
                             RME_NULL,
                             (rme_ptr_t)Thd_Cur)==RME_CASFAIL)
            {
                RME_COV_MARKER();

                return RME_ERR_SIV_CONFLICT;
8016b7b4:	e3e03e13 	mvn	r3, #304	@ 0x130
8016b7b8:	ea00000f 	b	8016b7fc <_RME_Sig_Rcv+0x424>
            /* Now we block our current thread. No need to set any return value
             * to the register set here, because we do not yet know how many
             * signals will be there when the thread unblocks. The unblocking
             * does not need an option so we don't keep that; we always treat
             * it as single receive when we unblock anyway. */
            Thd_Cur->Sched.Signal=Sig_Root;
8016b7bc:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b7c0:	e51b2010 	ldr	r2, [fp, #-16]
8016b7c4:	e5832028 	str	r2, [r3, #40]	@ 0x28
            Thd_Cur->Sched.State=RME_THD_BLOCKED;
8016b7c8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016b7cc:	e3a02001 	mov	r2, #1
8016b7d0:	e583201c 	str	r2, [r3, #28]
            _RME_Run_Del(Thd_Cur);
8016b7d4:	e51b0018 	ldr	r0, [fp, #-24]	@ 0xffffffe8
8016b7d8:	ebffe86c 	bl	80165990 <_RME_Run_Del>
            
            /* Pick the highest priority thread to run */
            _RME_Kern_High(Reg,Local);
8016b7dc:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
8016b7e0:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
8016b7e4:	ebfffdb1 	bl	8016aeb0 <_RME_Kern_High>
8016b7e8:	ea000002 	b	8016b7f8 <_RME_Sig_Rcv+0x420>
        else
        {
            RME_COV_MARKER();

            /* We have taken nothing but the system call is successful anyway */
            __RME_Svc_Retval_Set(Reg,0);
8016b7ec:	e3a01000 	mov	r1, #0
8016b7f0:	e51b0024 	ldr	r0, [fp, #-36]	@ 0xffffffdc
8016b7f4:	eb000839 	bl	8016d8e0 <__RME_Svc_Retval_Set>
        }
    }
    
    return 0;
8016b7f8:	e3a03000 	mov	r3, #0
}
8016b7fc:	e1a00003 	mov	r0, r3
8016b800:	e24bd004 	sub	sp, fp, #4
8016b804:	e8bd8800 	pop	{fp, pc}
8016b808:	8016ea68 	.word	0x8016ea68

8016b80c <_RME_Inv_Crt>:
                              rme_cid_t Cap_Cpt,
                              rme_cid_t Cap_Kom,
                              rme_cid_t Cap_Inv,
                              rme_cid_t Cap_Prc,
                              rme_ptr_t Raddr)
{
8016b80c:	e92d4800 	push	{fp, lr}
8016b810:	e28db004 	add	fp, sp, #4
8016b814:	e24dd030 	sub	sp, sp, #48	@ 0x30
8016b818:	e50b0028 	str	r0, [fp, #-40]	@ 0xffffffd8
8016b81c:	e50b102c 	str	r1, [fp, #-44]	@ 0xffffffd4
8016b820:	e50b2030 	str	r2, [fp, #-48]	@ 0xffffffd0
8016b824:	e50b3034 	str	r3, [fp, #-52]	@ 0xffffffcc
    struct RME_Inv_Struct* Invocation;
    rme_ptr_t Type_Stat;
    rme_ptr_t Vaddr;
    
    /* Get the capability slots */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
8016b828:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016b82c:	e2033080 	and	r3, r3, #128	@ 0x80
8016b830:	e3530000 	cmp	r3, #0
8016b834:	1a00001c 	bne	8016b8ac <_RME_Inv_Crt+0xa0>
8016b838:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b83c:	e5932014 	ldr	r2, [r3, #20]
8016b840:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016b844:	e1520003 	cmp	r2, r3
8016b848:	8a000001 	bhi	8016b854 <_RME_Inv_Crt+0x48>
8016b84c:	e3e03002 	mvn	r3, #2
8016b850:	ea000195 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016b854:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016b858:	e1a02283 	lsl	r2, r3, #5
8016b85c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b860:	e593300c 	ldr	r3, [r3, #12]
8016b864:	e0823003 	add	r3, r2, r3
8016b868:	e50b3008 	str	r3, [fp, #-8]
8016b86c:	e51b3008 	ldr	r3, [fp, #-8]
8016b870:	e1a00003 	mov	r0, r3
8016b874:	ebffd3a1 	bl	80160700 <__RME_A7A_Read_Acquire>
8016b878:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016b87c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016b880:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016b884:	e3530802 	cmp	r3, #131072	@ 0x20000
8016b888:	1a000001 	bne	8016b894 <_RME_Inv_Crt+0x88>
8016b88c:	e3e03008 	mvn	r3, #8
8016b890:	ea000185 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016b894:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016b898:	e1a03c23 	lsr	r3, r3, #24
8016b89c:	e3530003 	cmp	r3, #3
8016b8a0:	0a00003f 	beq	8016b9a4 <_RME_Inv_Crt+0x198>
8016b8a4:	e3e03001 	mvn	r3, #1
8016b8a8:	ea00017f 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016b8ac:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016b8b0:	e1a02423 	lsr	r2, r3, #8
8016b8b4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b8b8:	e5933014 	ldr	r3, [r3, #20]
8016b8bc:	e1520003 	cmp	r2, r3
8016b8c0:	3a000001 	bcc	8016b8cc <_RME_Inv_Crt+0xc0>
8016b8c4:	e3e03002 	mvn	r3, #2
8016b8c8:	ea000177 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016b8cc:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016b8d0:	e1a03423 	lsr	r3, r3, #8
8016b8d4:	e1a02283 	lsl	r2, r3, #5
8016b8d8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b8dc:	e593300c 	ldr	r3, [r3, #12]
8016b8e0:	e0823003 	add	r3, r2, r3
8016b8e4:	e50b3008 	str	r3, [fp, #-8]
8016b8e8:	e51b3008 	ldr	r3, [fp, #-8]
8016b8ec:	e1a00003 	mov	r0, r3
8016b8f0:	ebffd382 	bl	80160700 <__RME_A7A_Read_Acquire>
8016b8f4:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016b8f8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016b8fc:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016b900:	e3530802 	cmp	r3, #131072	@ 0x20000
8016b904:	1a000001 	bne	8016b910 <_RME_Inv_Crt+0x104>
8016b908:	e3e03008 	mvn	r3, #8
8016b90c:	ea000166 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016b910:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016b914:	e1a03c23 	lsr	r3, r3, #24
8016b918:	e3530003 	cmp	r3, #3
8016b91c:	0a000001 	beq	8016b928 <_RME_Inv_Crt+0x11c>
8016b920:	e3e03001 	mvn	r3, #1
8016b924:	ea000160 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016b928:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016b92c:	e203207f 	and	r2, r3, #127	@ 0x7f
8016b930:	e51b3008 	ldr	r3, [fp, #-8]
8016b934:	e5933014 	ldr	r3, [r3, #20]
8016b938:	e1520003 	cmp	r2, r3
8016b93c:	3a000001 	bcc	8016b948 <_RME_Inv_Crt+0x13c>
8016b940:	e3e03002 	mvn	r3, #2
8016b944:	ea000158 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016b948:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016b94c:	e203307f 	and	r3, r3, #127	@ 0x7f
8016b950:	e1a02283 	lsl	r2, r3, #5
8016b954:	e51b3008 	ldr	r3, [fp, #-8]
8016b958:	e593300c 	ldr	r3, [r3, #12]
8016b95c:	e0823003 	add	r3, r2, r3
8016b960:	e50b3008 	str	r3, [fp, #-8]
8016b964:	e51b3008 	ldr	r3, [fp, #-8]
8016b968:	e1a00003 	mov	r0, r3
8016b96c:	ebffd363 	bl	80160700 <__RME_A7A_Read_Acquire>
8016b970:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016b974:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016b978:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016b97c:	e3530802 	cmp	r3, #131072	@ 0x20000
8016b980:	1a000001 	bne	8016b98c <_RME_Inv_Crt+0x180>
8016b984:	e3e03008 	mvn	r3, #8
8016b988:	ea000147 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016b98c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016b990:	e1a03c23 	lsr	r3, r3, #24
8016b994:	e3530003 	cmp	r3, #3
8016b998:	0a000001 	beq	8016b9a4 <_RME_Inv_Crt+0x198>
8016b99c:	e3e03001 	mvn	r3, #1
8016b9a0:	ea000141 	b	8016beac <_RME_Inv_Crt+0x6a0>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Prc,RME_CAP_TYPE_PRC,
8016b9a4:	e59b3004 	ldr	r3, [fp, #4]
8016b9a8:	e2033080 	and	r3, r3, #128	@ 0x80
8016b9ac:	e3530000 	cmp	r3, #0
8016b9b0:	1a00001c 	bne	8016ba28 <_RME_Inv_Crt+0x21c>
8016b9b4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b9b8:	e5932014 	ldr	r2, [r3, #20]
8016b9bc:	e59b3004 	ldr	r3, [fp, #4]
8016b9c0:	e1520003 	cmp	r2, r3
8016b9c4:	8a000001 	bhi	8016b9d0 <_RME_Inv_Crt+0x1c4>
8016b9c8:	e3e03002 	mvn	r3, #2
8016b9cc:	ea000136 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016b9d0:	e59b3004 	ldr	r3, [fp, #4]
8016b9d4:	e1a02283 	lsl	r2, r3, #5
8016b9d8:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016b9dc:	e593300c 	ldr	r3, [r3, #12]
8016b9e0:	e0823003 	add	r3, r2, r3
8016b9e4:	e50b300c 	str	r3, [fp, #-12]
8016b9e8:	e51b300c 	ldr	r3, [fp, #-12]
8016b9ec:	e1a00003 	mov	r0, r3
8016b9f0:	ebffd342 	bl	80160700 <__RME_A7A_Read_Acquire>
8016b9f4:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016b9f8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016b9fc:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016ba00:	e3530802 	cmp	r3, #131072	@ 0x20000
8016ba04:	1a000001 	bne	8016ba10 <_RME_Inv_Crt+0x204>
8016ba08:	e3e03008 	mvn	r3, #8
8016ba0c:	ea000126 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016ba10:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016ba14:	e1a03c23 	lsr	r3, r3, #24
8016ba18:	e3530005 	cmp	r3, #5
8016ba1c:	0a00003f 	beq	8016bb20 <_RME_Inv_Crt+0x314>
8016ba20:	e3e03001 	mvn	r3, #1
8016ba24:	ea000120 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016ba28:	e59b3004 	ldr	r3, [fp, #4]
8016ba2c:	e1a02423 	lsr	r2, r3, #8
8016ba30:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016ba34:	e5933014 	ldr	r3, [r3, #20]
8016ba38:	e1520003 	cmp	r2, r3
8016ba3c:	3a000001 	bcc	8016ba48 <_RME_Inv_Crt+0x23c>
8016ba40:	e3e03002 	mvn	r3, #2
8016ba44:	ea000118 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016ba48:	e59b3004 	ldr	r3, [fp, #4]
8016ba4c:	e1a03423 	lsr	r3, r3, #8
8016ba50:	e1a02283 	lsl	r2, r3, #5
8016ba54:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016ba58:	e593300c 	ldr	r3, [r3, #12]
8016ba5c:	e0823003 	add	r3, r2, r3
8016ba60:	e50b300c 	str	r3, [fp, #-12]
8016ba64:	e51b300c 	ldr	r3, [fp, #-12]
8016ba68:	e1a00003 	mov	r0, r3
8016ba6c:	ebffd323 	bl	80160700 <__RME_A7A_Read_Acquire>
8016ba70:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016ba74:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016ba78:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016ba7c:	e3530802 	cmp	r3, #131072	@ 0x20000
8016ba80:	1a000001 	bne	8016ba8c <_RME_Inv_Crt+0x280>
8016ba84:	e3e03008 	mvn	r3, #8
8016ba88:	ea000107 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016ba8c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016ba90:	e1a03c23 	lsr	r3, r3, #24
8016ba94:	e3530003 	cmp	r3, #3
8016ba98:	0a000001 	beq	8016baa4 <_RME_Inv_Crt+0x298>
8016ba9c:	e3e03001 	mvn	r3, #1
8016baa0:	ea000101 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016baa4:	e59b3004 	ldr	r3, [fp, #4]
8016baa8:	e203207f 	and	r2, r3, #127	@ 0x7f
8016baac:	e51b300c 	ldr	r3, [fp, #-12]
8016bab0:	e5933014 	ldr	r3, [r3, #20]
8016bab4:	e1520003 	cmp	r2, r3
8016bab8:	3a000001 	bcc	8016bac4 <_RME_Inv_Crt+0x2b8>
8016babc:	e3e03002 	mvn	r3, #2
8016bac0:	ea0000f9 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bac4:	e59b3004 	ldr	r3, [fp, #4]
8016bac8:	e203307f 	and	r3, r3, #127	@ 0x7f
8016bacc:	e1a02283 	lsl	r2, r3, #5
8016bad0:	e51b300c 	ldr	r3, [fp, #-12]
8016bad4:	e593300c 	ldr	r3, [r3, #12]
8016bad8:	e0823003 	add	r3, r2, r3
8016badc:	e50b300c 	str	r3, [fp, #-12]
8016bae0:	e51b300c 	ldr	r3, [fp, #-12]
8016bae4:	e1a00003 	mov	r0, r3
8016bae8:	ebffd304 	bl	80160700 <__RME_A7A_Read_Acquire>
8016baec:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016baf0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016baf4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016baf8:	e3530802 	cmp	r3, #131072	@ 0x20000
8016bafc:	1a000001 	bne	8016bb08 <_RME_Inv_Crt+0x2fc>
8016bb00:	e3e03008 	mvn	r3, #8
8016bb04:	ea0000e8 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bb08:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016bb0c:	e1a03c23 	lsr	r3, r3, #24
8016bb10:	e3530005 	cmp	r3, #5
8016bb14:	0a000001 	beq	8016bb20 <_RME_Inv_Crt+0x314>
8016bb18:	e3e03001 	mvn	r3, #1
8016bb1c:	ea0000e2 	b	8016beac <_RME_Inv_Crt+0x6a0>
                   struct RME_Cap_Prc*,Prc_Op,Type_Stat);
    RME_CPT_GETCAP(Cpt,Cap_Kom,RME_CAP_TYPE_KOM,
8016bb20:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016bb24:	e2033080 	and	r3, r3, #128	@ 0x80
8016bb28:	e3530000 	cmp	r3, #0
8016bb2c:	1a00001c 	bne	8016bba4 <_RME_Inv_Crt+0x398>
8016bb30:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016bb34:	e5932014 	ldr	r2, [r3, #20]
8016bb38:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016bb3c:	e1520003 	cmp	r2, r3
8016bb40:	8a000001 	bhi	8016bb4c <_RME_Inv_Crt+0x340>
8016bb44:	e3e03002 	mvn	r3, #2
8016bb48:	ea0000d7 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bb4c:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016bb50:	e1a02283 	lsl	r2, r3, #5
8016bb54:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016bb58:	e593300c 	ldr	r3, [r3, #12]
8016bb5c:	e0823003 	add	r3, r2, r3
8016bb60:	e50b3010 	str	r3, [fp, #-16]
8016bb64:	e51b3010 	ldr	r3, [fp, #-16]
8016bb68:	e1a00003 	mov	r0, r3
8016bb6c:	ebffd2e3 	bl	80160700 <__RME_A7A_Read_Acquire>
8016bb70:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016bb74:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016bb78:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016bb7c:	e3530802 	cmp	r3, #131072	@ 0x20000
8016bb80:	1a000001 	bne	8016bb8c <_RME_Inv_Crt+0x380>
8016bb84:	e3e03008 	mvn	r3, #8
8016bb88:	ea0000c7 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bb8c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016bb90:	e1a03c23 	lsr	r3, r3, #24
8016bb94:	e3530002 	cmp	r3, #2
8016bb98:	0a00003f 	beq	8016bc9c <_RME_Inv_Crt+0x490>
8016bb9c:	e3e03001 	mvn	r3, #1
8016bba0:	ea0000c1 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bba4:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016bba8:	e1a02423 	lsr	r2, r3, #8
8016bbac:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016bbb0:	e5933014 	ldr	r3, [r3, #20]
8016bbb4:	e1520003 	cmp	r2, r3
8016bbb8:	3a000001 	bcc	8016bbc4 <_RME_Inv_Crt+0x3b8>
8016bbbc:	e3e03002 	mvn	r3, #2
8016bbc0:	ea0000b9 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bbc4:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016bbc8:	e1a03423 	lsr	r3, r3, #8
8016bbcc:	e1a02283 	lsl	r2, r3, #5
8016bbd0:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016bbd4:	e593300c 	ldr	r3, [r3, #12]
8016bbd8:	e0823003 	add	r3, r2, r3
8016bbdc:	e50b3010 	str	r3, [fp, #-16]
8016bbe0:	e51b3010 	ldr	r3, [fp, #-16]
8016bbe4:	e1a00003 	mov	r0, r3
8016bbe8:	ebffd2c4 	bl	80160700 <__RME_A7A_Read_Acquire>
8016bbec:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016bbf0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016bbf4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016bbf8:	e3530802 	cmp	r3, #131072	@ 0x20000
8016bbfc:	1a000001 	bne	8016bc08 <_RME_Inv_Crt+0x3fc>
8016bc00:	e3e03008 	mvn	r3, #8
8016bc04:	ea0000a8 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bc08:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016bc0c:	e1a03c23 	lsr	r3, r3, #24
8016bc10:	e3530003 	cmp	r3, #3
8016bc14:	0a000001 	beq	8016bc20 <_RME_Inv_Crt+0x414>
8016bc18:	e3e03001 	mvn	r3, #1
8016bc1c:	ea0000a2 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bc20:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016bc24:	e203207f 	and	r2, r3, #127	@ 0x7f
8016bc28:	e51b3010 	ldr	r3, [fp, #-16]
8016bc2c:	e5933014 	ldr	r3, [r3, #20]
8016bc30:	e1520003 	cmp	r2, r3
8016bc34:	3a000001 	bcc	8016bc40 <_RME_Inv_Crt+0x434>
8016bc38:	e3e03002 	mvn	r3, #2
8016bc3c:	ea00009a 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bc40:	e51b3030 	ldr	r3, [fp, #-48]	@ 0xffffffd0
8016bc44:	e203307f 	and	r3, r3, #127	@ 0x7f
8016bc48:	e1a02283 	lsl	r2, r3, #5
8016bc4c:	e51b3010 	ldr	r3, [fp, #-16]
8016bc50:	e593300c 	ldr	r3, [r3, #12]
8016bc54:	e0823003 	add	r3, r2, r3
8016bc58:	e50b3010 	str	r3, [fp, #-16]
8016bc5c:	e51b3010 	ldr	r3, [fp, #-16]
8016bc60:	e1a00003 	mov	r0, r3
8016bc64:	ebffd2a5 	bl	80160700 <__RME_A7A_Read_Acquire>
8016bc68:	e50b0014 	str	r0, [fp, #-20]	@ 0xffffffec
8016bc6c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016bc70:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016bc74:	e3530802 	cmp	r3, #131072	@ 0x20000
8016bc78:	1a000001 	bne	8016bc84 <_RME_Inv_Crt+0x478>
8016bc7c:	e3e03008 	mvn	r3, #8
8016bc80:	ea000089 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bc84:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016bc88:	e1a03c23 	lsr	r3, r3, #24
8016bc8c:	e3530002 	cmp	r3, #2
8016bc90:	0a000001 	beq	8016bc9c <_RME_Inv_Crt+0x490>
8016bc94:	e3e03001 	mvn	r3, #1
8016bc98:	ea000083 	b	8016beac <_RME_Inv_Crt+0x6a0>
                   struct RME_Cap_Kom*,Kom_Op,Type_Stat);
    /* Check if the captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_CRT);
8016bc9c:	e51b3008 	ldr	r3, [fp, #-8]
8016bca0:	e5933008 	ldr	r3, [r3, #8]
8016bca4:	e2033001 	and	r3, r3, #1
8016bca8:	e3530000 	cmp	r3, #0
8016bcac:	1a000001 	bne	8016bcb8 <_RME_Inv_Crt+0x4ac>
8016bcb0:	e3e03006 	mvn	r3, #6
8016bcb4:	ea00007c 	b	8016beac <_RME_Inv_Crt+0x6a0>
    RME_CAP_CHECK(Prc_Op,RME_PRC_FLAG_INV);
8016bcb8:	e51b300c 	ldr	r3, [fp, #-12]
8016bcbc:	e5933008 	ldr	r3, [r3, #8]
8016bcc0:	e2033001 	and	r3, r3, #1
8016bcc4:	e3530000 	cmp	r3, #0
8016bcc8:	1a000001 	bne	8016bcd4 <_RME_Inv_Crt+0x4c8>
8016bccc:	e3e03006 	mvn	r3, #6
8016bcd0:	ea000075 	b	8016beac <_RME_Inv_Crt+0x6a0>
    /* See if the creation is valid for this kmem range */
    RME_KOM_CHECK(Kom_Op,RME_KOM_FLAG_INV,Raddr,Vaddr,RME_INV_SIZE);
8016bcd4:	e51b3010 	ldr	r3, [fp, #-16]
8016bcd8:	e5933008 	ldr	r3, [r3, #8]
8016bcdc:	e2033008 	and	r3, r3, #8
8016bce0:	e3530000 	cmp	r3, #0
8016bce4:	1a000001 	bne	8016bcf0 <_RME_Inv_Crt+0x4e4>
8016bce8:	e3e03006 	mvn	r3, #6
8016bcec:	ea00006e 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bcf0:	e51b3010 	ldr	r3, [fp, #-16]
8016bcf4:	e5933014 	ldr	r3, [r3, #20]
8016bcf8:	e59b2008 	ldr	r2, [fp, #8]
8016bcfc:	e0823003 	add	r3, r2, r3
8016bd00:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
8016bd04:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016bd08:	e59b3008 	ldr	r3, [fp, #8]
8016bd0c:	e1520003 	cmp	r2, r3
8016bd10:	2a000001 	bcs	8016bd1c <_RME_Inv_Crt+0x510>
8016bd14:	e3e03006 	mvn	r3, #6
8016bd18:	ea000063 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bd1c:	e51b3010 	ldr	r3, [fp, #-16]
8016bd20:	e5933014 	ldr	r3, [r3, #20]
8016bd24:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016bd28:	e1520003 	cmp	r2, r3
8016bd2c:	2a000001 	bcs	8016bd38 <_RME_Inv_Crt+0x52c>
8016bd30:	e3e03006 	mvn	r3, #6
8016bd34:	ea00005c 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bd38:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016bd3c:	e3730025 	cmn	r3, #37	@ 0x25
8016bd40:	9a000001 	bls	8016bd4c <_RME_Inv_Crt+0x540>
8016bd44:	e3e03006 	mvn	r3, #6
8016bd48:	ea000057 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bd4c:	e51b3010 	ldr	r3, [fp, #-16]
8016bd50:	e5932018 	ldr	r2, [r3, #24]
8016bd54:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016bd58:	e2833023 	add	r3, r3, #35	@ 0x23
8016bd5c:	e1520003 	cmp	r2, r3
8016bd60:	2a000001 	bcs	8016bd6c <_RME_Inv_Crt+0x560>
8016bd64:	e3e03006 	mvn	r3, #6
8016bd68:	ea00004f 	b	8016beac <_RME_Inv_Crt+0x6a0>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Inv,struct RME_Cap_Inv*,Inv_Crt);
8016bd6c:	e51b3008 	ldr	r3, [fp, #-8]
8016bd70:	e5932014 	ldr	r2, [r3, #20]
8016bd74:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
8016bd78:	e1520003 	cmp	r2, r3
8016bd7c:	8a000001 	bhi	8016bd88 <_RME_Inv_Crt+0x57c>
8016bd80:	e3e03002 	mvn	r3, #2
8016bd84:	ea000048 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bd88:	e51b3034 	ldr	r3, [fp, #-52]	@ 0xffffffcc
8016bd8c:	e1a02283 	lsl	r2, r3, #5
8016bd90:	e51b3008 	ldr	r3, [fp, #-8]
8016bd94:	e593300c 	ldr	r3, [r3, #12]
8016bd98:	e0823003 	add	r3, r2, r3
8016bd9c:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Inv_Crt);
8016bda0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016bda4:	e3a02801 	mov	r2, #65536	@ 0x10000
8016bda8:	e3a01000 	mov	r1, #0
8016bdac:	e1a00003 	mov	r0, r3
8016bdb0:	ebffd381 	bl	80160bbc <_RME_Comp_Swap_Single>
8016bdb4:	e1a03000 	mov	r3, r0
8016bdb8:	e3530000 	cmp	r3, #0
8016bdbc:	1a000001 	bne	8016bdc8 <_RME_Inv_Crt+0x5bc>
8016bdc0:	e3e03004 	mvn	r3, #4
8016bdc4:	ea000038 	b	8016beac <_RME_Inv_Crt+0x6a0>
8016bdc8:	e3003000 	movw	r3, #0
8016bdcc:	e3483017 	movt	r3, #32791	@ 0x8017
8016bdd0:	e5932000 	ldr	r2, [r3]
8016bdd4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016bdd8:	e5832010 	str	r2, [r3, #16]
    
    /* Try to populate the area */
    if(_RME_Kot_Mark(Vaddr,RME_INV_SIZE)!=0)
8016bddc:	e3a01024 	mov	r1, #36	@ 0x24
8016bde0:	e51b0018 	ldr	r0, [fp, #-24]	@ 0xffffffe8
8016bde4:	ebffe464 	bl	80164f7c <_RME_Kot_Mark>
8016bde8:	e1a03000 	mov	r3, r0
8016bdec:	e3530000 	cmp	r3, #0
8016bdf0:	0a000005 	beq	8016be0c <_RME_Inv_Crt+0x600>
    {
        RME_COV_MARKER();

        RME_WRITE_RELEASE(&(Inv_Crt->Head.Type_Stat),0U);
8016bdf4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016bdf8:	e3a01000 	mov	r1, #0
8016bdfc:	e1a00003 	mov	r0, r3
8016be00:	ebffd241 	bl	8016070c <__RME_A7A_Write_Release>
        return RME_ERR_CPT_KOT;
8016be04:	e3e03003 	mvn	r3, #3
8016be08:	ea000027 	b	8016beac <_RME_Inv_Crt+0x6a0>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Object init */
    Invocation=(struct RME_Inv_Struct*)Vaddr;
8016be0c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016be10:	e50b3020 	str	r3, [fp, #-32]	@ 0xffffffe0
    Prc_Root=RME_CAP_CONV_ROOT(Prc_Op,struct RME_Cap_Prc*);
8016be14:	e51b300c 	ldr	r3, [fp, #-12]
8016be18:	e5933000 	ldr	r3, [r3]
8016be1c:	e6ff3073 	uxth	r3, r3
8016be20:	e3530000 	cmp	r3, #0
8016be24:	0a000002 	beq	8016be34 <_RME_Inv_Crt+0x628>
8016be28:	e51b300c 	ldr	r3, [fp, #-12]
8016be2c:	e5933004 	ldr	r3, [r3, #4]
8016be30:	ea000000 	b	8016be38 <_RME_Inv_Crt+0x62c>
8016be34:	e51b300c 	ldr	r3, [fp, #-12]
8016be38:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    Invocation->Prc=Prc_Root;
8016be3c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016be40:	e51b2024 	ldr	r2, [fp, #-36]	@ 0xffffffdc
8016be44:	e5832008 	str	r2, [r3, #8]
    Invocation->Thd_Act=RME_NULL;
8016be48:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016be4c:	e3a02000 	mov	r2, #0
8016be50:	e583200c 	str	r2, [r3, #12]
    /* By default we do not return on exception */
    Invocation->Is_Exc_Ret=0U;
8016be54:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016be58:	e3a02000 	mov	r2, #0
8016be5c:	e5832018 	str	r2, [r3, #24]
    
    /* Header init */
    Inv_Crt->Head.Root_Ref=0U;
8016be60:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016be64:	e3a02000 	mov	r2, #0
8016be68:	e5832004 	str	r2, [r3, #4]
    Inv_Crt->Head.Object=Vaddr;
8016be6c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016be70:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016be74:	e583200c 	str	r2, [r3, #12]
    Inv_Crt->Head.Flag=RME_INV_FLAG_ALL;
8016be78:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016be7c:	e3a02003 	mov	r2, #3
8016be80:	e5832008 	str	r2, [r3, #8]
    
    /* Reference object */
    RME_FETCH_ADD(&(Prc_Root->Head.Root_Ref),1U);
8016be84:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016be88:	e2833004 	add	r3, r3, #4
8016be8c:	e3a01001 	mov	r1, #1
8016be90:	e1a00003 	mov	r0, r3
8016be94:	ebffd35d 	bl	80160c10 <_RME_Fetch_Add_Single>
    
    /* Establish cap */
    RME_WRITE_RELEASE(&(Inv_Crt->Head.Type_Stat),
8016be98:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016be9c:	e3a01407 	mov	r1, #117440512	@ 0x7000000
8016bea0:	e1a00003 	mov	r0, r3
8016bea4:	ebffd218 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_INV,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
8016bea8:	e3a03000 	mov	r3, #0
}
8016beac:	e1a00003 	mov	r0, r3
8016beb0:	e24bd004 	sub	sp, fp, #4
8016beb4:	e8bd8800 	pop	{fp, pc}

8016beb8 <_RME_Inv_Del>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Inv_Del(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Cpt,
                              rme_cid_t Cap_Inv)
{
8016beb8:	e92d4800 	push	{fp, lr}
8016bebc:	e28db004 	add	fp, sp, #4
8016bec0:	e24dd020 	sub	sp, sp, #32
8016bec4:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
8016bec8:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
8016becc:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    rme_ptr_t Type_Stat;
    /* These are for deletion */
    struct RME_Inv_Struct* Invocation;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
8016bed0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016bed4:	e2033080 	and	r3, r3, #128	@ 0x80
8016bed8:	e3530000 	cmp	r3, #0
8016bedc:	1a00001c 	bne	8016bf54 <_RME_Inv_Del+0x9c>
8016bee0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016bee4:	e5932014 	ldr	r2, [r3, #20]
8016bee8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016beec:	e1520003 	cmp	r2, r3
8016bef0:	8a000001 	bhi	8016befc <_RME_Inv_Del+0x44>
8016bef4:	e3e03002 	mvn	r3, #2
8016bef8:	ea0000d1 	b	8016c244 <_RME_Inv_Del+0x38c>
8016befc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016bf00:	e1a02283 	lsl	r2, r3, #5
8016bf04:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016bf08:	e593300c 	ldr	r3, [r3, #12]
8016bf0c:	e0823003 	add	r3, r2, r3
8016bf10:	e50b3008 	str	r3, [fp, #-8]
8016bf14:	e51b3008 	ldr	r3, [fp, #-8]
8016bf18:	e1a00003 	mov	r0, r3
8016bf1c:	ebffd1f7 	bl	80160700 <__RME_A7A_Read_Acquire>
8016bf20:	e50b000c 	str	r0, [fp, #-12]
8016bf24:	e51b300c 	ldr	r3, [fp, #-12]
8016bf28:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016bf2c:	e3530802 	cmp	r3, #131072	@ 0x20000
8016bf30:	1a000001 	bne	8016bf3c <_RME_Inv_Del+0x84>
8016bf34:	e3e03008 	mvn	r3, #8
8016bf38:	ea0000c1 	b	8016c244 <_RME_Inv_Del+0x38c>
8016bf3c:	e51b300c 	ldr	r3, [fp, #-12]
8016bf40:	e1a03c23 	lsr	r3, r3, #24
8016bf44:	e3530003 	cmp	r3, #3
8016bf48:	0a00003f 	beq	8016c04c <_RME_Inv_Del+0x194>
8016bf4c:	e3e03001 	mvn	r3, #1
8016bf50:	ea0000bb 	b	8016c244 <_RME_Inv_Del+0x38c>
8016bf54:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016bf58:	e1a02423 	lsr	r2, r3, #8
8016bf5c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016bf60:	e5933014 	ldr	r3, [r3, #20]
8016bf64:	e1520003 	cmp	r2, r3
8016bf68:	3a000001 	bcc	8016bf74 <_RME_Inv_Del+0xbc>
8016bf6c:	e3e03002 	mvn	r3, #2
8016bf70:	ea0000b3 	b	8016c244 <_RME_Inv_Del+0x38c>
8016bf74:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016bf78:	e1a03423 	lsr	r3, r3, #8
8016bf7c:	e1a02283 	lsl	r2, r3, #5
8016bf80:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016bf84:	e593300c 	ldr	r3, [r3, #12]
8016bf88:	e0823003 	add	r3, r2, r3
8016bf8c:	e50b3008 	str	r3, [fp, #-8]
8016bf90:	e51b3008 	ldr	r3, [fp, #-8]
8016bf94:	e1a00003 	mov	r0, r3
8016bf98:	ebffd1d8 	bl	80160700 <__RME_A7A_Read_Acquire>
8016bf9c:	e50b000c 	str	r0, [fp, #-12]
8016bfa0:	e51b300c 	ldr	r3, [fp, #-12]
8016bfa4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016bfa8:	e3530802 	cmp	r3, #131072	@ 0x20000
8016bfac:	1a000001 	bne	8016bfb8 <_RME_Inv_Del+0x100>
8016bfb0:	e3e03008 	mvn	r3, #8
8016bfb4:	ea0000a2 	b	8016c244 <_RME_Inv_Del+0x38c>
8016bfb8:	e51b300c 	ldr	r3, [fp, #-12]
8016bfbc:	e1a03c23 	lsr	r3, r3, #24
8016bfc0:	e3530003 	cmp	r3, #3
8016bfc4:	0a000001 	beq	8016bfd0 <_RME_Inv_Del+0x118>
8016bfc8:	e3e03001 	mvn	r3, #1
8016bfcc:	ea00009c 	b	8016c244 <_RME_Inv_Del+0x38c>
8016bfd0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016bfd4:	e203207f 	and	r2, r3, #127	@ 0x7f
8016bfd8:	e51b3008 	ldr	r3, [fp, #-8]
8016bfdc:	e5933014 	ldr	r3, [r3, #20]
8016bfe0:	e1520003 	cmp	r2, r3
8016bfe4:	3a000001 	bcc	8016bff0 <_RME_Inv_Del+0x138>
8016bfe8:	e3e03002 	mvn	r3, #2
8016bfec:	ea000094 	b	8016c244 <_RME_Inv_Del+0x38c>
8016bff0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016bff4:	e203307f 	and	r3, r3, #127	@ 0x7f
8016bff8:	e1a02283 	lsl	r2, r3, #5
8016bffc:	e51b3008 	ldr	r3, [fp, #-8]
8016c000:	e593300c 	ldr	r3, [r3, #12]
8016c004:	e0823003 	add	r3, r2, r3
8016c008:	e50b3008 	str	r3, [fp, #-8]
8016c00c:	e51b3008 	ldr	r3, [fp, #-8]
8016c010:	e1a00003 	mov	r0, r3
8016c014:	ebffd1b9 	bl	80160700 <__RME_A7A_Read_Acquire>
8016c018:	e50b000c 	str	r0, [fp, #-12]
8016c01c:	e51b300c 	ldr	r3, [fp, #-12]
8016c020:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016c024:	e3530802 	cmp	r3, #131072	@ 0x20000
8016c028:	1a000001 	bne	8016c034 <_RME_Inv_Del+0x17c>
8016c02c:	e3e03008 	mvn	r3, #8
8016c030:	ea000083 	b	8016c244 <_RME_Inv_Del+0x38c>
8016c034:	e51b300c 	ldr	r3, [fp, #-12]
8016c038:	e1a03c23 	lsr	r3, r3, #24
8016c03c:	e3530003 	cmp	r3, #3
8016c040:	0a000001 	beq	8016c04c <_RME_Inv_Del+0x194>
8016c044:	e3e03001 	mvn	r3, #1
8016c048:	ea00007d 	b	8016c244 <_RME_Inv_Del+0x38c>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);    
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_DEL);
8016c04c:	e51b3008 	ldr	r3, [fp, #-8]
8016c050:	e5933008 	ldr	r3, [r3, #8]
8016c054:	e2033002 	and	r3, r3, #2
8016c058:	e3530000 	cmp	r3, #0
8016c05c:	1a000001 	bne	8016c068 <_RME_Inv_Del+0x1b0>
8016c060:	e3e03006 	mvn	r3, #6
8016c064:	ea000076 	b	8016c244 <_RME_Inv_Del+0x38c>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Inv,struct RME_Cap_Inv*,Inv_Del);
8016c068:	e51b3008 	ldr	r3, [fp, #-8]
8016c06c:	e5932014 	ldr	r2, [r3, #20]
8016c070:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016c074:	e1520003 	cmp	r2, r3
8016c078:	8a000001 	bhi	8016c084 <_RME_Inv_Del+0x1cc>
8016c07c:	e3e03002 	mvn	r3, #2
8016c080:	ea00006f 	b	8016c244 <_RME_Inv_Del+0x38c>
8016c084:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016c088:	e1a02283 	lsl	r2, r3, #5
8016c08c:	e51b3008 	ldr	r3, [fp, #-8]
8016c090:	e593300c 	ldr	r3, [r3, #12]
8016c094:	e0823003 	add	r3, r2, r3
8016c098:	e50b3010 	str	r3, [fp, #-16]
    /* Delete check */
    RME_CAP_DEL_CHECK(Inv_Del,Type_Stat,RME_CAP_TYPE_INV);
8016c09c:	e51b3010 	ldr	r3, [fp, #-16]
8016c0a0:	e1a00003 	mov	r0, r3
8016c0a4:	ebffd195 	bl	80160700 <__RME_A7A_Read_Acquire>
8016c0a8:	e50b000c 	str	r0, [fp, #-12]
8016c0ac:	e51b300c 	ldr	r3, [fp, #-12]
8016c0b0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016c0b4:	e3530802 	cmp	r3, #131072	@ 0x20000
8016c0b8:	0a000001 	beq	8016c0c4 <_RME_Inv_Del+0x20c>
8016c0bc:	e3e03008 	mvn	r3, #8
8016c0c0:	ea00005f 	b	8016c244 <_RME_Inv_Del+0x38c>
8016c0c4:	e51b300c 	ldr	r3, [fp, #-12]
8016c0c8:	e1a03c23 	lsr	r3, r3, #24
8016c0cc:	e3530007 	cmp	r3, #7
8016c0d0:	0a000001 	beq	8016c0dc <_RME_Inv_Del+0x224>
8016c0d4:	e3e03001 	mvn	r3, #1
8016c0d8:	ea000059 	b	8016c244 <_RME_Inv_Del+0x38c>
8016c0dc:	e3003000 	movw	r3, #0
8016c0e0:	e3483017 	movt	r3, #32791	@ 0x8017
8016c0e4:	e5932000 	ldr	r2, [r3]
8016c0e8:	e51b3010 	ldr	r3, [fp, #-16]
8016c0ec:	e5933010 	ldr	r3, [r3, #16]
8016c0f0:	e1a01003 	mov	r1, r3
8016c0f4:	e1a00002 	mov	r0, r2
8016c0f8:	ebffd31c 	bl	80160d70 <_RME_Diff>
8016c0fc:	e1a03000 	mov	r3, r0
8016c100:	e353000a 	cmp	r3, #10
8016c104:	8a000001 	bhi	8016c110 <_RME_Inv_Del+0x258>
8016c108:	e3e03007 	mvn	r3, #7
8016c10c:	ea00004c 	b	8016c244 <_RME_Inv_Del+0x38c>
8016c110:	e51b3010 	ldr	r3, [fp, #-16]
8016c114:	e5933004 	ldr	r3, [r3, #4]
8016c118:	e3530000 	cmp	r3, #0
8016c11c:	0a00000b 	beq	8016c150 <_RME_Inv_Del+0x298>
8016c120:	e51b300c 	ldr	r3, [fp, #-12]
8016c124:	e6ff3073 	uxth	r3, r3
8016c128:	e3530000 	cmp	r3, #0
8016c12c:	1a000005 	bne	8016c148 <_RME_Inv_Del+0x290>
8016c130:	e51b0010 	ldr	r0, [fp, #-16]
8016c134:	e51b300c 	ldr	r3, [fp, #-12]
8016c138:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
8016c13c:	e1a02003 	mov	r2, r3
8016c140:	e51b100c 	ldr	r1, [fp, #-12]
8016c144:	ebffd29c 	bl	80160bbc <_RME_Comp_Swap_Single>
8016c148:	e3e03005 	mvn	r3, #5
8016c14c:	ea00003c 	b	8016c244 <_RME_Inv_Del+0x38c>
8016c150:	e51b300c 	ldr	r3, [fp, #-12]
8016c154:	e6ff3073 	uxth	r3, r3
8016c158:	e3530000 	cmp	r3, #0
8016c15c:	0a000008 	beq	8016c184 <_RME_Inv_Del+0x2cc>
8016c160:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
8016c164:	e3483016 	movt	r3, #32790	@ 0x8016
8016c168:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
8016c16c:	e3482016 	movt	r2, #32790	@ 0x8016
8016c170:	e3011dbe 	movw	r1, #7614	@ 0x1dbe
8016c174:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
8016c178:	e3480016 	movt	r0, #32790	@ 0x8016
8016c17c:	ebffd283 	bl	80160b90 <RME_Log>
8016c180:	eafffffe 	b	8016c180 <_RME_Inv_Del+0x2c8>
    
    /* Get the invocation */
    Invocation=RME_CAP_GETOBJ(Inv_Del,struct RME_Inv_Struct*);
8016c184:	e51b3010 	ldr	r3, [fp, #-16]
8016c188:	e593300c 	ldr	r3, [r3, #12]
8016c18c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    
    /* See if the invocation is currently being used. If yes, we cannot delete it */
    if(Invocation->Thd_Act!=RME_NULL)
8016c190:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016c194:	e593300c 	ldr	r3, [r3, #12]
8016c198:	e3530000 	cmp	r3, #0
8016c19c:	0a000007 	beq	8016c1c0 <_RME_Inv_Del+0x308>
    {
        RME_COV_MARKER();

        RME_CAP_DEFROST(Inv_Del,Type_Stat);
8016c1a0:	e51b0010 	ldr	r0, [fp, #-16]
8016c1a4:	e51b300c 	ldr	r3, [fp, #-12]
8016c1a8:	e3c338ff 	bic	r3, r3, #16711680	@ 0xff0000
8016c1ac:	e1a02003 	mov	r2, r3
8016c1b0:	e51b100c 	ldr	r1, [fp, #-12]
8016c1b4:	ebffd280 	bl	80160bbc <_RME_Comp_Swap_Single>
        return RME_ERR_SIV_ACT;
8016c1b8:	e3e03f4b 	mvn	r3, #300	@ 0x12c
8016c1bc:	ea000020 	b	8016c244 <_RME_Inv_Del+0x38c>
        RME_COV_MARKER();
        /* No action required */
    }
    
    /* Now we can safely delete the cap */
    RME_CAP_DELETE(Inv_Del,Type_Stat);
8016c1c0:	e51b3010 	ldr	r3, [fp, #-16]
8016c1c4:	e3a02000 	mov	r2, #0
8016c1c8:	e51b100c 	ldr	r1, [fp, #-12]
8016c1cc:	e1a00003 	mov	r0, r3
8016c1d0:	ebffd279 	bl	80160bbc <_RME_Comp_Swap_Single>
8016c1d4:	e1a03000 	mov	r3, r0
8016c1d8:	e3530000 	cmp	r3, #0
8016c1dc:	1a000001 	bne	8016c1e8 <_RME_Inv_Del+0x330>
8016c1e0:	e3e03000 	mvn	r3, #0
8016c1e4:	ea000016 	b	8016c244 <_RME_Inv_Del+0x38c>
    
    /* Dereference the process */
    RME_FETCH_ADD(&(Invocation->Prc->Head.Root_Ref), -1);
8016c1e8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016c1ec:	e5933008 	ldr	r3, [r3, #8]
8016c1f0:	e2833004 	add	r3, r3, #4
8016c1f4:	e3e01000 	mvn	r1, #0
8016c1f8:	e1a00003 	mov	r0, r3
8016c1fc:	ebffd283 	bl	80160c10 <_RME_Fetch_Add_Single>
    
    /* Try to clear the area - this must be successful */
    RME_ASSERT(_RME_Kot_Erase((rme_ptr_t)Invocation,RME_INV_SIZE)==0);
8016c200:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016c204:	e3a01024 	mov	r1, #36	@ 0x24
8016c208:	e1a00003 	mov	r0, r3
8016c20c:	ebffe42e 	bl	801652cc <_RME_Kot_Erase>
8016c210:	e1a03000 	mov	r3, r0
8016c214:	e3530000 	cmp	r3, #0
8016c218:	0a000008 	beq	8016c240 <_RME_Inv_Del+0x388>
8016c21c:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
8016c220:	e3483016 	movt	r3, #32790	@ 0x8016
8016c224:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
8016c228:	e3482016 	movt	r2, #32790	@ 0x8016
8016c22c:	e3011dd8 	movw	r1, #7640	@ 0x1dd8
8016c230:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
8016c234:	e3480016 	movt	r0, #32790	@ 0x8016
8016c238:	ebffd254 	bl	80160b90 <RME_Log>
8016c23c:	eafffffe 	b	8016c23c <_RME_Inv_Del+0x384>
    
    return 0;
8016c240:	e3a03000 	mov	r3, #0
}
8016c244:	e1a00003 	mov	r0, r3
8016c248:	e24bd004 	sub	sp, fp, #4
8016c24c:	e8bd8800 	pop	{fp, pc}

8016c250 <_RME_Inv_Set>:
static rme_ret_t _RME_Inv_Set(struct RME_Cap_Cpt* Cpt,
                              rme_cid_t Cap_Inv,
                              rme_ptr_t Entry,
                              rme_ptr_t Stack,
                              rme_ptr_t Is_Exc_Ret)
{
8016c250:	e92d4800 	push	{fp, lr}
8016c254:	e28db004 	add	fp, sp, #4
8016c258:	e24dd020 	sub	sp, sp, #32
8016c25c:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
8016c260:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
8016c264:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
8016c268:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    struct RME_Cap_Inv* Inv_Op;
    volatile struct RME_Inv_Struct* Invocation;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Inv,RME_CAP_TYPE_INV,
8016c26c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016c270:	e2033080 	and	r3, r3, #128	@ 0x80
8016c274:	e3530000 	cmp	r3, #0
8016c278:	1a00001c 	bne	8016c2f0 <_RME_Inv_Set+0xa0>
8016c27c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016c280:	e5932014 	ldr	r2, [r3, #20]
8016c284:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016c288:	e1520003 	cmp	r2, r3
8016c28c:	8a000001 	bhi	8016c298 <_RME_Inv_Set+0x48>
8016c290:	e3e03002 	mvn	r3, #2
8016c294:	ea000067 	b	8016c438 <_RME_Inv_Set+0x1e8>
8016c298:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016c29c:	e1a02283 	lsl	r2, r3, #5
8016c2a0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016c2a4:	e593300c 	ldr	r3, [r3, #12]
8016c2a8:	e0823003 	add	r3, r2, r3
8016c2ac:	e50b3008 	str	r3, [fp, #-8]
8016c2b0:	e51b3008 	ldr	r3, [fp, #-8]
8016c2b4:	e1a00003 	mov	r0, r3
8016c2b8:	ebffd110 	bl	80160700 <__RME_A7A_Read_Acquire>
8016c2bc:	e50b000c 	str	r0, [fp, #-12]
8016c2c0:	e51b300c 	ldr	r3, [fp, #-12]
8016c2c4:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016c2c8:	e3530802 	cmp	r3, #131072	@ 0x20000
8016c2cc:	1a000001 	bne	8016c2d8 <_RME_Inv_Set+0x88>
8016c2d0:	e3e03008 	mvn	r3, #8
8016c2d4:	ea000057 	b	8016c438 <_RME_Inv_Set+0x1e8>
8016c2d8:	e51b300c 	ldr	r3, [fp, #-12]
8016c2dc:	e1a03c23 	lsr	r3, r3, #24
8016c2e0:	e3530007 	cmp	r3, #7
8016c2e4:	0a00003f 	beq	8016c3e8 <_RME_Inv_Set+0x198>
8016c2e8:	e3e03001 	mvn	r3, #1
8016c2ec:	ea000051 	b	8016c438 <_RME_Inv_Set+0x1e8>
8016c2f0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016c2f4:	e1a02423 	lsr	r2, r3, #8
8016c2f8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016c2fc:	e5933014 	ldr	r3, [r3, #20]
8016c300:	e1520003 	cmp	r2, r3
8016c304:	3a000001 	bcc	8016c310 <_RME_Inv_Set+0xc0>
8016c308:	e3e03002 	mvn	r3, #2
8016c30c:	ea000049 	b	8016c438 <_RME_Inv_Set+0x1e8>
8016c310:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016c314:	e1a03423 	lsr	r3, r3, #8
8016c318:	e1a02283 	lsl	r2, r3, #5
8016c31c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016c320:	e593300c 	ldr	r3, [r3, #12]
8016c324:	e0823003 	add	r3, r2, r3
8016c328:	e50b3008 	str	r3, [fp, #-8]
8016c32c:	e51b3008 	ldr	r3, [fp, #-8]
8016c330:	e1a00003 	mov	r0, r3
8016c334:	ebffd0f1 	bl	80160700 <__RME_A7A_Read_Acquire>
8016c338:	e50b000c 	str	r0, [fp, #-12]
8016c33c:	e51b300c 	ldr	r3, [fp, #-12]
8016c340:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016c344:	e3530802 	cmp	r3, #131072	@ 0x20000
8016c348:	1a000001 	bne	8016c354 <_RME_Inv_Set+0x104>
8016c34c:	e3e03008 	mvn	r3, #8
8016c350:	ea000038 	b	8016c438 <_RME_Inv_Set+0x1e8>
8016c354:	e51b300c 	ldr	r3, [fp, #-12]
8016c358:	e1a03c23 	lsr	r3, r3, #24
8016c35c:	e3530003 	cmp	r3, #3
8016c360:	0a000001 	beq	8016c36c <_RME_Inv_Set+0x11c>
8016c364:	e3e03001 	mvn	r3, #1
8016c368:	ea000032 	b	8016c438 <_RME_Inv_Set+0x1e8>
8016c36c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016c370:	e203207f 	and	r2, r3, #127	@ 0x7f
8016c374:	e51b3008 	ldr	r3, [fp, #-8]
8016c378:	e5933014 	ldr	r3, [r3, #20]
8016c37c:	e1520003 	cmp	r2, r3
8016c380:	3a000001 	bcc	8016c38c <_RME_Inv_Set+0x13c>
8016c384:	e3e03002 	mvn	r3, #2
8016c388:	ea00002a 	b	8016c438 <_RME_Inv_Set+0x1e8>
8016c38c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016c390:	e203307f 	and	r3, r3, #127	@ 0x7f
8016c394:	e1a02283 	lsl	r2, r3, #5
8016c398:	e51b3008 	ldr	r3, [fp, #-8]
8016c39c:	e593300c 	ldr	r3, [r3, #12]
8016c3a0:	e0823003 	add	r3, r2, r3
8016c3a4:	e50b3008 	str	r3, [fp, #-8]
8016c3a8:	e51b3008 	ldr	r3, [fp, #-8]
8016c3ac:	e1a00003 	mov	r0, r3
8016c3b0:	ebffd0d2 	bl	80160700 <__RME_A7A_Read_Acquire>
8016c3b4:	e50b000c 	str	r0, [fp, #-12]
8016c3b8:	e51b300c 	ldr	r3, [fp, #-12]
8016c3bc:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016c3c0:	e3530802 	cmp	r3, #131072	@ 0x20000
8016c3c4:	1a000001 	bne	8016c3d0 <_RME_Inv_Set+0x180>
8016c3c8:	e3e03008 	mvn	r3, #8
8016c3cc:	ea000019 	b	8016c438 <_RME_Inv_Set+0x1e8>
8016c3d0:	e51b300c 	ldr	r3, [fp, #-12]
8016c3d4:	e1a03c23 	lsr	r3, r3, #24
8016c3d8:	e3530007 	cmp	r3, #7
8016c3dc:	0a000001 	beq	8016c3e8 <_RME_Inv_Set+0x198>
8016c3e0:	e3e03001 	mvn	r3, #1
8016c3e4:	ea000013 	b	8016c438 <_RME_Inv_Set+0x1e8>
                   struct RME_Cap_Inv*,Inv_Op,Type_Stat);
    /* Check if the target cap is not frozen and allows such operations */
    RME_CAP_CHECK(Inv_Op,RME_INV_FLAG_SET);
8016c3e8:	e51b3008 	ldr	r3, [fp, #-8]
8016c3ec:	e5933008 	ldr	r3, [r3, #8]
8016c3f0:	e2033001 	and	r3, r3, #1
8016c3f4:	e3530000 	cmp	r3, #0
8016c3f8:	1a000001 	bne	8016c404 <_RME_Inv_Set+0x1b4>
8016c3fc:	e3e03006 	mvn	r3, #6
8016c400:	ea00000c 	b	8016c438 <_RME_Inv_Set+0x1e8>
    
    /* Commit the change - we do not care if the invocation is in use, it is
     * the user's responsibility to guarantee the integrity of applications */
    Invocation=RME_CAP_GETOBJ(Inv_Op,struct RME_Inv_Struct*);
8016c404:	e51b3008 	ldr	r3, [fp, #-8]
8016c408:	e593300c 	ldr	r3, [r3, #12]
8016c40c:	e50b3010 	str	r3, [fp, #-16]
    Invocation->Entry=Entry;
8016c410:	e51b3010 	ldr	r3, [fp, #-16]
8016c414:	e51b2020 	ldr	r2, [fp, #-32]	@ 0xffffffe0
8016c418:	e5832010 	str	r2, [r3, #16]
    Invocation->Stack=Stack;
8016c41c:	e51b3010 	ldr	r3, [fp, #-16]
8016c420:	e51b2024 	ldr	r2, [fp, #-36]	@ 0xffffffdc
8016c424:	e5832014 	str	r2, [r3, #20]
    Invocation->Is_Exc_Ret=Is_Exc_Ret;
8016c428:	e51b3010 	ldr	r3, [fp, #-16]
8016c42c:	e59b2004 	ldr	r2, [fp, #4]
8016c430:	e5832018 	str	r2, [r3, #24]
    
    return 0;
8016c434:	e3a03000 	mov	r3, #0
}
8016c438:	e1a00003 	mov	r0, r3
8016c43c:	e24bd004 	sub	sp, fp, #4
8016c440:	e8bd8800 	pop	{fp, pc}

8016c444 <_RME_Inv_Act>:
******************************************************************************/
static rme_ret_t _RME_Inv_Act(struct RME_Cap_Cpt* Cpt, 
                              struct RME_Reg_Struct* Reg,
                              rme_cid_t Cap_Inv,
                              rme_ptr_t Param)
{
8016c444:	e92d4800 	push	{fp, lr}
8016c448:	e28db004 	add	fp, sp, #4
8016c44c:	e24dd030 	sub	sp, sp, #48	@ 0x30
8016c450:	e50b0020 	str	r0, [fp, #-32]	@ 0xffffffe0
8016c454:	e50b1024 	str	r1, [fp, #-36]	@ 0xffffffdc
8016c458:	e50b2028 	str	r2, [fp, #-40]	@ 0xffffffd8
8016c45c:	e50b302c 	str	r3, [fp, #-44]	@ 0xffffffd4
        /* No action required */
    }
#endif

    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Inv,RME_CAP_TYPE_INV,
8016c460:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016c464:	e2033080 	and	r3, r3, #128	@ 0x80
8016c468:	e3530000 	cmp	r3, #0
8016c46c:	1a00001c 	bne	8016c4e4 <_RME_Inv_Act+0xa0>
8016c470:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016c474:	e5932014 	ldr	r2, [r3, #20]
8016c478:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016c47c:	e1520003 	cmp	r2, r3
8016c480:	8a000001 	bhi	8016c48c <_RME_Inv_Act+0x48>
8016c484:	e3e03002 	mvn	r3, #2
8016c488:	ea0000a6 	b	8016c728 <_RME_Inv_Act+0x2e4>
8016c48c:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016c490:	e1a02283 	lsl	r2, r3, #5
8016c494:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016c498:	e593300c 	ldr	r3, [r3, #12]
8016c49c:	e0823003 	add	r3, r2, r3
8016c4a0:	e50b3008 	str	r3, [fp, #-8]
8016c4a4:	e51b3008 	ldr	r3, [fp, #-8]
8016c4a8:	e1a00003 	mov	r0, r3
8016c4ac:	ebffd093 	bl	80160700 <__RME_A7A_Read_Acquire>
8016c4b0:	e50b000c 	str	r0, [fp, #-12]
8016c4b4:	e51b300c 	ldr	r3, [fp, #-12]
8016c4b8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016c4bc:	e3530802 	cmp	r3, #131072	@ 0x20000
8016c4c0:	1a000001 	bne	8016c4cc <_RME_Inv_Act+0x88>
8016c4c4:	e3e03008 	mvn	r3, #8
8016c4c8:	ea000096 	b	8016c728 <_RME_Inv_Act+0x2e4>
8016c4cc:	e51b300c 	ldr	r3, [fp, #-12]
8016c4d0:	e1a03c23 	lsr	r3, r3, #24
8016c4d4:	e3530007 	cmp	r3, #7
8016c4d8:	0a00003f 	beq	8016c5dc <_RME_Inv_Act+0x198>
8016c4dc:	e3e03001 	mvn	r3, #1
8016c4e0:	ea000090 	b	8016c728 <_RME_Inv_Act+0x2e4>
8016c4e4:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016c4e8:	e1a02423 	lsr	r2, r3, #8
8016c4ec:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016c4f0:	e5933014 	ldr	r3, [r3, #20]
8016c4f4:	e1520003 	cmp	r2, r3
8016c4f8:	3a000001 	bcc	8016c504 <_RME_Inv_Act+0xc0>
8016c4fc:	e3e03002 	mvn	r3, #2
8016c500:	ea000088 	b	8016c728 <_RME_Inv_Act+0x2e4>
8016c504:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016c508:	e1a03423 	lsr	r3, r3, #8
8016c50c:	e1a02283 	lsl	r2, r3, #5
8016c510:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016c514:	e593300c 	ldr	r3, [r3, #12]
8016c518:	e0823003 	add	r3, r2, r3
8016c51c:	e50b3008 	str	r3, [fp, #-8]
8016c520:	e51b3008 	ldr	r3, [fp, #-8]
8016c524:	e1a00003 	mov	r0, r3
8016c528:	ebffd074 	bl	80160700 <__RME_A7A_Read_Acquire>
8016c52c:	e50b000c 	str	r0, [fp, #-12]
8016c530:	e51b300c 	ldr	r3, [fp, #-12]
8016c534:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016c538:	e3530802 	cmp	r3, #131072	@ 0x20000
8016c53c:	1a000001 	bne	8016c548 <_RME_Inv_Act+0x104>
8016c540:	e3e03008 	mvn	r3, #8
8016c544:	ea000077 	b	8016c728 <_RME_Inv_Act+0x2e4>
8016c548:	e51b300c 	ldr	r3, [fp, #-12]
8016c54c:	e1a03c23 	lsr	r3, r3, #24
8016c550:	e3530003 	cmp	r3, #3
8016c554:	0a000001 	beq	8016c560 <_RME_Inv_Act+0x11c>
8016c558:	e3e03001 	mvn	r3, #1
8016c55c:	ea000071 	b	8016c728 <_RME_Inv_Act+0x2e4>
8016c560:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016c564:	e203207f 	and	r2, r3, #127	@ 0x7f
8016c568:	e51b3008 	ldr	r3, [fp, #-8]
8016c56c:	e5933014 	ldr	r3, [r3, #20]
8016c570:	e1520003 	cmp	r2, r3
8016c574:	3a000001 	bcc	8016c580 <_RME_Inv_Act+0x13c>
8016c578:	e3e03002 	mvn	r3, #2
8016c57c:	ea000069 	b	8016c728 <_RME_Inv_Act+0x2e4>
8016c580:	e51b3028 	ldr	r3, [fp, #-40]	@ 0xffffffd8
8016c584:	e203307f 	and	r3, r3, #127	@ 0x7f
8016c588:	e1a02283 	lsl	r2, r3, #5
8016c58c:	e51b3008 	ldr	r3, [fp, #-8]
8016c590:	e593300c 	ldr	r3, [r3, #12]
8016c594:	e0823003 	add	r3, r2, r3
8016c598:	e50b3008 	str	r3, [fp, #-8]
8016c59c:	e51b3008 	ldr	r3, [fp, #-8]
8016c5a0:	e1a00003 	mov	r0, r3
8016c5a4:	ebffd055 	bl	80160700 <__RME_A7A_Read_Acquire>
8016c5a8:	e50b000c 	str	r0, [fp, #-12]
8016c5ac:	e51b300c 	ldr	r3, [fp, #-12]
8016c5b0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016c5b4:	e3530802 	cmp	r3, #131072	@ 0x20000
8016c5b8:	1a000001 	bne	8016c5c4 <_RME_Inv_Act+0x180>
8016c5bc:	e3e03008 	mvn	r3, #8
8016c5c0:	ea000058 	b	8016c728 <_RME_Inv_Act+0x2e4>
8016c5c4:	e51b300c 	ldr	r3, [fp, #-12]
8016c5c8:	e1a03c23 	lsr	r3, r3, #24
8016c5cc:	e3530007 	cmp	r3, #7
8016c5d0:	0a000001 	beq	8016c5dc <_RME_Inv_Act+0x198>
8016c5d4:	e3e03001 	mvn	r3, #1
8016c5d8:	ea000052 	b	8016c728 <_RME_Inv_Act+0x2e4>
                   struct RME_Cap_Inv*,Inv_Op,Type_Stat);
    /* Check if the target cap is not frozen and allows such operations */
    RME_CAP_CHECK(Inv_Op,RME_INV_FLAG_ACT);
8016c5dc:	e51b3008 	ldr	r3, [fp, #-8]
8016c5e0:	e5933008 	ldr	r3, [r3, #8]
8016c5e4:	e2033002 	and	r3, r3, #2
8016c5e8:	e3530000 	cmp	r3, #0
8016c5ec:	1a000001 	bne	8016c5f8 <_RME_Inv_Act+0x1b4>
8016c5f0:	e3e03006 	mvn	r3, #6
8016c5f4:	ea00004b 	b	8016c728 <_RME_Inv_Act+0x2e4>

    /* Get the invocation struct */
    Invocation=RME_CAP_GETOBJ(Inv_Op,struct RME_Inv_Struct*);
8016c5f8:	e51b3008 	ldr	r3, [fp, #-8]
8016c5fc:	e593300c 	ldr	r3, [r3, #12]
8016c600:	e50b3010 	str	r3, [fp, #-16]
    /* Check if this invocation port is already active */
    Thd_Act=Invocation->Thd_Act;
8016c604:	e51b3010 	ldr	r3, [fp, #-16]
8016c608:	e593300c 	ldr	r3, [r3, #12]
8016c60c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    if(RME_UNLIKELY(Thd_Act!=0U))
8016c610:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016c614:	e3530000 	cmp	r3, #0
8016c618:	0a000001 	beq	8016c624 <_RME_Inv_Act+0x1e0>
    {
        RME_COV_MARKER();

        return RME_ERR_SIV_ACT;
8016c61c:	e3e03f4b 	mvn	r3, #300	@ 0x12c
8016c620:	ea000040 	b	8016c728 <_RME_Inv_Act+0x2e4>
        RME_COV_MARKER();
        /* No action required */
    }

#if(RME_CPT_ENTRY_MAX==0U)
    Thd_Cur=RME_CPU_LOCAL()->Thd_Cur;
8016c624:	e3003004 	movw	r3, #4
8016c628:	e3483017 	movt	r3, #32791	@ 0x8017
8016c62c:	e5933004 	ldr	r3, [r3, #4]
8016c630:	e50b3018 	str	r3, [fp, #-24]	@ 0xffffffe8
#endif
    
    /* Try to do CAS and activate this port */
    if(RME_UNLIKELY(RME_COMP_SWAP((volatile rme_ptr_t*)&(Invocation->Thd_Act),
8016c634:	e51b3010 	ldr	r3, [fp, #-16]
8016c638:	e283300c 	add	r3, r3, #12
8016c63c:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
8016c640:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016c644:	e1a00003 	mov	r0, r3
8016c648:	ebffd15b 	bl	80160bbc <_RME_Comp_Swap_Single>
8016c64c:	e1a03000 	mov	r3, r0
8016c650:	e3530000 	cmp	r3, #0
8016c654:	1a000001 	bne	8016c660 <_RME_Inv_Act+0x21c>
                                  (rme_ptr_t)Thd_Act,
                                  (rme_ptr_t)Thd_Cur)==RME_CASFAIL))
    {
        RME_COV_MARKER();

        return RME_ERR_SIV_ACT;
8016c658:	e3e03f4b 	mvn	r3, #300	@ 0x12c
8016c65c:	ea000031 	b	8016c728 <_RME_Inv_Act+0x2e4>

    /* Save whatever is needed to return to the point - normally only SP and IP needed
     * because all other registers, including the coprocessor registers, are saved at
     * user-level. We do not set the return value because it will be set by Inv_Ret.
     * The coprocessor state will be consistent across the call */
    __RME_Inv_Reg_Save(&(Invocation->Ret),Reg);
8016c660:	e51b3010 	ldr	r3, [fp, #-16]
8016c664:	e283301c 	add	r3, r3, #28
8016c668:	e51b1024 	ldr	r1, [fp, #-36]	@ 0xffffffdc
8016c66c:	e1a00003 	mov	r0, r3
8016c670:	eb000509 	bl	8016da9c <__RME_Inv_Reg_Save>
    /* Push this into the stack: insert after the thread list header */
    _RME_List_Ins(&(Invocation->Head),
8016c674:	e51b0010 	ldr	r0, [fp, #-16]
8016c678:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016c67c:	e283104c 	add	r1, r3, #76	@ 0x4c
8016c680:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016c684:	e593304c 	ldr	r3, [r3, #76]	@ 0x4c
8016c688:	e1a02003 	mov	r2, r3
8016c68c:	ebffd1a1 	bl	80160d18 <_RME_List_Ins>
                  &(Thd_Cur->Ctx.Invstk),
                  Thd_Cur->Ctx.Invstk.Next);
    /* Increase invocation depth - no atomic operation needed */
    Thd_Cur->Ctx.Invstk_Depth++;
8016c690:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016c694:	e5933054 	ldr	r3, [r3, #84]	@ 0x54
8016c698:	e2832001 	add	r2, r3, #1
8016c69c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016c6a0:	e5832054 	str	r2, [r3, #84]	@ 0x54
    /* Setup the register contents, and do the invocation */
    __RME_Thd_Reg_Init(RME_THD_ATTR(Thd_Cur->Ctx.Hyp_Attr),
8016c6a4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016c6a8:	e5933044 	ldr	r3, [r3, #68]	@ 0x44
8016c6ac:	e3c30102 	bic	r0, r3, #-2147483648	@ 0x80000000
8016c6b0:	e51b3010 	ldr	r3, [fp, #-16]
8016c6b4:	e5931010 	ldr	r1, [r3, #16]
8016c6b8:	e51b3010 	ldr	r3, [fp, #-16]
8016c6bc:	e5932014 	ldr	r2, [r3, #20]
8016c6c0:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016c6c4:	e58d3000 	str	r3, [sp]
8016c6c8:	e51b302c 	ldr	r3, [fp, #-44]	@ 0xffffffd4
8016c6cc:	eb00048f 	bl	8016d910 <__RME_Thd_Reg_Init>
    
    
    /* We are assuming that we are always invoking into a new process (why use synchronous
     * invocation if you don't do so?). So we always switch page tables regardless. */
#if(RME_PGT_RAW_ENABLE==0U)
    RME_ASSERT(RME_CAP_IS_ROOT(Invocation->Prc->Pgt)!=0U);
8016c6d0:	e51b3010 	ldr	r3, [fp, #-16]
8016c6d4:	e5933008 	ldr	r3, [r3, #8]
8016c6d8:	e5933018 	ldr	r3, [r3, #24]
8016c6dc:	e5933000 	ldr	r3, [r3]
8016c6e0:	e6ff3073 	uxth	r3, r3
8016c6e4:	e3530000 	cmp	r3, #0
8016c6e8:	0a000008 	beq	8016c710 <_RME_Inv_Act+0x2cc>
8016c6ec:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
8016c6f0:	e3483016 	movt	r3, #32790	@ 0x8016
8016c6f4:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
8016c6f8:	e3482016 	movt	r2, #32790	@ 0x8016
8016c6fc:	e3011e6f 	movw	r1, #7791	@ 0x1e6f
8016c700:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
8016c704:	e3480016 	movt	r0, #32790	@ 0x8016
8016c708:	ebffd120 	bl	80160b90 <RME_Log>
8016c70c:	eafffffe 	b	8016c70c <_RME_Inv_Act+0x2c8>
#endif
    __RME_Pgt_Set(Invocation->Prc->Pgt);
8016c710:	e51b3010 	ldr	r3, [fp, #-16]
8016c714:	e5933008 	ldr	r3, [r3, #8]
8016c718:	e5933018 	ldr	r3, [r3, #24]
8016c71c:	e1a00003 	mov	r0, r3
8016c720:	eb0005e1 	bl	8016deac <__RME_Pgt_Set>
    return 0;
8016c724:	e3a03000 	mov	r3, #0
}
8016c728:	e1a00003 	mov	r0, r3
8016c72c:	e24bd004 	sub	sp, fp, #4
8016c730:	e8bd8800 	pop	{fp, pc}

8016c734 <_RME_Inv_Ret>:
Return      : rme_ret_t - If successful, 0; or an error code.
******************************************************************************/
static rme_ret_t _RME_Inv_Ret(struct RME_Reg_Struct* Reg,
                              rme_ptr_t Retval,
                              rme_ptr_t Is_Exc)
{
8016c734:	e92d4800 	push	{fp, lr}
8016c738:	e28db004 	add	fp, sp, #4
8016c73c:	e24dd018 	sub	sp, sp, #24
8016c740:	e50b0010 	str	r0, [fp, #-16]
8016c744:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
8016c748:	e50b2018 	str	r2, [fp, #-24]	@ 0xffffffe8
    struct RME_Thd_Struct* Thread;
    struct RME_Inv_Struct* Invocation;
    /* See if we can return; If we can, get the structure */
    Thread=RME_CPU_LOCAL()->Thd_Cur;
8016c74c:	e3003004 	movw	r3, #4
8016c750:	e3483017 	movt	r3, #32791	@ 0x8017
8016c754:	e5933004 	ldr	r3, [r3, #4]
8016c758:	e50b3008 	str	r3, [fp, #-8]
    Invocation=RME_INVSTK_TOP(Thread);
8016c75c:	e51b3008 	ldr	r3, [fp, #-8]
8016c760:	e593204c 	ldr	r2, [r3, #76]	@ 0x4c
8016c764:	e51b3008 	ldr	r3, [fp, #-8]
8016c768:	e283304c 	add	r3, r3, #76	@ 0x4c
8016c76c:	e1520003 	cmp	r2, r3
8016c770:	0a000002 	beq	8016c780 <_RME_Inv_Ret+0x4c>
8016c774:	e51b3008 	ldr	r3, [fp, #-8]
8016c778:	e593304c 	ldr	r3, [r3, #76]	@ 0x4c
8016c77c:	ea000000 	b	8016c784 <_RME_Inv_Ret+0x50>
8016c780:	e3a03000 	mov	r3, #0
8016c784:	e50b300c 	str	r3, [fp, #-12]
    if(RME_UNLIKELY(Invocation==RME_NULL))
8016c788:	e51b300c 	ldr	r3, [fp, #-12]
8016c78c:	e3530000 	cmp	r3, #0
8016c790:	1a000002 	bne	8016c7a0 <_RME_Inv_Ret+0x6c>
    {
        RME_COV_MARKER();

        return RME_ERR_SIV_EMPTY;
8016c794:	e30f3ed0 	movw	r3, #65232	@ 0xfed0
8016c798:	e34f3fff 	movt	r3, #65535	@ 0xffff
8016c79c:	ea000068 	b	8016c944 <_RME_Inv_Ret+0x210>
        RME_COV_MARKER();
        /* No action required */
    }

    /* See if this port allows return-on-fault */
    if(RME_UNLIKELY((Is_Exc!=0U)&&(Invocation->Is_Exc_Ret==0U)))
8016c7a0:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016c7a4:	e3530000 	cmp	r3, #0
8016c7a8:	0a000006 	beq	8016c7c8 <_RME_Inv_Ret+0x94>
8016c7ac:	e51b300c 	ldr	r3, [fp, #-12]
8016c7b0:	e5933018 	ldr	r3, [r3, #24]
8016c7b4:	e3530000 	cmp	r3, #0
8016c7b8:	1a000002 	bne	8016c7c8 <_RME_Inv_Ret+0x94>
    {
        RME_COV_MARKER();

        return RME_ERR_SIV_FAULT;
8016c7bc:	e30f3ed2 	movw	r3, #65234	@ 0xfed2
8016c7c0:	e34f3fff 	movt	r3, #65535	@ 0xffff
8016c7c4:	ea00005e 	b	8016c944 <_RME_Inv_Ret+0x210>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Pop it from the stack */
    _RME_List_Del(Invocation->Head.Prev,Invocation->Head.Next);
8016c7c8:	e51b300c 	ldr	r3, [fp, #-12]
8016c7cc:	e5932004 	ldr	r2, [r3, #4]
8016c7d0:	e51b300c 	ldr	r3, [fp, #-12]
8016c7d4:	e5933000 	ldr	r3, [r3]
8016c7d8:	e1a01003 	mov	r1, r3
8016c7dc:	e1a00002 	mov	r0, r2
8016c7e0:	ebffd13d 	bl	80160cdc <_RME_List_Del>
    /* Decrease invocation depth - no atomic operation needed */
    Thread->Ctx.Invstk_Depth--;
8016c7e4:	e51b3008 	ldr	r3, [fp, #-8]
8016c7e8:	e5933054 	ldr	r3, [r3, #84]	@ 0x54
8016c7ec:	e2432001 	sub	r2, r3, #1
8016c7f0:	e51b3008 	ldr	r3, [fp, #-8]
8016c7f4:	e5832054 	str	r2, [r3, #84]	@ 0x54

    /* Restore the register contents, and set return value. We need to set
     * the return value of the invocation system call itself as well. */
    __RME_Inv_Reg_Restore(Reg,&(Invocation->Ret));
8016c7f8:	e51b300c 	ldr	r3, [fp, #-12]
8016c7fc:	e283301c 	add	r3, r3, #28
8016c800:	e1a01003 	mov	r1, r3
8016c804:	e51b0010 	ldr	r0, [fp, #-16]
8016c808:	eb0004b4 	bl	8016dae0 <__RME_Inv_Reg_Restore>
    __RME_Inv_Retval_Set(Reg,(rme_ret_t)Retval);
8016c80c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016c810:	e1a01003 	mov	r1, r3
8016c814:	e51b0010 	ldr	r0, [fp, #-16]
8016c818:	eb0004c1 	bl	8016db24 <__RME_Inv_Retval_Set>

    /* We have successfully returned, set the invocation as inactive. We need
     * a barrier here to avoid potential destruction of the return value. */
    RME_WRITE_RELEASE((volatile rme_ptr_t*)&(Invocation->Thd_Act),0U);
8016c81c:	e51b300c 	ldr	r3, [fp, #-12]
8016c820:	e283300c 	add	r3, r3, #12
8016c824:	e3a01000 	mov	r1, #0
8016c828:	e1a00003 	mov	r0, r3
8016c82c:	ebffcfb6 	bl	8016070c <__RME_A7A_Write_Release>

    /* Decide the system call's return value */
    if(RME_UNLIKELY(Is_Exc!=0U))
8016c830:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016c834:	e3530000 	cmp	r3, #0
8016c838:	0a000004 	beq	8016c850 <_RME_Inv_Ret+0x11c>
    {
        RME_COV_MARKER();

        __RME_Svc_Retval_Set(Reg, RME_ERR_SIV_FAULT);
8016c83c:	e30f1ed2 	movw	r1, #65234	@ 0xfed2
8016c840:	e34f1fff 	movt	r1, #65535	@ 0xffff
8016c844:	e51b0010 	ldr	r0, [fp, #-16]
8016c848:	eb000424 	bl	8016d8e0 <__RME_Svc_Retval_Set>
8016c84c:	ea000002 	b	8016c85c <_RME_Inv_Ret+0x128>
    }
    else
    {
        RME_COV_MARKER();

        __RME_Svc_Retval_Set(Reg,0);
8016c850:	e3a01000 	mov	r1, #0
8016c854:	e51b0010 	ldr	r0, [fp, #-16]
8016c858:	eb000420 	bl	8016d8e0 <__RME_Svc_Retval_Set>
    }

    /* Same assumptions as in invocation activation */
    Invocation=RME_INVSTK_TOP(Thread);
8016c85c:	e51b3008 	ldr	r3, [fp, #-8]
8016c860:	e593204c 	ldr	r2, [r3, #76]	@ 0x4c
8016c864:	e51b3008 	ldr	r3, [fp, #-8]
8016c868:	e283304c 	add	r3, r3, #76	@ 0x4c
8016c86c:	e1520003 	cmp	r2, r3
8016c870:	0a000002 	beq	8016c880 <_RME_Inv_Ret+0x14c>
8016c874:	e51b3008 	ldr	r3, [fp, #-8]
8016c878:	e593304c 	ldr	r3, [r3, #76]	@ 0x4c
8016c87c:	ea000000 	b	8016c884 <_RME_Inv_Ret+0x150>
8016c880:	e3a03000 	mov	r3, #0
8016c884:	e50b300c 	str	r3, [fp, #-12]
    if(Invocation!=RME_NULL)
8016c888:	e51b300c 	ldr	r3, [fp, #-12]
8016c88c:	e3530000 	cmp	r3, #0
8016c890:	0a000015 	beq	8016c8ec <_RME_Inv_Ret+0x1b8>
    {
        RME_COV_MARKER();
        
#if(RME_PGT_RAW_ENABLE==0U)
        RME_ASSERT(RME_CAP_IS_ROOT(Invocation->Prc->Pgt)!=0U);
8016c894:	e51b300c 	ldr	r3, [fp, #-12]
8016c898:	e5933008 	ldr	r3, [r3, #8]
8016c89c:	e5933018 	ldr	r3, [r3, #24]
8016c8a0:	e5933000 	ldr	r3, [r3]
8016c8a4:	e6ff3073 	uxth	r3, r3
8016c8a8:	e3530000 	cmp	r3, #0
8016c8ac:	0a000008 	beq	8016c8d4 <_RME_Inv_Ret+0x1a0>
8016c8b0:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
8016c8b4:	e3483016 	movt	r3, #32790	@ 0x8016
8016c8b8:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
8016c8bc:	e3482016 	movt	r2, #32790	@ 0x8016
8016c8c0:	e3011ec5 	movw	r1, #7877	@ 0x1ec5
8016c8c4:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
8016c8c8:	e3480016 	movt	r0, #32790	@ 0x8016
8016c8cc:	ebffd0af 	bl	80160b90 <RME_Log>
8016c8d0:	eafffffe 	b	8016c8d0 <_RME_Inv_Ret+0x19c>
#endif
        __RME_Pgt_Set(Invocation->Prc->Pgt);
8016c8d4:	e51b300c 	ldr	r3, [fp, #-12]
8016c8d8:	e5933008 	ldr	r3, [r3, #8]
8016c8dc:	e5933018 	ldr	r3, [r3, #24]
8016c8e0:	e1a00003 	mov	r0, r3
8016c8e4:	eb000570 	bl	8016deac <__RME_Pgt_Set>
8016c8e8:	ea000014 	b	8016c940 <_RME_Inv_Ret+0x20c>
    else
    {
        RME_COV_MARKER();
        
#if(RME_PGT_RAW_ENABLE==0U)
        RME_ASSERT(RME_CAP_IS_ROOT(Thread->Sched.Prc->Pgt)!=0U);
8016c8ec:	e51b3008 	ldr	r3, [fp, #-8]
8016c8f0:	e593302c 	ldr	r3, [r3, #44]	@ 0x2c
8016c8f4:	e5933018 	ldr	r3, [r3, #24]
8016c8f8:	e5933000 	ldr	r3, [r3]
8016c8fc:	e6ff3073 	uxth	r3, r3
8016c900:	e3530000 	cmp	r3, #0
8016c904:	0a000008 	beq	8016c92c <_RME_Inv_Ret+0x1f8>
8016c908:	e30e38d8 	movw	r3, #59608	@ 0xe8d8
8016c90c:	e3483016 	movt	r3, #32790	@ 0x8016
8016c910:	e30e28e4 	movw	r2, #59620	@ 0xe8e4
8016c914:	e3482016 	movt	r2, #32790	@ 0x8016
8016c918:	e3011ece 	movw	r1, #7886	@ 0x1ece
8016c91c:	e30e08f0 	movw	r0, #59632	@ 0xe8f0
8016c920:	e3480016 	movt	r0, #32790	@ 0x8016
8016c924:	ebffd099 	bl	80160b90 <RME_Log>
8016c928:	eafffffe 	b	8016c928 <_RME_Inv_Ret+0x1f4>
#endif
        __RME_Pgt_Set(Thread->Sched.Prc->Pgt);
8016c92c:	e51b3008 	ldr	r3, [fp, #-8]
8016c930:	e593302c 	ldr	r3, [r3, #44]	@ 0x2c
8016c934:	e5933018 	ldr	r3, [r3, #24]
8016c938:	e1a00003 	mov	r0, r3
8016c93c:	eb00055a 	bl	8016deac <__RME_Pgt_Set>
    }

    return 0;
8016c940:	e3a03000 	mov	r3, #0
}
8016c944:	e1a00003 	mov	r0, r3
8016c948:	e24bd004 	sub	sp, fp, #4
8016c94c:	e8bd8800 	pop	{fp, pc}

8016c950 <_RME_Kfn_Boot_Crt>:
Return      : rme_ret_t - If successful, 0; or error code.
******************************************************************************/
rme_ret_t _RME_Kfn_Boot_Crt(struct RME_Cap_Cpt* Cpt,
                            rme_cid_t Cap_Cpt,
                            rme_cid_t Cap_Kfn)
{
8016c950:	e92d4800 	push	{fp, lr}
8016c954:	e28db004 	add	fp, sp, #4
8016c958:	e24dd020 	sub	sp, sp, #32
8016c95c:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
8016c960:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
8016c964:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
    struct RME_Cap_Cpt* Cpt_Op;
    volatile struct RME_Cap_Kfn* Kfn_Crt;
    rme_ptr_t Type_Stat;
    
    /* Get the cap location that we care about */
    RME_CPT_GETCAP(Cpt,Cap_Cpt,RME_CAP_TYPE_CPT,
8016c968:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016c96c:	e2033080 	and	r3, r3, #128	@ 0x80
8016c970:	e3530000 	cmp	r3, #0
8016c974:	1a00001c 	bne	8016c9ec <_RME_Kfn_Boot_Crt+0x9c>
8016c978:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016c97c:	e5932014 	ldr	r2, [r3, #20]
8016c980:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016c984:	e1520003 	cmp	r2, r3
8016c988:	8a000001 	bhi	8016c994 <_RME_Kfn_Boot_Crt+0x44>
8016c98c:	e3e03002 	mvn	r3, #2
8016c990:	ea000085 	b	8016cbac <_RME_Kfn_Boot_Crt+0x25c>
8016c994:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016c998:	e1a02283 	lsl	r2, r3, #5
8016c99c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016c9a0:	e593300c 	ldr	r3, [r3, #12]
8016c9a4:	e0823003 	add	r3, r2, r3
8016c9a8:	e50b3008 	str	r3, [fp, #-8]
8016c9ac:	e51b3008 	ldr	r3, [fp, #-8]
8016c9b0:	e1a00003 	mov	r0, r3
8016c9b4:	ebffcf51 	bl	80160700 <__RME_A7A_Read_Acquire>
8016c9b8:	e50b000c 	str	r0, [fp, #-12]
8016c9bc:	e51b300c 	ldr	r3, [fp, #-12]
8016c9c0:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016c9c4:	e3530802 	cmp	r3, #131072	@ 0x20000
8016c9c8:	1a000001 	bne	8016c9d4 <_RME_Kfn_Boot_Crt+0x84>
8016c9cc:	e3e03008 	mvn	r3, #8
8016c9d0:	ea000075 	b	8016cbac <_RME_Kfn_Boot_Crt+0x25c>
8016c9d4:	e51b300c 	ldr	r3, [fp, #-12]
8016c9d8:	e1a03c23 	lsr	r3, r3, #24
8016c9dc:	e3530003 	cmp	r3, #3
8016c9e0:	0a00003f 	beq	8016cae4 <_RME_Kfn_Boot_Crt+0x194>
8016c9e4:	e3e03001 	mvn	r3, #1
8016c9e8:	ea00006f 	b	8016cbac <_RME_Kfn_Boot_Crt+0x25c>
8016c9ec:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016c9f0:	e1a02423 	lsr	r2, r3, #8
8016c9f4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016c9f8:	e5933014 	ldr	r3, [r3, #20]
8016c9fc:	e1520003 	cmp	r2, r3
8016ca00:	3a000001 	bcc	8016ca0c <_RME_Kfn_Boot_Crt+0xbc>
8016ca04:	e3e03002 	mvn	r3, #2
8016ca08:	ea000067 	b	8016cbac <_RME_Kfn_Boot_Crt+0x25c>
8016ca0c:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016ca10:	e1a03423 	lsr	r3, r3, #8
8016ca14:	e1a02283 	lsl	r2, r3, #5
8016ca18:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016ca1c:	e593300c 	ldr	r3, [r3, #12]
8016ca20:	e0823003 	add	r3, r2, r3
8016ca24:	e50b3008 	str	r3, [fp, #-8]
8016ca28:	e51b3008 	ldr	r3, [fp, #-8]
8016ca2c:	e1a00003 	mov	r0, r3
8016ca30:	ebffcf32 	bl	80160700 <__RME_A7A_Read_Acquire>
8016ca34:	e50b000c 	str	r0, [fp, #-12]
8016ca38:	e51b300c 	ldr	r3, [fp, #-12]
8016ca3c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016ca40:	e3530802 	cmp	r3, #131072	@ 0x20000
8016ca44:	1a000001 	bne	8016ca50 <_RME_Kfn_Boot_Crt+0x100>
8016ca48:	e3e03008 	mvn	r3, #8
8016ca4c:	ea000056 	b	8016cbac <_RME_Kfn_Boot_Crt+0x25c>
8016ca50:	e51b300c 	ldr	r3, [fp, #-12]
8016ca54:	e1a03c23 	lsr	r3, r3, #24
8016ca58:	e3530003 	cmp	r3, #3
8016ca5c:	0a000001 	beq	8016ca68 <_RME_Kfn_Boot_Crt+0x118>
8016ca60:	e3e03001 	mvn	r3, #1
8016ca64:	ea000050 	b	8016cbac <_RME_Kfn_Boot_Crt+0x25c>
8016ca68:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016ca6c:	e203207f 	and	r2, r3, #127	@ 0x7f
8016ca70:	e51b3008 	ldr	r3, [fp, #-8]
8016ca74:	e5933014 	ldr	r3, [r3, #20]
8016ca78:	e1520003 	cmp	r2, r3
8016ca7c:	3a000001 	bcc	8016ca88 <_RME_Kfn_Boot_Crt+0x138>
8016ca80:	e3e03002 	mvn	r3, #2
8016ca84:	ea000048 	b	8016cbac <_RME_Kfn_Boot_Crt+0x25c>
8016ca88:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016ca8c:	e203307f 	and	r3, r3, #127	@ 0x7f
8016ca90:	e1a02283 	lsl	r2, r3, #5
8016ca94:	e51b3008 	ldr	r3, [fp, #-8]
8016ca98:	e593300c 	ldr	r3, [r3, #12]
8016ca9c:	e0823003 	add	r3, r2, r3
8016caa0:	e50b3008 	str	r3, [fp, #-8]
8016caa4:	e51b3008 	ldr	r3, [fp, #-8]
8016caa8:	e1a00003 	mov	r0, r3
8016caac:	ebffcf13 	bl	80160700 <__RME_A7A_Read_Acquire>
8016cab0:	e50b000c 	str	r0, [fp, #-12]
8016cab4:	e51b300c 	ldr	r3, [fp, #-12]
8016cab8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016cabc:	e3530802 	cmp	r3, #131072	@ 0x20000
8016cac0:	1a000001 	bne	8016cacc <_RME_Kfn_Boot_Crt+0x17c>
8016cac4:	e3e03008 	mvn	r3, #8
8016cac8:	ea000037 	b	8016cbac <_RME_Kfn_Boot_Crt+0x25c>
8016cacc:	e51b300c 	ldr	r3, [fp, #-12]
8016cad0:	e1a03c23 	lsr	r3, r3, #24
8016cad4:	e3530003 	cmp	r3, #3
8016cad8:	0a000001 	beq	8016cae4 <_RME_Kfn_Boot_Crt+0x194>
8016cadc:	e3e03001 	mvn	r3, #1
8016cae0:	ea000031 	b	8016cbac <_RME_Kfn_Boot_Crt+0x25c>
                   struct RME_Cap_Cpt*,Cpt_Op,Type_Stat);
    /* Check if the target captbl is not frozen and allows such operations */
    RME_CAP_CHECK(Cpt_Op,RME_CPT_FLAG_CRT);
8016cae4:	e51b3008 	ldr	r3, [fp, #-8]
8016cae8:	e5933008 	ldr	r3, [r3, #8]
8016caec:	e2033001 	and	r3, r3, #1
8016caf0:	e3530000 	cmp	r3, #0
8016caf4:	1a000001 	bne	8016cb00 <_RME_Kfn_Boot_Crt+0x1b0>
8016caf8:	e3e03006 	mvn	r3, #6
8016cafc:	ea00002a 	b	8016cbac <_RME_Kfn_Boot_Crt+0x25c>
    
    /* Get the cap slot */
    RME_CPT_GETSLOT(Cpt_Op,Cap_Kfn,struct RME_Cap_Kfn*,Kfn_Crt);
8016cb00:	e51b3008 	ldr	r3, [fp, #-8]
8016cb04:	e5932014 	ldr	r2, [r3, #20]
8016cb08:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016cb0c:	e1520003 	cmp	r2, r3
8016cb10:	8a000001 	bhi	8016cb1c <_RME_Kfn_Boot_Crt+0x1cc>
8016cb14:	e3e03002 	mvn	r3, #2
8016cb18:	ea000023 	b	8016cbac <_RME_Kfn_Boot_Crt+0x25c>
8016cb1c:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016cb20:	e1a02283 	lsl	r2, r3, #5
8016cb24:	e51b3008 	ldr	r3, [fp, #-8]
8016cb28:	e593300c 	ldr	r3, [r3, #12]
8016cb2c:	e0823003 	add	r3, r2, r3
8016cb30:	e50b3010 	str	r3, [fp, #-16]
    /* Take the slot if possible */
    RME_CPT_OCCUPY(Kfn_Crt);
8016cb34:	e51b3010 	ldr	r3, [fp, #-16]
8016cb38:	e3a02801 	mov	r2, #65536	@ 0x10000
8016cb3c:	e3a01000 	mov	r1, #0
8016cb40:	e1a00003 	mov	r0, r3
8016cb44:	ebffd01c 	bl	80160bbc <_RME_Comp_Swap_Single>
8016cb48:	e1a03000 	mov	r3, r0
8016cb4c:	e3530000 	cmp	r3, #0
8016cb50:	1a000001 	bne	8016cb5c <_RME_Kfn_Boot_Crt+0x20c>
8016cb54:	e3e03004 	mvn	r3, #4
8016cb58:	ea000013 	b	8016cbac <_RME_Kfn_Boot_Crt+0x25c>
8016cb5c:	e3003000 	movw	r3, #0
8016cb60:	e3483017 	movt	r3, #32791	@ 0x8017
8016cb64:	e5932000 	ldr	r2, [r3]
8016cb68:	e51b3010 	ldr	r3, [fp, #-16]
8016cb6c:	e5832010 	str	r2, [r3, #16]
    
    /* Header init */
    Kfn_Crt->Head.Root_Ref=1U;
8016cb70:	e51b3010 	ldr	r3, [fp, #-16]
8016cb74:	e3a02001 	mov	r2, #1
8016cb78:	e5832004 	str	r2, [r3, #4]
    Kfn_Crt->Head.Object=0U;
8016cb7c:	e51b3010 	ldr	r3, [fp, #-16]
8016cb80:	e3a02000 	mov	r2, #0
8016cb84:	e583200c 	str	r2, [r3, #12]
    Kfn_Crt->Head.Flag=RME_KFN_FLAG_FULL_RANGE;
8016cb88:	e51b2010 	ldr	r2, [fp, #-16]
8016cb8c:	e3a03000 	mov	r3, #0
8016cb90:	e34f3fff 	movt	r3, #65535	@ 0xffff
8016cb94:	e5823008 	str	r3, [r2, #8]
    
    /* Establish cap */
    RME_WRITE_RELEASE(&(Kfn_Crt->Head.Type_Stat),
8016cb98:	e51b3010 	ldr	r3, [fp, #-16]
8016cb9c:	e3a01401 	mov	r1, #16777216	@ 0x1000000
8016cba0:	e1a00003 	mov	r0, r3
8016cba4:	ebffced8 	bl	8016070c <__RME_A7A_Write_Release>
                      RME_CAP_TYPE_STAT(RME_CAP_TYPE_KFN,
                                        RME_CAP_STAT_VALID,
                                        RME_CAP_ATTR_ROOT));

    return 0;
8016cba8:	e3a03000 	mov	r3, #0
}
8016cbac:	e1a00003 	mov	r0, r3
8016cbb0:	e24bd004 	sub	sp, fp, #4
8016cbb4:	e8bd8800 	pop	{fp, pc}

8016cbb8 <_RME_Kfn_Act>:
                              rme_cid_t Cap_Kfn,
                              rme_ptr_t Func_ID,
                              rme_ptr_t Sub_ID,
                              rme_ptr_t Param1,
                              rme_ptr_t Param2)
{
8016cbb8:	e92d4800 	push	{fp, lr}
8016cbbc:	e28db004 	add	fp, sp, #4
8016cbc0:	e24dd020 	sub	sp, sp, #32
8016cbc4:	e50b0010 	str	r0, [fp, #-16]
8016cbc8:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
8016cbcc:	e50b2018 	str	r2, [fp, #-24]	@ 0xffffffe8
8016cbd0:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    struct RME_Cap_Kfn* Kfn_Op;
    rme_ptr_t Type_Stat;
    
    /* Get the capability slot */
    RME_CPT_GETCAP(Cpt,Cap_Kfn,RME_CAP_TYPE_KFN,
8016cbd4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016cbd8:	e2033080 	and	r3, r3, #128	@ 0x80
8016cbdc:	e3530000 	cmp	r3, #0
8016cbe0:	1a00001c 	bne	8016cc58 <_RME_Kfn_Act+0xa0>
8016cbe4:	e51b3010 	ldr	r3, [fp, #-16]
8016cbe8:	e5932014 	ldr	r2, [r3, #20]
8016cbec:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016cbf0:	e1520003 	cmp	r2, r3
8016cbf4:	8a000001 	bhi	8016cc00 <_RME_Kfn_Act+0x48>
8016cbf8:	e3e03002 	mvn	r3, #2
8016cbfc:	ea00006b 	b	8016cdb0 <_RME_Kfn_Act+0x1f8>
8016cc00:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016cc04:	e1a02283 	lsl	r2, r3, #5
8016cc08:	e51b3010 	ldr	r3, [fp, #-16]
8016cc0c:	e593300c 	ldr	r3, [r3, #12]
8016cc10:	e0823003 	add	r3, r2, r3
8016cc14:	e50b3008 	str	r3, [fp, #-8]
8016cc18:	e51b3008 	ldr	r3, [fp, #-8]
8016cc1c:	e1a00003 	mov	r0, r3
8016cc20:	ebffceb6 	bl	80160700 <__RME_A7A_Read_Acquire>
8016cc24:	e50b000c 	str	r0, [fp, #-12]
8016cc28:	e51b300c 	ldr	r3, [fp, #-12]
8016cc2c:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016cc30:	e3530802 	cmp	r3, #131072	@ 0x20000
8016cc34:	1a000001 	bne	8016cc40 <_RME_Kfn_Act+0x88>
8016cc38:	e3e03008 	mvn	r3, #8
8016cc3c:	ea00005b 	b	8016cdb0 <_RME_Kfn_Act+0x1f8>
8016cc40:	e51b300c 	ldr	r3, [fp, #-12]
8016cc44:	e1a03c23 	lsr	r3, r3, #24
8016cc48:	e3530001 	cmp	r3, #1
8016cc4c:	0a00003f 	beq	8016cd50 <_RME_Kfn_Act+0x198>
8016cc50:	e3e03001 	mvn	r3, #1
8016cc54:	ea000055 	b	8016cdb0 <_RME_Kfn_Act+0x1f8>
8016cc58:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016cc5c:	e1a02423 	lsr	r2, r3, #8
8016cc60:	e51b3010 	ldr	r3, [fp, #-16]
8016cc64:	e5933014 	ldr	r3, [r3, #20]
8016cc68:	e1520003 	cmp	r2, r3
8016cc6c:	3a000001 	bcc	8016cc78 <_RME_Kfn_Act+0xc0>
8016cc70:	e3e03002 	mvn	r3, #2
8016cc74:	ea00004d 	b	8016cdb0 <_RME_Kfn_Act+0x1f8>
8016cc78:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016cc7c:	e1a03423 	lsr	r3, r3, #8
8016cc80:	e1a02283 	lsl	r2, r3, #5
8016cc84:	e51b3010 	ldr	r3, [fp, #-16]
8016cc88:	e593300c 	ldr	r3, [r3, #12]
8016cc8c:	e0823003 	add	r3, r2, r3
8016cc90:	e50b3008 	str	r3, [fp, #-8]
8016cc94:	e51b3008 	ldr	r3, [fp, #-8]
8016cc98:	e1a00003 	mov	r0, r3
8016cc9c:	ebffce97 	bl	80160700 <__RME_A7A_Read_Acquire>
8016cca0:	e50b000c 	str	r0, [fp, #-12]
8016cca4:	e51b300c 	ldr	r3, [fp, #-12]
8016cca8:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016ccac:	e3530802 	cmp	r3, #131072	@ 0x20000
8016ccb0:	1a000001 	bne	8016ccbc <_RME_Kfn_Act+0x104>
8016ccb4:	e3e03008 	mvn	r3, #8
8016ccb8:	ea00003c 	b	8016cdb0 <_RME_Kfn_Act+0x1f8>
8016ccbc:	e51b300c 	ldr	r3, [fp, #-12]
8016ccc0:	e1a03c23 	lsr	r3, r3, #24
8016ccc4:	e3530003 	cmp	r3, #3
8016ccc8:	0a000001 	beq	8016ccd4 <_RME_Kfn_Act+0x11c>
8016cccc:	e3e03001 	mvn	r3, #1
8016ccd0:	ea000036 	b	8016cdb0 <_RME_Kfn_Act+0x1f8>
8016ccd4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016ccd8:	e203207f 	and	r2, r3, #127	@ 0x7f
8016ccdc:	e51b3008 	ldr	r3, [fp, #-8]
8016cce0:	e5933014 	ldr	r3, [r3, #20]
8016cce4:	e1520003 	cmp	r2, r3
8016cce8:	3a000001 	bcc	8016ccf4 <_RME_Kfn_Act+0x13c>
8016ccec:	e3e03002 	mvn	r3, #2
8016ccf0:	ea00002e 	b	8016cdb0 <_RME_Kfn_Act+0x1f8>
8016ccf4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016ccf8:	e203307f 	and	r3, r3, #127	@ 0x7f
8016ccfc:	e1a02283 	lsl	r2, r3, #5
8016cd00:	e51b3008 	ldr	r3, [fp, #-8]
8016cd04:	e593300c 	ldr	r3, [r3, #12]
8016cd08:	e0823003 	add	r3, r2, r3
8016cd0c:	e50b3008 	str	r3, [fp, #-8]
8016cd10:	e51b3008 	ldr	r3, [fp, #-8]
8016cd14:	e1a00003 	mov	r0, r3
8016cd18:	ebffce78 	bl	80160700 <__RME_A7A_Read_Acquire>
8016cd1c:	e50b000c 	str	r0, [fp, #-12]
8016cd20:	e51b300c 	ldr	r3, [fp, #-12]
8016cd24:	e20338ff 	and	r3, r3, #16711680	@ 0xff0000
8016cd28:	e3530802 	cmp	r3, #131072	@ 0x20000
8016cd2c:	1a000001 	bne	8016cd38 <_RME_Kfn_Act+0x180>
8016cd30:	e3e03008 	mvn	r3, #8
8016cd34:	ea00001d 	b	8016cdb0 <_RME_Kfn_Act+0x1f8>
8016cd38:	e51b300c 	ldr	r3, [fp, #-12]
8016cd3c:	e1a03c23 	lsr	r3, r3, #24
8016cd40:	e3530001 	cmp	r3, #1
8016cd44:	0a000001 	beq	8016cd50 <_RME_Kfn_Act+0x198>
8016cd48:	e3e03001 	mvn	r3, #1
8016cd4c:	ea000017 	b	8016cdb0 <_RME_Kfn_Act+0x1f8>
                   struct RME_Cap_Kfn*,Kfn_Op,Type_Stat);    

    /* Check if the range of calling is allowed - kernel function specific */
    if((Func_ID>RME_KFN_FLAG_HIGH(Kfn_Op->Head.Flag))||
8016cd50:	e51b3008 	ldr	r3, [fp, #-8]
8016cd54:	e5933008 	ldr	r3, [r3, #8]
8016cd58:	e1a03823 	lsr	r3, r3, #16
8016cd5c:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
8016cd60:	e1520003 	cmp	r2, r3
8016cd64:	8a000005 	bhi	8016cd80 <_RME_Kfn_Act+0x1c8>
       (Func_ID<RME_KFN_FLAG_LOW(Kfn_Op->Head.Flag)))
8016cd68:	e51b3008 	ldr	r3, [fp, #-8]
8016cd6c:	e5933008 	ldr	r3, [r3, #8]
8016cd70:	e6ff3073 	uxth	r3, r3
    if((Func_ID>RME_KFN_FLAG_HIGH(Kfn_Op->Head.Flag))||
8016cd74:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
8016cd78:	e1520003 	cmp	r2, r3
8016cd7c:	2a000001 	bcs	8016cd88 <_RME_Kfn_Act+0x1d0>
    {
        RME_COV_MARKER();

        return RME_ERR_CPT_FLAG;
8016cd80:	e3e03006 	mvn	r3, #6
8016cd84:	ea000009 	b	8016cdb0 <_RME_Kfn_Act+0x1f8>
        RME_COV_MARKER();
        /* No action required */
    }

    /* Return whatever the function returns */
    return __RME_Kfn_Handler(Cpt,Reg,Func_ID,Sub_ID,Param1,Param2);
8016cd88:	e59b300c 	ldr	r3, [fp, #12]
8016cd8c:	e58d3004 	str	r3, [sp, #4]
8016cd90:	e59b3008 	ldr	r3, [fp, #8]
8016cd94:	e58d3000 	str	r3, [sp]
8016cd98:	e59b3004 	ldr	r3, [fp, #4]
8016cd9c:	e51b201c 	ldr	r2, [fp, #-28]	@ 0xffffffe4
8016cda0:	e51b1014 	ldr	r1, [fp, #-20]	@ 0xffffffec
8016cda4:	e51b0010 	ldr	r0, [fp, #-16]
8016cda8:	eb000369 	bl	8016db54 <__RME_Kfn_Handler>
8016cdac:	e1a03000 	mov	r3, r0
}
8016cdb0:	e1a00003 	mov	r0, r3
8016cdb4:	e24bd004 	sub	sp, fp, #4
8016cdb8:	e8bd8800 	pop	{fp, pc}

8016cdbc <main>:
Input       : None.
Output      : None.
Return      : int - This function never returns.
******************************************************************************/
int main(void)
{
8016cdbc:	e92d4800 	push	{fp, lr}
8016cdc0:	e28db004 	add	fp, sp, #4
	//RME_DBG_H(__RME_A7A_ID_ISAR0_Get());
	//RME_DBG_I(10);
	//RME_DBG_S("hello world\n");

   RME_Kmain();
8016cdc4:	ebffd001 	bl	80160dd0 <RME_Kmain>
    
    //test
    /* The main function of the kernel - we will start our kernel boot here */
    //_RME_Kmain(RME_KOM_STACK_ADDR);

    return 0;
8016cdc8:	e3a03000 	mov	r3, #0
}
8016cdcc:	e1a00003 	mov	r0, r3
8016cdd0:	e8bd8800 	pop	{fp, pc}

8016cdd4 <__RME_Putchar>:
Input       : char Char - The character to print.
Output      : None.
Return      : rme_ptr_t - Always 0.
******************************************************************************/
rme_ptr_t __RME_Putchar(char Char)
{
8016cdd4:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016cdd8:	e28db000 	add	fp, sp, #0
8016cddc:	e24dd00c 	sub	sp, sp, #12
8016cde0:	e1a03000 	mov	r3, r0
8016cde4:	e54b3005 	strb	r3, [fp, #-5]
    RME_A7A_PUTCHAR(Char);
8016cde8:	e301302c 	movw	r3, #4140	@ 0x102c
8016cdec:	e34e3000 	movt	r3, #57344	@ 0xe000
8016cdf0:	e5933000 	ldr	r3, [r3]
8016cdf4:	e2033008 	and	r3, r3, #8
8016cdf8:	e3530000 	cmp	r3, #0
8016cdfc:	0afffff9 	beq	8016cde8 <__RME_Putchar+0x14>
8016ce00:	e3013030 	movw	r3, #4144	@ 0x1030
8016ce04:	e34e3000 	movt	r3, #57344	@ 0xe000
8016ce08:	e15b20d5 	ldrsb	r2, [fp, #-5]
8016ce0c:	e5832000 	str	r2, [r3]
    return 0;
8016ce10:	e3a03000 	mov	r3, #0
}
8016ce14:	e1a00003 	mov	r0, r3
8016ce18:	e28bd000 	add	sp, fp, #0
8016ce1c:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016ce20:	e12fff1e 	bx	lr

8016ce24 <__RME_A7A_Int_Init>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
void __RME_A7A_Int_Init(void)
{
8016ce24:	e92d4800 	push	{fp, lr}
8016ce28:	e28db004 	add	fp, sp, #4
8016ce2c:	e24dd008 	sub	sp, sp, #8
    rme_ptr_t Temp;
    rme_ptr_t Lines;

    /* Who implemented the GIC, what variant, how many interrupts? */
    Temp=RME_A7A_GICD_IIDR;
8016ce30:	e3013008 	movw	r3, #4104	@ 0x1008
8016ce34:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016ce38:	e5933000 	ldr	r3, [r3]
8016ce3c:	e50b3008 	str	r3, [fp, #-8]
    RME_DBG_S("\r\nA7A-GIC: ProductID: ");
8016ce40:	e30e0c5c 	movw	r0, #60508	@ 0xec5c
8016ce44:	e3480016 	movt	r0, #32790	@ 0x8016
8016ce48:	ebffcf31 	bl	80160b14 <RME_Str_Print>
    RME_DBG_I(Temp>>24);
8016ce4c:	e51b3008 	ldr	r3, [fp, #-8]
8016ce50:	e1a03c23 	lsr	r3, r3, #24
8016ce54:	e1a00003 	mov	r0, r3
8016ce58:	ebffce8c 	bl	80160890 <RME_Int_Print>
    RME_DBG_S("\r\nA7A-GIC: Variant: ");
8016ce5c:	e30e0c74 	movw	r0, #60532	@ 0xec74
8016ce60:	e3480016 	movt	r0, #32790	@ 0x8016
8016ce64:	ebffcf2a 	bl	80160b14 <RME_Str_Print>
    RME_DBG_I((Temp>>20)&0xF);
8016ce68:	e51b3008 	ldr	r3, [fp, #-8]
8016ce6c:	e1a03a23 	lsr	r3, r3, #20
8016ce70:	e203300f 	and	r3, r3, #15
8016ce74:	e1a00003 	mov	r0, r3
8016ce78:	ebffce84 	bl	80160890 <RME_Int_Print>
    RME_DBG_S("\r\nA7A-GIC: Revision: ");
8016ce7c:	e30e0c8c 	movw	r0, #60556	@ 0xec8c
8016ce80:	e3480016 	movt	r0, #32790	@ 0x8016
8016ce84:	ebffcf22 	bl	80160b14 <RME_Str_Print>
    RME_DBG_I((Temp>>12)&0xF);
8016ce88:	e51b3008 	ldr	r3, [fp, #-8]
8016ce8c:	e1a03623 	lsr	r3, r3, #12
8016ce90:	e203300f 	and	r3, r3, #15
8016ce94:	e1a00003 	mov	r0, r3
8016ce98:	ebffce7c 	bl	80160890 <RME_Int_Print>
    RME_DBG_S("\r\nA7A-GIC: Implementer: 0x");
8016ce9c:	e30e0ca4 	movw	r0, #60580	@ 0xeca4
8016cea0:	e3480016 	movt	r0, #32790	@ 0x8016
8016cea4:	ebffcf1a 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(Temp&0xFFF);
8016cea8:	e51b3008 	ldr	r3, [fp, #-8]
8016ceac:	e7eb3053 	ubfx	r3, r3, #0, #12
8016ceb0:	e1a00003 	mov	r0, r3
8016ceb4:	ebffced4 	bl	80160a0c <RME_Hex_Print>

    /* How many locked SPIs, security extension enabled or not, number of
     * actual CPUs and interrupt lines */
    Temp=RME_A7A_GICD_TYPER;
8016ceb8:	e3013004 	movw	r3, #4100	@ 0x1004
8016cebc:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016cec0:	e5933000 	ldr	r3, [r3]
8016cec4:	e50b3008 	str	r3, [fp, #-8]
    RME_DBG_S("\r\nA7A-GIC: SPI number: ");
8016cec8:	e30e0cc0 	movw	r0, #60608	@ 0xecc0
8016cecc:	e3480016 	movt	r0, #32790	@ 0x8016
8016ced0:	ebffcf0f 	bl	80160b14 <RME_Str_Print>
    RME_DBG_I(Temp>>16);
8016ced4:	e51b3008 	ldr	r3, [fp, #-8]
8016ced8:	e1a03823 	lsr	r3, r3, #16
8016cedc:	e1a00003 	mov	r0, r3
8016cee0:	ebffce6a 	bl	80160890 <RME_Int_Print>
    RME_DBG_S("\r\nA7A-GIC: Security extension: ");
8016cee4:	e30e0cd8 	movw	r0, #60632	@ 0xecd8
8016cee8:	e3480016 	movt	r0, #32790	@ 0x8016
8016ceec:	ebffcf08 	bl	80160b14 <RME_Str_Print>
    RME_DBG_I((Temp>>10)&0x1);
8016cef0:	e51b3008 	ldr	r3, [fp, #-8]
8016cef4:	e1a03523 	lsr	r3, r3, #10
8016cef8:	e2033001 	and	r3, r3, #1
8016cefc:	e1a00003 	mov	r0, r3
8016cf00:	ebffce62 	bl	80160890 <RME_Int_Print>
    RME_DBG_S("\r\nA7A-GIC: CPU number: ");
8016cf04:	e30e0cf8 	movw	r0, #60664	@ 0xecf8
8016cf08:	e3480016 	movt	r0, #32790	@ 0x8016
8016cf0c:	ebffcf00 	bl	80160b14 <RME_Str_Print>
    RME_DBG_I(((Temp>>5)&0x7)+1);
8016cf10:	e51b3008 	ldr	r3, [fp, #-8]
8016cf14:	e1a032a3 	lsr	r3, r3, #5
8016cf18:	e2033007 	and	r3, r3, #7
8016cf1c:	e2833001 	add	r3, r3, #1
8016cf20:	e1a00003 	mov	r0, r3
8016cf24:	ebffce59 	bl	80160890 <RME_Int_Print>
    RME_DBG_S("\r\nA7A-GIC: Interrupt line number: ");
8016cf28:	e30e0d10 	movw	r0, #60688	@ 0xed10
8016cf2c:	e3480016 	movt	r0, #32790	@ 0x8016
8016cf30:	ebffcef7 	bl	80160b14 <RME_Str_Print>
    Lines=((Temp&0x1F)+1)*32;
8016cf34:	e51b3008 	ldr	r3, [fp, #-8]
8016cf38:	e203301f 	and	r3, r3, #31
8016cf3c:	e2833001 	add	r3, r3, #1
8016cf40:	e1a03283 	lsl	r3, r3, #5
8016cf44:	e50b300c 	str	r3, [fp, #-12]
    RME_DBG_I(Lines);
8016cf48:	e51b300c 	ldr	r3, [fp, #-12]
8016cf4c:	e1a00003 	mov	r0, r3
8016cf50:	ebffce4e 	bl	80160890 <RME_Int_Print>


#if(RME_A7A_GIC_TYPE==RME_A7A_GIC_V1)
    /* Initialize all vectors to group 0, and disable all */
	for(Temp=0;Temp<Lines/32;Temp++)
8016cf54:	e3a03000 	mov	r3, #0
8016cf58:	e50b3008 	str	r3, [fp, #-8]
8016cf5c:	ea00001a 	b	8016cfcc <__RME_A7A_Int_Init+0x1a8>
	{
		RME_A7A_GICD_ICPENDR(Temp)=0xFFFFFFFFU;
8016cf60:	e51b2008 	ldr	r2, [fp, #-8]
8016cf64:	e3a03e4a 	mov	r3, #1184	@ 0x4a0
8016cf68:	e3433e3c 	movt	r3, #15932	@ 0x3e3c
8016cf6c:	e0823003 	add	r3, r2, r3
8016cf70:	e1a03103 	lsl	r3, r3, #2
8016cf74:	e1a02003 	mov	r2, r3
8016cf78:	e3e03000 	mvn	r3, #0
8016cf7c:	e5823000 	str	r3, [r2]
		RME_A7A_GICD_IGROUPR(Temp)=0x00000000U;
8016cf80:	e51b2008 	ldr	r2, [fp, #-8]
8016cf84:	e3a03e42 	mov	r3, #1056	@ 0x420
8016cf88:	e3433e3c 	movt	r3, #15932	@ 0x3e3c
8016cf8c:	e0823003 	add	r3, r2, r3
8016cf90:	e1a03103 	lsl	r3, r3, #2
8016cf94:	e1a02003 	mov	r2, r3
8016cf98:	e3a03000 	mov	r3, #0
8016cf9c:	e5823000 	str	r3, [r2]
		RME_A7A_GICD_ICENABLER(Temp)=0xFFFFFFFFU;
8016cfa0:	e51b2008 	ldr	r2, [fp, #-8]
8016cfa4:	e3a03e46 	mov	r3, #1120	@ 0x460
8016cfa8:	e3433e3c 	movt	r3, #15932	@ 0x3e3c
8016cfac:	e0823003 	add	r3, r2, r3
8016cfb0:	e1a03103 	lsl	r3, r3, #2
8016cfb4:	e1a02003 	mov	r2, r3
8016cfb8:	e3e03000 	mvn	r3, #0
8016cfbc:	e5823000 	str	r3, [r2]
	for(Temp=0;Temp<Lines/32;Temp++)
8016cfc0:	e51b3008 	ldr	r3, [fp, #-8]
8016cfc4:	e2833001 	add	r3, r3, #1
8016cfc8:	e50b3008 	str	r3, [fp, #-8]
8016cfcc:	e51b300c 	ldr	r3, [fp, #-12]
8016cfd0:	e1a032a3 	lsr	r3, r3, #5
8016cfd4:	e51b2008 	ldr	r2, [fp, #-8]
8016cfd8:	e1520003 	cmp	r2, r3
8016cfdc:	3affffdf 	bcc	8016cf60 <__RME_A7A_Int_Init+0x13c>
	}

	/* Set the priority of all such interrupts to the lowest level */
	for(Temp=0;Temp<Lines/4;Temp++)
8016cfe0:	e3a03000 	mov	r3, #0
8016cfe4:	e50b3008 	str	r3, [fp, #-8]
8016cfe8:	ea00000b 	b	8016d01c <__RME_A7A_Int_Init+0x1f8>
		RME_A7A_GICD_IPRIORITYR(Temp)=0xA0A0A0A0U;
8016cfec:	e51b2008 	ldr	r2, [fp, #-8]
8016cff0:	e3a03c05 	mov	r3, #1280	@ 0x500
8016cff4:	e3433e3c 	movt	r3, #15932	@ 0x3e3c
8016cff8:	e0823003 	add	r3, r2, r3
8016cffc:	e1a03103 	lsl	r3, r3, #2
8016d000:	e1a02003 	mov	r2, r3
8016d004:	e30a30a0 	movw	r3, #41120	@ 0xa0a0
8016d008:	e34a30a0 	movt	r3, #41120	@ 0xa0a0
8016d00c:	e5823000 	str	r3, [r2]
	for(Temp=0;Temp<Lines/4;Temp++)
8016d010:	e51b3008 	ldr	r3, [fp, #-8]
8016d014:	e2833001 	add	r3, r3, #1
8016d018:	e50b3008 	str	r3, [fp, #-8]
8016d01c:	e51b300c 	ldr	r3, [fp, #-12]
8016d020:	e1a03123 	lsr	r3, r3, #2
8016d024:	e51b2008 	ldr	r2, [fp, #-8]
8016d028:	e1520003 	cmp	r2, r3
8016d02c:	3affffee 	bcc	8016cfec <__RME_A7A_Int_Init+0x1c8>

	/* All interrupts target CPU0 */
	for(Temp=8;Temp<Lines/4;Temp++)
8016d030:	e3a03008 	mov	r3, #8
8016d034:	e50b3008 	str	r3, [fp, #-8]
8016d038:	ea00000b 	b	8016d06c <__RME_A7A_Int_Init+0x248>
		RME_A7A_GICD_ITARGETSR(Temp)=0x01010101U;
8016d03c:	e51b2008 	ldr	r2, [fp, #-8]
8016d040:	e3a03c06 	mov	r3, #1536	@ 0x600
8016d044:	e3433e3c 	movt	r3, #15932	@ 0x3e3c
8016d048:	e0823003 	add	r3, r2, r3
8016d04c:	e1a03103 	lsl	r3, r3, #2
8016d050:	e1a02003 	mov	r2, r3
8016d054:	e3003101 	movw	r3, #257	@ 0x101
8016d058:	e3403101 	movt	r3, #257	@ 0x101
8016d05c:	e5823000 	str	r3, [r2]
	for(Temp=8;Temp<Lines/4;Temp++)
8016d060:	e51b3008 	ldr	r3, [fp, #-8]
8016d064:	e2833001 	add	r3, r3, #1
8016d068:	e50b3008 	str	r3, [fp, #-8]
8016d06c:	e51b300c 	ldr	r3, [fp, #-12]
8016d070:	e1a03123 	lsr	r3, r3, #2
8016d074:	e51b2008 	ldr	r2, [fp, #-8]
8016d078:	e1520003 	cmp	r2, r3
8016d07c:	3affffee 	bcc	8016d03c <__RME_A7A_Int_Init+0x218>

	/* All interrupts are edge triggered, and use 1-N model */
	for(Temp=0;Temp<Lines/16;Temp++)
8016d080:	e3a03000 	mov	r3, #0
8016d084:	e50b3008 	str	r3, [fp, #-8]
8016d088:	ea00000b 	b	8016d0bc <__RME_A7A_Int_Init+0x298>
		RME_A7A_GICD_ICFGR(Temp)=0x55555555U;
8016d08c:	e51b2008 	ldr	r2, [fp, #-8]
8016d090:	e3a03c07 	mov	r3, #1792	@ 0x700
8016d094:	e3433e3c 	movt	r3, #15932	@ 0x3e3c
8016d098:	e0823003 	add	r3, r2, r3
8016d09c:	e1a03103 	lsl	r3, r3, #2
8016d0a0:	e1a02003 	mov	r2, r3
8016d0a4:	e3053555 	movw	r3, #21845	@ 0x5555
8016d0a8:	e3453555 	movt	r3, #21845	@ 0x5555
8016d0ac:	e5823000 	str	r3, [r2]
	for(Temp=0;Temp<Lines/16;Temp++)
8016d0b0:	e51b3008 	ldr	r3, [fp, #-8]
8016d0b4:	e2833001 	add	r3, r3, #1
8016d0b8:	e50b3008 	str	r3, [fp, #-8]
8016d0bc:	e51b300c 	ldr	r3, [fp, #-12]
8016d0c0:	e1a03223 	lsr	r3, r3, #4
8016d0c4:	e51b2008 	ldr	r2, [fp, #-8]
8016d0c8:	e1520003 	cmp	r2, r3
8016d0cc:	3affffee 	bcc	8016d08c <__RME_A7A_Int_Init+0x268>

	/* Enable the interrupt controller */
	RME_A7A_GICD_CTLR=RME_A7A_GICD_CTLR_GRP1EN|RME_A7A_GICD_CTLR_GRP0EN;
8016d0d0:	e3a03a01 	mov	r3, #4096	@ 0x1000
8016d0d4:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016d0d8:	e3a02003 	mov	r2, #3
8016d0dc:	e5832000 	str	r2, [r3]
    	RME_A7A_GICD_ICFGR(Temp)=0xFFFFFFFFU;

    /* Enable the interrupt controller */
    RME_A7A_GICD_CTLR=RME_A7A_GICD_CTLR_GRP1EN|RME_A7A_GICD_CTLR_GRP0EN;
#endif
}
8016d0e0:	e320f000 	nop	{0}
8016d0e4:	e24bd004 	sub	sp, fp, #4
8016d0e8:	e8bd8800 	pop	{fp, pc}

8016d0ec <__RME_A7A_Int_Local_Init>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
void __RME_A7A_Int_Local_Init(void)
{
8016d0ec:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016d0f0:	e28db000 	add	fp, sp, #0
	/* Priority grouping */
	RME_A7A_GICC_BPR=RME_A7A_GIC_GROUPING;
8016d0f4:	e3a03f41 	mov	r3, #260	@ 0x104
8016d0f8:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016d0fc:	e3a02000 	mov	r2, #0
8016d100:	e5832000 	str	r2, [r3]

#if(RME_A7A_GIC_TYPE==RME_A7A_GIC_V1)
	/* Enable all interrupts to this interface - FIQ is bypassed, and all
	 * interrupts go through the IRQ. The FIQ feature is only available on
	 * the standalone FIQ interrupt line */
	RME_A7A_GICC_CTLR=RME_A7A_GICC_ENABLEGRP0;
8016d104:	e3a03c01 	mov	r3, #256	@ 0x100
8016d108:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016d10c:	e3a02001 	mov	r2, #1
8016d110:	e5832000 	str	r2, [r3]

	/* No interrupts are masked - This must be set at last because enabling
	 * will trash the contents of this register if previously set. To maintain
	 * compatibility across all possible implementations, no priority level
	 * lower than 0xF0 will be considered valid */
	RME_A7A_GICC_PMR=0xF0U;
8016d114:	e3a03f41 	mov	r3, #260	@ 0x104
8016d118:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016d11c:	e3a020f0 	mov	r2, #240	@ 0xf0
8016d120:	e5832000 	str	r2, [r3]
}
8016d124:	e320f000 	nop	{0}
8016d128:	e28bd000 	add	sp, fp, #0
8016d12c:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016d130:	e12fff1e 	bx	lr

8016d134 <__RME_A7A_Timer_Init>:
Input       : None.
Output      : None.
Return      : None.
******************************************************************************/
void __RME_A7A_Timer_Init(void)
{
8016d134:	e92d4800 	push	{fp, lr}
8016d138:	e28db004 	add	fp, sp, #4
	RME_DBG_S("\r\ntimer init begin");
8016d13c:	e30e0d34 	movw	r0, #60724	@ 0xed34
8016d140:	e3480016 	movt	r0, #32790	@ 0x8016
8016d144:	ebffce72 	bl	80160b14 <RME_Str_Print>
#if((RME_A7A_CPU_TYPE==RME_A7A_CPU_CORTEX_A5)|| \
	(RME_A7A_CPU_TYPE==RME_A7A_CPU_CORTEX_A9))
    /* Writing this will also write the counter register as well */
    RME_A7A_PTWD_PTLR=RME_A7A_SYSTICK_VAL;
8016d148:	e3a03c06 	mov	r3, #1536	@ 0x600
8016d14c:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016d150:	e30e2358 	movw	r2, #58200	@ 0xe358
8016d154:	e3402032 	movt	r2, #50	@ 0x32
8016d158:	e5832000 	str	r2, [r3]
    /* Clear the interrupt flag */
    RME_A7A_PTWD_PTISR=0;
8016d15c:	e300360c 	movw	r3, #1548	@ 0x60c
8016d160:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016d164:	e3a02000 	mov	r2, #0
8016d168:	e5832000 	str	r2, [r3]
                         RME_A7A_PTWD_PTCTLR_IRQEN|
						 RME_A7A_PTWD_PTCTLR_AUTOREL|
						 RME_A7A_PTWD_PTCTLR_TIMEN;*/
//RME_A7A_PTWD_PTLR
    /* Enable the timer interrupt in the GIC */
    RME_A7A_GICD_ISENABLER(0)|=1<<29;
8016d16c:	e3a03c11 	mov	r3, #4352	@ 0x1100
8016d170:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016d174:	e5932000 	ldr	r2, [r3]
8016d178:	e3a03c11 	mov	r3, #4352	@ 0x1100
8016d17c:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016d180:	e3822202 	orr	r2, r2, #536870912	@ 0x20000000
8016d184:	e5832000 	str	r2, [r3]
#endif

	// init global timer here
	// global timer free-running
	// 0-0xFFFFFFFF
	RME_A7A_GTWD_GTCR0=RME_A7A_SYSTICK_VAL;
8016d188:	e3a03c02 	mov	r3, #512	@ 0x200
8016d18c:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016d190:	e30e2358 	movw	r2, #58200	@ 0xe358
8016d194:	e3402032 	movt	r2, #50	@ 0x32
8016d198:	e5832000 	str	r2, [r3]
    RME_A7A_GTWD_GTCTLR=RME_A7A_GTWD_GTCTLR_TIMEN;
8016d19c:	e3a03f82 	mov	r3, #520	@ 0x208
8016d1a0:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016d1a4:	e3a02001 	mov	r2, #1
8016d1a8:	e5832000 	str	r2, [r3]


    RME_DBG_S("\r\ntimer init finish");
8016d1ac:	e30e0d48 	movw	r0, #60744	@ 0xed48
8016d1b0:	e3480016 	movt	r0, #32790	@ 0x8016
8016d1b4:	ebffce56 	bl	80160b14 <RME_Str_Print>

}
8016d1b8:	e320f000 	nop	{0}
8016d1bc:	e8bd8800 	pop	{fp, pc}

8016d1c0 <__RME_Lowlvl_Init>:
Input       : None.
Output      : None.
Return      : rme_ptr_t - Always 0.
******************************************************************************/
void __RME_Lowlvl_Init(void)
{
8016d1c0:	e92d4800 	push	{fp, lr}
8016d1c4:	e28db004 	add	fp, sp, #4
    /* Initialize hardware */
    RME_A7A_LOW_LEVEL_INIT();

    /* Initialize our own CPU-local data structure */
    _RME_CPU_Local_Init(&RME_A7A_Local,0);
8016d1c8:	e3a01000 	mov	r1, #0
8016d1cc:	e3000004 	movw	r0, #4
8016d1d0:	e3480017 	movt	r0, #32791	@ 0x8017
8016d1d4:	ebffe18a 	bl	80165804 <_RME_CPU_Local_Init>

    /* Initialize the interrupt controller */
    __RME_A7A_Int_Init();
8016d1d8:	ebffff11 	bl	8016ce24 <__RME_A7A_Int_Init>

    /* Initialize CPU-local interrupt resources */
	__RME_A7A_Int_Local_Init();
8016d1dc:	ebffffc2 	bl	8016d0ec <__RME_A7A_Int_Local_Init>

    /* Initialize the vector table */
    RME_DBG_S("\r\nA7A-Vector: 0x");
8016d1e0:	e30e0d5c 	movw	r0, #60764	@ 0xed5c
8016d1e4:	e3480016 	movt	r0, #32790	@ 0x8016
8016d1e8:	ebffce49 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H((rme_ptr_t)&__RME_A7A_Vector_Table);
8016d1ec:	e3003000 	movw	r3, #0
8016d1f0:	e3483016 	movt	r3, #32790	@ 0x8016
8016d1f4:	e1a00003 	mov	r0, r3
8016d1f8:	ebffce03 	bl	80160a0c <RME_Hex_Print>
    __RME_A7A_VBAR_Set((rme_ptr_t)&__RME_A7A_Vector_Table);
8016d1fc:	e3003000 	movw	r3, #0
8016d200:	e3483016 	movt	r3, #32790	@ 0x8016
8016d204:	e1a00003 	mov	r0, r3
8016d208:	ebffcd04 	bl	80160620 <__RME_A7A_VBAR_Set>

    RME_DBG_S("\r\nA7A-Non-Secure: ");
8016d20c:	e30e0d70 	movw	r0, #60784	@ 0xed70
8016d210:	e3480016 	movt	r0, #32790	@ 0x8016
8016d214:	ebffce3e 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(__RME_A7A_SCR_Get());
8016d218:	ebffcbbe 	bl	80160118 <__RME_A7A_SCR_Get>
8016d21c:	e1a03000 	mov	r3, r0
8016d220:	e1a00003 	mov	r0, r3
8016d224:	ebffcdf8 	bl	80160a0c <RME_Hex_Print>
}
8016d228:	e320f000 	nop	{0}
8016d22c:	e8bd8800 	pop	{fp, pc}

8016d230 <__RME_Pgt_Kom_Init>:
Input       : None.
Output      : None.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Kom_Init(void)
{
8016d230:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016d234:	e28db000 	add	fp, sp, #0
	/* Use initial page table here instead for kernel, which is sufficient */

    return 0;
8016d238:	e3a03000 	mov	r3, #0
}
8016d23c:	e1a00003 	mov	r0, r3
8016d240:	e28bd000 	add	sp, fp, #0
8016d244:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016d248:	e12fff1e 	bx	lr

8016d24c <__RME_Boot>:
Input       : None.
Output      : None.
Return      : rme_ptr_t - Always 0.
******************************************************************************/
void __RME_Boot(void)
{
8016d24c:	e92d4800 	push	{fp, lr}
8016d250:	e28db004 	add	fp, sp, #4
8016d254:	e24dd018 	sub	sp, sp, #24
    rme_ptr_t Count;
    rme_ptr_t Cur_Addr;

    Cur_Addr=RME_KOM_VA_BASE;
8016d258:	e3a03481 	mov	r3, #-2130706432	@ 0x81000000
8016d25c:	e50b300c 	str	r3, [fp, #-12]

    /* Create the capability table for the init process */
    RME_DBG_S("\r\nCreating boot-time capability table @ ");
8016d260:	e30e0d84 	movw	r0, #60804	@ 0xed84
8016d264:	e3480016 	movt	r0, #32790	@ 0x8016
8016d268:	ebffce29 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(Cur_Addr);
8016d26c:	e51b000c 	ldr	r0, [fp, #-12]
8016d270:	ebffcde5 	bl	80160a0c <RME_Hex_Print>
    RME_ASSERT(_RME_Cpt_Boot_Init(RME_BOOT_INIT_CPT,
8016d274:	e3a02080 	mov	r2, #128	@ 0x80
8016d278:	e51b100c 	ldr	r1, [fp, #-12]
8016d27c:	e3a00000 	mov	r0, #0
8016d280:	ebffd149 	bl	801617ac <_RME_Cpt_Boot_Init>
8016d284:	e1a03000 	mov	r3, r0
8016d288:	e3530000 	cmp	r3, #0
8016d28c:	0a000008 	beq	8016d2b4 <__RME_Boot+0x68>
8016d290:	e30e3db0 	movw	r3, #60848	@ 0xedb0
8016d294:	e3483016 	movt	r3, #32790	@ 0x8016
8016d298:	e30e2dbc 	movw	r2, #60860	@ 0xedbc
8016d29c:	e3482016 	movt	r2, #32790	@ 0x8016
8016d2a0:	e30011d1 	movw	r1, #465	@ 0x1d1
8016d2a4:	e30e0dc8 	movw	r0, #60872	@ 0xedc8
8016d2a8:	e3480016 	movt	r0, #32790	@ 0x8016
8016d2ac:	ebffce37 	bl	80160b90 <RME_Log>
8016d2b0:	eafffffe 	b	8016d2b0 <__RME_Boot+0x64>
                                  Cur_Addr,
                                  RME_A7A_INIT_CPT_SIZE)==0);
    Cur_Addr+=RME_KOM_ROUND(RME_CPT_SIZE(RME_A7A_INIT_CPT_SIZE));
8016d2b4:	e51b300c 	ldr	r3, [fp, #-12]
8016d2b8:	e2833a01 	add	r3, r3, #4096	@ 0x1000
8016d2bc:	e50b300c 	str	r3, [fp, #-12]

    /* The top-level page table - covers 1M address range - align to 16kB */
    Cur_Addr=RME_ROUND_UP(Cur_Addr,16U);
8016d2c0:	e51b300c 	ldr	r3, [fp, #-12]
8016d2c4:	e2833cff 	add	r3, r3, #65280	@ 0xff00
8016d2c8:	e28330ff 	add	r3, r3, #255	@ 0xff
8016d2cc:	e1a03823 	lsr	r3, r3, #16
8016d2d0:	e1a03803 	lsl	r3, r3, #16
8016d2d4:	e50b300c 	str	r3, [fp, #-12]
    RME_DBG_S("\r\nCreating boot-time page table @ ");
8016d2d8:	e30e0df8 	movw	r0, #60920	@ 0xedf8
8016d2dc:	e3480016 	movt	r0, #32790	@ 0x8016
8016d2e0:	ebffce0b 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(Cur_Addr);
8016d2e4:	e51b000c 	ldr	r0, [fp, #-12]
8016d2e8:	ebffcdc7 	bl	80160a0c <RME_Hex_Print>
    RME_ASSERT(_RME_Pgt_Boot_Crt(RME_A7A_CPT,
8016d2ec:	e3a0300c 	mov	r3, #12
8016d2f0:	e58d300c 	str	r3, [sp, #12]
8016d2f4:	e3a03014 	mov	r3, #20
8016d2f8:	e58d3008 	str	r3, [sp, #8]
8016d2fc:	e3a03001 	mov	r3, #1
8016d300:	e58d3004 	str	r3, [sp, #4]
8016d304:	e3a03000 	mov	r3, #0
8016d308:	e58d3000 	str	r3, [sp]
8016d30c:	e51b300c 	ldr	r3, [fp, #-12]
8016d310:	e3a02001 	mov	r2, #1
8016d314:	e3a01000 	mov	r1, #0
8016d318:	e3a00481 	mov	r0, #-2130706432	@ 0x81000000
8016d31c:	ebffd732 	bl	80162fec <_RME_Pgt_Boot_Crt>
8016d320:	e1a03000 	mov	r3, r0
8016d324:	e3530000 	cmp	r3, #0
8016d328:	0a000008 	beq	8016d350 <__RME_Boot+0x104>
8016d32c:	e30e3db0 	movw	r3, #60848	@ 0xedb0
8016d330:	e3483016 	movt	r3, #32790	@ 0x8016
8016d334:	e30e2dbc 	movw	r2, #60860	@ 0xedbc
8016d338:	e3482016 	movt	r2, #32790	@ 0x8016
8016d33c:	e30011da 	movw	r1, #474	@ 0x1da
8016d340:	e30e0dc8 	movw	r0, #60872	@ 0xedc8
8016d344:	e3480016 	movt	r0, #32790	@ 0x8016
8016d348:	ebffce10 	bl	80160b90 <RME_Log>
8016d34c:	eafffffe 	b	8016d34c <__RME_Boot+0x100>
                                 RME_PGT_TOP,
                                 RME_PGT_SIZE_1M,
                                 RME_PGT_NUM_4K)==0);

    /* Normal memory, 1GiB 0x00000000 -> 0x00000000 */
    for(Count=0U;Count<0x400U;Count++)
8016d350:	e3a03000 	mov	r3, #0
8016d354:	e50b3008 	str	r3, [fp, #-8]
8016d358:	ea000016 	b	8016d3b8 <__RME_Boot+0x16c>
    {
		RME_ASSERT(_RME_Pgt_Boot_Add(RME_A7A_CPT,
8016d35c:	e51b3008 	ldr	r3, [fp, #-8]
8016d360:	e1a02a03 	lsl	r2, r3, #20
8016d364:	e3a0301f 	mov	r3, #31
8016d368:	e58d3000 	str	r3, [sp]
8016d36c:	e51b3008 	ldr	r3, [fp, #-8]
8016d370:	e3a01001 	mov	r1, #1
8016d374:	e3a00481 	mov	r0, #-2130706432	@ 0x81000000
8016d378:	ebffd7fd 	bl	80163374 <_RME_Pgt_Boot_Add>
8016d37c:	e1a03000 	mov	r3, r0
8016d380:	e3530000 	cmp	r3, #0
8016d384:	0a000008 	beq	8016d3ac <__RME_Boot+0x160>
8016d388:	e30e3db0 	movw	r3, #60848	@ 0xedb0
8016d38c:	e3483016 	movt	r3, #32790	@ 0x8016
8016d390:	e30e2dbc 	movw	r2, #60860	@ 0xedbc
8016d394:	e3482016 	movt	r2, #32790	@ 0x8016
8016d398:	e30011e6 	movw	r1, #486	@ 0x1e6
8016d39c:	e30e0dc8 	movw	r0, #60872	@ 0xedc8
8016d3a0:	e3480016 	movt	r0, #32790	@ 0x8016
8016d3a4:	ebffcdf9 	bl	80160b90 <RME_Log>
8016d3a8:	eafffffe 	b	8016d3a8 <__RME_Boot+0x15c>
    for(Count=0U;Count<0x400U;Count++)
8016d3ac:	e51b3008 	ldr	r3, [fp, #-8]
8016d3b0:	e2833001 	add	r3, r3, #1
8016d3b4:	e50b3008 	str	r3, [fp, #-8]
8016d3b8:	e51b3008 	ldr	r3, [fp, #-8]
8016d3bc:	e3530b01 	cmp	r3, #1024	@ 0x400
8016d3c0:	3affffe5 	bcc	8016d35c <__RME_Boot+0x110>
									 Count*RME_POW2(RME_PGT_SIZE_1M),
									 Count,
                                     RME_PGT_ALL_DYN)==0);
    }
	/* Device memory 1, 512MiB 0x40000000 -> 0x40000000 */
    for(Count=0U;Count<0x200U;Count++)
8016d3c4:	e3a03000 	mov	r3, #0
8016d3c8:	e50b3008 	str	r3, [fp, #-8]
8016d3cc:	ea000018 	b	8016d434 <__RME_Boot+0x1e8>
    {
		RME_ASSERT(_RME_Pgt_Boot_Add(RME_A7A_CPT,
8016d3d0:	e51b3008 	ldr	r3, [fp, #-8]
8016d3d4:	e2833b01 	add	r3, r3, #1024	@ 0x400
8016d3d8:	e1a02a03 	lsl	r2, r3, #20
8016d3dc:	e51b3008 	ldr	r3, [fp, #-8]
8016d3e0:	e2833b01 	add	r3, r3, #1024	@ 0x400
8016d3e4:	e3a01003 	mov	r1, #3
8016d3e8:	e58d1000 	str	r1, [sp]
8016d3ec:	e3a01001 	mov	r1, #1
8016d3f0:	e3a00481 	mov	r0, #-2130706432	@ 0x81000000
8016d3f4:	ebffd7de 	bl	80163374 <_RME_Pgt_Boot_Add>
8016d3f8:	e1a03000 	mov	r3, r0
8016d3fc:	e3530000 	cmp	r3, #0
8016d400:	0a000008 	beq	8016d428 <__RME_Boot+0x1dc>
8016d404:	e30e3db0 	movw	r3, #60848	@ 0xedb0
8016d408:	e3483016 	movt	r3, #32790	@ 0x8016
8016d40c:	e30e2dbc 	movw	r2, #60860	@ 0xedbc
8016d410:	e3482016 	movt	r2, #32790	@ 0x8016
8016d414:	e30011ef 	movw	r1, #495	@ 0x1ef
8016d418:	e30e0dc8 	movw	r0, #60872	@ 0xedc8
8016d41c:	e3480016 	movt	r0, #32790	@ 0x8016
8016d420:	ebffcdda 	bl	80160b90 <RME_Log>
8016d424:	eafffffe 	b	8016d424 <__RME_Boot+0x1d8>
    for(Count=0U;Count<0x200U;Count++)
8016d428:	e51b3008 	ldr	r3, [fp, #-8]
8016d42c:	e2833001 	add	r3, r3, #1
8016d430:	e50b3008 	str	r3, [fp, #-8]
8016d434:	e51b3008 	ldr	r3, [fp, #-8]
8016d438:	e3530c02 	cmp	r3, #512	@ 0x200
8016d43c:	3affffe3 	bcc	8016d3d0 <__RME_Boot+0x184>
									 (Count+0x400U),
									 RME_PGT_READ|RME_PGT_WRITE)==0);
    }
    
    /* Device memory 2, 512MiB 0x60000000 -> 0xE0000000 */
    for(Count=0U;Count<0x200U;Count++)
8016d440:	e3a03000 	mov	r3, #0
8016d444:	e50b3008 	str	r3, [fp, #-8]
8016d448:	ea000018 	b	8016d4b0 <__RME_Boot+0x264>
    {
		RME_ASSERT(_RME_Pgt_Boot_Add(RME_A7A_CPT,
8016d44c:	e51b3008 	ldr	r3, [fp, #-8]
8016d450:	e2833c0e 	add	r3, r3, #3584	@ 0xe00
8016d454:	e1a02a03 	lsl	r2, r3, #20
8016d458:	e51b3008 	ldr	r3, [fp, #-8]
8016d45c:	e2833c06 	add	r3, r3, #1536	@ 0x600
8016d460:	e3a01003 	mov	r1, #3
8016d464:	e58d1000 	str	r1, [sp]
8016d468:	e3a01001 	mov	r1, #1
8016d46c:	e3a00481 	mov	r0, #-2130706432	@ 0x81000000
8016d470:	ebffd7bf 	bl	80163374 <_RME_Pgt_Boot_Add>
8016d474:	e1a03000 	mov	r3, r0
8016d478:	e3530000 	cmp	r3, #0
8016d47c:	0a000008 	beq	8016d4a4 <__RME_Boot+0x258>
8016d480:	e30e3db0 	movw	r3, #60848	@ 0xedb0
8016d484:	e3483016 	movt	r3, #32790	@ 0x8016
8016d488:	e30e2dbc 	movw	r2, #60860	@ 0xedbc
8016d48c:	e3482016 	movt	r2, #32790	@ 0x8016
8016d490:	e30011f9 	movw	r1, #505	@ 0x1f9
8016d494:	e30e0dc8 	movw	r0, #60872	@ 0xedc8
8016d498:	e3480016 	movt	r0, #32790	@ 0x8016
8016d49c:	ebffcdbb 	bl	80160b90 <RME_Log>
8016d4a0:	eafffffe 	b	8016d4a0 <__RME_Boot+0x254>
    for(Count=0U;Count<0x200U;Count++)
8016d4a4:	e51b3008 	ldr	r3, [fp, #-8]
8016d4a8:	e2833001 	add	r3, r3, #1
8016d4ac:	e50b3008 	str	r3, [fp, #-8]
8016d4b0:	e51b3008 	ldr	r3, [fp, #-8]
8016d4b4:	e3530c02 	cmp	r3, #512	@ 0x200
8016d4b8:	3affffe3 	bcc	8016d44c <__RME_Boot+0x200>
									 (Count+0xE00U)*RME_POW2(RME_PGT_SIZE_1M),
									 (Count+0x600U),
									 RME_PGT_READ|RME_PGT_WRITE)==0);
    }

    RME_DBG_S("\r\nFirst section's first entry ");
8016d4bc:	e30e0e1c 	movw	r0, #60956	@ 0xee1c
8016d4c0:	e3480016 	movt	r0, #32790	@ 0x8016
8016d4c4:	ebffcd92 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(RME_A7A_REG(Cur_Addr));
8016d4c8:	e51b300c 	ldr	r3, [fp, #-12]
8016d4cc:	e5933000 	ldr	r3, [r3]
8016d4d0:	e1a00003 	mov	r0, r3
8016d4d4:	ebffcd4c 	bl	80160a0c <RME_Hex_Print>
    RME_DBG_S(" @ ");
8016d4d8:	e30e0e3c 	movw	r0, #60988	@ 0xee3c
8016d4dc:	e3480016 	movt	r0, #32790	@ 0x8016
8016d4e0:	ebffcd8b 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(Cur_Addr);
8016d4e4:	e51b000c 	ldr	r0, [fp, #-12]
8016d4e8:	ebffcd47 	bl	80160a0c <RME_Hex_Print>

    RME_DBG_S("\r\nFirst section's 0x080th entry ");
8016d4ec:	e30e0e40 	movw	r0, #60992	@ 0xee40
8016d4f0:	e3480016 	movt	r0, #32790	@ 0x8016
8016d4f4:	ebffcd86 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(RME_A7A_REG(Cur_Addr+0x080*RME_WORD_BYTE));
8016d4f8:	e51b300c 	ldr	r3, [fp, #-12]
8016d4fc:	e2833c02 	add	r3, r3, #512	@ 0x200
8016d500:	e5933000 	ldr	r3, [r3]
8016d504:	e1a00003 	mov	r0, r3
8016d508:	ebffcd3f 	bl	80160a0c <RME_Hex_Print>
    RME_DBG_S(" @ ");
8016d50c:	e30e0e3c 	movw	r0, #60988	@ 0xee3c
8016d510:	e3480016 	movt	r0, #32790	@ 0x8016
8016d514:	ebffcd7e 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(Cur_Addr+0x080*RME_WORD_BYTE);
8016d518:	e51b300c 	ldr	r3, [fp, #-12]
8016d51c:	e2833c02 	add	r3, r3, #512	@ 0x200
8016d520:	e1a00003 	mov	r0, r3
8016d524:	ebffcd38 	bl	80160a0c <RME_Hex_Print>

    RME_DBG_S("\r\nSecond section's first entry ");
8016d528:	e30e0e64 	movw	r0, #61028	@ 0xee64
8016d52c:	e3480016 	movt	r0, #32790	@ 0x8016
8016d530:	ebffcd77 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(RME_A7A_REG(Cur_Addr+0x400*RME_WORD_BYTE));
8016d534:	e51b300c 	ldr	r3, [fp, #-12]
8016d538:	e2833a01 	add	r3, r3, #4096	@ 0x1000
8016d53c:	e5933000 	ldr	r3, [r3]
8016d540:	e1a00003 	mov	r0, r3
8016d544:	ebffcd30 	bl	80160a0c <RME_Hex_Print>
    RME_DBG_S(" @ ");
8016d548:	e30e0e3c 	movw	r0, #60988	@ 0xee3c
8016d54c:	e3480016 	movt	r0, #32790	@ 0x8016
8016d550:	ebffcd6f 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(Cur_Addr+0x400*RME_WORD_BYTE);
8016d554:	e51b300c 	ldr	r3, [fp, #-12]
8016d558:	e2833a01 	add	r3, r3, #4096	@ 0x1000
8016d55c:	e1a00003 	mov	r0, r3
8016d560:	ebffcd29 	bl	80160a0c <RME_Hex_Print>

    RME_DBG_S("\r\nThird section's first entry ");
8016d564:	e30e0e84 	movw	r0, #61060	@ 0xee84
8016d568:	e3480016 	movt	r0, #32790	@ 0x8016
8016d56c:	ebffcd68 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(RME_A7A_REG(Cur_Addr+0x600*RME_WORD_BYTE));
8016d570:	e51b300c 	ldr	r3, [fp, #-12]
8016d574:	e2833b06 	add	r3, r3, #6144	@ 0x1800
8016d578:	e5933000 	ldr	r3, [r3]
8016d57c:	e1a00003 	mov	r0, r3
8016d580:	ebffcd21 	bl	80160a0c <RME_Hex_Print>
    RME_DBG_S(" @ ");
8016d584:	e30e0e3c 	movw	r0, #60988	@ 0xee3c
8016d588:	e3480016 	movt	r0, #32790	@ 0x8016
8016d58c:	ebffcd60 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(Cur_Addr+0x600*RME_WORD_BYTE);
8016d590:	e51b300c 	ldr	r3, [fp, #-12]
8016d594:	e2833b06 	add	r3, r3, #6144	@ 0x1800
8016d598:	e1a00003 	mov	r0, r3
8016d59c:	ebffcd1a 	bl	80160a0c <RME_Hex_Print>

    RME_DBG_S("\r\nKernel pgtbl's 80th entry ");
8016d5a0:	e30e0ea4 	movw	r0, #61092	@ 0xeea4
8016d5a4:	e3480016 	movt	r0, #32790	@ 0x8016
8016d5a8:	ebffcd59 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(RME_A7A_REG(((rme_ptr_t)(&__RME_A7A_Kern_Pgt))+0x080*RME_WORD_BYTE));
8016d5ac:	e3003000 	movw	r3, #0
8016d5b0:	e3483015 	movt	r3, #32789	@ 0x8015
8016d5b4:	e2833c02 	add	r3, r3, #512	@ 0x200
8016d5b8:	e5933000 	ldr	r3, [r3]
8016d5bc:	e1a00003 	mov	r0, r3
8016d5c0:	ebffcd11 	bl	80160a0c <RME_Hex_Print>
    RME_DBG_S(" @ ");
8016d5c4:	e30e0e3c 	movw	r0, #60988	@ 0xee3c
8016d5c8:	e3480016 	movt	r0, #32790	@ 0x8016
8016d5cc:	ebffcd50 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(((rme_ptr_t)(&__RME_A7A_Kern_Pgt))+0x080*RME_WORD_BYTE);
8016d5d0:	e3003000 	movw	r3, #0
8016d5d4:	e3483015 	movt	r3, #32789	@ 0x8015
8016d5d8:	e2833c02 	add	r3, r3, #512	@ 0x200
8016d5dc:	e1a00003 	mov	r0, r3
8016d5e0:	ebffcd09 	bl	80160a0c <RME_Hex_Print>

    Cur_Addr+=RME_KOM_ROUND(RME_PGT_SIZE_TOP(RME_PGT_NUM_4K));
8016d5e4:	e51b300c 	ldr	r3, [fp, #-12]
8016d5e8:	e2833901 	add	r3, r3, #16384	@ 0x4000
8016d5ec:	e50b300c 	str	r3, [fp, #-12]

    /* Activate the first process - This process cannot be deleted */
    RME_DBG_S("\r\nstart prc creation.");
8016d5f0:	e30e0ec4 	movw	r0, #61124	@ 0xeec4
8016d5f4:	e3480016 	movt	r0, #32790	@ 0x8016
8016d5f8:	ebffcd45 	bl	80160b14 <RME_Str_Print>
    RME_ASSERT(_RME_Prc_Boot_Crt(RME_A7A_CPT,
8016d5fc:	e3a03001 	mov	r3, #1
8016d600:	e58d3000 	str	r3, [sp]
8016d604:	e3a03000 	mov	r3, #0
8016d608:	e3a02002 	mov	r2, #2
8016d60c:	e3a01000 	mov	r1, #0
8016d610:	e3a00481 	mov	r0, #-2130706432	@ 0x81000000
8016d614:	ebffe1ce 	bl	80165d54 <_RME_Prc_Boot_Crt>
8016d618:	e1a03000 	mov	r3, r0
8016d61c:	e3530000 	cmp	r3, #0
8016d620:	0a000008 	beq	8016d648 <__RME_Boot+0x3fc>
8016d624:	e30e3db0 	movw	r3, #60848	@ 0xedb0
8016d628:	e3483016 	movt	r3, #32790	@ 0x8016
8016d62c:	e30e2dbc 	movw	r2, #60860	@ 0xedbc
8016d630:	e3482016 	movt	r2, #32790	@ 0x8016
8016d634:	e300121d 	movw	r1, #541	@ 0x21d
8016d638:	e30e0dc8 	movw	r0, #60872	@ 0xedc8
8016d63c:	e3480016 	movt	r0, #32790	@ 0x8016
8016d640:	ebffcd52 	bl	80160b90 <RME_Log>
8016d644:	eafffffe 	b	8016d644 <__RME_Boot+0x3f8>
                                 RME_BOOT_INIT_PRC,
                                 RME_BOOT_INIT_CPT,
                                 RME_BOOT_INIT_PGT)==0U);

    /* Activate the first thread, and set its priority */
    RME_DBG_S("\r\nCreating boot-time thread @ ");
8016d648:	e30e0edc 	movw	r0, #61148	@ 0xeedc
8016d64c:	e3480016 	movt	r0, #32790	@ 0x8016
8016d650:	ebffcd2f 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(Cur_Addr);
8016d654:	e51b000c 	ldr	r0, [fp, #-12]
8016d658:	ebffcceb 	bl	80160a0c <RME_Hex_Print>
    RME_ASSERT(_RME_Thd_Boot_Crt(RME_A7A_CPT,
8016d65c:	e3003004 	movw	r3, #4
8016d660:	e3483017 	movt	r3, #32791	@ 0x8017
8016d664:	e58d3008 	str	r3, [sp, #8]
8016d668:	e3a03000 	mov	r3, #0
8016d66c:	e58d3004 	str	r3, [sp, #4]
8016d670:	e51b300c 	ldr	r3, [fp, #-12]
8016d674:	e58d3000 	str	r3, [sp]
8016d678:	e3a03002 	mov	r3, #2
8016d67c:	e3a02003 	mov	r2, #3
8016d680:	e3a01000 	mov	r1, #0
8016d684:	e3a00481 	mov	r0, #-2130706432	@ 0x81000000
8016d688:	ebffe786 	bl	801674a8 <_RME_Thd_Boot_Crt>
8016d68c:	e1a03000 	mov	r3, r0
8016d690:	e3530000 	cmp	r3, #0
8016d694:	0a000008 	beq	8016d6bc <__RME_Boot+0x470>
8016d698:	e30e3db0 	movw	r3, #60848	@ 0xedb0
8016d69c:	e3483016 	movt	r3, #32790	@ 0x8016
8016d6a0:	e30e2dbc 	movw	r2, #60860	@ 0xedbc
8016d6a4:	e3482016 	movt	r2, #32790	@ 0x8016
8016d6a8:	e3001226 	movw	r1, #550	@ 0x226
8016d6ac:	e30e0dc8 	movw	r0, #60872	@ 0xedc8
8016d6b0:	e3480016 	movt	r0, #32790	@ 0x8016
8016d6b4:	ebffcd35 	bl	80160b90 <RME_Log>
8016d6b8:	eafffffe 	b	8016d6b8 <__RME_Boot+0x46c>
                                 RME_BOOT_INIT_THD,
                                 RME_BOOT_INIT_PRC,
                                 Cur_Addr,
                                 0U,
                                 &RME_A7A_Local)==0);
    Cur_Addr+=RME_KOM_ROUND(RME_THD_SIZE(0U));
8016d6bc:	e51b300c 	ldr	r3, [fp, #-12]
8016d6c0:	e28330a0 	add	r3, r3, #160	@ 0xa0
8016d6c4:	e50b300c 	str	r3, [fp, #-12]
    RME_DBG_S("\r\nFinish creating boot-time thread @ ");
8016d6c8:	e30e0efc 	movw	r0, #61180	@ 0xeefc
8016d6cc:	e3480016 	movt	r0, #32790	@ 0x8016
8016d6d0:	ebffcd0f 	bl	80160b14 <RME_Str_Print>
    RME_DBG_H(Cur_Addr);
8016d6d4:	e51b000c 	ldr	r0, [fp, #-12]
8016d6d8:	ebffcccb 	bl	80160a0c <RME_Hex_Print>
    /* Create the initial kernel function capability, and kernel memory capability */
    RME_DBG_S("\r\nCreating boot-time kernel function");
8016d6dc:	e30e0f24 	movw	r0, #61220	@ 0xef24
8016d6e0:	e3480016 	movt	r0, #32790	@ 0x8016
8016d6e4:	ebffcd0a 	bl	80160b14 <RME_Str_Print>
    RME_ASSERT(_RME_Kfn_Boot_Crt(RME_A7A_CPT,
8016d6e8:	e3a02004 	mov	r2, #4
8016d6ec:	e3a01000 	mov	r1, #0
8016d6f0:	e3a00481 	mov	r0, #-2130706432	@ 0x81000000
8016d6f4:	ebfffc95 	bl	8016c950 <_RME_Kfn_Boot_Crt>
8016d6f8:	e1a03000 	mov	r3, r0
8016d6fc:	e3530000 	cmp	r3, #0
8016d700:	0a000008 	beq	8016d728 <__RME_Boot+0x4dc>
8016d704:	e30e3db0 	movw	r3, #60848	@ 0xedb0
8016d708:	e3483016 	movt	r3, #32790	@ 0x8016
8016d70c:	e30e2dbc 	movw	r2, #60860	@ 0xedbc
8016d710:	e3482016 	movt	r2, #32790	@ 0x8016
8016d714:	e3001232 	movw	r1, #562	@ 0x232
8016d718:	e30e0dc8 	movw	r0, #60872	@ 0xedc8
8016d71c:	e3480016 	movt	r0, #32790	@ 0x8016
8016d720:	ebffcd1a 	bl	80160b90 <RME_Log>
8016d724:	eafffffe 	b	8016d724 <__RME_Boot+0x4d8>
                                 RME_BOOT_INIT_CPT,
                                 RME_BOOT_INIT_KFN)==0);
    RME_DBG_S("\r\nCreating boot-time kernel memory");
8016d728:	e30e0f4c 	movw	r0, #61260	@ 0xef4c
8016d72c:	e3480016 	movt	r0, #32790	@ 0x8016
8016d730:	ebffccf7 	bl	80160b14 <RME_Str_Print>
    RME_ASSERT(_RME_Kom_Boot_Crt(RME_A7A_CPT, 
8016d734:	e3a0300f 	mov	r3, #15
8016d738:	e58d3004 	str	r3, [sp, #4]
8016d73c:	e3e0347e 	mvn	r3, #2113929216	@ 0x7e000000
8016d740:	e58d3000 	str	r3, [sp]
8016d744:	e3a03481 	mov	r3, #-2130706432	@ 0x81000000
8016d748:	e3a02005 	mov	r2, #5
8016d74c:	e3a01000 	mov	r1, #0
8016d750:	e3a00481 	mov	r0, #-2130706432	@ 0x81000000
8016d754:	ebffdf75 	bl	80165530 <_RME_Kom_Boot_Crt>
8016d758:	e1a03000 	mov	r3, r0
8016d75c:	e3530000 	cmp	r3, #0
8016d760:	0a000008 	beq	8016d788 <__RME_Boot+0x53c>
8016d764:	e30e3db0 	movw	r3, #60848	@ 0xedb0
8016d768:	e3483016 	movt	r3, #32790	@ 0x8016
8016d76c:	e30e2dbc 	movw	r2, #60860	@ 0xedbc
8016d770:	e3482016 	movt	r2, #32790	@ 0x8016
8016d774:	e3001236 	movw	r1, #566	@ 0x236
8016d778:	e30e0dc8 	movw	r0, #60872	@ 0xedc8
8016d77c:	e3480016 	movt	r0, #32790	@ 0x8016
8016d780:	ebffcd02 	bl	80160b90 <RME_Log>
8016d784:	eafffffe 	b	8016d784 <__RME_Boot+0x538>
                                 RME_KOM_VA_BASE,
                                 RME_KOM_VA_BASE+RME_KOM_VA_SIZE-1U,
                                 RME_KOM_FLAG_ALL)==0U);
    
    /* Create the initial kernel endpoint for timer ticks and interrupts */
    RME_A7A_Local.Sig_Tim=(struct RME_Cap_Sig*)&(RME_A7A_CPT[RME_BOOT_INIT_VCT]);
8016d788:	e3002004 	movw	r2, #4
8016d78c:	e3482017 	movt	r2, #32791	@ 0x8017
8016d790:	e3a030c0 	mov	r3, #192	@ 0xc0
8016d794:	e3483100 	movt	r3, #33024	@ 0x8100
8016d798:	e5823008 	str	r3, [r2, #8]
    RME_A7A_Local.Sig_Vct=(struct RME_Cap_Sig*)&(RME_A7A_CPT[RME_BOOT_INIT_VCT]);
8016d79c:	e3002004 	movw	r2, #4
8016d7a0:	e3482017 	movt	r2, #32791	@ 0x8017
8016d7a4:	e3a030c0 	mov	r3, #192	@ 0xc0
8016d7a8:	e3483100 	movt	r3, #33024	@ 0x8100
8016d7ac:	e582300c 	str	r3, [r2, #12]
    RME_DBG_S("\r\nCreate the initial kernel endpoint for timer ticks and interrupts");
8016d7b0:	e30e0f70 	movw	r0, #61296	@ 0xef70
8016d7b4:	e3480016 	movt	r0, #32790	@ 0x8016
8016d7b8:	ebffccd5 	bl	80160b14 <RME_Str_Print>
    RME_ASSERT(_RME_Sig_Boot_Crt(RME_A7A_CPT,
8016d7bc:	e3a02006 	mov	r2, #6
8016d7c0:	e3a01000 	mov	r1, #0
8016d7c4:	e3a00481 	mov	r0, #-2130706432	@ 0x81000000
8016d7c8:	ebfff3ad 	bl	8016a684 <_RME_Sig_Boot_Crt>
8016d7cc:	e1a03000 	mov	r3, r0
8016d7d0:	e3530000 	cmp	r3, #0
8016d7d4:	0a000008 	beq	8016d7fc <__RME_Boot+0x5b0>
8016d7d8:	e30e3db0 	movw	r3, #60848	@ 0xedb0
8016d7dc:	e3483016 	movt	r3, #32790	@ 0x8016
8016d7e0:	e30e2dbc 	movw	r2, #60860	@ 0xedbc
8016d7e4:	e3482016 	movt	r2, #32790	@ 0x8016
8016d7e8:	e3001241 	movw	r1, #577	@ 0x241
8016d7ec:	e30e0dc8 	movw	r0, #60872	@ 0xedc8
8016d7f0:	e3480016 	movt	r0, #32790	@ 0x8016
8016d7f4:	ebffcce5 	bl	80160b90 <RME_Log>
8016d7f8:	eafffffe 	b	8016d7f8 <__RME_Boot+0x5ac>
                                 RME_BOOT_INIT_CPT,
                                 RME_BOOT_INIT_VCT)==0);
    
    /* Set page table as current */
    __RME_Pgt_Set(RME_A7A_Local.Thd_Cur->Sched.Prc->Pgt);
8016d7fc:	e3003004 	movw	r3, #4
8016d800:	e3483017 	movt	r3, #32791	@ 0x8017
8016d804:	e5933004 	ldr	r3, [r3, #4]
8016d808:	e593302c 	ldr	r3, [r3, #44]	@ 0x2c
8016d80c:	e5933018 	ldr	r3, [r3, #24]
8016d810:	e1a00003 	mov	r0, r3
8016d814:	eb0001a4 	bl	8016deac <__RME_Pgt_Set>

    /* Initialize timer and enable interrupts */
    RME_DBG_S("\r\nenable interrupts\r\n");
8016d818:	e30e0fb4 	movw	r0, #61364	@ 0xefb4
8016d81c:	e3480016 	movt	r0, #32790	@ 0x8016
8016d820:	ebffccbb 	bl	80160b14 <RME_Str_Print>
	__RME_A7A_Timer_Init();
8016d824:	ebfffe42 	bl	8016d134 <__RME_A7A_Timer_Init>
    __RME_Int_Enable();
8016d828:	ebffcbbc 	bl	80160720 <__RME_Int_Enable>

    /* enable l2 cache */
    //__RME_L2CacheEnable();
    RME_DBG_S("\r\nenable l2 cache\r\n");
8016d82c:	e30e0fcc 	movw	r0, #61388	@ 0xefcc
8016d830:	e3480016 	movt	r0, #32790	@ 0x8016
8016d834:	ebffccb6 	bl	80160b14 <RME_Str_Print>
    /* Boot into the init thread */
    __RME_User_Enter(RME_A7A_INIT_ENTRY,RME_A7A_INIT_STACK,0U);
8016d838:	e3a02000 	mov	r2, #0
8016d83c:	e3a01cff 	mov	r1, #65280	@ 0xff00
8016d840:	e340181f 	movt	r1, #2079	@ 0x81f
8016d844:	e3a00901 	mov	r0, #16384	@ 0x4000
8016d848:	e3400800 	movt	r0, #2048	@ 0x800
8016d84c:	ebffcbbd 	bl	80160748 <__RME_User_Enter>
    
    /* Should never reach here */
    while(1);
8016d850:	eafffffe 	b	8016d850 <__RME_Boot+0x604>

8016d854 <__RME_Svc_Param_Get>:
              rme_ptr_t* Capid - The capability ID number.
              rme_ptr_t* Param - The parameters.
Return      : None.
******************************************************************************/
void __RME_Svc_Param_Get(struct RME_Reg_Struct* Reg,rme_ptr_t* Svc,rme_ptr_t* Capid,rme_ptr_t* Param)
{
8016d854:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016d858:	e28db000 	add	fp, sp, #0
8016d85c:	e24dd014 	sub	sp, sp, #20
8016d860:	e50b0008 	str	r0, [fp, #-8]
8016d864:	e50b100c 	str	r1, [fp, #-12]
8016d868:	e50b2010 	str	r2, [fp, #-16]
8016d86c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    *Svc=(Reg->R0)>>16;
8016d870:	e51b3008 	ldr	r3, [fp, #-8]
8016d874:	e5933004 	ldr	r3, [r3, #4]
8016d878:	e1a02823 	lsr	r2, r3, #16
8016d87c:	e51b300c 	ldr	r3, [fp, #-12]
8016d880:	e5832000 	str	r2, [r3]
    *Capid=(Reg->R0)&0xFFFF;
8016d884:	e51b3008 	ldr	r3, [fp, #-8]
8016d888:	e5933004 	ldr	r3, [r3, #4]
8016d88c:	e6ff2073 	uxth	r2, r3
8016d890:	e51b3010 	ldr	r3, [fp, #-16]
8016d894:	e5832000 	str	r2, [r3]
    Param[0]=Reg->R1;
8016d898:	e51b3008 	ldr	r3, [fp, #-8]
8016d89c:	e5932008 	ldr	r2, [r3, #8]
8016d8a0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016d8a4:	e5832000 	str	r2, [r3]
    Param[1]=Reg->R2;
8016d8a8:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016d8ac:	e2833004 	add	r3, r3, #4
8016d8b0:	e51b2008 	ldr	r2, [fp, #-8]
8016d8b4:	e592200c 	ldr	r2, [r2, #12]
8016d8b8:	e5832000 	str	r2, [r3]
    Param[2]=Reg->R3;
8016d8bc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016d8c0:	e2833008 	add	r3, r3, #8
8016d8c4:	e51b2008 	ldr	r2, [fp, #-8]
8016d8c8:	e5922010 	ldr	r2, [r2, #16]
8016d8cc:	e5832000 	str	r2, [r3]
}
8016d8d0:	e320f000 	nop	{0}
8016d8d4:	e28bd000 	add	sp, fp, #0
8016d8d8:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016d8dc:	e12fff1e 	bx	lr

8016d8e0 <__RME_Svc_Retval_Set>:
Input       : rme_ret_t Retval - The return value.
Output      : struct RME_Reg_Struct* Reg - The register set.
Return      : None.
******************************************************************************/
void __RME_Svc_Retval_Set(struct RME_Reg_Struct* Reg,rme_ret_t Retval)
{
8016d8e0:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016d8e4:	e28db000 	add	fp, sp, #0
8016d8e8:	e24dd00c 	sub	sp, sp, #12
8016d8ec:	e50b0008 	str	r0, [fp, #-8]
8016d8f0:	e50b100c 	str	r1, [fp, #-12]
    Reg->R0=(rme_ptr_t)Retval;
8016d8f4:	e51b200c 	ldr	r2, [fp, #-12]
8016d8f8:	e51b3008 	ldr	r3, [fp, #-8]
8016d8fc:	e5832004 	str	r2, [r3, #4]
}
8016d900:	e320f000 	nop	{0}
8016d904:	e28bd000 	add	sp, fp, #0
8016d908:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016d90c:	e12fff1e 	bx	lr

8016d910 <__RME_Thd_Reg_Init>:
Output      : struct RME_Reg_Struct* Reg - The register set content generated.
Return      : None.
******************************************************************************/
void __RME_Thd_Reg_Init(rme_ptr_t Attr,rme_ptr_t Entry,rme_ptr_t Stack,rme_ptr_t Param,
                                       struct RME_Reg_Struct* Reg)
{
8016d910:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016d914:	e28db000 	add	fp, sp, #0
8016d918:	e24dd014 	sub	sp, sp, #20
8016d91c:	e50b0008 	str	r0, [fp, #-8]
8016d920:	e50b100c 	str	r1, [fp, #-12]
8016d924:	e50b2010 	str	r2, [fp, #-16]
8016d928:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    /* Set the entry and stack */
    Reg->PC=Entry;
8016d92c:	e59b3004 	ldr	r3, [fp, #4]
8016d930:	e51b200c 	ldr	r2, [fp, #-12]
8016d934:	e583203c 	str	r2, [r3, #60]	@ 0x3c
    Reg->SP=Stack;
8016d938:	e59b3004 	ldr	r3, [fp, #4]
8016d93c:	e51b2010 	ldr	r2, [fp, #-16]
8016d940:	e5832034 	str	r2, [r3, #52]	@ 0x34
    /* LR needs to be a multiple of 4 upon return, ARMv7-A does not allow
     * unaligned LR upon exception entry. Setting it to PC for convenience. */
    Reg->LR=Entry;
8016d944:	e59b3004 	ldr	r3, [fp, #4]
8016d948:	e51b200c 	ldr	r2, [fp, #-12]
8016d94c:	e5832038 	str	r2, [r3, #56]	@ 0x38
    /* Set the parameter */
    Reg->R0=Param;
8016d950:	e59b3004 	ldr	r3, [fp, #4]
8016d954:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
8016d958:	e5832004 	str	r2, [r3, #4]
    /* Initialize CPSR */
    Reg->CPSR=0U;
8016d95c:	e59b3004 	ldr	r3, [fp, #4]
8016d960:	e3a02000 	mov	r2, #0
8016d964:	e5832000 	str	r2, [r3]
}
8016d968:	e320f000 	nop	{0}
8016d96c:	e28bd000 	add	sp, fp, #0
8016d970:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016d974:	e12fff1e 	bx	lr

8016d978 <__RME_Thd_Reg_Copy>:
Input       : struct RME_Reg_Struct* Src - The source register set.
Output      : struct RME_Reg_Struct* Dst - The destination register set.
Return      : None.
******************************************************************************/
void __RME_Thd_Reg_Copy(struct RME_Reg_Struct* Dst, struct RME_Reg_Struct* Src)
{
8016d978:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016d97c:	e28db000 	add	fp, sp, #0
8016d980:	e24dd00c 	sub	sp, sp, #12
8016d984:	e50b0008 	str	r0, [fp, #-8]
8016d988:	e50b100c 	str	r1, [fp, #-12]
    /* Make sure that the ordering is the same so the compiler can optimize */
    Dst->CPSR=Src->CPSR;
8016d98c:	e51b300c 	ldr	r3, [fp, #-12]
8016d990:	e5932000 	ldr	r2, [r3]
8016d994:	e51b3008 	ldr	r3, [fp, #-8]
8016d998:	e5832000 	str	r2, [r3]
    Dst->R0=Src->R0;
8016d99c:	e51b300c 	ldr	r3, [fp, #-12]
8016d9a0:	e5932004 	ldr	r2, [r3, #4]
8016d9a4:	e51b3008 	ldr	r3, [fp, #-8]
8016d9a8:	e5832004 	str	r2, [r3, #4]
    Dst->R1=Src->R1;
8016d9ac:	e51b300c 	ldr	r3, [fp, #-12]
8016d9b0:	e5932008 	ldr	r2, [r3, #8]
8016d9b4:	e51b3008 	ldr	r3, [fp, #-8]
8016d9b8:	e5832008 	str	r2, [r3, #8]
    Dst->R2=Src->R2;
8016d9bc:	e51b300c 	ldr	r3, [fp, #-12]
8016d9c0:	e593200c 	ldr	r2, [r3, #12]
8016d9c4:	e51b3008 	ldr	r3, [fp, #-8]
8016d9c8:	e583200c 	str	r2, [r3, #12]
    Dst->R3=Src->R3;
8016d9cc:	e51b300c 	ldr	r3, [fp, #-12]
8016d9d0:	e5932010 	ldr	r2, [r3, #16]
8016d9d4:	e51b3008 	ldr	r3, [fp, #-8]
8016d9d8:	e5832010 	str	r2, [r3, #16]
    Dst->R4=Src->R4;
8016d9dc:	e51b300c 	ldr	r3, [fp, #-12]
8016d9e0:	e5932014 	ldr	r2, [r3, #20]
8016d9e4:	e51b3008 	ldr	r3, [fp, #-8]
8016d9e8:	e5832014 	str	r2, [r3, #20]
    Dst->R5=Src->R5;
8016d9ec:	e51b300c 	ldr	r3, [fp, #-12]
8016d9f0:	e5932018 	ldr	r2, [r3, #24]
8016d9f4:	e51b3008 	ldr	r3, [fp, #-8]
8016d9f8:	e5832018 	str	r2, [r3, #24]
    Dst->R6=Src->R6;
8016d9fc:	e51b300c 	ldr	r3, [fp, #-12]
8016da00:	e593201c 	ldr	r2, [r3, #28]
8016da04:	e51b3008 	ldr	r3, [fp, #-8]
8016da08:	e583201c 	str	r2, [r3, #28]
    Dst->R7=Src->R7;
8016da0c:	e51b300c 	ldr	r3, [fp, #-12]
8016da10:	e5932020 	ldr	r2, [r3, #32]
8016da14:	e51b3008 	ldr	r3, [fp, #-8]
8016da18:	e5832020 	str	r2, [r3, #32]
    Dst->R8=Src->R8;
8016da1c:	e51b300c 	ldr	r3, [fp, #-12]
8016da20:	e5932024 	ldr	r2, [r3, #36]	@ 0x24
8016da24:	e51b3008 	ldr	r3, [fp, #-8]
8016da28:	e5832024 	str	r2, [r3, #36]	@ 0x24
    Dst->R9=Src->R9;
8016da2c:	e51b300c 	ldr	r3, [fp, #-12]
8016da30:	e5932028 	ldr	r2, [r3, #40]	@ 0x28
8016da34:	e51b3008 	ldr	r3, [fp, #-8]
8016da38:	e5832028 	str	r2, [r3, #40]	@ 0x28
    Dst->R10=Src->R10;
8016da3c:	e51b300c 	ldr	r3, [fp, #-12]
8016da40:	e593202c 	ldr	r2, [r3, #44]	@ 0x2c
8016da44:	e51b3008 	ldr	r3, [fp, #-8]
8016da48:	e583202c 	str	r2, [r3, #44]	@ 0x2c
    Dst->R11=Src->R11;
8016da4c:	e51b300c 	ldr	r3, [fp, #-12]
8016da50:	e5932030 	ldr	r2, [r3, #48]	@ 0x30
8016da54:	e51b3008 	ldr	r3, [fp, #-8]
8016da58:	e5832030 	str	r2, [r3, #48]	@ 0x30
    Dst->SP=Src->SP;
8016da5c:	e51b300c 	ldr	r3, [fp, #-12]
8016da60:	e5932034 	ldr	r2, [r3, #52]	@ 0x34
8016da64:	e51b3008 	ldr	r3, [fp, #-8]
8016da68:	e5832034 	str	r2, [r3, #52]	@ 0x34
    Dst->LR=Src->LR;
8016da6c:	e51b300c 	ldr	r3, [fp, #-12]
8016da70:	e5932038 	ldr	r2, [r3, #56]	@ 0x38
8016da74:	e51b3008 	ldr	r3, [fp, #-8]
8016da78:	e5832038 	str	r2, [r3, #56]	@ 0x38
    Dst->PC=Src->PC;
8016da7c:	e51b300c 	ldr	r3, [fp, #-12]
8016da80:	e593203c 	ldr	r2, [r3, #60]	@ 0x3c
8016da84:	e51b3008 	ldr	r3, [fp, #-8]
8016da88:	e583203c 	str	r2, [r3, #60]	@ 0x3c
}
8016da8c:	e320f000 	nop	{0}
8016da90:	e28bd000 	add	sp, fp, #0
8016da94:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016da98:	e12fff1e 	bx	lr

8016da9c <__RME_Inv_Reg_Save>:
Input       : struct RME_Reg_Struct* Reg - The register set.
Output      : struct RME_Iret_Struct* Ret - The invocation return register context.
Return      : None.
******************************************************************************/
void __RME_Inv_Reg_Save(struct RME_Iret_Struct* Ret, struct RME_Reg_Struct* Reg)
{
8016da9c:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016daa0:	e28db000 	add	fp, sp, #0
8016daa4:	e24dd00c 	sub	sp, sp, #12
8016daa8:	e50b0008 	str	r0, [fp, #-8]
8016daac:	e50b100c 	str	r1, [fp, #-12]
    Ret->PC=Reg->PC;
8016dab0:	e51b300c 	ldr	r3, [fp, #-12]
8016dab4:	e593203c 	ldr	r2, [r3, #60]	@ 0x3c
8016dab8:	e51b3008 	ldr	r3, [fp, #-8]
8016dabc:	e5832000 	str	r2, [r3]
    Ret->SP=Reg->SP;
8016dac0:	e51b300c 	ldr	r3, [fp, #-12]
8016dac4:	e5932034 	ldr	r2, [r3, #52]	@ 0x34
8016dac8:	e51b3008 	ldr	r3, [fp, #-8]
8016dacc:	e5832004 	str	r2, [r3, #4]
}
8016dad0:	e320f000 	nop	{0}
8016dad4:	e28bd000 	add	sp, fp, #0
8016dad8:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016dadc:	e12fff1e 	bx	lr

8016dae0 <__RME_Inv_Reg_Restore>:
Input       : struct RME_Iret_Struct* Ret - The invocation return register context.
Output      : struct RME_Reg_Struct* Reg - The register set.
Return      : None.
******************************************************************************/
void __RME_Inv_Reg_Restore(struct RME_Reg_Struct* Reg, struct RME_Iret_Struct* Ret)
{
8016dae0:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016dae4:	e28db000 	add	fp, sp, #0
8016dae8:	e24dd00c 	sub	sp, sp, #12
8016daec:	e50b0008 	str	r0, [fp, #-8]
8016daf0:	e50b100c 	str	r1, [fp, #-12]
    Reg->PC=Ret->PC;
8016daf4:	e51b300c 	ldr	r3, [fp, #-12]
8016daf8:	e5932000 	ldr	r2, [r3]
8016dafc:	e51b3008 	ldr	r3, [fp, #-8]
8016db00:	e583203c 	str	r2, [r3, #60]	@ 0x3c
    Reg->SP=Ret->SP;
8016db04:	e51b300c 	ldr	r3, [fp, #-12]
8016db08:	e5932004 	ldr	r2, [r3, #4]
8016db0c:	e51b3008 	ldr	r3, [fp, #-8]
8016db10:	e5832034 	str	r2, [r3, #52]	@ 0x34
}
8016db14:	e320f000 	nop	{0}
8016db18:	e28bd000 	add	sp, fp, #0
8016db1c:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016db20:	e12fff1e 	bx	lr

8016db24 <__RME_Inv_Retval_Set>:
Output      : struct RME_Reg_Struct* Reg - The register set.
Return      : None.
******************************************************************************/
void __RME_Inv_Retval_Set(struct RME_Reg_Struct* Reg,
                          rme_ret_t Retval)
{
8016db24:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016db28:	e28db000 	add	fp, sp, #0
8016db2c:	e24dd00c 	sub	sp, sp, #12
8016db30:	e50b0008 	str	r0, [fp, #-8]
8016db34:	e50b100c 	str	r1, [fp, #-12]
    Reg->R1=(rme_ptr_t)Retval;
8016db38:	e51b200c 	ldr	r2, [fp, #-12]
8016db3c:	e51b3008 	ldr	r3, [fp, #-8]
8016db40:	e5832008 	str	r2, [r3, #8]
}
8016db44:	e320f000 	nop	{0}
8016db48:	e28bd000 	add	sp, fp, #0
8016db4c:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016db50:	e12fff1e 	bx	lr

8016db54 <__RME_Kfn_Handler>:
                                           struct RME_Reg_Struct* Reg,
                                           rme_ptr_t Func_ID,
                                           rme_ptr_t Sub_ID,
                                           rme_ptr_t Param1,
                                           rme_ptr_t Param2)
{
8016db54:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016db58:	e28db000 	add	fp, sp, #0
8016db5c:	e24dd014 	sub	sp, sp, #20
8016db60:	e50b0008 	str	r0, [fp, #-8]
8016db64:	e50b100c 	str	r1, [fp, #-12]
8016db68:	e50b2010 	str	r2, [fp, #-16]
8016db6c:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
	/* Currently no kernel function implemented */
    return 0;
8016db70:	e3a03000 	mov	r3, #0
}
8016db74:	e1a00003 	mov	r0, r3
8016db78:	e28bd000 	add	sp, fp, #0
8016db7c:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016db80:	e12fff1e 	bx	lr

8016db84 <__RME_A7A_Undefined_Handler>:
Input       : struct RME_Reg_Struct* Reg - The register set when entering the handler.
Output      : struct RME_Reg_Struct* Reg - The register set when exiting the handler.
Return      : None.
******************************************************************************/
void __RME_A7A_Undefined_Handler(struct RME_Reg_Struct* Reg)
{
8016db84:	e92d4800 	push	{fp, lr}
8016db88:	e28db004 	add	fp, sp, #4
8016db8c:	e24dd010 	sub	sp, sp, #16
8016db90:	e50b0010 	str	r0, [fp, #-16]
	/* We don't handle undefined instructions now */
	rme_ptr_t end;
	end=RME_A7A_REG(&RME_A7A_GTWD_GTCR0);
8016db94:	e3a03c02 	mov	r3, #512	@ 0x200
8016db98:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016db9c:	e5933000 	ldr	r3, [r3]
8016dba0:	e50b3008 	str	r3, [fp, #-8]
	RME_DBG_S(" \r\ntime ");
8016dba4:	e30e0fe0 	movw	r0, #61408	@ 0xefe0
8016dba8:	e3480016 	movt	r0, #32790	@ 0x8016
8016dbac:	ebffcbd8 	bl	80160b14 <RME_Str_Print>
	RME_DBG_H(end);
8016dbb0:	e51b0008 	ldr	r0, [fp, #-8]
8016dbb4:	ebffcb94 	bl	80160a0c <RME_Hex_Print>
	RME_DBG_S("\r\nUndefined_Handler");
8016dbb8:	e30e0fec 	movw	r0, #61420	@ 0xefec
8016dbbc:	e3480016 	movt	r0, #32790	@ 0x8016
8016dbc0:	ebffcbd3 	bl	80160b14 <RME_Str_Print>
	RME_DBG_S(" PC - ");
8016dbc4:	e30f0000 	movw	r0, #61440	@ 0xf000
8016dbc8:	e3480016 	movt	r0, #32790	@ 0x8016
8016dbcc:	ebffcbd0 	bl	80160b14 <RME_Str_Print>
	RME_DBG_H(Reg->PC);
8016dbd0:	e51b3010 	ldr	r3, [fp, #-16]
8016dbd4:	e593303c 	ldr	r3, [r3, #60]	@ 0x3c
8016dbd8:	e1a00003 	mov	r0, r3
8016dbdc:	ebffcb8a 	bl	80160a0c <RME_Hex_Print>
	RME_DBG_S(" SP - ");
8016dbe0:	e30f0008 	movw	r0, #61448	@ 0xf008
8016dbe4:	e3480016 	movt	r0, #32790	@ 0x8016
8016dbe8:	ebffcbc9 	bl	80160b14 <RME_Str_Print>
	RME_DBG_H(Reg->SP);
8016dbec:	e51b3010 	ldr	r3, [fp, #-16]
8016dbf0:	e5933034 	ldr	r3, [r3, #52]	@ 0x34
8016dbf4:	e1a00003 	mov	r0, r3
8016dbf8:	ebffcb83 	bl	80160a0c <RME_Hex_Print>
	RME_DBG_S(" CPSR - ");
8016dbfc:	e30f0010 	movw	r0, #61456	@ 0xf010
8016dc00:	e3480016 	movt	r0, #32790	@ 0x8016
8016dc04:	ebffcbc2 	bl	80160b14 <RME_Str_Print>
	RME_DBG_H(Reg->CPSR);
8016dc08:	e51b3010 	ldr	r3, [fp, #-16]
8016dc0c:	e5933000 	ldr	r3, [r3]
8016dc10:	e1a00003 	mov	r0, r3
8016dc14:	ebffcb7c 	bl	80160a0c <RME_Hex_Print>
	while(1);
8016dc18:	eafffffe 	b	8016dc18 <__RME_A7A_Undefined_Handler+0x94>

8016dc1c <__RME_A7A_Prefetch_Abort_Handler>:
Input       : struct RME_Reg_Struct* Reg - The register set when entering the handler.
Output      : struct RME_Reg_Struct* Reg - The register set when exiting the handler.
Return      : None.
******************************************************************************/
void __RME_A7A_Prefetch_Abort_Handler(struct RME_Reg_Struct* Reg)
{
8016dc1c:	e92d4800 	push	{fp, lr}
8016dc20:	e28db004 	add	fp, sp, #4
8016dc24:	e24dd008 	sub	sp, sp, #8
8016dc28:	e50b0008 	str	r0, [fp, #-8]
	/* We don't handle prefetch aborts now */
	RME_DBG_S("Prefetch_Abort_Handler");
8016dc2c:	e30f001c 	movw	r0, #61468	@ 0xf01c
8016dc30:	e3480016 	movt	r0, #32790	@ 0x8016
8016dc34:	ebffcbb6 	bl	80160b14 <RME_Str_Print>
	RME_DBG_S(" PC - ");
8016dc38:	e30f0000 	movw	r0, #61440	@ 0xf000
8016dc3c:	e3480016 	movt	r0, #32790	@ 0x8016
8016dc40:	ebffcbb3 	bl	80160b14 <RME_Str_Print>
	RME_DBG_H(Reg->PC);
8016dc44:	e51b3008 	ldr	r3, [fp, #-8]
8016dc48:	e593303c 	ldr	r3, [r3, #60]	@ 0x3c
8016dc4c:	e1a00003 	mov	r0, r3
8016dc50:	ebffcb6d 	bl	80160a0c <RME_Hex_Print>
	RME_DBG_S(" SP - ");
8016dc54:	e30f0008 	movw	r0, #61448	@ 0xf008
8016dc58:	e3480016 	movt	r0, #32790	@ 0x8016
8016dc5c:	ebffcbac 	bl	80160b14 <RME_Str_Print>
	RME_DBG_H(Reg->SP);
8016dc60:	e51b3008 	ldr	r3, [fp, #-8]
8016dc64:	e5933034 	ldr	r3, [r3, #52]	@ 0x34
8016dc68:	e1a00003 	mov	r0, r3
8016dc6c:	ebffcb66 	bl	80160a0c <RME_Hex_Print>
	RME_DBG_S(" CPSR - ");
8016dc70:	e30f0010 	movw	r0, #61456	@ 0xf010
8016dc74:	e3480016 	movt	r0, #32790	@ 0x8016
8016dc78:	ebffcba5 	bl	80160b14 <RME_Str_Print>
	RME_DBG_H(Reg->CPSR);
8016dc7c:	e51b3008 	ldr	r3, [fp, #-8]
8016dc80:	e5933000 	ldr	r3, [r3]
8016dc84:	e1a00003 	mov	r0, r3
8016dc88:	ebffcb5f 	bl	80160a0c <RME_Hex_Print>
	while(1);
8016dc8c:	eafffffe 	b	8016dc8c <__RME_A7A_Prefetch_Abort_Handler+0x70>

8016dc90 <__RME_A7A_Data_Abort_Handler>:
Input       : struct RME_Reg_Struct* Reg - The register set when entering the handler.
Output      : struct RME_Reg_Struct* Reg - The register set when exiting the handler.
Return      : None.
******************************************************************************/
void __RME_A7A_Data_Abort_Handler(struct RME_Reg_Struct* Reg)
{
8016dc90:	e92d4800 	push	{fp, lr}
8016dc94:	e28db004 	add	fp, sp, #4
8016dc98:	e24dd008 	sub	sp, sp, #8
8016dc9c:	e50b0008 	str	r0, [fp, #-8]
	/* We don't handle data aborts now */
	RME_DBG_S("\r\nData_Abort_Handler");
8016dca0:	e30f0034 	movw	r0, #61492	@ 0xf034
8016dca4:	e3480016 	movt	r0, #32790	@ 0x8016
8016dca8:	ebffcb99 	bl	80160b14 <RME_Str_Print>
	RME_DBG_S(" PC - ");
8016dcac:	e30f0000 	movw	r0, #61440	@ 0xf000
8016dcb0:	e3480016 	movt	r0, #32790	@ 0x8016
8016dcb4:	ebffcb96 	bl	80160b14 <RME_Str_Print>
	RME_DBG_H(Reg->PC);
8016dcb8:	e51b3008 	ldr	r3, [fp, #-8]
8016dcbc:	e593303c 	ldr	r3, [r3, #60]	@ 0x3c
8016dcc0:	e1a00003 	mov	r0, r3
8016dcc4:	ebffcb50 	bl	80160a0c <RME_Hex_Print>
	RME_DBG_S(" SP - ");
8016dcc8:	e30f0008 	movw	r0, #61448	@ 0xf008
8016dccc:	e3480016 	movt	r0, #32790	@ 0x8016
8016dcd0:	ebffcb8f 	bl	80160b14 <RME_Str_Print>
	RME_DBG_H(Reg->SP);
8016dcd4:	e51b3008 	ldr	r3, [fp, #-8]
8016dcd8:	e5933034 	ldr	r3, [r3, #52]	@ 0x34
8016dcdc:	e1a00003 	mov	r0, r3
8016dce0:	ebffcb49 	bl	80160a0c <RME_Hex_Print>
	RME_DBG_S(" CPSR - ");
8016dce4:	e30f0010 	movw	r0, #61456	@ 0xf010
8016dce8:	e3480016 	movt	r0, #32790	@ 0x8016
8016dcec:	ebffcb88 	bl	80160b14 <RME_Str_Print>
	RME_DBG_H(Reg->CPSR);
8016dcf0:	e51b3008 	ldr	r3, [fp, #-8]
8016dcf4:	e5933000 	ldr	r3, [r3]
8016dcf8:	e1a00003 	mov	r0, r3
8016dcfc:	ebffcb42 	bl	80160a0c <RME_Hex_Print>
	while(1);
8016dd00:	eafffffe 	b	8016dd00 <__RME_A7A_Data_Abort_Handler+0x70>

8016dd04 <__RME_A7A_IRQ_Handler>:
Input       : struct RME_Reg_Struct* Reg - The register set when entering the handler.
Output      : struct RME_Reg_Struct* Reg - The register set when exiting the handler.
Return      : None.
******************************************************************************/
void __RME_A7A_IRQ_Handler(struct RME_Reg_Struct* Reg)
{
8016dd04:	e92d4800 	push	{fp, lr}
8016dd08:	e28db004 	add	fp, sp, #4
8016dd0c:	e24dd010 	sub	sp, sp, #16
8016dd10:	e50b0010 	str	r0, [fp, #-16]
	rme_ptr_t Int_ID;
	rme_ptr_t CPUID;

	/* What interrupt is this? */
	Int_ID=RME_A7A_GICC_IAR;
8016dd14:	e3a03f43 	mov	r3, #268	@ 0x10c
8016dd18:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016dd1c:	e5933000 	ldr	r3, [r3]
8016dd20:	e50b3008 	str	r3, [fp, #-8]
	CPUID=Int_ID>>10;
8016dd24:	e51b3008 	ldr	r3, [fp, #-8]
8016dd28:	e1a03523 	lsr	r3, r3, #10
8016dd2c:	e50b300c 	str	r3, [fp, #-12]
	Int_ID&=0x3FFU;
8016dd30:	e51b3008 	ldr	r3, [fp, #-8]
8016dd34:	e7e93053 	ubfx	r3, r3, #0, #10
8016dd38:	e50b3008 	str	r3, [fp, #-8]
    //RME_DBG_S("\r\nINT_ID is ");
	//RME_DBG_I(Int_ID);

#if(RME_A7A_GIC_TYPE==RME_A7A_GIC_V1)
	/* Is this a spurious interrupt? (Can't be 1022 because GICv1 don't have group1) */
	RME_ASSERT(Int_ID!=1022);
8016dd3c:	e51b3008 	ldr	r3, [fp, #-8]
8016dd40:	e30023fe 	movw	r2, #1022	@ 0x3fe
8016dd44:	e1530002 	cmp	r3, r2
8016dd48:	1a000008 	bne	8016dd70 <__RME_A7A_IRQ_Handler+0x6c>
8016dd4c:	e30e3db0 	movw	r3, #60848	@ 0xedb0
8016dd50:	e3483016 	movt	r3, #32790	@ 0x8016
8016dd54:	e30e2dbc 	movw	r2, #60860	@ 0xedbc
8016dd58:	e3482016 	movt	r2, #32790	@ 0x8016
8016dd5c:	e300139e 	movw	r1, #926	@ 0x39e
8016dd60:	e30e0dc8 	movw	r0, #60872	@ 0xedc8
8016dd64:	e3480016 	movt	r0, #32790	@ 0x8016
8016dd68:	ebffcb88 	bl	80160b90 <RME_Log>
8016dd6c:	eafffffe 	b	8016dd6c <__RME_A7A_IRQ_Handler+0x68>
	if(Int_ID==1023)
8016dd70:	e51b3008 	ldr	r3, [fp, #-8]
8016dd74:	e30023ff 	movw	r2, #1023	@ 0x3ff
8016dd78:	e1530002 	cmp	r3, r2
8016dd7c:	0a00003d 	beq	8016de78 <__RME_A7A_IRQ_Handler+0x174>
		return;
	/* Only the booting processor will receive timer interrupts */
#if((RME_A7A_CPU_TYPE==RME_A7A_CPU_CORTEX_A5)|| \
	(RME_A7A_CPU_TYPE==RME_A7A_CPU_CORTEX_A9))
	/* Is is an timer interrupt? (we know that it is at 29) */
	if(Int_ID==29)
8016dd80:	e51b3008 	ldr	r3, [fp, #-8]
8016dd84:	e353001d 	cmp	r3, #29
8016dd88:	1a00000b 	bne	8016ddbc <__RME_A7A_IRQ_Handler+0xb8>
	{
		/* Clear the interrupt flag */
	    RME_A7A_PTWD_PTISR=0;
8016dd8c:	e300360c 	movw	r3, #1548	@ 0x60c
8016dd90:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016dd94:	e3a02000 	mov	r2, #0
8016dd98:	e5832000 	str	r2, [r3]
		//_RME_Tick_Handler(Reg);
	    _RME_Tim_Handler(Reg,1);
8016dd9c:	e3a01001 	mov	r1, #1
8016dda0:	e51b0010 	ldr	r0, [fp, #-16]
8016dda4:	ebffce51 	bl	801616f0 <_RME_Tim_Handler>
		/* Send interrupt to all other processors to notify them about this */
		/* EOI the interrupt */
		RME_A7A_GICC_EOIR=Int_ID;
8016dda8:	e3a03e11 	mov	r3, #272	@ 0x110
8016ddac:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016ddb0:	e51b2008 	ldr	r2, [fp, #-8]
8016ddb4:	e5832000 	str	r2, [r3]
		return;
8016ddb8:	ea00002f 	b	8016de7c <__RME_A7A_IRQ_Handler+0x178>

#else

#endif
	/* Is this a coprocessor timer interrupt? (We use interrupt number 0 for these) */
	if(Int_ID==0)
8016ddbc:	e51b3008 	ldr	r3, [fp, #-8]
8016ddc0:	e3530000 	cmp	r3, #0
8016ddc4:	1a000010 	bne	8016de0c <__RME_A7A_IRQ_Handler+0x108>
	{
		/* This must have originated from interface 0 */
		RME_ASSERT(CPUID==0);
8016ddc8:	e51b300c 	ldr	r3, [fp, #-12]
8016ddcc:	e3530000 	cmp	r3, #0
8016ddd0:	0a000008 	beq	8016ddf8 <__RME_A7A_IRQ_Handler+0xf4>
8016ddd4:	e30e3db0 	movw	r3, #60848	@ 0xedb0
8016ddd8:	e3483016 	movt	r3, #32790	@ 0x8016
8016dddc:	e30e2dbc 	movw	r2, #60860	@ 0xedbc
8016dde0:	e3482016 	movt	r2, #32790	@ 0x8016
8016dde4:	e30013bb 	movw	r1, #955	@ 0x3bb
8016dde8:	e30e0dc8 	movw	r0, #60872	@ 0xedc8
8016ddec:	e3480016 	movt	r0, #32790	@ 0x8016
8016ddf0:	ebffcb66 	bl	80160b90 <RME_Log>
8016ddf4:	eafffffe 	b	8016ddf4 <__RME_A7A_IRQ_Handler+0xf0>
		//_RME_Tick_SMP_Handler(Reg);
		/* EOI the interrupt */
		RME_A7A_GICC_EOIR=Int_ID;
8016ddf8:	e3a03e11 	mov	r3, #272	@ 0x110
8016ddfc:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016de00:	e51b2008 	ldr	r2, [fp, #-8]
8016de04:	e5832000 	str	r2, [r3]
		return;
8016de08:	ea00001b 	b	8016de7c <__RME_A7A_IRQ_Handler+0x178>
	}

	/* Is this an other IPI? (All the rest of the SGIs are these) */
	if(Int_ID<16)
8016de0c:	e51b3008 	ldr	r3, [fp, #-8]
8016de10:	e353000f 	cmp	r3, #15
8016de14:	8a00000b 	bhi	8016de48 <__RME_A7A_IRQ_Handler+0x144>
	{
		_RME_A7A_SGI_Handler(Reg,CPUID,Int_ID);
8016de18:	e51b2008 	ldr	r2, [fp, #-8]
8016de1c:	e51b100c 	ldr	r1, [fp, #-12]
8016de20:	e51b0010 	ldr	r0, [fp, #-16]
8016de24:	eb000016 	bl	8016de84 <_RME_A7A_SGI_Handler>
		/* EOI the interrupt */
		RME_A7A_GICC_EOIR=(CPUID<<10U)|Int_ID;
8016de28:	e51b300c 	ldr	r3, [fp, #-12]
8016de2c:	e1a01503 	lsl	r1, r3, #10
8016de30:	e3a03e11 	mov	r3, #272	@ 0x110
8016de34:	e34f38f0 	movt	r3, #63728	@ 0xf8f0
8016de38:	e51b2008 	ldr	r2, [fp, #-8]
8016de3c:	e1812002 	orr	r2, r1, r2
8016de40:	e5832000 	str	r2, [r3]
		return;
8016de44:	ea00000c 	b	8016de7c <__RME_A7A_IRQ_Handler+0x178>
	}

	/* Is this an casual interrupt? */
	RME_ASSERT(CPUID==0);
8016de48:	e51b300c 	ldr	r3, [fp, #-12]
8016de4c:	e3530000 	cmp	r3, #0
8016de50:	0a000009 	beq	8016de7c <__RME_A7A_IRQ_Handler+0x178>
8016de54:	e30e3db0 	movw	r3, #60848	@ 0xedb0
8016de58:	e3483016 	movt	r3, #32790	@ 0x8016
8016de5c:	e30e2dbc 	movw	r2, #60860	@ 0xedbc
8016de60:	e3482016 	movt	r2, #32790	@ 0x8016
8016de64:	e3a01ff3 	mov	r1, #972	@ 0x3cc
8016de68:	e30e0dc8 	movw	r0, #60872	@ 0xedc8
8016de6c:	e3480016 	movt	r0, #32790	@ 0x8016
8016de70:	ebffcb46 	bl	80160b90 <RME_Log>
8016de74:	eafffffe 	b	8016de74 <__RME_A7A_IRQ_Handler+0x170>
		return;
8016de78:	e320f000 	nop	{0}

}
8016de7c:	e24bd004 	sub	sp, fp, #4
8016de80:	e8bd8800 	pop	{fp, pc}

8016de84 <_RME_A7A_SGI_Handler>:
              rme_ptr_t Int_ID - The ID of the SGI.
Output      : struct RME_Reg_Struct* Reg - The register set when exiting the handler.
Return      : None.
******************************************************************************/
void _RME_A7A_SGI_Handler(struct RME_Reg_Struct* Reg, rme_ptr_t CPUID, rme_ptr_t Int_ID)
{
8016de84:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016de88:	e28db000 	add	fp, sp, #0
8016de8c:	e24dd014 	sub	sp, sp, #20
8016de90:	e50b0008 	str	r0, [fp, #-8]
8016de94:	e50b100c 	str	r1, [fp, #-12]
8016de98:	e50b2010 	str	r2, [fp, #-16]
	/* Not handling SGIs */
	return;
8016de9c:	e320f000 	nop	{0}
}
8016dea0:	e28bd000 	add	sp, fp, #0
8016dea4:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016dea8:	e12fff1e 	bx	lr

8016deac <__RME_Pgt_Set>:
Input       : rme_ptr_t Pgt - The virtual address of the page table.
Output      : None.
Return      : None.
******************************************************************************/
void __RME_Pgt_Set(struct RME_Cap_Pgt* Pgt)
{
8016deac:	e92d4800 	push	{fp, lr}
8016deb0:	e28db004 	add	fp, sp, #4
8016deb4:	e24dd010 	sub	sp, sp, #16
8016deb8:	e50b0010 	str	r0, [fp, #-16]
    rme_ptr_t* Ptr;

    /* Get the actual table */
    Ptr=RME_CAP_GETOBJ(Pgt,rme_ptr_t*);
8016debc:	e51b3010 	ldr	r3, [fp, #-16]
8016dec0:	e593300c 	ldr	r3, [r3, #12]
8016dec4:	e50b3008 	str	r3, [fp, #-8]

    /*RME_DBG_S("\r\n__RME_Pgt_Set table kernel VA @ ");
    RME_DBG_H(Ptr);*/

    __RME_A7A_TTBR0_Set(RME_A7A_VA2PA(Ptr)|0x4A);
8016dec8:	e51b3008 	ldr	r3, [fp, #-8]
8016decc:	e2833102 	add	r3, r3, #-2147483648	@ 0x80000000
8016ded0:	e383304a 	orr	r3, r3, #74	@ 0x4a
8016ded4:	e1a00003 	mov	r0, r3
8016ded8:	ebffc93c 	bl	801603d0 <__RME_A7A_Pgt_Set>
	__RME_A7A_TLBIALL_Set(0);
8016dedc:	e3a00000 	mov	r0, #0
8016dee0:	ebffc9a8 	bl	80160588 <__RME_A7A_TLBIALL_Set>
}
8016dee4:	e320f000 	nop	{0}
8016dee8:	e24bd004 	sub	sp, fp, #4
8016deec:	e8bd8800 	pop	{fp, pc}

8016def0 <__RME_Pgt_Check>:
Output      : None.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Check(rme_ptr_t Base, rme_ptr_t Is_Top,
                          rme_ptr_t Size_Order, rme_ptr_t Num_Order, rme_ptr_t Vaddr)
{
8016def0:	e92d4800 	push	{fp, lr}
8016def4:	e28db004 	add	fp, sp, #4
8016def8:	e24dd010 	sub	sp, sp, #16
8016defc:	e50b0008 	str	r0, [fp, #-8]
8016df00:	e50b100c 	str	r1, [fp, #-12]
8016df04:	e50b2010 	str	r2, [fp, #-16]
8016df08:	e50b3014 	str	r3, [fp, #-20]	@ 0xffffffec
    /* Top-level - 1MiB pages, 4096 entries, 16KiB alignment */
    if(Is_Top!=0)
8016df0c:	e51b300c 	ldr	r3, [fp, #-12]
8016df10:	e3530000 	cmp	r3, #0
8016df14:	0a000014 	beq	8016df6c <__RME_Pgt_Check+0x7c>
    {
        if(Size_Order!=RME_PGT_SIZE_1M)
8016df18:	e51b3010 	ldr	r3, [fp, #-16]
8016df1c:	e3530014 	cmp	r3, #20
8016df20:	0a000001 	beq	8016df2c <__RME_Pgt_Check+0x3c>
            return RME_ERR_HAL_FAIL;
8016df24:	e3e03000 	mvn	r3, #0
8016df28:	ea000025 	b	8016dfc4 <__RME_Pgt_Check+0xd4>
        if(Num_Order!=RME_PGT_NUM_4K)
8016df2c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016df30:	e353000c 	cmp	r3, #12
8016df34:	0a000001 	beq	8016df40 <__RME_Pgt_Check+0x50>
            return RME_ERR_HAL_FAIL;
8016df38:	e3e03000 	mvn	r3, #0
8016df3c:	ea000020 	b	8016dfc4 <__RME_Pgt_Check+0xd4>
        if((Vaddr&0x3FFF)!=0)
8016df40:	e59b3004 	ldr	r3, [fp, #4]
8016df44:	e7ed3053 	ubfx	r3, r3, #0, #14
8016df48:	e3530000 	cmp	r3, #0
8016df4c:	0a00001b 	beq	8016dfc0 <__RME_Pgt_Check+0xd0>
        {
            RME_DBG_S("\r\nvaddr alignment error= ");
8016df50:	e30f005c 	movw	r0, #61532	@ 0xf05c
8016df54:	e3480016 	movt	r0, #32790	@ 0x8016
8016df58:	ebffcaed 	bl	80160b14 <RME_Str_Print>
            RME_DBG_H(Vaddr);
8016df5c:	e59b0004 	ldr	r0, [fp, #4]
8016df60:	ebffcaa9 	bl	80160a0c <RME_Hex_Print>
            return RME_ERR_HAL_FAIL;
8016df64:	e3e03000 	mvn	r3, #0
8016df68:	ea000015 	b	8016dfc4 <__RME_Pgt_Check+0xd4>
        }
    }
    /* Second-level - 4KiB pages, 256 entries, 1KiB alignment */
    else
    {
        if(Size_Order!=RME_PGT_SIZE_4K)
8016df6c:	e51b3010 	ldr	r3, [fp, #-16]
8016df70:	e353000c 	cmp	r3, #12
8016df74:	0a000001 	beq	8016df80 <__RME_Pgt_Check+0x90>
            return RME_ERR_HAL_FAIL;
8016df78:	e3e03000 	mvn	r3, #0
8016df7c:	ea000010 	b	8016dfc4 <__RME_Pgt_Check+0xd4>
        if(Num_Order!=RME_PGT_NUM_256)
8016df80:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016df84:	e3530008 	cmp	r3, #8
8016df88:	0a000001 	beq	8016df94 <__RME_Pgt_Check+0xa4>
            return RME_ERR_HAL_FAIL;
8016df8c:	e3e03000 	mvn	r3, #0
8016df90:	ea00000b 	b	8016dfc4 <__RME_Pgt_Check+0xd4>
        if((Vaddr&0x3FF)!=0)
8016df94:	e59b3004 	ldr	r3, [fp, #4]
8016df98:	e7e93053 	ubfx	r3, r3, #0, #10
8016df9c:	e3530000 	cmp	r3, #0
8016dfa0:	0a000006 	beq	8016dfc0 <__RME_Pgt_Check+0xd0>
        {
            RME_DBG_S("\r\nvaddr alignment error= ");
8016dfa4:	e30f005c 	movw	r0, #61532	@ 0xf05c
8016dfa8:	e3480016 	movt	r0, #32790	@ 0x8016
8016dfac:	ebffcad8 	bl	80160b14 <RME_Str_Print>
            RME_DBG_H(Vaddr);
8016dfb0:	e59b0004 	ldr	r0, [fp, #4]
8016dfb4:	ebffca94 	bl	80160a0c <RME_Hex_Print>
            return RME_ERR_HAL_FAIL;
8016dfb8:	e3e03000 	mvn	r3, #0
8016dfbc:	ea000000 	b	8016dfc4 <__RME_Pgt_Check+0xd4>
        }
    }

    return 0;
8016dfc0:	e3a03000 	mov	r3, #0
}
8016dfc4:	e1a00003 	mov	r0, r3
8016dfc8:	e24bd004 	sub	sp, fp, #4
8016dfcc:	e8bd8800 	pop	{fp, pc}

8016dfd0 <__RME_Pgt_Init>:
Input       : struct RME_Cap_Pgt* - The capability to the page table to operate on.
Output      : None.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Init(struct RME_Cap_Pgt* Pgt_Op)
{
8016dfd0:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016dfd4:	e28db000 	add	fp, sp, #0
8016dfd8:	e24dd014 	sub	sp, sp, #20
8016dfdc:	e50b0010 	str	r0, [fp, #-16]
    rme_cnt_t Count;
    rme_ptr_t* Ptr;

    /* Get the actual table */
    Ptr=RME_CAP_GETOBJ(Pgt_Op,rme_ptr_t*);  //*((volatile rme_ptr_t*)0x12345678)
8016dfe0:	e51b3010 	ldr	r3, [fp, #-16]
8016dfe4:	e593300c 	ldr	r3, [r3, #12]
8016dfe8:	e50b300c 	str	r3, [fp, #-12]

    /* Is this a first-level or a second-level? */
    if((Pgt_Op->Base&RME_PGT_TOP)!=0)
8016dfec:	e51b3010 	ldr	r3, [fp, #-16]
8016dff0:	e5933018 	ldr	r3, [r3, #24]
8016dff4:	e2033001 	and	r3, r3, #1
8016dff8:	e3530000 	cmp	r3, #0
8016dffc:	0a000021 	beq	8016e088 <__RME_Pgt_Init+0xb8>
    {
    	/* First-level - clean up the first half and map in the second half as kernel entries */
		for(Count=0;Count<2048;Count++)
8016e000:	e3a03000 	mov	r3, #0
8016e004:	e50b3008 	str	r3, [fp, #-8]
8016e008:	ea000008 	b	8016e030 <__RME_Pgt_Init+0x60>
			Ptr[Count]=0;
8016e00c:	e51b3008 	ldr	r3, [fp, #-8]
8016e010:	e1a03103 	lsl	r3, r3, #2
8016e014:	e51b200c 	ldr	r2, [fp, #-12]
8016e018:	e0823003 	add	r3, r2, r3
8016e01c:	e3a02000 	mov	r2, #0
8016e020:	e5832000 	str	r2, [r3]
		for(Count=0;Count<2048;Count++)
8016e024:	e51b3008 	ldr	r3, [fp, #-8]
8016e028:	e2833001 	add	r3, r3, #1
8016e02c:	e50b3008 	str	r3, [fp, #-8]
8016e030:	e51b3008 	ldr	r3, [fp, #-8]
8016e034:	e3530b02 	cmp	r3, #2048	@ 0x800
8016e038:	bafffff3 	blt	8016e00c <__RME_Pgt_Init+0x3c>

		for(;Count<4096;Count++)
8016e03c:	ea00000d 	b	8016e078 <__RME_Pgt_Init+0xa8>
			Ptr[Count]=(&__RME_A7A_Kern_Pgt)[Count];
8016e040:	e51b3008 	ldr	r3, [fp, #-8]
8016e044:	e1a02103 	lsl	r2, r3, #2
8016e048:	e3003000 	movw	r3, #0
8016e04c:	e3483015 	movt	r3, #32789	@ 0x8015
8016e050:	e0822003 	add	r2, r2, r3
8016e054:	e51b3008 	ldr	r3, [fp, #-8]
8016e058:	e1a03103 	lsl	r3, r3, #2
8016e05c:	e51b100c 	ldr	r1, [fp, #-12]
8016e060:	e0813003 	add	r3, r1, r3
8016e064:	e5922000 	ldr	r2, [r2]
8016e068:	e5832000 	str	r2, [r3]
		for(;Count<4096;Count++)
8016e06c:	e51b3008 	ldr	r3, [fp, #-8]
8016e070:	e2833001 	add	r3, r3, #1
8016e074:	e50b3008 	str	r3, [fp, #-8]
8016e078:	e51b3008 	ldr	r3, [fp, #-8]
8016e07c:	e3530a01 	cmp	r3, #4096	@ 0x1000
8016e080:	baffffee 	blt	8016e040 <__RME_Pgt_Init+0x70>
8016e084:	ea00000e 	b	8016e0c4 <__RME_Pgt_Init+0xf4>
    }
    else
    {
    	/* Second-level - just clean it up to all zeros */
		for(Count=0;Count<256;Count++)
8016e088:	e3a03000 	mov	r3, #0
8016e08c:	e50b3008 	str	r3, [fp, #-8]
8016e090:	ea000008 	b	8016e0b8 <__RME_Pgt_Init+0xe8>
			Ptr[Count]=0;
8016e094:	e51b3008 	ldr	r3, [fp, #-8]
8016e098:	e1a03103 	lsl	r3, r3, #2
8016e09c:	e51b200c 	ldr	r2, [fp, #-12]
8016e0a0:	e0823003 	add	r3, r2, r3
8016e0a4:	e3a02000 	mov	r2, #0
8016e0a8:	e5832000 	str	r2, [r3]
		for(Count=0;Count<256;Count++)
8016e0ac:	e51b3008 	ldr	r3, [fp, #-8]
8016e0b0:	e2833001 	add	r3, r3, #1
8016e0b4:	e50b3008 	str	r3, [fp, #-8]
8016e0b8:	e51b3008 	ldr	r3, [fp, #-8]
8016e0bc:	e35300ff 	cmp	r3, #255	@ 0xff
8016e0c0:	dafffff3 	ble	8016e094 <__RME_Pgt_Init+0xc4>
    }

    return 0;
8016e0c4:	e3a03000 	mov	r3, #0
}
8016e0c8:	e1a00003 	mov	r0, r3
8016e0cc:	e28bd000 	add	sp, fp, #0
8016e0d0:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016e0d4:	e12fff1e 	bx	lr

8016e0d8 <__RME_Pgt_Del_Check>:
Input       : struct RME_Cap_Pgt Pgt_Op* - The capability to the page table to operate on.
Output      : None.
Return      : rme_ptr_t - If can be deleted, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Del_Check(struct RME_Cap_Pgt* Pgt_Op)
{
8016e0d8:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016e0dc:	e28db000 	add	fp, sp, #0
8016e0e0:	e24dd00c 	sub	sp, sp, #12
8016e0e4:	e50b0008 	str	r0, [fp, #-8]
    return 0;
8016e0e8:	e3a03000 	mov	r3, #0
}
8016e0ec:	e1a00003 	mov	r0, r3
8016e0f0:	e28bd000 	add	sp, fp, #0
8016e0f4:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016e0f8:	e12fff1e 	bx	lr

8016e0fc <__RME_Pgt_Page_Map>:
                                them into architecture specific page table's settings.
Output      : None.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Page_Map(struct RME_Cap_Pgt* Pgt_Op, rme_ptr_t Paddr, rme_ptr_t Pos, rme_ptr_t Flags)
{
8016e0fc:	e92d4800 	push	{fp, lr}
8016e100:	e28db004 	add	fp, sp, #4
8016e104:	e24dd018 	sub	sp, sp, #24
8016e108:	e50b0010 	str	r0, [fp, #-16]
8016e10c:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
8016e110:	e50b2018 	str	r2, [fp, #-24]	@ 0xffffffe8
8016e114:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4

    rme_ptr_t* Table;
    rme_ptr_t A7A_Flags;

    /* It should at least be readable */
    if((Flags&RME_PGT_READ)==0)
8016e118:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016e11c:	e2033001 	and	r3, r3, #1
8016e120:	e3530000 	cmp	r3, #0
8016e124:	1a000004 	bne	8016e13c <__RME_Pgt_Page_Map+0x40>
    {
        RME_DBG_S("\r\nunreadable");
8016e128:	e30f0078 	movw	r0, #61560	@ 0xf078
8016e12c:	e3480016 	movt	r0, #32790	@ 0x8016
8016e130:	ebffca77 	bl	80160b14 <RME_Str_Print>
        return RME_ERR_HAL_FAIL;
8016e134:	e3e03000 	mvn	r3, #0
8016e138:	ea00004e 	b	8016e278 <__RME_Pgt_Page_Map+0x17c>
    }

    /* Are we trying to map into the kernel space on the top level? */
    if(((Pgt_Op->Base&RME_PGT_TOP)!=0)&&(Pos>=2048)){
8016e13c:	e51b3010 	ldr	r3, [fp, #-16]
8016e140:	e5933018 	ldr	r3, [r3, #24]
8016e144:	e2033001 	and	r3, r3, #1
8016e148:	e3530000 	cmp	r3, #0
8016e14c:	0a000007 	beq	8016e170 <__RME_Pgt_Page_Map+0x74>
8016e150:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016e154:	e3530b02 	cmp	r3, #2048	@ 0x800
8016e158:	3a000004 	bcc	8016e170 <__RME_Pgt_Page_Map+0x74>
        RME_DBG_S("\r\nAre we trying to map into the kernel space on the top level?");
8016e15c:	e30f0088 	movw	r0, #61576	@ 0xf088
8016e160:	e3480016 	movt	r0, #32790	@ 0x8016
8016e164:	ebffca6a 	bl	80160b14 <RME_Str_Print>
        return RME_ERR_HAL_FAIL;
8016e168:	e3e03000 	mvn	r3, #0
8016e16c:	ea000041 	b	8016e278 <__RME_Pgt_Page_Map+0x17c>
    }
    /* Get the table */
    Table=RME_CAP_GETOBJ(Pgt_Op,rme_ptr_t*);
8016e170:	e51b3010 	ldr	r3, [fp, #-16]
8016e174:	e593300c 	ldr	r3, [r3, #12]
8016e178:	e50b300c 	str	r3, [fp, #-12]

    /* Generate flags */
    //if(RME_PGT_SZORD(Pgt_Op->Order)==RME_PGT_SIZE_4K)
    if(((Pgt_Op->Base)&RME_PGT_TOP)!=0U)
8016e17c:	e51b3010 	ldr	r3, [fp, #-16]
8016e180:	e5933018 	ldr	r3, [r3, #24]
8016e184:	e2033001 	and	r3, r3, #1
8016e188:	e3530000 	cmp	r3, #0
8016e18c:	0a00000c 	beq	8016e1c4 <__RME_Pgt_Page_Map+0xc8>
    {
        Flags&=(~RME_PGT_STATIC);
8016e190:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016e194:	e3c33020 	bic	r3, r3, #32
8016e198:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
        /*RME_DBG_S("\r\n Flags ");
        RME_DBG_H(Flags); */
        
        A7A_Flags=RME_A7A_MMU_1M_PAGE_ADDR(Paddr)|RME_A7A_PGFLG_1M_RME2NAT(Flags);
8016e19c:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016e1a0:	e1a03a23 	lsr	r3, r3, #20
8016e1a4:	e1a03a03 	lsl	r3, r3, #20
8016e1a8:	e30e2a78 	movw	r2, #60024	@ 0xea78
8016e1ac:	e3482016 	movt	r2, #32790	@ 0x8016
8016e1b0:	e51b101c 	ldr	r1, [fp, #-28]	@ 0xffffffe4
8016e1b4:	e7922101 	ldr	r2, [r2, r1, lsl #2]
8016e1b8:	e1833002 	orr	r3, r3, r2
8016e1bc:	e50b3008 	str	r3, [fp, #-8]
8016e1c0:	ea000008 	b	8016e1e8 <__RME_Pgt_Page_Map+0xec>
        /*RME_DBG_S("\r\n A7A_Flags= ");
        RME_DBG_H(A7A_Flags);*/
    }
    else
        A7A_Flags=RME_A7A_MMU_4K_PAGE_ADDR(Paddr)|RME_A7A_PGFLG_4K_RME2NAT(Flags);
8016e1c4:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016e1c8:	e3c33eff 	bic	r3, r3, #4080	@ 0xff0
8016e1cc:	e3c3300f 	bic	r3, r3, #15
8016e1d0:	e30e2af8 	movw	r2, #60152	@ 0xeaf8
8016e1d4:	e3482016 	movt	r2, #32790	@ 0x8016
8016e1d8:	e51b101c 	ldr	r1, [fp, #-28]	@ 0xffffffe4
8016e1dc:	e7922101 	ldr	r2, [r2, r1, lsl #2]
8016e1e0:	e1833002 	orr	r3, r3, r2
8016e1e4:	e50b3008 	str	r3, [fp, #-8]
    /* Try to map it in */
    if(RME_COMP_SWAP(&(Table[Pos]),0,A7A_Flags)==0)
8016e1e8:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016e1ec:	e1a03103 	lsl	r3, r3, #2
8016e1f0:	e51b200c 	ldr	r2, [fp, #-12]
8016e1f4:	e0823003 	add	r3, r2, r3
8016e1f8:	e51b2008 	ldr	r2, [fp, #-8]
8016e1fc:	e3a01000 	mov	r1, #0
8016e200:	e1a00003 	mov	r0, r3
8016e204:	ebffca6c 	bl	80160bbc <_RME_Comp_Swap_Single>
8016e208:	e1a03000 	mov	r3, r0
8016e20c:	e3530000 	cmp	r3, #0
8016e210:	1a000017 	bne	8016e274 <__RME_Pgt_Page_Map+0x178>
    {
        RME_DBG_S("\r\n&Table[Pos] = ");
8016e214:	e30f00c8 	movw	r0, #61640	@ 0xf0c8
8016e218:	e3480016 	movt	r0, #32790	@ 0x8016
8016e21c:	ebffca3c 	bl	80160b14 <RME_Str_Print>
        RME_DBG_H(&Table[Pos]);
8016e220:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016e224:	e1a03103 	lsl	r3, r3, #2
8016e228:	e51b200c 	ldr	r2, [fp, #-12]
8016e22c:	e0823003 	add	r3, r2, r3
8016e230:	e1a00003 	mov	r0, r3
8016e234:	ebffc9f4 	bl	80160a0c <RME_Hex_Print>
        RME_DBG_S("\r\n*(Table[Pos])");
8016e238:	e30f00dc 	movw	r0, #61660	@ 0xf0dc
8016e23c:	e3480016 	movt	r0, #32790	@ 0x8016
8016e240:	ebffca33 	bl	80160b14 <RME_Str_Print>
        RME_DBG_H(Table[Pos]);
8016e244:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016e248:	e1a03103 	lsl	r3, r3, #2
8016e24c:	e51b200c 	ldr	r2, [fp, #-12]
8016e250:	e0823003 	add	r3, r2, r3
8016e254:	e5933000 	ldr	r3, [r3]
8016e258:	e1a00003 	mov	r0, r3
8016e25c:	ebffc9ea 	bl	80160a0c <RME_Hex_Print>
        RME_DBG_S("\r\nmap it in error");
8016e260:	e30f00ec 	movw	r0, #61676	@ 0xf0ec
8016e264:	e3480016 	movt	r0, #32790	@ 0x8016
8016e268:	ebffca29 	bl	80160b14 <RME_Str_Print>
        return RME_ERR_HAL_FAIL;
8016e26c:	e3e03000 	mvn	r3, #0
8016e270:	ea000000 	b	8016e278 <__RME_Pgt_Page_Map+0x17c>
    /*RME_DBG_S("\r\n&Table[Pos] = ");
    RME_DBG_H(&Table[Pos]);
    RME_DBG_S("\r\n*(Table[Pos])");
    RME_DBG_H(Table[Pos]);*/

    return 0;
8016e274:	e3a03000 	mov	r3, #0
}
8016e278:	e1a00003 	mov	r0, r3
8016e27c:	e24bd004 	sub	sp, fp, #4
8016e280:	e8bd8800 	pop	{fp, pc}

8016e284 <__RME_Pgt_Page_Unmap>:
              rme_ptr_t Pos - The position in the page table.
Output      : None.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Page_Unmap(struct RME_Cap_Pgt* Pgt_Op, rme_ptr_t Pos)
{
8016e284:	e92d4800 	push	{fp, lr}
8016e288:	e28db004 	add	fp, sp, #4
8016e28c:	e24dd010 	sub	sp, sp, #16
8016e290:	e50b0010 	str	r0, [fp, #-16]
8016e294:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
    rme_ptr_t* Table;
    rme_ptr_t Temp;

    /* Are we trying to unmap the kernel space on the top level? */
    if(((Pgt_Op->Base&RME_PGT_TOP)!=0)&&(Pos>=2048))
8016e298:	e51b3010 	ldr	r3, [fp, #-16]
8016e29c:	e5933018 	ldr	r3, [r3, #24]
8016e2a0:	e2033001 	and	r3, r3, #1
8016e2a4:	e3530000 	cmp	r3, #0
8016e2a8:	0a000004 	beq	8016e2c0 <__RME_Pgt_Page_Unmap+0x3c>
8016e2ac:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016e2b0:	e3530b02 	cmp	r3, #2048	@ 0x800
8016e2b4:	3a000001 	bcc	8016e2c0 <__RME_Pgt_Page_Unmap+0x3c>
        return RME_ERR_HAL_FAIL;
8016e2b8:	e3e03000 	mvn	r3, #0
8016e2bc:	ea000026 	b	8016e35c <__RME_Pgt_Page_Unmap+0xd8>

    /* Get the table */
    Table=RME_CAP_GETOBJ(Pgt_Op,rme_ptr_t*);
8016e2c0:	e51b3010 	ldr	r3, [fp, #-16]
8016e2c4:	e593300c 	ldr	r3, [r3, #12]
8016e2c8:	e50b3008 	str	r3, [fp, #-8]

    /* Make sure that there is something */
    Temp=Table[Pos];
8016e2cc:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016e2d0:	e1a03103 	lsl	r3, r3, #2
8016e2d4:	e51b2008 	ldr	r2, [fp, #-8]
8016e2d8:	e0823003 	add	r3, r2, r3
8016e2dc:	e5933000 	ldr	r3, [r3]
8016e2e0:	e50b300c 	str	r3, [fp, #-12]
    if(Temp==0)
8016e2e4:	e51b300c 	ldr	r3, [fp, #-12]
8016e2e8:	e3530000 	cmp	r3, #0
8016e2ec:	1a000001 	bne	8016e2f8 <__RME_Pgt_Page_Unmap+0x74>
        return RME_ERR_HAL_FAIL;
8016e2f0:	e3e03000 	mvn	r3, #0
8016e2f4:	ea000018 	b	8016e35c <__RME_Pgt_Page_Unmap+0xd8>

    /* Is this a page directory? We cannot unmap page directories like this */
    if((RME_PGT_SZORD(Pgt_Op->Order)!=RME_PGT_SIZE_4K)&&((Temp&RME_A7A_MMU_1M_PGDIR_PRESENT)!=0))
8016e2f8:	e51b3010 	ldr	r3, [fp, #-16]
8016e2fc:	e5933014 	ldr	r3, [r3, #20]
8016e300:	e1a03823 	lsr	r3, r3, #16
8016e304:	e353000c 	cmp	r3, #12
8016e308:	0a000005 	beq	8016e324 <__RME_Pgt_Page_Unmap+0xa0>
8016e30c:	e51b300c 	ldr	r3, [fp, #-12]
8016e310:	e2033001 	and	r3, r3, #1
8016e314:	e3530000 	cmp	r3, #0
8016e318:	0a000001 	beq	8016e324 <__RME_Pgt_Page_Unmap+0xa0>
        return RME_ERR_HAL_FAIL;
8016e31c:	e3e03000 	mvn	r3, #0
8016e320:	ea00000d 	b	8016e35c <__RME_Pgt_Page_Unmap+0xd8>

    /* Try to unmap it. Use CAS just in case */
    if(RME_COMP_SWAP(&(Table[Pos]),Temp,0)==0)
8016e324:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016e328:	e1a03103 	lsl	r3, r3, #2
8016e32c:	e51b2008 	ldr	r2, [fp, #-8]
8016e330:	e0823003 	add	r3, r2, r3
8016e334:	e3a02000 	mov	r2, #0
8016e338:	e51b100c 	ldr	r1, [fp, #-12]
8016e33c:	e1a00003 	mov	r0, r3
8016e340:	ebffca1d 	bl	80160bbc <_RME_Comp_Swap_Single>
8016e344:	e1a03000 	mov	r3, r0
8016e348:	e3530000 	cmp	r3, #0
8016e34c:	1a000001 	bne	8016e358 <__RME_Pgt_Page_Unmap+0xd4>
        return RME_ERR_HAL_FAIL;
8016e350:	e3e03000 	mvn	r3, #0
8016e354:	ea000000 	b	8016e35c <__RME_Pgt_Page_Unmap+0xd8>

    return 0;
8016e358:	e3a03000 	mov	r3, #0
}
8016e35c:	e1a00003 	mov	r0, r3
8016e360:	e24bd004 	sub	sp, fp, #4
8016e364:	e8bd8800 	pop	{fp, pc}

8016e368 <__RME_Pgt_Pgdir_Map>:
Output      : None.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Pgdir_Map(struct RME_Cap_Pgt* Pgt_Parent, rme_ptr_t Pos,
                              struct RME_Cap_Pgt* Pgt_Child, rme_ptr_t Flags)
{
8016e368:	e92d4800 	push	{fp, lr}
8016e36c:	e28db004 	add	fp, sp, #4
8016e370:	e24dd020 	sub	sp, sp, #32
8016e374:	e50b0018 	str	r0, [fp, #-24]	@ 0xffffffe8
8016e378:	e50b101c 	str	r1, [fp, #-28]	@ 0xffffffe4
8016e37c:	e50b2020 	str	r2, [fp, #-32]	@ 0xffffffe0
8016e380:	e50b3024 	str	r3, [fp, #-36]	@ 0xffffffdc
    rme_ptr_t* Parent_Table;
    rme_ptr_t* Child_Table;
    rme_ptr_t A7A_Flags;

    /* It should at least be readable */
    if((Flags&RME_PGT_READ)==0)
8016e384:	e51b3024 	ldr	r3, [fp, #-36]	@ 0xffffffdc
8016e388:	e2033001 	and	r3, r3, #1
8016e38c:	e3530000 	cmp	r3, #0
8016e390:	1a000001 	bne	8016e39c <__RME_Pgt_Pgdir_Map+0x34>
        return RME_ERR_HAL_FAIL;
8016e394:	e3e03000 	mvn	r3, #0
8016e398:	ea000023 	b	8016e42c <__RME_Pgt_Pgdir_Map+0xc4>

    /* Are we trying to map into the kernel space on the top level? */
    if(((Pgt_Parent->Base&RME_PGT_TOP)!=0)&&(Pos>=2048))
8016e39c:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016e3a0:	e5933018 	ldr	r3, [r3, #24]
8016e3a4:	e2033001 	and	r3, r3, #1
8016e3a8:	e3530000 	cmp	r3, #0
8016e3ac:	0a000004 	beq	8016e3c4 <__RME_Pgt_Pgdir_Map+0x5c>
8016e3b0:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016e3b4:	e3530b02 	cmp	r3, #2048	@ 0x800
8016e3b8:	3a000001 	bcc	8016e3c4 <__RME_Pgt_Pgdir_Map+0x5c>
        return RME_ERR_HAL_FAIL;
8016e3bc:	e3e03000 	mvn	r3, #0
8016e3c0:	ea000019 	b	8016e42c <__RME_Pgt_Pgdir_Map+0xc4>

    /* Get the table */
    Parent_Table=RME_CAP_GETOBJ(Pgt_Parent,rme_ptr_t*);
8016e3c4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016e3c8:	e593300c 	ldr	r3, [r3, #12]
8016e3cc:	e50b3008 	str	r3, [fp, #-8]
    Child_Table=RME_CAP_GETOBJ(Pgt_Child,rme_ptr_t*);
8016e3d0:	e51b3020 	ldr	r3, [fp, #-32]	@ 0xffffffe0
8016e3d4:	e593300c 	ldr	r3, [r3, #12]
8016e3d8:	e50b300c 	str	r3, [fp, #-12]

    /* Generate the content */
    A7A_Flags=RME_A7A_MMU_1M_PGT_ADDR(RME_A7A_VA2PA(Child_Table))|RME_A7A_MMU_1M_PGDIR_PRESENT;
8016e3dc:	e51b300c 	ldr	r3, [fp, #-12]
8016e3e0:	e2833102 	add	r3, r3, #-2147483648	@ 0x80000000
8016e3e4:	e3c33fff 	bic	r3, r3, #1020	@ 0x3fc
8016e3e8:	e3c33003 	bic	r3, r3, #3
8016e3ec:	e3833001 	orr	r3, r3, #1
8016e3f0:	e50b3010 	str	r3, [fp, #-16]

    /* Try to map it in - may need to increase some count */
    if(RME_COMP_SWAP(&(Parent_Table[Pos]),0,A7A_Flags)==0)
8016e3f4:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016e3f8:	e1a03103 	lsl	r3, r3, #2
8016e3fc:	e51b2008 	ldr	r2, [fp, #-8]
8016e400:	e0823003 	add	r3, r2, r3
8016e404:	e51b2010 	ldr	r2, [fp, #-16]
8016e408:	e3a01000 	mov	r1, #0
8016e40c:	e1a00003 	mov	r0, r3
8016e410:	ebffc9e9 	bl	80160bbc <_RME_Comp_Swap_Single>
8016e414:	e1a03000 	mov	r3, r0
8016e418:	e3530000 	cmp	r3, #0
8016e41c:	1a000001 	bne	8016e428 <__RME_Pgt_Pgdir_Map+0xc0>
        return RME_ERR_HAL_FAIL;
8016e420:	e3e03000 	mvn	r3, #0
8016e424:	ea000000 	b	8016e42c <__RME_Pgt_Pgdir_Map+0xc4>

    return 0;
8016e428:	e3a03000 	mov	r3, #0
}
8016e42c:	e1a00003 	mov	r0, r3
8016e430:	e24bd004 	sub	sp, fp, #4
8016e434:	e8bd8800 	pop	{fp, pc}

8016e438 <__RME_Pgt_Pgdir_Unmap>:
Output      : None.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ret_t __RME_Pgt_Pgdir_Unmap(struct RME_Cap_Pgt* Pgt_Parent,rme_ptr_t Pos,
                                struct RME_Cap_Pgt* Pgt_Child)
{
8016e438:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016e43c:	e28db000 	add	fp, sp, #0
8016e440:	e24dd014 	sub	sp, sp, #20
8016e444:	e50b0008 	str	r0, [fp, #-8]
8016e448:	e50b100c 	str	r1, [fp, #-12]
8016e44c:	e50b2010 	str	r2, [fp, #-16]

   return 0;
8016e450:	e3a03000 	mov	r3, #0
}
8016e454:	e1a00003 	mov	r0, r3
8016e458:	e28bd000 	add	sp, fp, #0
8016e45c:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016e460:	e12fff1e 	bx	lr

8016e464 <__RME_Pgt_Lookup>:
Output      : rme_ptr_t* Paddr - The physical address of the page.
              rme_ptr_t* Flags - The RME standard flags of the page.
Return      : rme_ptr_t - If successful, 0; else RME_ERR_HAL_FAIL.
******************************************************************************/
rme_ptr_t __RME_Pgt_Lookup(struct RME_Cap_Pgt* Pgt_Op, rme_ptr_t Pos, rme_ptr_t* Paddr, rme_ptr_t* Flags)
{
8016e464:	e52db004 	push	{fp}		@ (str fp, [sp, #-4]!)
8016e468:	e28db000 	add	fp, sp, #0
8016e46c:	e24dd01c 	sub	sp, sp, #28
8016e470:	e50b0010 	str	r0, [fp, #-16]
8016e474:	e50b1014 	str	r1, [fp, #-20]	@ 0xffffffec
8016e478:	e50b2018 	str	r2, [fp, #-24]	@ 0xffffffe8
8016e47c:	e50b301c 	str	r3, [fp, #-28]	@ 0xffffffe4
    rme_ptr_t* Table;
    rme_ptr_t Temp;

    /* Check if the position is within the range of this page table */
    if((Pos>>RME_PGT_NMORD(Pgt_Op->Order))!=0)
8016e480:	e51b3010 	ldr	r3, [fp, #-16]
8016e484:	e5933014 	ldr	r3, [r3, #20]
8016e488:	e6ff3073 	uxth	r3, r3
8016e48c:	e51b2014 	ldr	r2, [fp, #-20]	@ 0xffffffec
8016e490:	e1a03332 	lsr	r3, r2, r3
8016e494:	e3530000 	cmp	r3, #0
8016e498:	0a000001 	beq	8016e4a4 <__RME_Pgt_Lookup+0x40>
        return RME_ERR_HAL_FAIL;
8016e49c:	e3e03000 	mvn	r3, #0
8016e4a0:	ea000058 	b	8016e608 <__RME_Pgt_Lookup+0x1a4>

    /* Get the table */
    Table=RME_CAP_GETOBJ(Pgt_Op,rme_ptr_t*);
8016e4a4:	e51b3010 	ldr	r3, [fp, #-16]
8016e4a8:	e593300c 	ldr	r3, [r3, #12]
8016e4ac:	e50b3008 	str	r3, [fp, #-8]
    /* Get the position requested - atomic read */
    Temp=Table[Pos];
8016e4b0:	e51b3014 	ldr	r3, [fp, #-20]	@ 0xffffffec
8016e4b4:	e1a03103 	lsl	r3, r3, #2
8016e4b8:	e51b2008 	ldr	r2, [fp, #-8]
8016e4bc:	e0823003 	add	r3, r2, r3
8016e4c0:	e5933000 	ldr	r3, [r3]
8016e4c4:	e50b300c 	str	r3, [fp, #-12]

    /* Start lookup - is this a terminal page, or? */
    if(RME_PGT_SZORD(Pgt_Op->Order)==RME_PGT_SIZE_4K)
8016e4c8:	e51b3010 	ldr	r3, [fp, #-16]
8016e4cc:	e5933014 	ldr	r3, [r3, #20]
8016e4d0:	e1a03823 	lsr	r3, r3, #16
8016e4d4:	e353000c 	cmp	r3, #12
8016e4d8:	1a000024 	bne	8016e570 <__RME_Pgt_Lookup+0x10c>
    {
        if((Temp&RME_A7A_MMU_4K_PAGE_PRESENT)==0)
8016e4dc:	e51b300c 	ldr	r3, [fp, #-12]
8016e4e0:	e2033002 	and	r3, r3, #2
8016e4e4:	e3530000 	cmp	r3, #0
8016e4e8:	1a000001 	bne	8016e4f4 <__RME_Pgt_Lookup+0x90>
            return RME_ERR_HAL_FAIL;
8016e4ec:	e3e03000 	mvn	r3, #0
8016e4f0:	ea000044 	b	8016e608 <__RME_Pgt_Lookup+0x1a4>

        /* This is a small page. Return the physical address and flags */
        if(Paddr!=0)
8016e4f4:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016e4f8:	e3530000 	cmp	r3, #0
8016e4fc:	0a000004 	beq	8016e514 <__RME_Pgt_Lookup+0xb0>
        	*Paddr=RME_A7A_MMU_4K_PAGE_ADDR(Temp);
8016e500:	e51b300c 	ldr	r3, [fp, #-12]
8016e504:	e3c33eff 	bic	r3, r3, #4080	@ 0xff0
8016e508:	e3c3300f 	bic	r3, r3, #15
8016e50c:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016e510:	e5823000 	str	r3, [r2]
        if(Flags!=0)
8016e514:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016e518:	e3530000 	cmp	r3, #0
8016e51c:	0a000038 	beq	8016e604 <__RME_Pgt_Lookup+0x1a0>
            *Flags=RME_A7A_PGFLG_4K_NAT2RME(Temp);
8016e520:	e51b300c 	ldr	r3, [fp, #-12]
8016e524:	e1a03323 	lsr	r3, r3, #6
8016e528:	e2032008 	and	r2, r3, #8
8016e52c:	e51b300c 	ldr	r3, [fp, #-12]
8016e530:	e1a030a3 	lsr	r3, r3, #1
8016e534:	e2033004 	and	r3, r3, #4
8016e538:	e1822003 	orr	r2, r2, r3
8016e53c:	e51b300c 	ldr	r3, [fp, #-12]
8016e540:	e1a030a3 	lsr	r3, r3, #1
8016e544:	e2033002 	and	r3, r3, #2
8016e548:	e1822003 	orr	r2, r2, r3
8016e54c:	e51b300c 	ldr	r3, [fp, #-12]
8016e550:	e2033001 	and	r3, r3, #1
8016e554:	e1822003 	orr	r2, r2, r3
8016e558:	e30e3bb8 	movw	r3, #60344	@ 0xebb8
8016e55c:	e3483016 	movt	r3, #32790	@ 0x8016
8016e560:	e7932102 	ldr	r2, [r3, r2, lsl #2]
8016e564:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016e568:	e5832000 	str	r2, [r3]
8016e56c:	ea000024 	b	8016e604 <__RME_Pgt_Lookup+0x1a0>
    }
    else
    {
        if((Temp&RME_A7A_MMU_1M_PAGE_PRESENT)==0)
8016e570:	e51b300c 	ldr	r3, [fp, #-12]
8016e574:	e2033002 	and	r3, r3, #2
8016e578:	e3530000 	cmp	r3, #0
8016e57c:	1a000001 	bne	8016e588 <__RME_Pgt_Lookup+0x124>
            return RME_ERR_HAL_FAIL;
8016e580:	e3e03000 	mvn	r3, #0
8016e584:	ea00001f 	b	8016e608 <__RME_Pgt_Lookup+0x1a4>

        /* This is a section. Return the physical address and flags */
        if(Paddr!=0)
8016e588:	e51b3018 	ldr	r3, [fp, #-24]	@ 0xffffffe8
8016e58c:	e3530000 	cmp	r3, #0
8016e590:	0a000004 	beq	8016e5a8 <__RME_Pgt_Lookup+0x144>
        	*Paddr=RME_A7A_MMU_1M_PAGE_ADDR(Temp);
8016e594:	e51b300c 	ldr	r3, [fp, #-12]
8016e598:	e1a03a23 	lsr	r3, r3, #20
8016e59c:	e1a03a03 	lsl	r3, r3, #20
8016e5a0:	e51b2018 	ldr	r2, [fp, #-24]	@ 0xffffffe8
8016e5a4:	e5823000 	str	r3, [r2]
        if(Flags!=0)
8016e5a8:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016e5ac:	e3530000 	cmp	r3, #0
8016e5b0:	0a000013 	beq	8016e604 <__RME_Pgt_Lookup+0x1a0>
            *Flags=RME_A7A_PGFLG_1M_NAT2RME(Temp);
8016e5b4:	e51b300c 	ldr	r3, [fp, #-12]
8016e5b8:	e1a03623 	lsr	r3, r3, #12
8016e5bc:	e2032008 	and	r2, r3, #8
8016e5c0:	e51b300c 	ldr	r3, [fp, #-12]
8016e5c4:	e1a03123 	lsr	r3, r3, #2
8016e5c8:	e2033004 	and	r3, r3, #4
8016e5cc:	e1822003 	orr	r2, r2, r3
8016e5d0:	e51b300c 	ldr	r3, [fp, #-12]
8016e5d4:	e1a03123 	lsr	r3, r3, #2
8016e5d8:	e2033002 	and	r3, r3, #2
8016e5dc:	e1822003 	orr	r2, r2, r3
8016e5e0:	e51b300c 	ldr	r3, [fp, #-12]
8016e5e4:	e1a03123 	lsr	r3, r3, #2
8016e5e8:	e2033001 	and	r3, r3, #1
8016e5ec:	e1822003 	orr	r2, r2, r3
8016e5f0:	e30e3b78 	movw	r3, #60280	@ 0xeb78
8016e5f4:	e3483016 	movt	r3, #32790	@ 0x8016
8016e5f8:	e7932102 	ldr	r2, [r3, r2, lsl #2]
8016e5fc:	e51b301c 	ldr	r3, [fp, #-28]	@ 0xffffffe4
8016e600:	e5832000 	str	r2, [r3]
    }

    return 0;
8016e604:	e3a03000 	mov	r3, #0
}
8016e608:	e1a00003 	mov	r0, r3
8016e60c:	e28bd000 	add	sp, fp, #0
8016e610:	e49db004 	pop	{fp}		@ (ldr fp, [sp], #4)
8016e614:	e12fff1e 	bx	lr

8016e618 <__divsi3>:
8016e618:	2900      	cmp	r1, #0
8016e61a:	f000 813e 	beq.w	8016e89a <.divsi3_skip_div0_test+0x27c>

8016e61e <.divsi3_skip_div0_test>:
8016e61e:	ea80 0c01 	eor.w	ip, r0, r1
8016e622:	bf48      	it	mi
8016e624:	4249      	negmi	r1, r1
8016e626:	1e4a      	subs	r2, r1, #1
8016e628:	f000 811f 	beq.w	8016e86a <.divsi3_skip_div0_test+0x24c>
8016e62c:	0003      	movs	r3, r0
8016e62e:	bf48      	it	mi
8016e630:	4243      	negmi	r3, r0
8016e632:	428b      	cmp	r3, r1
8016e634:	f240 811e 	bls.w	8016e874 <.divsi3_skip_div0_test+0x256>
8016e638:	4211      	tst	r1, r2
8016e63a:	f000 8123 	beq.w	8016e884 <.divsi3_skip_div0_test+0x266>
8016e63e:	fab3 f283 	clz	r2, r3
8016e642:	fab1 f081 	clz	r0, r1
8016e646:	eba0 0202 	sub.w	r2, r0, r2
8016e64a:	f1c2 021f 	rsb	r2, r2, #31
8016e64e:	a004      	add	r0, pc, #16	@ (adr r0, 8016e660 <.divsi3_skip_div0_test+0x42>)
8016e650:	eb00 1202 	add.w	r2, r0, r2, lsl #4
8016e654:	f04f 0000 	mov.w	r0, #0
8016e658:	4697      	mov	pc, r2
8016e65a:	bf00      	nop
8016e65c:	f3af 8000 	nop.w
8016e660:	ebb3 7fc1 	cmp.w	r3, r1, lsl #31
8016e664:	bf00      	nop
8016e666:	eb40 0000 	adc.w	r0, r0, r0
8016e66a:	bf28      	it	cs
8016e66c:	eba3 73c1 	subcs.w	r3, r3, r1, lsl #31
8016e670:	ebb3 7f81 	cmp.w	r3, r1, lsl #30
8016e674:	bf00      	nop
8016e676:	eb40 0000 	adc.w	r0, r0, r0
8016e67a:	bf28      	it	cs
8016e67c:	eba3 7381 	subcs.w	r3, r3, r1, lsl #30
8016e680:	ebb3 7f41 	cmp.w	r3, r1, lsl #29
8016e684:	bf00      	nop
8016e686:	eb40 0000 	adc.w	r0, r0, r0
8016e68a:	bf28      	it	cs
8016e68c:	eba3 7341 	subcs.w	r3, r3, r1, lsl #29
8016e690:	ebb3 7f01 	cmp.w	r3, r1, lsl #28
8016e694:	bf00      	nop
8016e696:	eb40 0000 	adc.w	r0, r0, r0
8016e69a:	bf28      	it	cs
8016e69c:	eba3 7301 	subcs.w	r3, r3, r1, lsl #28
8016e6a0:	ebb3 6fc1 	cmp.w	r3, r1, lsl #27
8016e6a4:	bf00      	nop
8016e6a6:	eb40 0000 	adc.w	r0, r0, r0
8016e6aa:	bf28      	it	cs
8016e6ac:	eba3 63c1 	subcs.w	r3, r3, r1, lsl #27
8016e6b0:	ebb3 6f81 	cmp.w	r3, r1, lsl #26
8016e6b4:	bf00      	nop
8016e6b6:	eb40 0000 	adc.w	r0, r0, r0
8016e6ba:	bf28      	it	cs
8016e6bc:	eba3 6381 	subcs.w	r3, r3, r1, lsl #26
8016e6c0:	ebb3 6f41 	cmp.w	r3, r1, lsl #25
8016e6c4:	bf00      	nop
8016e6c6:	eb40 0000 	adc.w	r0, r0, r0
8016e6ca:	bf28      	it	cs
8016e6cc:	eba3 6341 	subcs.w	r3, r3, r1, lsl #25
8016e6d0:	ebb3 6f01 	cmp.w	r3, r1, lsl #24
8016e6d4:	bf00      	nop
8016e6d6:	eb40 0000 	adc.w	r0, r0, r0
8016e6da:	bf28      	it	cs
8016e6dc:	eba3 6301 	subcs.w	r3, r3, r1, lsl #24
8016e6e0:	ebb3 5fc1 	cmp.w	r3, r1, lsl #23
8016e6e4:	bf00      	nop
8016e6e6:	eb40 0000 	adc.w	r0, r0, r0
8016e6ea:	bf28      	it	cs
8016e6ec:	eba3 53c1 	subcs.w	r3, r3, r1, lsl #23
8016e6f0:	ebb3 5f81 	cmp.w	r3, r1, lsl #22
8016e6f4:	bf00      	nop
8016e6f6:	eb40 0000 	adc.w	r0, r0, r0
8016e6fa:	bf28      	it	cs
8016e6fc:	eba3 5381 	subcs.w	r3, r3, r1, lsl #22
8016e700:	ebb3 5f41 	cmp.w	r3, r1, lsl #21
8016e704:	bf00      	nop
8016e706:	eb40 0000 	adc.w	r0, r0, r0
8016e70a:	bf28      	it	cs
8016e70c:	eba3 5341 	subcs.w	r3, r3, r1, lsl #21
8016e710:	ebb3 5f01 	cmp.w	r3, r1, lsl #20
8016e714:	bf00      	nop
8016e716:	eb40 0000 	adc.w	r0, r0, r0
8016e71a:	bf28      	it	cs
8016e71c:	eba3 5301 	subcs.w	r3, r3, r1, lsl #20
8016e720:	ebb3 4fc1 	cmp.w	r3, r1, lsl #19
8016e724:	bf00      	nop
8016e726:	eb40 0000 	adc.w	r0, r0, r0
8016e72a:	bf28      	it	cs
8016e72c:	eba3 43c1 	subcs.w	r3, r3, r1, lsl #19
8016e730:	ebb3 4f81 	cmp.w	r3, r1, lsl #18
8016e734:	bf00      	nop
8016e736:	eb40 0000 	adc.w	r0, r0, r0
8016e73a:	bf28      	it	cs
8016e73c:	eba3 4381 	subcs.w	r3, r3, r1, lsl #18
8016e740:	ebb3 4f41 	cmp.w	r3, r1, lsl #17
8016e744:	bf00      	nop
8016e746:	eb40 0000 	adc.w	r0, r0, r0
8016e74a:	bf28      	it	cs
8016e74c:	eba3 4341 	subcs.w	r3, r3, r1, lsl #17
8016e750:	ebb3 4f01 	cmp.w	r3, r1, lsl #16
8016e754:	bf00      	nop
8016e756:	eb40 0000 	adc.w	r0, r0, r0
8016e75a:	bf28      	it	cs
8016e75c:	eba3 4301 	subcs.w	r3, r3, r1, lsl #16
8016e760:	ebb3 3fc1 	cmp.w	r3, r1, lsl #15
8016e764:	bf00      	nop
8016e766:	eb40 0000 	adc.w	r0, r0, r0
8016e76a:	bf28      	it	cs
8016e76c:	eba3 33c1 	subcs.w	r3, r3, r1, lsl #15
8016e770:	ebb3 3f81 	cmp.w	r3, r1, lsl #14
8016e774:	bf00      	nop
8016e776:	eb40 0000 	adc.w	r0, r0, r0
8016e77a:	bf28      	it	cs
8016e77c:	eba3 3381 	subcs.w	r3, r3, r1, lsl #14
8016e780:	ebb3 3f41 	cmp.w	r3, r1, lsl #13
8016e784:	bf00      	nop
8016e786:	eb40 0000 	adc.w	r0, r0, r0
8016e78a:	bf28      	it	cs
8016e78c:	eba3 3341 	subcs.w	r3, r3, r1, lsl #13
8016e790:	ebb3 3f01 	cmp.w	r3, r1, lsl #12
8016e794:	bf00      	nop
8016e796:	eb40 0000 	adc.w	r0, r0, r0
8016e79a:	bf28      	it	cs
8016e79c:	eba3 3301 	subcs.w	r3, r3, r1, lsl #12
8016e7a0:	ebb3 2fc1 	cmp.w	r3, r1, lsl #11
8016e7a4:	bf00      	nop
8016e7a6:	eb40 0000 	adc.w	r0, r0, r0
8016e7aa:	bf28      	it	cs
8016e7ac:	eba3 23c1 	subcs.w	r3, r3, r1, lsl #11
8016e7b0:	ebb3 2f81 	cmp.w	r3, r1, lsl #10
8016e7b4:	bf00      	nop
8016e7b6:	eb40 0000 	adc.w	r0, r0, r0
8016e7ba:	bf28      	it	cs
8016e7bc:	eba3 2381 	subcs.w	r3, r3, r1, lsl #10
8016e7c0:	ebb3 2f41 	cmp.w	r3, r1, lsl #9
8016e7c4:	bf00      	nop
8016e7c6:	eb40 0000 	adc.w	r0, r0, r0
8016e7ca:	bf28      	it	cs
8016e7cc:	eba3 2341 	subcs.w	r3, r3, r1, lsl #9
8016e7d0:	ebb3 2f01 	cmp.w	r3, r1, lsl #8
8016e7d4:	bf00      	nop
8016e7d6:	eb40 0000 	adc.w	r0, r0, r0
8016e7da:	bf28      	it	cs
8016e7dc:	eba3 2301 	subcs.w	r3, r3, r1, lsl #8
8016e7e0:	ebb3 1fc1 	cmp.w	r3, r1, lsl #7
8016e7e4:	bf00      	nop
8016e7e6:	eb40 0000 	adc.w	r0, r0, r0
8016e7ea:	bf28      	it	cs
8016e7ec:	eba3 13c1 	subcs.w	r3, r3, r1, lsl #7
8016e7f0:	ebb3 1f81 	cmp.w	r3, r1, lsl #6
8016e7f4:	bf00      	nop
8016e7f6:	eb40 0000 	adc.w	r0, r0, r0
8016e7fa:	bf28      	it	cs
8016e7fc:	eba3 1381 	subcs.w	r3, r3, r1, lsl #6
8016e800:	ebb3 1f41 	cmp.w	r3, r1, lsl #5
8016e804:	bf00      	nop
8016e806:	eb40 0000 	adc.w	r0, r0, r0
8016e80a:	bf28      	it	cs
8016e80c:	eba3 1341 	subcs.w	r3, r3, r1, lsl #5
8016e810:	ebb3 1f01 	cmp.w	r3, r1, lsl #4
8016e814:	bf00      	nop
8016e816:	eb40 0000 	adc.w	r0, r0, r0
8016e81a:	bf28      	it	cs
8016e81c:	eba3 1301 	subcs.w	r3, r3, r1, lsl #4
8016e820:	ebb3 0fc1 	cmp.w	r3, r1, lsl #3
8016e824:	bf00      	nop
8016e826:	eb40 0000 	adc.w	r0, r0, r0
8016e82a:	bf28      	it	cs
8016e82c:	eba3 03c1 	subcs.w	r3, r3, r1, lsl #3
8016e830:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
8016e834:	bf00      	nop
8016e836:	eb40 0000 	adc.w	r0, r0, r0
8016e83a:	bf28      	it	cs
8016e83c:	eba3 0381 	subcs.w	r3, r3, r1, lsl #2
8016e840:	ebb3 0f41 	cmp.w	r3, r1, lsl #1
8016e844:	bf00      	nop
8016e846:	eb40 0000 	adc.w	r0, r0, r0
8016e84a:	bf28      	it	cs
8016e84c:	eba3 0341 	subcs.w	r3, r3, r1, lsl #1
8016e850:	ebb3 0f01 	cmp.w	r3, r1
8016e854:	bf00      	nop
8016e856:	eb40 0000 	adc.w	r0, r0, r0
8016e85a:	bf28      	it	cs
8016e85c:	eba3 0301 	subcs.w	r3, r3, r1
8016e860:	f1bc 0f00 	cmp.w	ip, #0
8016e864:	bf48      	it	mi
8016e866:	4240      	negmi	r0, r0
8016e868:	4770      	bx	lr
8016e86a:	ea9c 0f00 	teq	ip, r0
8016e86e:	bf48      	it	mi
8016e870:	4240      	negmi	r0, r0
8016e872:	4770      	bx	lr
8016e874:	bf38      	it	cc
8016e876:	2000      	movcc	r0, #0
8016e878:	bf04      	itt	eq
8016e87a:	ea4f 70ec 	moveq.w	r0, ip, asr #31
8016e87e:	f040 0001 	orreq.w	r0, r0, #1
8016e882:	4770      	bx	lr
8016e884:	fab1 f281 	clz	r2, r1
8016e888:	f1c2 021f 	rsb	r2, r2, #31
8016e88c:	f1bc 0f00 	cmp.w	ip, #0
8016e890:	fa23 f002 	lsr.w	r0, r3, r2
8016e894:	bf48      	it	mi
8016e896:	4240      	negmi	r0, r0
8016e898:	4770      	bx	lr
8016e89a:	2800      	cmp	r0, #0
8016e89c:	bfc8      	it	gt
8016e89e:	f06f 4000 	mvngt.w	r0, #2147483648	@ 0x80000000
8016e8a2:	bfb8      	it	lt
8016e8a4:	f04f 4000 	movlt.w	r0, #2147483648	@ 0x80000000
8016e8a8:	f000 b80e 	b.w	8016e8c8 <__aeabi_idiv0>

8016e8ac <__aeabi_idivmod>:
8016e8ac:	2900      	cmp	r1, #0
8016e8ae:	d0f4      	beq.n	8016e89a <.divsi3_skip_div0_test+0x27c>
8016e8b0:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
8016e8b4:	f7ff feb3 	bl	8016e61e <.divsi3_skip_div0_test>
8016e8b8:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
8016e8bc:	fb02 f300 	mul.w	r3, r2, r0
8016e8c0:	eba1 0103 	sub.w	r1, r1, r3
8016e8c4:	4770      	bx	lr
8016e8c6:	bf00      	nop

8016e8c8 <__aeabi_idiv0>:
8016e8c8:	4770      	bx	lr
8016e8ca:	bf00      	nop
